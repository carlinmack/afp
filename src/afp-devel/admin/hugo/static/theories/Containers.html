<div id="Containers_Auxiliary">
<div class="head">
<h1>Theory Containers_Auxiliary</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Containers_Auxiliary.thy
    Author:     Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> Containers_Auxiliary <span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Monad_Syntax.html">HOL-Library.Monad_Syntax</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹An executable linear order on sets›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{chapter:linear:order:set}›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary definitions›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> insert_bind_set<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="free">a</span> <span class="free">A</span> <span class="main">⤜</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span> <span class="free">a</span> <span class="main">∪</span> <span class="main">(</span><span class="free">A</span> <span class="main">⤜</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Set.bind_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_bind_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>List.bind <span class="free">xs</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> Set.bind <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>set <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_bind_set<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_bind_conv_fold<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⤜</span> <span class="free">f</span> <span class="main">=</span> fold <span class="main">(</span><span class="main">(∪)</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="free">xs</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_bind_set<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> card_gt_1D<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"card <span class="free">A</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> card_eq_1_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="free">A</span> <span class="main">=</span> <span class="main">1</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> card<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="free">A</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> card_gt_0_iff<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> <span class="main">{</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> equalityI subsetI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> the_equality<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x'</span>
      <span class="keyword3"><span class="command">assume</span></span> x'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">≠</span> <span class="skolem">x</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> x x' <span class="keyword1"><span class="command">have</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> insert <span class="skolem">x</span> <span class="main">(</span>insert <span class="skolem">x'</span> <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x'</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="free">A</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">+</span> card <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x'</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> neq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> eq<span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> card <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">{</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">{</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> card <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x'</span></span> <span class="keyword2"><span class="keyword">where</span></span> x'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> x
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> theI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x'</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">x'</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> x x' <span class="keyword1"><span class="command">have</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> insert <span class="skolem">x</span> <span class="main">(</span>insert <span class="skolem">x'</span> <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x'</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="free">A</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">+</span> card <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x'</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> neq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> eq<span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> card <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> card_eq_Suc_0_ex1<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="free">A</span> <span class="main">=</span> Suc <span class="main">0</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> One_nat_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> card_eq_1_iff<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_last<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sorted <span class="free">xs</span><span class="main">;</span> <span class="free">x</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> last <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_append<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> empty_filter_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span> <span class="main">=</span> filter <span class="free">P</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="free">xs</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> sym <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> filter_empty_conv<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ID</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ID</span> <span class="main">=</span> id"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ID_code <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_def id_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ID_Some<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="main">(</span>Some <span class="free">x</span><span class="main">)</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ID_None<span class="main">:</span> <span class="quoted"><span class="quoted">"ID None <span class="main">=</span> None"</span></span> 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹lexicographic order on pairs›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">leq_a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑<span class="hidden">⇩</span><sub>a</sub></span>"</span> 50<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">less_a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏<span class="hidden">⇩</span><sub>a</sub></span>"</span> 50<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">leq_b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑<span class="hidden">⇩</span><sub>b</sub></span>"</span> 50<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">less_b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏<span class="hidden">⇩</span><sub>b</sub></span>"</span> 50<span class="main">)</span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">less_eq_prod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">less_eq_prod</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x1</span><span class="main">,</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">(</span><span class="bound">y1</span><span class="main">,</span> <span class="bound">y2</span><span class="main">)</span><span class="main">.</span> <span class="bound">x1</span> <span class="keyword1"><span class="free">⊏<span class="hidden">⇩</span><sub>a</sub></span></span> <span class="bound">y1</span> <span class="main">∨</span> <span class="bound">x1</span> <span class="keyword1"><span class="free">⊑<span class="hidden">⇩</span><sub>a</sub></span></span> <span class="bound">y1</span> <span class="main">∧</span> <span class="bound">x2</span> <span class="keyword1"><span class="free">⊑<span class="hidden">⇩</span><sub>b</sub></span></span> <span class="bound">y2</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">less_prod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">less_prod</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x1</span><span class="main">,</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">(</span><span class="bound">y1</span><span class="main">,</span> <span class="bound">y2</span><span class="main">)</span><span class="main">.</span> <span class="bound">x1</span> <span class="keyword1"><span class="free">⊏<span class="hidden">⇩</span><sub>a</sub></span></span> <span class="bound">y1</span> <span class="main">∨</span> <span class="bound">x1</span> <span class="keyword1"><span class="free">⊑<span class="hidden">⇩</span><sub>a</sub></span></span> <span class="bound">y1</span> <span class="main">∧</span> <span class="bound">x2</span> <span class="keyword1"><span class="free">⊏<span class="hidden">⇩</span><sub>b</sub></span></span> <span class="bound">y2</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> less_eq_prod_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x1</span><span class="main">,</span> <span class="free">x2</span><span class="main">)</span> <span class="main">⊑</span> <span class="main">(</span><span class="free">y1</span><span class="main">,</span> <span class="free">y2</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x1</span> <span class="keyword1"><span class="free">⊏<span class="hidden">⇩</span><sub>a</sub></span></span> <span class="free">y1</span> <span class="main">∨</span> <span class="free">x1</span> <span class="keyword1"><span class="free">⊑<span class="hidden">⇩</span><sub>a</sub></span></span> <span class="free">y1</span> <span class="main">∧</span> <span class="free">x2</span> <span class="keyword1"><span class="free">⊑<span class="hidden">⇩</span><sub>b</sub></span></span> <span class="free">y2</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_eq_prod_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> less_prod_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x1</span><span class="main">,</span> <span class="free">x2</span><span class="main">)</span> <span class="main">⊏</span> <span class="main">(</span><span class="free">y1</span><span class="main">,</span> <span class="free">y2</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x1</span> <span class="keyword1"><span class="free">⊏<span class="hidden">⇩</span><sub>a</sub></span></span> <span class="free">y1</span> <span class="main">∨</span> <span class="free">x1</span> <span class="keyword1"><span class="free">⊑<span class="hidden">⇩</span><sub>a</sub></span></span> <span class="free">y1</span> <span class="main">∧</span> <span class="free">x2</span> <span class="keyword1"><span class="free">⊏<span class="hidden">⇩</span><sub>b</sub></span></span> <span class="free">y2</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_prod_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">leq_a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑<span class="hidden">⇩</span><sub>a</sub></span>"</span> 50<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">less_a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏<span class="hidden">⇩</span><sub>a</sub></span>"</span> 50<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">leq_b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑<span class="hidden">⇩</span><sub>b</sub></span>"</span> 50<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">less_b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏<span class="hidden">⇩</span><sub>b</sub></span>"</span> 50<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> lin_a<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder <span class="free">leq_a</span> <span class="free">less_a</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> lin_b<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder <span class="free">leq_b</span> <span class="free">less_b</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">less_eq_prod'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">less_eq_prod'</span> <span class="main">≡</span> less_eq_prod <span class="free">leq_a</span> <span class="free">less_a</span> <span class="free">leq_b</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">less_prod'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">less_prod'</span> <span class="main">≡</span> less_prod <span class="free">leq_a</span> <span class="free">less_a</span> <span class="free">less_b</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> linorder_prod<span class="main">:</span>
  <span class="quoted"><span class="quoted">"class.linorder <span class="main">(⊑)</span> <span class="main">(⊏)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> a<span class="main">:</span> linorder <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">(⊑<span class="hidden">⇩</span><sub>a</sub>)</span></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">(⊏<span class="hidden">⇩</span><sub>a</sub>)</span></span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> lin_a<span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> b<span class="main">:</span> linorder <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">(⊑<span class="hidden">⇩</span><sub>b</sub>)</span></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">(⊏<span class="hidden">⇩</span><sub>b</sub>)</span></span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> lin_b<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> less_eq_prod' less_prod'

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Card_Datatype">
<div class="head">
<h1>Theory Card_Datatype</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Card_Datatype.thy
    Author:     Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Card_Datatype
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="../../HOL/HOL-Library/Cardinality.html">HOL-Library.Cardinality</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Definitions to prove equations about the cardinality of data types›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Specialised <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">range</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> constants›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rangeIt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rangeIt</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> range <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">^^</span> <span class="bound">n</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rangeC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> set <span class="main">⇒</span> <span class="tfree">'b</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rangeC</span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">f</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">F</span></span></span><span class="main">.</span> range <span class="bound">f</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> infinite_rangeIt<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">f</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> finite <span class="main">(</span>rangeIt <span class="free">x</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="bound">n</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> injI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="skolem">m</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="skolem">n</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="skolem">m</span><span class="main">)</span> <span class="free">x</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">m</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sym<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sym <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> injD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inj<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeIt_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> finite_imageD<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> in_rangeC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟹</span> <span class="free">f</span> <span class="free">x</span> <span class="main">∈</span> rangeC <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeC_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> in_rangeCE<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> rangeC <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">f</span> <span class="free">x</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeC_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> in_rangeC_singleton<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">x</span> <span class="main">∈</span> rangeC <span class="main">{</span><span class="free">f</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeC_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> in_rangeC_singleton_const<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> rangeC <span class="main">{</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">x</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> in_rangeC_singleton<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rangeC_rangeC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> rangeC <span class="free">A</span> <span class="main">⟹</span> <span class="free">f</span> <span class="free">x</span> <span class="main">∈</span> rangeC <span class="main">(</span>rangeC <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeC_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rangeC_eq_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"rangeC <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeC_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Ball_rangeC_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> rangeC <span class="free">A</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> in_rangeC <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> in_rangeCE<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Ball_rangeC_singleton<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> rangeC <span class="main">{</span><span class="free">f</span><span class="main">}</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Ball_rangeC_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Ball_rangeC_rangeC<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> rangeC <span class="main">(</span>rangeC <span class="free">A</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> rangeC <span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Ball_rangeC_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_rangeC<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> inj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> inj <span class="bound">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> disjoint<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">g</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> <span class="bound">f</span> <span class="main">≠</span> <span class="bound">g</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">g</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>rangeC <span class="main">(</span><span class="free">A</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> set<span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> finite <span class="free">A</span> <span class="main">∧</span> <span class="main">(</span><span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">using</span></span> inj disjoint
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"rangeC <span class="free">A</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_psubset_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>psubset <span class="skolem">A</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="skolem"><span class="skolem">A'</span></span> <span class="keyword2"><span class="keyword">where</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> insert <span class="skolem">f</span> <span class="skolem">A'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">∉</span> <span class="skolem">A'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> mk_disjoint_insert<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> rA<span class="main">:</span> <span class="quoted"><span class="quoted">"rangeC <span class="skolem">A</span> <span class="main">=</span> rangeC <span class="skolem">A'</span> <span class="main">∪</span> range <span class="skolem">f</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeC_def<span class="main">)</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> range <span class="skolem">f</span> <span class="main">⊆</span> rangeC <span class="skolem">A'</span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"range <span class="skolem">f</span> <span class="main">⊆</span> rangeC <span class="skolem">A'</span>"</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> range <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> rangeC <span class="skolem">A'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">∈</span> <span class="skolem">A'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> range <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeC_def<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">f</span> <span class="main">∉</span> <span class="skolem">A'</span>›</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">≠</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">f</span> <span class="main">∈</span> <span class="skolem">A</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="main">≠</span> <span class="skolem">g</span> <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> psubset.prems<span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> x <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> range <span class="skolem">g</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"rangeC <span class="skolem">A'</span> <span class="main">⊂</span> rangeC <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> rA <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">A'</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">A'</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> psubset.prems
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">erule</span> psubset.hyps<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> <span class="quoted"><span class="quoted">‹finite <span class="main">(</span>rangeC <span class="skolem">A</span><span class="main">)</span>›</span></span> A <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> inj <span class="bound">f</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeC_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> finite_imageD<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeC_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_rangeC_singleton_const<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>rangeC <span class="main">{</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeC_def image_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> card_Un<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> finite <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> card <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span><span class="free">A</span><span class="main">)</span> <span class="main">+</span> card <span class="main">(</span><span class="free">B</span><span class="main">)</span> <span class="main">-</span> card<span class="main">(</span><span class="free">A</span> <span class="main">∩</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> card_Un_Int<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> card_rangeC_singleton_const<span class="main">:</span>
  <span class="quoted"><span class="quoted">"card <span class="main">(</span>rangeC <span class="main">{</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">f</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeC_def image_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> card_rangeC<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> inj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> inj <span class="bound">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> disjoint<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">g</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> <span class="bound">f</span> <span class="main">≠</span> <span class="bound">g</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">g</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>rangeC <span class="main">(</span><span class="free">A</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> set<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">*</span> card <span class="free">A</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∧</span> finite <span class="free">A</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False finite_rangeC<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_eq_0_iff rangeC_eq_empty<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>range <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> inj <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_image<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> disjoint True <span class="keyword1"><span class="command">unfolding</span></span> rangeC_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> card_UN_disjoint<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rangeC_Int_rangeC<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> <span class="main">∀</span><span class="bound">g</span> <span class="main">∈</span> <span class="free">B</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">g</span> <span class="bound">y</span> <span class="main">⟧</span> <span class="main">⟹</span> rangeC <span class="free">A</span> <span class="main">∩</span> rangeC <span class="free">B</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rangeC_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> rangeC_simps <span class="main">=</span>
  in_rangeC_singleton
  in_rangeC_singleton_const
  rangeC_rangeC
  rangeC_eq_empty
  Ball_rangeC_singleton
  Ball_rangeC_rangeC
  finite_rangeC
  finite_rangeC_singleton_const
  card_rangeC_singleton_const
  card_rangeC
  rangeC_Int_rangeC

<span class="keyword1"><span class="command">bundle</span></span> card_datatype <span class="main">=</span>
  rangeC_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  card_Un <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  fun_eq_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  Int_Un_distrib <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  Int_Un_distrib2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  card_eq_0_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  imageI <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> image_eqI <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  conj_cong <span class="main">[</span><span class="operator">cong</span><span class="main">]</span>
  infinite_rangeIt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Cardinality primitives for polymorphic HOL types›</span></span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Card_Simp_Rules</span> <span class="main">=</span> <span class="entity">Named_Thms</span>
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> card_simps<span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">description</span> <span class="main">=</span> <span class="inner_quoted">"Simplification rules for cardinality of types"</span>
<span class="main">)</span>
›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Card_Simp_Rules.setup</span>›</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">card_fun</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">card_fun</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="main">1</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">^</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> CARD_fun <span class="main">[</span><span class="operator">card_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> card_fun <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_fun card_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">card_sum</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">card_sum</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> CARD_sum <span class="main">[</span><span class="operator">card_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> card_sum <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_UNIV_sum card_sum_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">card_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">card_option</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> CARD_option <span class="main">[</span><span class="operator">card_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span> option<span class="main">)</span> <span class="main">=</span> card_option <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_option_def card_UNIV_option<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">card_prod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">card_prod</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> CARD_prod <span class="main">[</span><span class="operator">card_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">*</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> card_prod <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_prod_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">card_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">card_list</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> CARD_list <span class="main">[</span><span class="operator">card_simps</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span> list<span class="main">)</span> <span class="main">=</span> card_list <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_list_def infinite_UNIV_listI<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="List_Fusion">
<div class="head">
<h1>Theory List_Fusion</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/List_Fusion.thy
    Author:     Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> List_Fusion
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Shortcut fusion for lists›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Option_map_mono <span class="main">[</span><span class="operator">partial_function_mono</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mono_option <span class="free">f</span> <span class="main">⟹</span> mono_option <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> map_option <span class="free">g</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> monotoneI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> monotoneD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_option_case flat_ord_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> list_all2_coinduct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> Nil Cons<span class="main">,</span> <span class="operator">case_conclusion</span> Cons hd tl<span class="main">,</span> <span class="operator">coinduct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">pred</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> list_all2<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Nil'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="free">X</span> <span class="bound">xs</span> <span class="bound">ys</span> <span class="main">⟹</span> <span class="bound">xs</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟷</span> <span class="bound">ys</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Cons'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">X</span> <span class="bound">xs</span> <span class="bound">ys</span><span class="main">;</span> <span class="bound">xs</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">(</span>hd <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>hd <span class="bound">ys</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">X</span> <span class="main">(</span>tl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>tl <span class="bound">ys</span><span class="main">)</span> <span class="main">∨</span> list_all2 <span class="free">A</span> <span class="main">(</span>tl <span class="bound">xs</span><span class="main">)</span> <span class="main">(</span>tl <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"list_all2 <span class="free">A</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> X
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword1"><span class="command">from</span></span> Nil'<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Nil'<span class="main">[</span><span class="operator">OF</span> Cons.prems<span class="main">]</span> Cons'<span class="main">[</span><span class="operator">OF</span> Cons.prems<span class="main">]</span> Cons.IH
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The type of generators for finite lists›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> raw_generator <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">terminates_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> raw_generator <span class="main">⇒</span> <span class="tfree">'s</span> set"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> raw_generator"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  stop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> fst <span class="free">g</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∈</span> <span class="free">terminates_on</span> <span class="free">g</span>"</span></span>
<span class="main">|</span> unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> fst <span class="free">g</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span> snd <span class="main">(</span>snd <span class="free">g</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">terminates_on</span> <span class="free">g</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∈</span> <span class="free">terminates_on</span> <span class="free">g</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">terminates</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> raw_generator <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">terminates</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">⟷</span> <span class="main">(</span>terminates_on <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> UNIV<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> terminatesI <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">?</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">∈</span> terminates_on <span class="free">g</span><span class="main">)</span> <span class="main">⟹</span> terminates <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> terminates_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> terminatesD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"terminates <span class="free">g</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">∈</span> terminates_on <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> terminates_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> terminates_on_stop<span class="main">:</span>
  <span class="quoted"><span class="quoted">"terminates_on <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">,</span> <span class="free">next</span><span class="main">)</span> <span class="main">=</span> UNIV"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> terminates_on.stop<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> wf_terminates<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> fst <span class="free">g</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="main">(</span>snd <span class="main">(</span>snd <span class="free">g</span> <span class="bound">s</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"terminates <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> terminatesI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹wf <span class="free">R</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">∈</span> terminates_on <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_induct<span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">consumes</span> 1<span class="main"><span class="main">,</span></span> <span class="operator">case_names</span> wf<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>wf <span class="skolem">s</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"fst <span class="free">g</span> <span class="skolem">s</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>snd <span class="main">(</span>snd <span class="free">g</span> <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> step<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>snd <span class="free">g</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">∈</span> terminates_on <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> wf.IH<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> terminates_on.unfold<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">rule</span> terminates_on.stop<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> terminates_wfD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"terminates <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf <span class="main">{</span><span class="main">(</span>snd <span class="main">(</span>snd <span class="free">g</span> <span class="bound">s</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">|</span> <span class="bound">s</span> <span class="main">.</span> fst <span class="free">g</span> <span class="bound">s</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> wfUNIVI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">thesis</span> <span class="skolem">s</span>
  <span class="keyword3"><span class="command">assume</span></span> wf <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">s'</span><span class="main">.</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span>snd <span class="main">(</span>snd <span class="free">g</span> <span class="bound">s</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">|</span><span class="bound">s</span><span class="main">.</span> fst <span class="free">g</span> <span class="bound">s</span><span class="main">}</span> <span class="main">⟶</span> <span class="skolem">thesis</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">⟶</span> <span class="skolem">thesis</span> <span class="bound">s</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">∈</span> terminates_on <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> terminates_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">thesis</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> wf<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> terminates_wfE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"terminates <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">R</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"wf <span class="free">R</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> fst <span class="free">g</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="main">(</span>snd <span class="main">(</span>snd <span class="free">g</span> <span class="bound">s</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> that<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> terminates_wfD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> raw_generator"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>option<span class="main">)</span> <span class="entity">terminates_within</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> nat option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">terminates_within</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">has_next</span><span class="main">,</span> <span class="bound">next</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span>
    <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">has_next</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> 
          map_option <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="free">terminates_within</span> <span class="main">(</span>snd <span class="main">(</span><span class="bound">next</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
       <span class="keyword1">else</span> Some <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> terminates_on_conv_dom_terminates_within<span class="main">:</span>
  <span class="quoted"><span class="quoted">"terminates_on <span class="free">g</span> <span class="main">=</span> dom terminates_within"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">∈</span> terminates_on <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">n</span><span class="main">.</span> terminates_within <span class="skolem">s</span> <span class="main">=</span> Some <span class="bound">n</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span><span class="main">)</span><span class="main">(</span><span class="operator">subst</span> terminates_within.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">n</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"terminates_within <span class="skolem">s</span> <span class="main">=</span> Some <span class="skolem">n</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">∈</span> terminates_on <span class="free">g</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> terminates_within.raw_induct<span class="main"><span class="main">[</span></span><span class="operator">rotated</span> 1<span class="main"><span class="main">,</span></span> <span class="operator">consumes</span> 1<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> terminates_on.intros<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> terminates_within_unfold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">has_next</span> <span class="free">s</span> <span class="main">⟹</span> 
  terminates_within <span class="main">(</span><span class="free">has_next</span><span class="main">,</span> <span class="free">next</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>terminates_within <span class="main">(</span><span class="free">has_next</span><span class="main">,</span> <span class="free">next</span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span><span class="free">next</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> terminates_within.simps<span class="main">)</span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">g</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> raw_generator<span class="main">.</span> terminates <span class="bound">g</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">morphisms</span></span> generator Generator
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">,</span> undefined<span class="main">)</span> <span class="main">∈</span> <span class="var">?generator</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> terminates_on_stop terminates_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_generator

<span class="keyword1"><span class="command">lemma</span></span> terminates_on_generator_eq_UNIV<span class="main">:</span>
  <span class="quoted"><span class="quoted">"terminates_on <span class="main">(</span>generator <span class="free">g</span><span class="main">)</span> <span class="main">=</span> UNIV"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> terminates_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> terminates_within_stop<span class="main">:</span>
  <span class="quoted"><span class="quoted">"terminates_within <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">,</span> <span class="free">next</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> Some <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> terminates_within.simps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> terminates_within_generator_neq_None<span class="main">:</span>
  <span class="quoted"><span class="quoted">"terminates_within <span class="main">(</span>generator <span class="free">g</span><span class="main">)</span> <span class="free">s</span> <span class="main">≠</span> None"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> terminates_def terminates_on_conv_dom_terminates_within<span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> list <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">has_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">has_next</span> <span class="main">=</span> fst <span class="main">(</span>generator <span class="free">g</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted">"<span class="entity">next</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">next</span> <span class="main">=</span> snd <span class="main">(</span>generator <span class="free">g</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">unfoldr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">unfoldr</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> has_next <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> next <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> <span class="bound">a</span> <span class="main">#</span> <span class="free">unfoldr</span> <span class="bound">s'</span> <span class="keyword1">else</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"terminates <span class="main">(</span>generator <span class="free">g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> generator<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> terminates_wfE<span class="main">)</span><span class="main">(</span><span class="operator">erule</span> <span class="quoted">"termination"</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> has_next_def next_def snd_conv<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">declare</span></span> unfoldr.simps <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"has_next <span class="free">s</span> <span class="main">⟹</span> unfoldr <span class="free">s</span> <span class="main">=</span> fst <span class="main">(</span>next <span class="free">s</span><span class="main">)</span> <span class="main">#</span> unfoldr <span class="main">(</span>snd <span class="main">(</span>next <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> has_next <span class="free">s</span> <span class="main">⟹</span> unfoldr <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unfoldr.simps split_beta<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span> 
  list.has_next_def<span class="main">[</span><span class="operator">code</span><span class="main">]</span>
  list.next_def<span class="main">[</span><span class="operator">code</span><span class="main">]</span>
  list.unfoldr.simps<span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> generator_has_next_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_generator <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> fst list.has_next"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> generator.pcr_cr_eq cr_generator_def list.has_next_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> sym<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> generator_next_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_generator <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> snd list.next"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> generator.pcr_cr_eq cr_generator_def list.next_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_eq_Nil_iff <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr <span class="free">g</span> <span class="free">s</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟷</span> <span class="main">¬</span> list.has_next <span class="free">g</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Nil_eq_unfoldr_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">[]</span> <span class="main">=</span> list.unfoldr <span class="free">g</span> <span class="free">s</span> <span class="main">⟷</span> <span class="main">¬</span> list.has_next <span class="free">g</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sym <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> sym<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generators for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> list"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">list_has_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list_has_next</span> <span class="main">[]</span> <span class="main">⟷</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">list_has_next</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">⟷</span> True"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">list_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list_next</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> terminates_list_generator<span class="main">:</span> <span class="quoted"><span class="quoted">"terminates <span class="main">(</span>list_has_next<span class="main">,</span> list_next<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">∈</span> terminates_on <span class="main">(</span>list_has_next<span class="main">,</span> list_next<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> terminates_on.intros<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> list_generator <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> list<span class="main">)</span> generator"</span></span> 
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>list_has_next<span class="main">,</span> list_next<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> terminates_list_generator<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> has_next_list_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"list.has_next list_generator <span class="main">=</span> list_has_next"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> next_list_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"list.next list_generator <span class="main">=</span> list_next"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_list_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr list_generator <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list.unfoldr_simps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> terminates_replicate_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"terminates <span class="main">(</span><span class="main">λ</span><span class="bound">n</span> <span class="main">::</span> nat<span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span><span class="main">,</span> <span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> wf_terminates<span class="main">)</span><span class="main">(</span><span class="operator">lexicographic_order</span><span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> replicate_generator <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> nat<span class="main">)</span> generator"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span><span class="main">,</span> <span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> terminates_replicate_generator<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> has_next_replicate_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.has_next <span class="main">(</span>replicate_generator <span class="free">a</span><span class="main">)</span> <span class="free">n</span> <span class="main">⟷</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> next_replicate_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.next <span class="main">(</span>replicate_generator <span class="free">a</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_replicate_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr <span class="main">(</span>replicate_generator <span class="free">a</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> replicate <span class="free">n</span> <span class="free">a</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list.unfoldr_simps<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> map_generator <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">has_next</span><span class="main">,</span> <span class="bound">next</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">has_next</span><span class="main">,</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> <span class="bound">next</span> <span class="bound">s</span> <span class="keyword1">in</span> <span class="main">(</span><span class="free">f</span> <span class="bound">a</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">erule</span> terminates_wfE<span class="main">)</span><span class="main">(</span><span class="operator">erule</span> wf_terminates<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> has_next_map_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.has_next <span class="main">(</span>map_generator <span class="free">g</span><span class="main">)</span> <span class="main">=</span> list.has_next <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">clarsimp</span>

<span class="keyword1"><span class="command">lemma</span></span> next_map_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.next <span class="main">(</span>map_generator <span class="free">g</span><span class="main">)</span> <span class="main">=</span> apfst <span class="free">f</span> <span class="main">∘</span> list.next <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff split_beta apfst_def map_prod_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_map_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr <span class="main">(</span>map_generator <span class="free">g</span><span class="main">)</span> <span class="main">=</span> map <span class="free">f</span> <span class="main">∘</span> list.unfoldr <span class="free">g</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">s</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">s</span></span> <span class="quasi_keyword">taking</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"map_generator <span class="free">g</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list.unfoldr.induct<span class="main">)</span>
      <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta apfst_def map_prod_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> raw_generator"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> raw_generator"</span></span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">append_has_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s1</span> <span class="main">×</span> <span class="tfree">'s2</span> <span class="main">+</span> <span class="tfree">'s2</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">append_has_next</span> <span class="main">(</span>Inl <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> fst <span class="free">g1</span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="main">∨</span> fst <span class="free">g2</span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">append_has_next</span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span> <span class="main">⟷</span> fst <span class="free">g2</span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">append_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s1</span> <span class="main">×</span> <span class="tfree">'s2</span> <span class="main">+</span> <span class="tfree">'s2</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'s1</span> <span class="main">×</span> <span class="tfree">'s2</span> <span class="main">+</span> <span class="tfree">'s2</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">append_next</span> <span class="main">(</span>Inl <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> fst <span class="free">g1</span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="keyword1">then</span> 
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> snd <span class="free">g1</span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> Inl <span class="main">(</span><span class="bound">s1'</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span><span class="main">)</span> 
   <span class="keyword1">else</span> <span class="free">append_next</span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">append_next</span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> snd <span class="free">g2</span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> Inr <span class="bound">s2'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> append_generator <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span> <span class="main">×</span> <span class="tfree">'s2</span> <span class="main">+</span> <span class="tfree">'s2</span><span class="main">)</span> generator"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">g1</span> <span class="bound">g2</span><span class="main">.</span> <span class="main">(</span>append_has_next <span class="bound">g1</span> <span class="bound">g2</span><span class="main">,</span> append_next <span class="bound">g1</span> <span class="bound">g2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> terminatesI<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">has_next1</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">next1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s1</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">has_next2</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">next2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s2</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">s</span>
  <span class="keyword3"><span class="command">assume</span></span> t1<span class="main">:</span> <span class="quoted"><span class="quoted">"terminates <span class="main">(</span><span class="skolem">has_next1</span><span class="main">,</span> <span class="skolem">next1</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> t2<span class="main">:</span> <span class="quoted"><span class="quoted">"terminates <span class="main">(</span><span class="skolem">has_next2</span><span class="main">,</span> <span class="skolem">next2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?has_next</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"append_has_next <span class="main">(</span><span class="skolem">has_next1</span><span class="main">,</span> <span class="skolem">next1</span><span class="main">)</span> <span class="main">(</span><span class="skolem">has_next2</span><span class="main">,</span> <span class="skolem">next2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?next</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"append_next <span class="main">(</span><span class="skolem">has_next1</span><span class="main">,</span> <span class="skolem">next1</span><span class="main">)</span> <span class="main">(</span><span class="skolem">has_next2</span><span class="main">,</span> <span class="skolem">next2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> split_beta
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span> <span class="main">=</span> terminates_on.intros
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s2</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'s2</span></span></span>
    <span class="keyword1"><span class="command">from</span></span> t2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s2</span> <span class="main">∈</span> terminates_on <span class="main">(</span><span class="skolem">has_next2</span><span class="main">,</span> <span class="skolem">next2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> terminatesD<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Inr <span class="skolem">s2</span> <span class="main">∈</span> terminates_on <span class="main">(</span><span class="var">?has_next</span><span class="main">,</span> <span class="var">?next</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="operator">auto</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> Inr' <span class="main">=</span> this

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">∈</span> terminates_on <span class="main">(</span><span class="var">?has_next</span><span class="main">,</span> <span class="var">?next</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">s</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Inr <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inr'<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Inl <span class="skolem">s1s2</span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">s1</span></span> <span class="skolem"><span class="skolem">s2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s1s2</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">s1</span><span class="main">,</span> <span class="skolem">s2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">s1s2</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> Inl <span class="main">(</span><span class="skolem">s1</span><span class="main">,</span> <span class="skolem">s2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> t1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s1</span> <span class="main">∈</span> terminates_on <span class="main">(</span><span class="skolem">has_next1</span><span class="main">,</span> <span class="skolem">next1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> terminatesD<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> s
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
      <span class="keyword3"><span class="command">case</span></span> stop <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">has_next2</span> <span class="skolem">s2</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inr'<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">append_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">×</span> <span class="tfree">'s2</span> <span class="main">+</span> <span class="tfree">'s2</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">append_init</span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span> Inl <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> has_next_append_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.has_next <span class="main">(</span>append_generator <span class="free">g1</span> <span class="free">g2</span><span class="main">)</span> <span class="main">(</span>Inl <span class="main">(</span><span class="free">s1</span><span class="main">,</span> <span class="free">s2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span>
   list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="main">∨</span> list.has_next <span class="free">g2</span> <span class="free">s2</span>"</span></span>
  <span class="quoted"><span class="quoted">"list.has_next <span class="main">(</span>append_generator <span class="free">g1</span> <span class="free">g2</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">s2</span><span class="main">)</span> <span class="main">⟷</span> list.has_next <span class="free">g2</span> <span class="free">s2</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> next_append_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.next <span class="main">(</span>append_generator <span class="free">g1</span> <span class="free">g2</span><span class="main">)</span> <span class="main">(</span>Inl <span class="main">(</span><span class="free">s1</span><span class="main">,</span> <span class="free">s2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="keyword1">then</span> 
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> Inl <span class="main">(</span><span class="bound">s1'</span><span class="main">,</span> <span class="free">s2</span><span class="main">)</span><span class="main">)</span>
   <span class="keyword1">else</span> list.next <span class="main">(</span>append_generator <span class="free">g1</span> <span class="free">g2</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">s2</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"list.next <span class="main">(</span>append_generator <span class="free">g1</span> <span class="free">g2</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">s2</span><span class="main">)</span> <span class="main">=</span> apsnd Inr <span class="main">(</span>list.next <span class="free">g2</span> <span class="free">s2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> apsnd_def map_prod_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_append_generator_Inr<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"list.unfoldr <span class="main">(</span>append_generator <span class="free">g1</span> <span class="free">g2</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">s2</span><span class="main">)</span> <span class="main">=</span> list.unfoldr <span class="free">g2</span> <span class="free">s2</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">s2</span></span> <span class="quasi_keyword">taking</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">g2</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list.unfoldr.induct<span class="main">)</span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_append_generator_Inl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr <span class="main">(</span>append_generator <span class="free">g1</span> <span class="free">g2</span><span class="main">)</span> <span class="main">(</span>Inl <span class="main">(</span><span class="free">s1</span><span class="main">,</span> <span class="free">s2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
   list.unfoldr <span class="free">g1</span> <span class="free">s1</span> <span class="main">@</span> list.unfoldr <span class="free">g2</span> <span class="free">s2</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">s1</span></span> <span class="quasi_keyword">taking</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">g1</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list.unfoldr.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 3<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> apsnd_def map_prod_def unfoldr_append_generator_Inr<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list.unfoldr_simps<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_append_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr <span class="main">(</span>append_generator <span class="free">g1</span> <span class="free">g2</span><span class="main">)</span> <span class="main">(</span>append_init <span class="free">s1</span> <span class="free">s2</span><span class="main">)</span> <span class="main">=</span>
   list.unfoldr <span class="free">g1</span> <span class="free">s1</span> <span class="main">@</span> list.unfoldr <span class="free">g2</span> <span class="free">s2</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unfoldr_append_generator_Inl append_init_def<span class="main">)</span>


<span class="keyword1"><span class="command">lift_definition</span></span> zip_generator <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'s1</span> <span class="main">×</span> <span class="tfree">'s2</span><span class="main">)</span> generator"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">has_next1</span><span class="main">,</span> <span class="bound">next1</span><span class="main">)</span> <span class="main">(</span><span class="bound">has_next2</span><span class="main">,</span> <span class="bound">next2</span><span class="main">)</span><span class="main">.</span> 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s1</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span><span class="main">.</span> <span class="bound">has_next1</span> <span class="bound">s1</span> <span class="main">∧</span> <span class="bound">has_next2</span> <span class="bound">s2</span><span class="main">,</span> 
       <span class="main">λ</span><span class="main">(</span><span class="bound">s1</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> <span class="bound">next1</span> <span class="bound">s1</span><span class="main">;</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> <span class="bound">next2</span> <span class="bound">s2</span>
                  <span class="keyword1">in</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">s1'</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> terminatesI<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">has_next1</span> <span class="skolem">next1</span> <span class="skolem">has_next2</span> <span class="skolem">next2</span> <span class="skolem">s1</span> <span class="skolem">s2</span>
  <span class="keyword3"><span class="command">assume</span></span> t1<span class="main">:</span> <span class="quoted"><span class="quoted">"terminates <span class="main">(</span><span class="skolem">has_next1</span><span class="main">,</span> <span class="skolem">next1</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> t2<span class="main">:</span> <span class="quoted"><span class="quoted">"terminates <span class="main">(</span><span class="skolem">has_next2</span><span class="main">,</span> <span class="skolem">next2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s1</span> <span class="main">∈</span> terminates_on <span class="main">(</span><span class="skolem">has_next1</span><span class="main">,</span> <span class="skolem">next1</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s2</span> <span class="main">∈</span> terminates_on <span class="main">(</span><span class="skolem">has_next2</span><span class="main">,</span> <span class="skolem">next2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> t1 t2 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> terminatesD<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">s1</span><span class="main">,</span> <span class="skolem">s2</span><span class="main">)</span> <span class="main">∈</span> terminates_on <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s1</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span><span class="main">.</span> <span class="skolem">has_next1</span> <span class="bound">s1</span> <span class="main">∧</span> <span class="skolem">has_next2</span> <span class="bound">s2</span><span class="main">,</span> <span class="main">λ</span><span class="main">(</span><span class="bound">s1</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">next1</span> <span class="bound">s1</span><span class="main">;</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">next2</span> <span class="bound">s2</span> <span class="keyword1">in</span> <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">s1'</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">s2</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> terminates_on.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> terminates_on.intros <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta Let_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">zip_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">×</span> <span class="tfree">'s2</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">zip_init</span> <span class="main">≡</span> Pair"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> has_next_zip_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"list.has_next <span class="main">(</span>zip_generator <span class="free">g1</span> <span class="free">g2</span><span class="main">)</span> <span class="main">(</span><span class="free">s1</span><span class="main">,</span> <span class="free">s2</span><span class="main">)</span> <span class="main">⟷</span> 
   list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="main">∧</span> list.has_next <span class="free">g2</span> <span class="free">s2</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">clarsimp</span>

<span class="keyword1"><span class="command">lemma</span></span> next_zip_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"list.next <span class="main">(</span>zip_generator <span class="free">g1</span> <span class="free">g2</span><span class="main">)</span> <span class="main">(</span><span class="free">s1</span><span class="main">,</span> <span class="free">s2</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="main">(</span>fst <span class="main">(</span>list.next <span class="free">g1</span> <span class="free">s1</span><span class="main">)</span><span class="main">,</span> fst <span class="main">(</span>list.next <span class="free">g2</span> <span class="free">s2</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> 
   <span class="main">(</span>snd <span class="main">(</span>list.next <span class="free">g1</span> <span class="free">s1</span><span class="main">)</span><span class="main">,</span> snd <span class="main">(</span>list.next <span class="free">g2</span> <span class="free">s2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_zip_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr <span class="main">(</span>zip_generator <span class="free">g1</span> <span class="free">g2</span><span class="main">)</span> <span class="main">(</span>zip_init <span class="free">s1</span> <span class="free">s2</span><span class="main">)</span> <span class="main">=</span> 
   zip <span class="main">(</span>list.unfoldr <span class="free">g1</span> <span class="free">s1</span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free">g2</span> <span class="free">s2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s1</span><span class="main">,</span> <span class="free">s2</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s1</span></span> <span class="quoted"><span class="free">s2</span></span> <span class="quasi_keyword">taking</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"zip_generator <span class="free">g1</span> <span class="free">g2</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list.unfoldr.induct<span class="main">)</span>
  <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 3<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> 9 2 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">bound</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> upt_generator <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span> nat<span class="main">)</span> generator"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="bound">n</span> <span class="main">&lt;</span> <span class="free">bound</span><span class="main">,</span> <span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span> Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> wf_terminates<span class="main">)</span><span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">bound</span> <span class="main">-</span> <span class="bound">n</span><span class="main">)</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> has_next_upt_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.has_next upt_generator <span class="free">n</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="free">bound</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> next_upt_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.next upt_generator <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="free">n</span><span class="main">,</span> Suc <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_upt_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr upt_generator <span class="free">n</span> <span class="main">=</span> <span class="main">[</span><span class="free">n</span><span class="main">..&lt;</span><span class="free">bound</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">bound</span> <span class="main">-</span> <span class="free">n</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list.unfoldr_simps upt_conv_Cons<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">bound</span> <span class="main">::</span> <span class="quoted">int</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> upto_generator <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> int<span class="main">)</span> generator"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="bound">n</span> <span class="main">≤</span> <span class="free">bound</span><span class="main">,</span> <span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> wf_terminates<span class="main">)</span><span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> nat <span class="main">(</span><span class="free">bound</span> <span class="main">+</span> <span class="main">1</span> <span class="main">-</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> has_next_upto_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.has_next upto_generator <span class="free">n</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">≤</span> <span class="free">bound</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> next_upto_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.next upto_generator <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_upto_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr upto_generator <span class="free">n</span> <span class="main">=</span> <span class="main">[</span><span class="free">n</span><span class="main">..</span><span class="free">bound</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">taking</span><span class="main"><span class="main">:</span></span> <span class="quoted">upto_generator</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list.unfoldr.induct<span class="main">)</span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> upto.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> raw_generator"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">filter_has_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> fst <span class="free">g</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span> <span class="free">P</span> <span class="main">(</span>fst <span class="main">(</span>snd <span class="free">g</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">filter_has_next</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> fst <span class="free">g</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>fst <span class="main">(</span>snd <span class="free">g</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span> <span class="free">filter_has_next</span> <span class="main">(</span>snd <span class="main">(</span>snd <span class="free">g</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">filter_has_next</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>tailrec<span class="main">)</span> <span class="entity">filter_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">filter_next</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> snd <span class="free">g</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">filter_next</span> <span class="bound">s'</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> filter_generator <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">g</span><span class="main">.</span> <span class="main">(</span>filter_has_next <span class="bound">g</span><span class="main">,</span> filter_next <span class="bound">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> wf_terminates<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> raw_generator"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">s</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span>snd <span class="main">(</span>snd <span class="skolem">g</span> <span class="bound">s</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">|</span> <span class="bound">s</span><span class="main">.</span> fst <span class="skolem">g</span> <span class="bound">s</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?g</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>filter_has_next <span class="skolem">g</span><span class="main">,</span> filter_next <span class="skolem">g</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"terminates <span class="skolem">g</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span><span class="var">?R</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> terminates_wfD<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> wf_trancl<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"fst <span class="var">?g</span> <span class="skolem">s</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"filter_has_next <span class="skolem">g</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>snd <span class="main">(</span>snd <span class="var">?g</span> <span class="skolem">s</span><span class="main">)</span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?R</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">subst</span> filter_next.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta filter_next.simps <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> trancl_into_trancl<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> has_next_filter_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.has_next <span class="main">(</span>filter_generator <span class="free">g</span><span class="main">)</span> <span class="free">s</span> <span class="main">⟷</span>
  list.has_next <span class="free">g</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g</span> <span class="free">s</span> <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> True <span class="keyword1">else</span> list.has_next <span class="main">(</span>filter_generator <span class="free">g</span><span class="main">)</span> <span class="bound">s'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> filter_has_next.simps<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> next_filter_generator<span class="main">:</span>
   <span class="quoted"><span class="quoted">"list.next <span class="main">(</span>filter_generator <span class="free">g</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g</span> <span class="free">s</span>
    <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="keyword1">else</span> list.next <span class="main">(</span>filter_generator <span class="free">g</span><span class="main">)</span> <span class="bound">s'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> filter_next.simps<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> has_next_filter_generator_induct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> find step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"list.has_next <span class="main">(</span>filter_generator <span class="free">g</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> find<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> list.has_next <span class="free">g</span> <span class="bound">s</span><span class="main">;</span> <span class="free">P</span> <span class="main">(</span>fst <span class="main">(</span>list.next <span class="free">g</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="bound">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> list.has_next <span class="free">g</span> <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>fst <span class="main">(</span>list.next <span class="free">g</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> <span class="free">Q</span> <span class="main">(</span>snd <span class="main">(</span>list.next <span class="free">g</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="bound">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> filter_has_next.induct<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> filter_generator_empty_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.has_next <span class="main">(</span>filter_generator <span class="free">g</span><span class="main">)</span> <span class="free">s</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>set <span class="main">(</span>list.unfoldr <span class="free">g</span> <span class="free">s</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> has_next_filter_generator_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>find <span class="skolem">s</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"list.next <span class="free">g</span> <span class="skolem">s</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">s</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"list.next <span class="free">g</span> <span class="skolem">s</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>list.unfoldr <span class="free">g</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">xs</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"list.unfoldr <span class="free">g</span> <span class="free">s</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> Nil_eq_unfoldr_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x'</span> <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x'</span> <span class="main">#</span> <span class="skolem">xs</span> <span class="main">=</span> list.unfoldr <span class="free">g</span> <span class="skolem">s</span>›</span></span><span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>list.next <span class="free">g</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x'</span> <span class="main">∧</span> list.has_next <span class="free">g</span> <span class="skolem">s</span> <span class="main">∧</span> list.unfoldr <span class="free">g</span> <span class="main">(</span>snd <span class="main">(</span>list.next <span class="free">g</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">xs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> Cons.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"snd <span class="main">(</span>list.next <span class="free">g</span> <span class="skolem">s</span><span class="main">)</span>"</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span>list.unfoldr <span class="free">g</span> <span class="skolem">s</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="skolem">x</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> has_next_filter_generator<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_filter_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr <span class="main">(</span>filter_generator <span class="free">g</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> filter <span class="free">P</span> <span class="main">(</span>list.unfoldr <span class="free">g</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> list_all2_eq
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> filter_empty_conv filter_generator_empty_conv<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">s</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"list.has_next <span class="main">(</span>filter_generator <span class="free">g</span><span class="main">)</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> has_next_filter_generator_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>find <span class="skolem">s</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 3 5<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> has_next_filter_generator<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> next_filter_generator<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> disjI1 exI conjI refl<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> next_filter_generator<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">s</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> step.hyps
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list.unfoldr <span class="main">(</span>filter_generator <span class="free">g</span><span class="main">)</span> <span class="skolem">s</span> <span class="main">=</span> list.unfoldr <span class="main">(</span>filter_generator <span class="free">g</span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span>list.next <span class="free">g</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> has_next_filter_generator<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> next_filter_generator<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> step.hyps
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"filter <span class="free">P</span> <span class="main">(</span>list.unfoldr <span class="free">g</span> <span class="main">(</span>snd <span class="main">(</span>list.next <span class="free">g</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> filter <span class="free">P</span> <span class="main">(</span>list.unfoldr <span class="free">g</span> <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> step.IH <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Destroying lists›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hd_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hd_fusion</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> hd <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hd_fusion_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"hd_fusion <span class="free">g</span> <span class="free">s</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g</span> <span class="free">s</span> <span class="keyword1">then</span> fst <span class="main">(</span>list.next <span class="free">g</span> <span class="free">s</span><span class="main">)</span> <span class="keyword1">else</span> undefined<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> hd_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hd_def split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> hd_fusion_def <span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fold_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fold_fusion</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> fold <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fold_fusion_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fold_fusion <span class="free">g</span> <span class="free">f</span> <span class="free">s</span> <span class="free">b</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g</span> <span class="free">s</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g</span> <span class="free">s</span>
     <span class="keyword1">in</span> fold_fusion <span class="free">g</span> <span class="free">f</span> <span class="bound">s'</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span> <span class="free">b</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fold_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> fold_fusion_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">gen_length_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_length_fusion</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">+</span> length <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> gen_length_fusion_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"gen_length_fusion <span class="free">g</span> <span class="free">n</span> <span class="free">s</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g</span> <span class="free">s</span> <span class="keyword1">then</span> gen_length_fusion <span class="free">g</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span>list.next <span class="free">g</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> gen_length_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">length_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">length_fusion</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> length <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> length_fusion_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"length_fusion <span class="free">g</span> <span class="main">=</span> gen_length_fusion <span class="free">g</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff length_fusion_def gen_length_fusion_def<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> length_fusion_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'b</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">map_fusion</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> map <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_fusion_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_fusion <span class="free">f</span> <span class="free">g</span> <span class="free">s</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g</span> <span class="free">s</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g</span> <span class="free">s</span>
     <span class="keyword1">in</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">#</span> map_fusion <span class="free">f</span> <span class="free">g</span> <span class="bound">s'</span>
   <span class="keyword1">else</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> map_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> map_fusion_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">append_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">append_fusion</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span> list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="main">@</span> list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> append_fusion <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"append_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span>
     <span class="keyword1">in</span> <span class="bound">x</span> <span class="main">#</span> append_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="bound">s1'</span> <span class="free">s2</span>
   <span class="keyword1">else</span> list.unfoldr <span class="free">g2</span> <span class="free">s2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> append_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> append_fusion_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">zip_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">zip_fusion</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span> zip <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> zip_fusion_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"zip_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="main">∧</span> list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span><span class="main">;</span>
         <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
     <span class="keyword1">in</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">#</span> zip_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="bound">s1'</span> <span class="bound">s2'</span>
   <span class="keyword1">else</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> zip_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> zip_fusion_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">list_all_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">list_all_fusion</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> List.list_all <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> list_all_fusion_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list_all_fusion <span class="free">g</span> <span class="free">P</span> <span class="free">s</span> <span class="main">⟷</span>
  <span class="main">(</span>list.has_next <span class="free">g</span> <span class="free">s</span> <span class="main">⟶</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g</span> <span class="free">s</span>
    <span class="keyword1">in</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">∧</span> list_all_fusion <span class="free">g</span> <span class="free">P</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> list_all_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> list_all_fusion_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">list_all2_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list_all2_fusion</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span> 
   list_all2 <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> list_all2_fusion_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list_all2_fusion <span class="free">P</span> <span class="free">g1</span> <span class="free">g2</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="keyword1">then</span>
     list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="main">∧</span>
     <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span><span class="main">;</span>
          <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
      <span class="keyword1">in</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">∧</span> list_all2_fusion <span class="free">P</span> <span class="free">g1</span> <span class="free">g2</span> <span class="bound">s1'</span> <span class="bound">s2'</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="main">¬</span> list.has_next <span class="free">g2</span> <span class="free">s2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> list_all2_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> list_all2_fusion_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">singleton_list_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'state</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">singleton_list_fusion</span> <span class="free"><span class="bound"><span class="entity">gen</span></span></span> <span class="free"><span class="bound"><span class="entity">state</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> list.unfoldr <span class="free"><span class="bound"><span class="entity">gen</span></span></span> <span class="free"><span class="bound"><span class="entity">state</span></span></span> <span class="keyword1">of</span> <span class="main">[</span><span class="main"><span class="bound">_</span></span><span class="main">]</span> <span class="main">⇒</span> True <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> singleton_list_fusion_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"singleton_list_fusion <span class="free">g</span> <span class="free">s</span> <span class="main">⟷</span>
  list.has_next <span class="free">g</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">¬</span> list.has_next <span class="free">g</span> <span class="main">(</span>snd <span class="main">(</span>list.next <span class="free">g</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 5 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> singleton_list_fusion_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.split if_split_asm prod.splits <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> list.unfoldr.elims <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> sym<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Lexicographic_Order">
<div class="head">
<h1>Theory Lexicographic_Order</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Lexicographic_Order.thy
    Author:     Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> Lexicographic_Order <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="List_Fusion.html">List_Fusion</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Char_ord.html">HOL-Library.Char_ord</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> List.lexordp

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹List fusion for lexicographic order›</span></span>

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lexordp_take_index_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lexordp <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> 
   <span class="main">(</span>length <span class="free">xs</span> <span class="main">&lt;</span> length <span class="free">ys</span> <span class="main">∧</span> take <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span> <span class="free">xs</span><span class="main">)</span> <span class="main">∨</span>
   <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">i</span></span> <span class="main">&lt;</span> min <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>length <span class="free">ys</span><span class="main">)</span><span class="main">.</span> take <span class="bound">i</span> <span class="free">xs</span> <span class="main">=</span> take <span class="bound">i</span> <span class="free">ys</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">ys</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> disjCI <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> disjI2 exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Suc <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">i</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?prefix</span> <span class="main">∨</span> <span class="var">?less</span>"</span></span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?prefix</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">@</span> hd <span class="main">(</span>drop <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="main">#</span> tl <span class="main">(</span>drop <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_Nil2 append_take_drop_id less_not_refl list.collapse<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> lexordp_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?less</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> min <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>length <span class="free">ys</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"take <span class="skolem">i</span> <span class="free">xs</span> <span class="main">=</span> take <span class="skolem">i</span> <span class="free">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> nth<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">ys</span> <span class="main">!</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> take <span class="skolem">i</span> <span class="free">xs</span> <span class="main">@</span> <span class="free">xs</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">#</span> drop <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> take <span class="skolem">i</span> <span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">#</span> drop <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">subst</span> append_take_drop_id<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">i</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cons_nth_drop_Suc<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> nth <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> lexordp_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">― ‹lexord is extension of partial ordering List.lex›</span> 
<span class="keyword1"><span class="command">lemma</span></span> lexordp_lex<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span><span class="main">,</span> <span class="free">ys</span><span class="main">)</span> <span class="main">∈</span> lex <span class="main">{</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">&lt;</span> <span class="bound">ys</span><span class="main">}</span> <span class="main">⟷</span> lexordp <span class="free">xs</span> <span class="free">ys</span> <span class="main">∧</span> length <span class="free">xs</span> <span class="main">=</span> length <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> Cons <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>                

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Setup for list fusion›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lexord_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lexord_fusion</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span> lexordp <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lexord_eq_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lexord_eq_fusion</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span> lexordp_eq <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lexord_fusion_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lexord_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="keyword1">then</span>
     <span class="keyword1">if</span> list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="keyword1">then</span>
       <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span><span class="main">;</span>
           <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
       <span class="keyword1">in</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="main">∨</span> <span class="main">¬</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="main">∧</span> lexord_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="bound">s1'</span> <span class="bound">s2'</span>
     <span class="keyword1">else</span> False
   <span class="keyword1">else</span> list.has_next <span class="free">g2</span> <span class="free">s2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lexord_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lexord_eq_fusion_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lexord_eq_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">⟷</span>
  <span class="main">(</span>list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="main">⟶</span>
   list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="main">∧</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
    <span class="keyword1">in</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="main">∨</span> <span class="main">¬</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="main">∧</span> lexord_eq_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="bound">s1'</span> <span class="bound">s2'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lexord_eq_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  lexord_fusion_code ord.lexord_fusion_code
  lexord_eq_fusion_code ord.lexord_eq_fusion_code

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span> <span class="main">=</span>
  lexord_fusion_def ord.lexord_fusion_def
  lexord_eq_fusion_def ord.lexord_eq_fusion_def

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Extend_Partial_Order">
<div class="head">
<h1>Theory Extend_Partial_Order</h1>
</div>
<pre class="source"><span class="comment1">(* Title:      Containers/Extend_Partial_Order.thy
   Author:     Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> Extend_Partial_Order
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Every partial order can be extended to a total order›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ChainsD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">C</span><span class="main">;</span> <span class="free">C</span> <span class="main">∈</span> Chains <span class="free">r</span><span class="main">;</span> <span class="free">y</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span> <span class="main">∨</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Chains_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Chains_Field<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">C</span> <span class="main">∈</span> Chains <span class="free">r</span><span class="main">;</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> Field <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Chains_def Field_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> total_onD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> total_on <span class="free">A</span> <span class="free">r</span><span class="main">;</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">;</span> <span class="free">y</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∨</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> total_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> linear_order_imp_linorder<span class="main">:</span> <span class="quoted"><span class="quoted">"linear_order <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="free">leq</span> <span class="bound">A</span> <span class="bound">B</span><span class="main">}</span> <span class="main">⟹</span> class.linorder <span class="free">leq</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">leq</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">leq</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linear_order_on_def partial_order_on_def preorder_on_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD antisymD transD total_onD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> linorder<span class="main">)</span> linear_order<span class="main">:</span> <span class="quoted"><span class="quoted">"linear_order <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">A</span> <span class="main">≤</span> <span class="bound">B</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linear_order_on_def partial_order_on_def preorder_on_def total_on_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> refl_onI antisymI transI<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">order_consistent</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">order_consistent</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="bound">a'</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">a'</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">a'</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">a'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> order_consistent_sym<span class="main">:</span>
  <span class="quoted"><span class="quoted">"order_consistent <span class="free">r</span> <span class="free">s</span> <span class="main">⟹</span> order_consistent <span class="free">s</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> order_consistent_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> antisym_order_consistent_self<span class="main">:</span>
  <span class="quoted"><span class="quoted">"antisym <span class="free">r</span> <span class="main">⟹</span> order_consistent <span class="free">r</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> order_consistent_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> antisymD<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> refl_on_trancl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">A</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">A</span> <span class="main">(</span><span class="free">r</span><span class="main">^+</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> refl_onI<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> conjI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main">^+</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∧</span> <span class="skolem">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> refl_onD1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span> refl_onD2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> total_on_refl_on_consistent_into<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"total_on <span class="free">A</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">A</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> consist<span class="main">:</span> <span class="quoted"><span class="quoted">"order_consistent <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">with</span></span> r x y <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span> <span class="main">∨</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> total_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> s consist <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> order_consistent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">contradiction</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> refl_onD r x y<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> porder_linorder_tranclpE <span class="main">[</span><span class="operator">consumes</span> 5<span class="main">,</span> <span class="operator">case_names</span> base step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"partial_order_on <span class="free">A</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"linear_order_on <span class="free">B</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> consist<span class="main">:</span> <span class="quoted"><span class="quoted">"order_consistent <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> B_subset_A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> trancl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">r</span> <span class="main">∪</span> <span class="free">s</span><span class="main">)</span><span class="main">^+</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
        <span class="main">|</span> <span class="free">u</span> <span class="free">v</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">atomize_elim</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> r <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">A</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"trans <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> partial_order_on_def preorder_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">B</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"total_on <span class="free">B</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"trans <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> partial_order_on_def preorder_on_def linear_order_on_def<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> trancl <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>base <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹refl_on <span class="free">B</span> <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">B</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD1 refl_onD2<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">with</span></span> B_subset_A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹refl_on <span class="free">A</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> refl_onD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span> <span class="main">∪</span> <span class="free">s</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹refl_on <span class="free">B</span> <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="free">B</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD2 refl_onD1<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">from</span></span> step.IH <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="free">B</span>›</span></span> B_subset_A <span class="quoted"><span class="quoted">‹refl_on <span class="free">A</span> <span class="free">r</span>›</span></span> 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD<span class="main">)</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹refl_on <span class="free">B</span> <span class="free">s</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> refl_onD2<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹total_on <span class="free">B</span> <span class="free">s</span>›</span></span> <span class="quoted"><span class="quoted">‹refl_on <span class="free">B</span> <span class="free">s</span>›</span></span> order_consistent_sym<span class="main">[</span><span class="operator">OF</span> consist<span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="free">B</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> total_on_refl_on_consistent_into<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹trans <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> transD<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹trans <span class="free">s</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> transD<span class="main">)</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">∈</span> <span class="free">B</span>›</span></span> B_subset_A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹refl_on <span class="free">A</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> refl_onD<span class="main">)</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> step.IH <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> transD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹trans <span class="free">r</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> porder_on_consistent_linorder_on_trancl_antisym<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"partial_order_on <span class="free">A</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"linear_order_on <span class="free">B</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> consist<span class="main">:</span> <span class="quoted"><span class="quoted">"order_consistent <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> B_subset_A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"antisym <span class="main">(</span><span class="main">(</span><span class="free">r</span> <span class="main">∪</span> <span class="free">s</span><span class="main">)</span><span class="main">^+</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> antisymI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">r</span> <span class="main">∪</span> <span class="free">s</span><span class="main">)</span><span class="main">^+</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rs</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> r <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"antisym <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"trans <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> partial_order_on_def preorder_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"total_on <span class="free">B</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">B</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"trans <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"antisym <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> partial_order_on_def preorder_on_def linear_order_on_def<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> r s consist B_subset_A <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rs</span>›</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> porder_linorder_tranclpE<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> base
    <span class="keyword1"><span class="command">from</span></span> r s consist B_subset_A <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rs</span>›</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> porder_linorder_tranclpE<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> base
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹antisym <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> antisymD<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> transD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹trans <span class="free">r</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> consist <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span> 
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> order_consistent_def<span class="main">)</span> 
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> transD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹trans <span class="free">r</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹antisym <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> antisymD<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> r s consist B_subset_A <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rs</span>›</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> porder_linorder_tranclpE<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> base
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> transD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹trans <span class="free">r</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> consist <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> order_consistent_def<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> transD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹trans <span class="free">r</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹antisym <span class="free">r</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> antisymD<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">u'</span> <span class="skolem">v'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> r_into_s <span class="main">=</span> total_on_refl_on_consistent_into<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹total_on <span class="free">B</span> <span class="free">s</span>›</span></span> <span class="quoted"><span class="quoted">‹refl_on <span class="free">B</span> <span class="free">s</span>›</span></span> order_consistent_sym<span class="main"><span class="main">[</span></span><span class="operator">OF</span> consist<span class="main"><span class="main">]</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹refl_on <span class="free">B</span> <span class="free">s</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> <span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span> <span class="main">∈</span> <span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">∈</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD1 refl_onD2<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹trans <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> transD<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v'</span> <span class="main">∈</span> <span class="free">B</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span> <span class="main">∈</span> <span class="free">B</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> r_into_s<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">also</span></span> <span class="main">(</span>transD<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹trans <span class="free">s</span>›</span></span><span class="main">]</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹trans <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">u'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> transD<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span> <span class="main">∈</span> <span class="free">B</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u'</span> <span class="main">∈</span> <span class="free">B</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> r_into_s<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="main">(</span>transD<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹trans <span class="free">s</span>›</span></span><span class="main">]</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">=</span> <span class="skolem">u'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> antisymD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹antisym <span class="free">s</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> transD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹trans <span class="free">s</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹antisym <span class="free">s</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> antisymD<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">u'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> transD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹trans <span class="free">r</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹antisym <span class="free">r</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> antisymD<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> porder_on_linorder_on_tranclp_porder_onI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"partial_order_on <span class="free">A</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"linear_order_on <span class="free">B</span> <span class="free">s</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> consist<span class="main">:</span> <span class="quoted"><span class="quoted">"order_consistent <span class="free">r</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"partial_order_on <span class="free">A</span> <span class="main">(</span><span class="main">(</span><span class="free">r</span> <span class="main">∪</span> <span class="free">s</span><span class="main">)</span><span class="main">^+</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> partial_order_on_def preorder_on_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∪</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> r <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">A</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> partial_order_on_def preorder_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">B</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linear_order_on_def partial_order_on_def preorder_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="var">?rs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> refl_on_Un<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> subset <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∪</span> <span class="free">B</span> <span class="main">=</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">A</span> <span class="main">(</span><span class="var">?rs</span><span class="main">^+</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> refl_on_trancl<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"trans <span class="main">(</span><span class="var">?rs</span><span class="main">^+</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> trans_trancl<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> r s consist subset <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"antisym <span class="main">(</span><span class="var">?rs</span><span class="main">^+</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> porder_on_consistent_linorder_on_trancl_antisym<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> porder_extend_to_linorder<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"partial_order_on <span class="free">A</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">s</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"linear_order_on <span class="free">A</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"order_consistent <span class="free">r</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">atomize_elim</span><span class="main">)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">=</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> partial_order_on <span class="free">A</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">⊆</span> <span class="bound">s</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> r <span class="keyword1"><span class="command">have</span></span> r_in_S<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> <span class="skolem">S</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="skolem">S</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="skolem">S</span><span class="main">.</span> <span class="bound">y</span> <span class="main">⊆</span> <span class="bound">x</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Zorn_Lemma2<span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">c</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> chains <span class="skolem">S</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">⊆</span> <span class="skolem">S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chainsD2<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="skolem">S</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="skolem">c</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊆</span> <span class="bound">y</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">with</span></span> r_in_S <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">s</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">∈</span> <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">hence</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"partial_order_on <span class="free">A</span> <span class="skolem">s</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> r_in_s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">⊆</span> <span class="skolem">s</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c</span> <span class="main">⊆</span> <span class="skolem">S</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"partial_order_on <span class="free">A</span> <span class="main">(</span><span class="main">⋃</span><span class="skolem">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> partial_order_on_def preorder_on_def
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">A</span> <span class="main">(</span><span class="main">⋃</span><span class="skolem">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> refl_onI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subsetI<span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">⋃</span><span class="skolem">c</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">X</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X</span> <span class="main">∈</span> <span class="skolem">c</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">X</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c</span> <span class="main">⊆</span> <span class="skolem">S</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X</span> <span class="main">∈</span> <span class="skolem">S</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"partial_order_on <span class="free">A</span> <span class="skolem">X</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">X</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">×</span> <span class="free">A</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> partial_order_on_def preorder_on_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD1 refl_onD2<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> partial_order_on_def preorder_on_def
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">s</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⋃</span><span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> UnionI<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>

        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"antisym <span class="main">(</span><span class="main">⋃</span><span class="skolem">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> antisymI<span class="main">)</span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⋃</span><span class="skolem">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⋃</span><span class="skolem">c</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">X</span></span> <span class="skolem"><span class="skolem">Y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X</span> <span class="main">∈</span> <span class="skolem">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">∈</span> <span class="skolem">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">X</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">X</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">Y</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c</span> <span class="main">⊆</span> <span class="skolem">S</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"antisym <span class="skolem">X</span>"</span></span> <span class="quoted"><span class="quoted">"antisym <span class="skolem">Y</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> partial_order_on_def<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c</span> <span class="main">∈</span> chains <span class="skolem">S</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">X</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">Y</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> 
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X</span> <span class="main">⊆</span> <span class="skolem">Y</span> <span class="main">∨</span> <span class="skolem">Y</span> <span class="main">⊆</span> <span class="skolem">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chainsD<span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">X</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Y</span>›</span></span> 
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> antisymD<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>

        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"trans <span class="main">(</span><span class="main">⋃</span><span class="skolem">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> transI<span class="main">)</span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⋃</span><span class="skolem">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⋃</span><span class="skolem">c</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">X</span></span> <span class="skolem"><span class="skolem">Y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X</span> <span class="main">∈</span> <span class="skolem">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">∈</span> <span class="skolem">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">X</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">X</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">Y</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c</span> <span class="main">⊆</span> <span class="skolem">S</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"trans <span class="skolem">X</span>"</span></span> <span class="quoted"><span class="quoted">"trans <span class="skolem">Y</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> partial_order_on_def preorder_on_def<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">c</span> <span class="main">∈</span> chains <span class="skolem">S</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">X</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">Y</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> 
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X</span> <span class="main">⊆</span> <span class="skolem">Y</span> <span class="main">∨</span> <span class="skolem">Y</span> <span class="main">⊆</span> <span class="skolem">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chainsD<span class="main">)</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⋃</span><span class="skolem">c</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X</span> <span class="main">⊆</span> <span class="skolem">Y</span>"</span></span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹trans <span class="skolem">Y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">X</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Y</span>›</span></span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> transD<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">Y</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> UnionI<span class="main">)</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">⊆</span> <span class="skolem">X</span>"</span></span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹trans <span class="skolem">X</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">X</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Y</span>›</span></span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> transD<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">X</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> UnionI<span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">⊆</span> <span class="main">⋃</span><span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> r_in_s <span class="quoted"><span class="quoted">‹<span class="skolem">s</span> <span class="main">∈</span> <span class="skolem">c</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="skolem">c</span> <span class="main">∈</span> <span class="skolem">S</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">s</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">∈</span> <span class="skolem">S</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y_max<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">t</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">t</span> <span class="main">∈</span> <span class="skolem">S</span><span class="main">;</span> <span class="skolem">s</span> <span class="main">⊆</span> <span class="bound">t</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">s</span> <span class="main">=</span> <span class="bound">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"partial_order_on <span class="free">A</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">s</span> <span class="main">∈</span> <span class="skolem">S</span>›</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> r_in_s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">⊆</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">s</span> <span class="main">∈</span> <span class="skolem">S</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"total_on <span class="free">A</span> <span class="skolem">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> total_on_def
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> strip<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">s</span> <span class="main">∨</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">s</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> xy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">s'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">b</span> <span class="main">=</span> <span class="skolem">y</span> <span class="main">∨</span> <span class="bound">b</span> <span class="main">=</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">a</span> <span class="main">=</span> <span class="skolem">y</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">=</span> <span class="skolem">y</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">s</span> <span class="main">∪</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">^+</span>"</span></span>
      <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹partial_order_on <span class="free">A</span> <span class="skolem">s</span>›</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"linear_order_on <span class="main">{</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">}</span> <span class="skolem">s'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> s'_def
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linear_order_on_def partial_order_on_def preorder_on_def total_on_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> refl_onI transI antisymI<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"order_consistent <span class="skolem">s</span> <span class="skolem">s'</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> s'_def <span class="keyword1"><span class="command">using</span></span> xy <span class="keyword1"><span class="command">unfolding</span></span> order_consistent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> <span class="free">A</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"partial_order_on <span class="free">A</span> <span class="var">?s'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> porder_on_linorder_on_tranclp_porder_onI<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">⊆</span> <span class="var">?s'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> r_in_s <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?s'</span> <span class="main">∈</span> <span class="skolem">S</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">⊆</span> <span class="var">?s'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="var">?s'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> y_max<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?s'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> s'_def<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">s</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"linear_order_on <span class="free">A</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linear_order_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"order_consistent <span class="free">r</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> order_consistent_def
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> strip<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">a'</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">a'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a'</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">s</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">a'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">a'</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> r_in_s <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹partial_order_on <span class="free">A</span> <span class="skolem">s</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">a'</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">s</span>›</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="skolem">a'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> partial_order_on_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> antisymD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s</span><span class="main">.</span> linear_order_on <span class="free">A</span> <span class="bound">s</span> <span class="main">∧</span> order_consistent <span class="free">r</span> <span class="bound">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Set_Linorder">
<div class="head">
<h1>Theory Set_Linorder</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Set_Linorder.thy
    Author:     Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> Set_Linorder 
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Containers_Auxiliary.html">Containers_Auxiliary</a>
  <a href="Lexicographic_Order.html">Lexicographic_Order</a>
  <a href="Extend_Partial_Order.html">Extend_Partial_Order</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Cardinality.html">HOL-Library.Cardinality</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹An executable linear order on sets›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definition of the linear order›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Extending finite and cofinite sets›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Partition sets into finite and cofinite sets and distribute the rest arbitrarily such that
  complement switches between the two.
›</span></span>

<span class="keyword1"><span class="command">consts</span></span> infinite_complement_partition <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set set"</span></span>

<span class="keyword1"><span class="command">specification</span></span> <span class="main">(</span><span class="quoted">infinite_complement_partition</span><span class="main">)</span>
  finite_complement_partition<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">A</span> <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">∈</span> infinite_complement_partition"</span></span>
  complement_partition<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>
    <span class="main">⟹</span> <span class="main">(</span><span class="free">A</span> <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∈</span> infinite_complement_partition <span class="main">⟷</span> <span class="main">-</span> <span class="free">A</span> <span class="main">∉</span> infinite_complement_partition"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">Field_r</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Field_r</span> <span class="main">=</span> <span class="main">{</span><span class="bound">𝒫</span> <span class="main">::</span> <span class="tfree">'a</span> set set<span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">C</span> <span class="main">∈</span> <span class="bound">𝒫</span><span class="main">.</span> <span class="main">-</span> <span class="bound">C</span> <span class="main">∉</span> <span class="bound">𝒫</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">A</span><span class="main">.</span> finite <span class="bound">A</span> <span class="main">⟶</span> <span class="bound">A</span> <span class="main">∈</span> <span class="bound">𝒫</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">𝒫1</span><span class="main">,</span> <span class="bound">𝒫2</span><span class="main">)</span><span class="main">.</span> <span class="bound">𝒫1</span> <span class="main">⊆</span> <span class="bound">𝒫2</span> <span class="main">∧</span> <span class="bound">𝒫1</span> <span class="main">∈</span> <span class="skolem">Field_r</span> <span class="main">∧</span> <span class="bound">𝒫2</span> <span class="main">∈</span> <span class="skolem">Field_r</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> in_Field_r <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">𝒫</span><span class="main">.</span> <span class="bound">𝒫</span> <span class="main">∈</span> <span class="skolem">Field_r</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">C</span> <span class="main">∈</span> <span class="bound">𝒫</span><span class="main">.</span> <span class="main">-</span> <span class="bound">C</span> <span class="main">∉</span> <span class="bound">𝒫</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">A</span><span class="main">.</span> finite <span class="bound">A</span> <span class="main">⟶</span> <span class="bound">A</span> <span class="main">∈</span> <span class="bound">𝒫</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Field_r_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> in_r <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">𝒫1</span> <span class="bound">𝒫2</span><span class="main">.</span> <span class="main">(</span><span class="bound">𝒫1</span><span class="main">,</span> <span class="bound">𝒫2</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">r</span> <span class="main">⟷</span> <span class="bound">𝒫1</span> <span class="main">⊆</span> <span class="bound">𝒫2</span> <span class="main">∧</span> <span class="bound">𝒫1</span> <span class="main">∈</span> <span class="skolem">Field_r</span> <span class="main">∧</span> <span class="bound">𝒫2</span> <span class="main">∈</span> <span class="skolem">Field_r</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> r_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> Field_r <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Field <span class="skolem">r</span> <span class="main">=</span> <span class="skolem">Field_r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Field_def Field_r_def<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Partial_order <span class="skolem">r</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Field_def r_def partial_order_on_def preorder_on_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> refl_onI transI antisymI<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ℬ</span> <span class="main">∈</span> Field <span class="skolem">r</span><span class="main">.</span> <span class="main">∀</span><span class="bound">𝒜</span> <span class="main">∈</span> <span class="skolem">ℭ</span><span class="main">.</span> <span class="main">(</span><span class="bound">𝒜</span><span class="main">,</span> <span class="bound">ℬ</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">r</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> ℭ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ℭ</span> <span class="main">∈</span> Chains <span class="skolem">r</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">ℭ</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ℬ</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="skolem">ℭ</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">A</span><span class="main">.</span> finite <span class="bound">A</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?ℬ</span> <span class="main">∈</span> Field <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> False ℭ
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span><span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">drule</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> ChainsD<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> 4 4 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Chains_Field<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">𝒜</span><span class="main">.</span> <span class="bound">𝒜</span> <span class="main">∈</span> <span class="skolem">ℭ</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">𝒜</span><span class="main">,</span> <span class="var">?ℬ</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">r</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ℭ <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> in_Field_r <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Chains_Field<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ℬ</span> <span class="main">∈</span> Field <span class="skolem">r</span><span class="main">.</span> <span class="main">∀</span><span class="bound">𝒜</span> <span class="main">∈</span> <span class="skolem">ℭ</span><span class="main">.</span> <span class="main">(</span><span class="bound">𝒜</span><span class="main">,</span> <span class="bound">ℬ</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">𝒫</span> <span class="main">∈</span> Field <span class="skolem">r</span><span class="main">.</span> <span class="main">∀</span><span class="bound">𝒜</span> <span class="main">∈</span> Field <span class="skolem">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">𝒫</span><span class="main">,</span> <span class="bound">𝒜</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">r</span> <span class="main">⟶</span> <span class="bound">𝒜</span> <span class="main">=</span> <span class="bound">𝒫</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Zorns_po_lemma<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">𝒫</span></span> <span class="keyword2"><span class="keyword">where</span></span> 𝒫<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">𝒫</span> <span class="main">∈</span> Field <span class="skolem">r</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> max<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">𝒜</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">𝒜</span> <span class="main">∈</span> Field <span class="skolem">r</span><span class="main">;</span> <span class="main">(</span><span class="skolem">𝒫</span><span class="main">,</span> <span class="bound">𝒜</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">r</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">𝒜</span> <span class="main">=</span> <span class="skolem">𝒫</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">A</span><span class="main">.</span> finite <span class="bound">A</span> <span class="main">⟶</span> <span class="bound">A</span> <span class="main">∈</span> <span class="skolem">𝒫</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 𝒫 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">C</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">∈</span> <span class="skolem">𝒫</span> <span class="main">∨</span> <span class="main">-</span> <span class="skolem">C</span> <span class="main">∈</span> <span class="skolem">𝒫</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">∉</span> <span class="skolem">𝒫</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="skolem">C</span> <span class="main">∉</span> <span class="skolem">𝒫</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?𝒜</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insert <span class="skolem">C</span> <span class="skolem">𝒫</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?𝒜</span> <span class="main">∈</span> Field <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> C 𝒫 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">𝒫</span><span class="main">,</span> <span class="var">?𝒜</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 𝒫 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?𝒜</span> <span class="main">=</span> <span class="skolem">𝒫</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> max<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> C <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">C</span> <span class="main">∈</span> <span class="skolem">𝒫</span> <span class="main">⟷</span> <span class="main">-</span> <span class="skolem">C</span> <span class="main">∉</span> <span class="skolem">𝒫</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 𝒫 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">𝒫</span> <span class="main">::</span> <span class="tfree">'a</span> set set<span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">A</span><span class="main">.</span> finite <span class="bound">A</span> <span class="main">⟶</span> <span class="bound">A</span> <span class="main">∈</span> <span class="bound">𝒫</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">C</span><span class="main">.</span> <span class="bound">C</span> <span class="main">∈</span> <span class="bound">𝒫</span> <span class="main">⟷</span> <span class="main">-</span> <span class="bound">C</span> <span class="main">∉</span> <span class="bound">𝒫</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> not_in_complement_partition<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>
  <span class="main">⟹</span> <span class="main">(</span><span class="free">A</span> <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∉</span> infinite_complement_partition <span class="main">⟷</span> <span class="main">-</span> <span class="free">A</span> <span class="main">∈</span> infinite_complement_partition"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> complement_partition<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> not_in_complement_partition_False<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">A</span> <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∈</span> infinite_complement_partition<span class="main">;</span> <span class="main">¬</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟧</span> 
  <span class="main">⟹</span> <span class="main">-</span> <span class="free">A</span> <span class="main">∈</span> infinite_complement_partition <span class="main">=</span> False"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_in_complement_partition<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> infinite_complement_partition_finite <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟹</span> infinite_complement_partition <span class="main">=</span> <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set set<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset finite_complement_partition<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Compl_eq_empty_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">=</span> UNIV"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹A lexicographic-style order on finite subsets›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_less_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏''</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main"><span class="free">⊏'</span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">⟷</span> finite <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> finite <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">z</span> <span class="main">∈</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">z</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="bound">y</span> <span class="main">=</span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_less_eq_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑''</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main"><span class="free">⊑'</span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∈</span> infinite_complement_partition <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⊏'</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_irrefl <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">A</span> <span class="main">⊏'</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux_refl <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑'</span> <span class="free">A</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">∈</span> infinite_complement_partition"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">A</span> <span class="main">⊏'</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset finite_complement_partition<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑'</span> <span class="main">{}</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def finite_complement_partition<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_antisym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span><span class="main">;</span> <span class="free">B</span> <span class="main">⊏'</span> <span class="free">A</span> <span class="main">⟧</span> <span class="main">⟹</span> False"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_conv_set_less_eq_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">⊑'</span> <span class="free">B</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">B</span> <span class="main">⊑'</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_aux_antisym<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux_antisym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">⊑'</span> <span class="free">B</span><span class="main">;</span> <span class="free">B</span> <span class="main">⊑'</span> <span class="free">A</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">=</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_aux_antisym<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_finiteD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span> <span class="main">⟹</span> finite <span class="free">A</span> <span class="main">∧</span> <span class="free">B</span> <span class="main">∈</span> infinite_complement_partition"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def finite_complement_partition<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux_infinite_complement_partitionD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑'</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">∈</span> infinite_complement_partition <span class="main">∧</span> <span class="free">B</span> <span class="main">∈</span> infinite_complement_partition"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_aux_finiteD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_complement_partition<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Compl_set_less_aux_Compl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟹</span> <span class="main">-</span> <span class="free">A</span> <span class="main">⊏'</span> <span class="main">-</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">B</span> <span class="main">⊏'</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subset_UNIV<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Compl_set_less_eq_aux_Compl<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟹</span> <span class="main">-</span> <span class="free">A</span> <span class="main">⊑'</span> <span class="main">-</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">B</span> <span class="main">⊑'</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def Compl_set_less_aux_Compl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_insert_same<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">B</span> <span class="main">⟹</span> insert <span class="free">x</span> <span class="free">A</span> <span class="main">⊏'</span> insert <span class="free">x</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux_insert_same<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">∈</span> infinite_complement_partition<span class="main">;</span> insert <span class="free">x</span> <span class="free">B</span> <span class="main">∈</span> infinite_complement_partition<span class="main">;</span>
    <span class="free">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">B</span> <span class="main">⟧</span>
  <span class="main">⟹</span> insert <span class="free">x</span> <span class="free">A</span> <span class="main">⊑'</span> insert <span class="free">x</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">⊑'</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def set_less_aux_insert_same<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> order <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_singleton_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊏'</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">⟷</span> finite <span class="free">A</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def less_le Bex_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wlog_le <span class="main">[</span><span class="operator">case_names</span> sym le<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="free">P</span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">b</span> <span class="bound">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">a</span> <span class="bound">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">b</span> <span class="free">a</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms linear<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> empty_set_less_aux <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">⊏'</span> <span class="free">A</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> finite <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Min <span class="free">A</span>"</span></span><span class="main"><span class="main">]</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> y<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Min <span class="free">A</span>"</span></span><span class="main"><span class="main">]</span></span> Min_in<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> empty_set_less_eq_aux <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">⊑'</span> <span class="free">A</span> <span class="main">⟷</span> finite <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def finite_complement_partition<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_trans<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> BC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊏'</span> <span class="free">C</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊏'</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> AB BC <span class="keyword1"><span class="command">have</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">C</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> AB A B <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ab</span></span> <span class="keyword2"><span class="keyword">where</span></span> ab<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ab</span> <span class="main">∈</span> <span class="free">B</span> <span class="main">-</span> <span class="free">A</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> minAB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">ab</span> <span class="main">≤</span> <span class="bound">x</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">x</span> <span class="main">≤</span> <span class="skolem">ab</span> <span class="main">⟶</span> <span class="skolem">ab</span> <span class="main">=</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> minBA<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">B</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">A</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">ab</span> <span class="main">≤</span> <span class="bound">x</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">x</span> <span class="main">≤</span> <span class="skolem">ab</span> <span class="main">⟶</span> <span class="skolem">ab</span> <span class="main">=</span> <span class="bound">x</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> set_less_aux_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> BC B C <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">bc</span></span> <span class="keyword2"><span class="keyword">where</span></span> bc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">bc</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">-</span> <span class="free">B</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> minBC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">B</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">C</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">bc</span> <span class="main">≤</span> <span class="bound">x</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">x</span> <span class="main">≤</span> <span class="skolem">bc</span> <span class="main">⟶</span> <span class="skolem">bc</span> <span class="main">=</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> minCB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">C</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">bc</span> <span class="main">≤</span> <span class="bound">x</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">x</span> <span class="main">≤</span> <span class="skolem">bc</span> <span class="main">⟶</span> <span class="skolem">bc</span> <span class="main">=</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> set_less_aux_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">ab</span> <span class="main">≤</span> <span class="skolem">bc</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ab</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">-</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ab</span> <span class="main">∉</span> <span class="free">A</span> <span class="main">-</span> <span class="free">C</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ab bc <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> minBC antisym<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span><span class="free">C</span> <span class="main">-</span> <span class="free">A</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="free">C</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ab</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">B</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> minAB minBA minBC minCB <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> True<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ab</span> <span class="main">≠</span> <span class="skolem">x</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">ab</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ab bc x
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">B</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> antisym<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> calculation <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> A C <span class="keyword1"><span class="command">unfolding</span></span> set_less_aux_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> linear<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">ab</span></span> <span class="quoted"><span class="skolem">bc</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bc</span> <span class="main">≤</span> <span class="skolem">ab</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> ab bc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bc</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">-</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bc</span> <span class="main">∉</span> <span class="free">A</span> <span class="main">-</span> <span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> minAB antisym<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span><span class="free">C</span> <span class="main">-</span> <span class="free">A</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="free">C</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bc</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">B</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> minAB minBA minBC minCB <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">bc</span> <span class="main">≤</span> <span class="skolem">ab</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bc</span> <span class="main">≠</span> <span class="skolem">x</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">bc</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ab bc x
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">B</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> antisym<span class="main">)</span> 
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> calculation <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> A C <span class="keyword1"><span class="command">unfolding</span></span> set_less_aux_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux_trans <span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">⊑'</span> <span class="free">B</span><span class="main">;</span> <span class="free">B</span> <span class="main">⊑'</span> <span class="free">C</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊑'</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_aux_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_trans_set_less_eq <span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span><span class="main">;</span> <span class="free">B</span> <span class="main">⊑'</span> <span class="free">C</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊏'</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_aux_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux_porder<span class="main">:</span> <span class="quoted"><span class="quoted">"partial_order_on infinite_complement_partition <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">A</span> <span class="main">⊑'</span> <span class="bound">B</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> preorder_on_def partial_order_on_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> refl_onI transI antisymI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_infinite_complement_partitionD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_antisym set_less_eq_aux_trans <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> equalityI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> psubset_finite_imp_set_less_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> AsB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊂</span> <span class="free">B</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> AsB B <span class="keyword1"><span class="command">have</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> AsB B <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="free">B</span> <span class="main">-</span> <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> <span class="free">B</span> <span class="main">-</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> Min_in<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> B AsB
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rev_bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="free">B</span> <span class="main">-</span> <span class="free">A</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span> Min_eqI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Min_ge_iff<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> iffD1<span class="main"><span class="main">,</span></span> <span class="operator">rotated</span> 2<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> subset_finite_imp_set_less_eq_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">⊆</span> <span class="free">B</span><span class="main">;</span> finite <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊑'</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> <span class="free">B</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def finite_complement_partition <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> psubset_finite_imp_set_less_aux<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> empty_set_less_aux_finite_iff<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"finite <span class="free">A</span> <span class="main">⟹</span> <span class="main">{}</span> <span class="main">⊏'</span> <span class="free">A</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> psubset_finite_imp_set_less_aux<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_finite_total<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">A</span> <span class="main">=</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">B</span> <span class="main">⊏'</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> A B psubset_finite_imp_set_less_aux<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="free">B</span></span><span class="main">]</span> psubset_finite_imp_set_less_aux<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">B</span></span> <span class="quoted"><span class="free">A</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> A'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">A</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> B'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> AnB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> A B
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="free">B</span> <span class="main">-</span> <span class="free">A</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="free">B</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="free">B</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wlog_le<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>sym <span class="skolem">m</span> <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> sym.hyps<span class="main">[</span><span class="operator">OF</span> refl refl<span class="main">]</span> sym.prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>le <span class="skolem">A</span> <span class="skolem">B</span><span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> A <span class="main">=</span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span> <span class="keyword2"><span class="keyword">and</span></span> B <span class="main">=</span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">B</span>›</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> A' <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">A</span> <span class="main">⊆</span> <span class="skolem">B</span>›</span></span> <span class="keyword2"><span class="keyword">and</span></span> B' <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">B</span> <span class="main">⊆</span> <span class="skolem">A</span>›</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span>
      <span class="keyword3"><span class="command">assume</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="main">(</span><span class="skolem">A</span> <span class="main">-</span> <span class="skolem">B</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="skolem">A</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="skolem">A</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">z</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">z</span> <span class="main">≤</span> Min <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="skolem">A</span><span class="main">)</span> <span class="main">⟶</span> Min <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="skolem">A</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">z</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">B</span> <span class="main">-</span> <span class="skolem">A</span>"</span></span> 
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="skolem">A</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> B<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">-</span> <span class="skolem">B</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">A</span> <span class="main">-</span> <span class="skolem">B</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> le.hyps <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">B</span> <span class="main">-</span> <span class="skolem">A</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">B</span> <span class="main">-</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Min_in<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> B B'<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="skolem">B</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A B <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux_finite_total<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> finite <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊑'</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">A</span> <span class="main">=</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">B</span> <span class="main">⊑'</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> set_less_aux_finite_total<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux_finite_total2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> finite <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊑'</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">B</span> <span class="main">⊑'</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> set_less_eq_aux_finite_total<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_complement_partition<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_rec<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> A'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> B'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span> <span class="main">⟷</span> Min <span class="free">B</span> <span class="main">&lt;</span> Min <span class="free">A</span> <span class="main">∨</span> Min <span class="free">A</span> <span class="main">=</span> Min <span class="free">B</span> <span class="main">∧</span> <span class="free">A</span> <span class="main">-</span> <span class="main">{</span>Min <span class="free">A</span><span class="main">}</span> <span class="main">⊏'</span> <span class="free">B</span> <span class="main">-</span> <span class="main">{</span>Min <span class="free">A</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"Min <span class="free">A</span> <span class="main">=</span> Min <span class="free">B</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">from</span></span> A A' B B' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span>Min <span class="free">A</span><span class="main">)</span> <span class="free">A</span> <span class="main">=</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span>Min <span class="free">B</span><span class="main">)</span> <span class="free">B</span> <span class="main">=</span> <span class="free">B</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ex_in_conv<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> exI<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> set_less_aux_insert_same<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"Min <span class="free"><span class="free"><span class="free">A</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span> <span class="main">⟷</span> Min <span class="free">B</span> <span class="main">&lt;</span> Min <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> AB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> B A <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ab</span></span> <span class="keyword2"><span class="keyword">where</span></span> ab<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ab</span> <span class="main">∈</span> <span class="free">B</span> <span class="main">-</span> <span class="free">A</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> AB<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">;</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">ab</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def<span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="free">B</span> <span class="main">≤</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A A' B B' ab
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="free">B</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> y<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">ab</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> AB<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="free">B</span> <span class="main">≤</span> Min <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A A' <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Min <span class="free">B</span> <span class="main">&lt;</span> Min <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Min <span class="free">B</span> <span class="main">&lt;</span> Min <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span><span class="free">A</span> <span class="main">-</span> <span class="free">B</span> <span class="main">∪</span> <span class="main">(</span><span class="free">B</span> <span class="main">-</span> <span class="free">A</span><span class="main">)</span><span class="main">.</span> Min <span class="free">B</span> <span class="main">≤</span> <span class="bound">z</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">z</span> <span class="main">≤</span> Min <span class="free">B</span> <span class="main">⟶</span> Min <span class="free">B</span> <span class="main">=</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> A B A' B' <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Min_in Min_eqI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> bspec bspec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Min <span class="free">B</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="free">B</span> <span class="main">∉</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹Min <span class="free">B</span> <span class="main">&lt;</span> Min <span class="free">A</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> A Min_le not_less<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A B A' B' <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Min <span class="free">B</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux_rec<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑'</span> <span class="free">B</span> <span class="main">⟷</span> Min <span class="free">B</span> <span class="main">&lt;</span> Min <span class="free">A</span> <span class="main">∨</span> Min <span class="free">A</span> <span class="main">=</span> Min <span class="free">B</span> <span class="main">∧</span> <span class="free">A</span> <span class="main">-</span> <span class="main">{</span>Min <span class="free">A</span><span class="main">}</span> <span class="main">⊑'</span> <span class="free">B</span> <span class="main">-</span> <span class="main">{</span>Min <span class="free">A</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> <span class="free">B</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_complement_partition<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">moreover</span></span> 
  <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"Min <span class="free">A</span> <span class="main">=</span> Min <span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">-</span> <span class="main">{</span>Min <span class="free">A</span><span class="main">}</span> <span class="main">≠</span> <span class="free">B</span> <span class="main">-</span> <span class="main">{</span>Min <span class="free">B</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>lifting<span class="main"><span class="main">)</span></span> assms Min_in insert_Diff<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> set_less_aux_rec<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> conj_cong<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_Min_antimono<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Min <span class="free">A</span> <span class="main">&lt;</span> Min <span class="free">B</span><span class="main">;</span>  finite <span class="free">A</span><span class="main">;</span> finite <span class="free">B</span><span class="main">;</span> <span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">B</span> <span class="main">⊏'</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> set_less_aux_rec<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">B</span></span> <span class="quoted"><span class="free">A</span></span><span class="main">]</span> 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_set_less_aux_finite_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_Cons_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> Min <span class="main">(</span>insert <span class="free">x</span> <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Min_eqI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sorted <span class="free">xs</span><span class="main">;</span> distinct <span class="free">xs</span><span class="main">;</span> sorted <span class="free">ys</span><span class="main">;</span> distinct <span class="free">ys</span> <span class="main">⟧</span>
  <span class="main">⟹</span> set <span class="free">xs</span> <span class="main">⊏'</span> set <span class="free">ys</span> <span class="main">⟷</span> ord.lexordp <span class="main">(&gt;)</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_induct2'<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_set_less_aux_finite_iff sorted_Cons_Min set_less_aux_rec neq_Nil_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> conj_cong<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux_code<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"sorted <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊑'</span> set <span class="free">ys</span> <span class="main">⟷</span> ord.lexordp_eq <span class="main">(&gt;)</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> dual<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder <span class="main">(≥)</span> <span class="main">(&gt;)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> linorder.dual_linorder<span class="main">)</span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def finite_complement_partition linorder.lexordp_eq_conv_lexord<span class="main"><span class="main">[</span></span><span class="operator">OF</span> dual<span class="main"><span class="main">]</span></span> set_less_aux_code <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sorted_distinct_set_unique<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Extending <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">set_less_eq_aux</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to have <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as least element›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_less_eq_aux'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑''''</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main"><span class="free">⊑''</span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⊑'</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">∈</span> infinite_complement_partition"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux'_refl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑''</span> <span class="free">A</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">∈</span> infinite_complement_partition"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux'_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux'_antisym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">⊑''</span> <span class="free">B</span><span class="main">;</span> <span class="free">B</span> <span class="main">⊑''</span> <span class="free">A</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">=</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux'_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_antisym <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> equalityI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux'_infinite_complement_partitionD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑''</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">∈</span> infinite_complement_partition <span class="main">∧</span> <span class="free">B</span> <span class="main">∈</span> infinite_complement_partition"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux'_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_complement_partition <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_infinite_complement_partitionD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> empty_set_less_eq_def <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">⊑''</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">B</span> <span class="main">∈</span> infinite_complement_partition"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux'_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_infinite_complement_partitionD<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux'_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">⊑''</span> <span class="free">B</span><span class="main">;</span> <span class="free">B</span> <span class="main">⊑''</span> <span class="free">C</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊑''</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux'_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> equalityI <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_trans <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_infinite_complement_partitionD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux'_porder<span class="main">:</span> <span class="quoted"><span class="quoted">"partial_order_on infinite_complement_partition <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">A</span> <span class="main">⊑''</span> <span class="bound">B</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> partial_order_on_def preorder_on_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> refl_onI transI antisymI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_eq_aux'_antisym set_less_eq_aux'_infinite_complement_partitionD <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux'_refl <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> set_less_eq_aux'_trans<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Extend <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">set_less_eq_aux'</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to a total order on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">infinite_complement_partition</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_less_eq_aux''</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑''''''</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">set_less_eq_aux''</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">sleq</span><span class="main">.</span> 
    <span class="main">(</span>linear_order_on UNIV <span class="main">{</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span><span class="main">}</span> <span class="main">⟶</span> linear_order_on infinite_complement_partition <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">sleq</span> <span class="bound">A</span> <span class="bound">B</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span> order_consistent <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">A</span> <span class="main">⊑''</span> <span class="bound">B</span><span class="main">}</span> <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">sleq</span> <span class="bound">A</span> <span class="bound">B</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux''_spec<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"linear_order <span class="main">{</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span><span class="main">}</span> <span class="main">⟹</span> linear_order_on infinite_complement_partition <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">A</span> <span class="main">⊑'''</span> <span class="bound">B</span><span class="main">}</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?thesis1</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"order_consistent <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">A</span> <span class="main">⊑''</span> <span class="bound">B</span><span class="main">}</span> <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">A</span> <span class="main">⊑'''</span> <span class="bound">B</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?thesis2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?P</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">sleq</span><span class="main">.</span> <span class="main">(</span>linear_order <span class="main">{</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span><span class="main">}</span> <span class="main">⟶</span> linear_order_on infinite_complement_partition <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">sleq</span> <span class="bound">A</span> <span class="bound">B</span><span class="main">}</span><span class="main">)</span> <span class="main">∧</span> 
                  order_consistent <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">A</span> <span class="main">⊑''</span> <span class="bound">B</span><span class="main">}</span> <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">sleq</span> <span class="bound">A</span> <span class="bound">B</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Ex <span class="var">?P</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"linear_order <span class="main">{</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">≤</span> <span class="bound">b</span><span class="main">}</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"antisym <span class="main">{</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">⊑''</span> <span class="bound">b</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> antisymI<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux'_antisym<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> antisym_order_consistent_self<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"partial_order_on infinite_complement_partition <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">A</span> <span class="main">⊑''</span> <span class="bound">B</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> linorder.set_less_eq_aux'_porder<span class="main"><span class="main">[</span></span><span class="operator">OF</span> linear_order_imp_linorder<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">s</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"linear_order_on infinite_complement_partition <span class="skolem">s</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"order_consistent <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">A</span> <span class="main">⊑''</span> <span class="bound">B</span><span class="main">}</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> porder_extend_to_linorder<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">A</span> <span class="bound">B</span><span class="main">.</span> <span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">s</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span>Eps <span class="var">?P</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> someI_ex<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">PROP</span> <span class="var">?thesis1</span>"</span></span> <span class="var"><span class="quoted"><span class="var">?thesis2</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux''_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux''_linear_order<span class="main">:</span>
  <span class="quoted"><span class="quoted">"linear_order_on infinite_complement_partition <span class="main">{</span><span class="main">(</span><span class="bound">A</span><span class="main">,</span> <span class="bound">B</span><span class="main">)</span><span class="main">.</span> <span class="bound">A</span> <span class="main">⊑'''</span> <span class="bound">B</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_eq_aux''_spec<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> linear_order<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux''_refl <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑'''</span> <span class="free">A</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">∈</span> infinite_complement_partition"</span></span>
<span class="keyword1"><span class="command">using</span></span> set_less_eq_aux''_linear_order
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linear_order_on_def partial_order_on_def preorder_on_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD refl_onD1<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux'_into_set_less_eq_aux''<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑''</span> <span class="free">B</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑'''</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> nleq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∈</span> infinite_complement_partition"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">∈</span> infinite_complement_partition"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_eq_aux'_infinite_complement_partitionD<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> set_less_eq_aux''_linear_order <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑'''</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">A</span> <span class="main">=</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">B</span> <span class="main">⊑'''</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linear_order_on_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> total_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊑'''</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> B <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> set_less_eq_aux''_spec<span class="main">(</span>2<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> order_consistent_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> A nleq <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_set_less_eq_aux''_finite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑'''</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">⊑''</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑'''</span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑'</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">B</span> <span class="main">⊑'</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_eq_aux_finite_total2<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑''</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">B</span> <span class="main">⊑''</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux'_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑''</span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊑''</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊑'''</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_eq_aux'_into_set_less_eq_aux''<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">A</span> <span class="main">⊑'''</span> <span class="free">B</span>›</span></span> set_less_eq_aux''_linear_order <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> <span class="free">B</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linear_order_on_def partial_order_on_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> antisymD<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_complement_partition set_less_eq_aux'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">rule</span> set_less_eq_aux'_into_set_less_eq_aux''<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux''_finite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟹</span> set_less_eq_aux'' <span class="main">=</span> set_less_eq_aux"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff finite_set_less_eq_aux''_finite set_less_eq_aux'_def finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subset_UNIV<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux''_antisym<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">⊑'''</span> <span class="free">B</span><span class="main">;</span> <span class="free">B</span> <span class="main">⊑'''</span> <span class="free">A</span><span class="main">;</span> 
     <span class="free">A</span> <span class="main">∈</span> infinite_complement_partition<span class="main">;</span> <span class="free">B</span> <span class="main">∈</span> infinite_complement_partition <span class="main">⟧</span>
  <span class="main">⟹</span> <span class="free">A</span> <span class="main">=</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> set_less_eq_aux''_linear_order 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linear_order_on_def partial_order_on_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> antisymD <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> equalityI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux''_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">⊑'''</span> <span class="free">B</span><span class="main">;</span> <span class="free">B</span> <span class="main">⊑'''</span> <span class="free">C</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊑'''</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> set_less_eq_aux''_linear_order
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linear_order_on_def partial_order_on_def preorder_on_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> transD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux''_total<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">∈</span> infinite_complement_partition<span class="main">;</span> <span class="free">B</span> <span class="main">∈</span> infinite_complement_partition <span class="main">⟧</span>
  <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊑'''</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">B</span> <span class="main">⊑'''</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> set_less_eq_aux''_linear_order
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linear_order_on_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> total_onD<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Extend <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">set_less_eq_aux''</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to cofinite sets›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_less_eq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main"><span class="free">⊑</span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∈</span> infinite_complement_partition <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⊑'''</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">∉</span> infinite_complement_partition
   <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">∉</span> infinite_complement_partition <span class="main">∧</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">⊑'''</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_less</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main"><span class="free">⊏</span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⊑</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">∧</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">⊑</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_def2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑</span> <span class="free">B</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="keyword1">then</span> <span class="free">A</span> <span class="main">⊑'''</span> <span class="free">B</span> 
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">A</span> <span class="main">∈</span> infinite_complement_partition <span class="keyword1">then</span> <span class="free">A</span> <span class="main">⊑'''</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">B</span> <span class="main">∉</span> infinite_complement_partition
   <span class="keyword1">else</span> <span class="free">B</span> <span class="main">∉</span> infinite_complement_partition <span class="main">∧</span> <span class="main">-</span> <span class="free">B</span> <span class="main">⊑'''</span> <span class="main">-</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_refl <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_def2 not_in_complement_partition<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_antisym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">⊑</span> <span class="free">B</span><span class="main">;</span> <span class="free">B</span> <span class="main">⊑</span> <span class="free">A</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">=</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_def2 set_less_eq_aux''_finite not_in_complement_partition not_in_complement_partition_False <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> equalityI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_antisym set_less_eq_aux''_antisym<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="main">⊑</span> <span class="free">B</span><span class="main">;</span> <span class="free">B</span> <span class="main">⊑</span> <span class="free">C</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊑</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> set_less_eq_aux''_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_total<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑</span> <span class="free">B</span> <span class="main">∨</span> <span class="free">B</span> <span class="main">⊑</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_def2 set_less_eq_aux''_finite not_in_complement_partition not_in_complement_partition_False <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_finite_total2 finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subset_UNIV<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> disjCI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_eq_aux''_total<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_linorder<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder <span class="main">(⊑)</span> <span class="main">(⊏)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_def set_less_eq_antisym set_less_eq_total <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> set_less_eq_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_conv_set_less<span class="main">:</span> <span class="quoted"><span class="quoted">"set_less_eq <span class="free">A</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">=</span> <span class="free">B</span> <span class="main">∨</span> set_less <span class="free">A</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> equalityI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_eq_antisym<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Compl_set_less_eq_Compl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">A</span> <span class="main">⊑</span> <span class="main">-</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">B</span> <span class="main">⊑</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_def2 not_in_complement_partition_False not_in_complement_partition set_less_eq_aux''_finite Compl_set_less_eq_aux_Compl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Compl_set_less_Compl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">A</span> <span class="main">⊏</span> <span class="main">-</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">B</span> <span class="main">⊏</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_def Compl_set_less_eq_Compl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_finite_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> finite <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊑</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">⊑'</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_def finite_complement_partition set_less_eq_aux'_def finite_set_less_eq_aux''_finite<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_finite_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> finite <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊏</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">⊏'</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_def set_less_aux_conv_set_less_eq_aux set_less_eq_finite_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> infinite_set_less_eq_Complement<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> finite <span class="free">B</span><span class="main">;</span> <span class="main">¬</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊑</span> <span class="main">-</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_def finite_complement_partition not_in_complement_partition<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> infinite_set_less_Complement<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> finite <span class="free">B</span><span class="main">;</span> <span class="main">¬</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊏</span> <span class="main">-</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_eq_antisym <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> infinite_set_less_eq_Complement<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> infinite_Complement_set_less_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> finite <span class="free">B</span><span class="main">;</span> <span class="main">¬</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="main">-</span> <span class="free">A</span> <span class="main">⊑</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> infinite_set_less_eq_Complement<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="free">B</span></span><span class="main">]</span> Compl_set_less_eq_Compl<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">B</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_eq_antisym<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> infinite_Complement_set_less<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> finite <span class="free">B</span><span class="main">;</span> <span class="main">¬</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="main">-</span> <span class="free">A</span> <span class="main">⊏</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> infinite_Complement_set_less_eq<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="free">B</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> empty_set_less_eq <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">⊑</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_def finite_complement_partition <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> set_less_eq_aux'_into_set_less_eq_aux''<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_empty <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑</span> <span class="main">{}</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> empty_set_less_eq set_less_eq_antisym<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> empty_set_less_iff <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">⊏</span> <span class="free">A</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> not_set_less_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">A</span> <span class="main">⊏</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_UNIV <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑</span> UNIV"</span></span>
<span class="keyword1"><span class="command">using</span></span> Compl_set_less_eq_Compl<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> UNIV_set_less_eq <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">⊑</span> <span class="free">A</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">=</span> UNIV"</span></span>
<span class="keyword1"><span class="command">using</span></span> Compl_set_less_eq_Compl<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">A</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Compl_eq_empty_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_UNIV_iff <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊏</span> UNIV <span class="main">⟷</span> <span class="free">A</span> <span class="main">≠</span> UNIV"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> not_UNIV_set_less <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> UNIV <span class="main">⊏</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation based on sorted lists›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> proper_interval <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> bool"</span></span>

<span class="keyword1"><span class="command">class</span></span> proper_intrvl <span class="main">=</span> ord <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">proper_interval</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> proper_interval"</span></span>

<span class="keyword1"><span class="command">class</span></span> proper_interval <span class="main">=</span> proper_intrvl <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> proper_interval_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"proper_interval None None <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"proper_interval None <span class="main">(</span>Some <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="bound">z</span> <span class="main">&lt;</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="free">x</span><span class="main">)</span> None <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="free">x</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">z</span> <span class="main">&lt;</span> <span class="free">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> proper_intrvl <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">set_less_eq_aux_Compl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">set_less_eq_aux_Compl</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">set_less_eq_aux_Compl</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span> <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">set_less_eq_aux_Compl</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∨</span> <span class="free">set_less_eq_aux_Compl</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∨</span> <span class="free">set_less_eq_aux_Compl</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>
   <span class="keyword1">else</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">pat_completeness</span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">lexicographic_order</span><span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">Compl_set_less_eq_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Compl_set_less_eq_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">[]</span> <span class="main">[]</span> <span class="main">⟷</span> <span class="main">¬</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">Compl_set_less_eq_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">[]</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="free">Compl_set_less_eq_aux</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">Compl_set_less_eq_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="main">⟷</span> <span class="main">¬</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="free">Compl_set_less_eq_aux</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">Compl_set_less_eq_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> <span class="main">¬</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="free">Compl_set_less_eq_aux</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="main">¬</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="free">Compl_set_less_eq_aux</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>
   <span class="keyword1">else</span> <span class="main">¬</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">set_less_aux_Compl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">set_less_aux_Compl</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">[]</span> <span class="main">[]</span> <span class="main">⟷</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">set_less_aux_Compl</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">[]</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∨</span> <span class="free">set_less_aux_Compl</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">set_less_aux_Compl</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="main">⟷</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∨</span> <span class="free">set_less_aux_Compl</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">set_less_aux_Compl</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∨</span> <span class="free">set_less_aux_Compl</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∨</span> <span class="free">set_less_aux_Compl</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>
   <span class="keyword1">else</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">Compl_set_less_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Compl_set_less_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">⟷</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">Compl_set_less_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span> <span class="main">⟷</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">Compl_set_less_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> <span class="main">¬</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="free">Compl_set_less_aux</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="main">¬</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="free">Compl_set_less_aux</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>
   <span class="keyword1">else</span> <span class="main">¬</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  proper_intrvl.set_less_eq_aux_Compl.simps
  proper_intrvl.set_less_aux_Compl.simps
  proper_intrvl.Compl_set_less_eq_aux.simps
  proper_intrvl.Compl_set_less_aux.simps

<span class="keyword1"><span class="command">class</span></span> linorder_proper_interval <span class="main">=</span> linorder <span class="main">+</span> proper_interval 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> set_less_eq_aux_Compl2_conv_set_less_eq_aux_Compl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊑'</span> <span class="main">-</span> set <span class="free">ys</span> <span class="main">⟷</span> set_less_eq_aux_Compl None <span class="free">xs</span> <span class="free">ys</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Compl2</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> Compl1_set_less_eq_aux_conv_Compl_set_less_eq_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="free">xs</span> <span class="main">⊑'</span> set <span class="free">ys</span> <span class="main">⟷</span> Compl_set_less_eq_aux None <span class="free">xs</span> <span class="free">ys</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Compl1</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> fin' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> finite_subset<span class="main">[</span><span class="operator">OF</span> subset_UNIV fin<span class="main">]</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">above</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="main">=</span> case_option UNIV <span class="main">(</span>Collect <span class="main">∘</span> less<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> above_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> None <span class="main">=</span> UNIV"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> above_upclosed<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">ao</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="bound">ao</span><span class="main">;</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">y</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="bound">ao</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> proper_interval_Some2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">ao</span><span class="main">.</span> proper_interval <span class="bound">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">∈</span><span class="skolem">above</span> <span class="bound">ao</span><span class="main">.</span> <span class="bound">z</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> proper_interval_None2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">ao</span><span class="main">.</span> proper_interval <span class="bound">ao</span> None <span class="main">⟷</span> <span class="skolem">above</span> <span class="bound">ao</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_simps above_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ao</span> <span class="skolem">x</span> <span class="skolem">A</span> <span class="skolem">B</span>
    <span class="keyword3"><span class="command">assume</span></span> ex<span class="main">:</span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="bound">a</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b</span> <span class="main">∈</span> <span class="skolem">B</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="bound">b</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> ex <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z_ao<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> A <span class="keyword1"><span class="command">have</span></span> A_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> <span class="skolem">A</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> z_ao z B <span class="keyword1"><span class="command">have</span></span> B_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> <span class="skolem">B</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">=</span> Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> z_ao <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">.</span> <span class="skolem">w</span> <span class="main">≤</span> <span class="bound">z</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Min_le_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Min_in<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="main">(</span><span class="main">-</span> <span class="skolem">B</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊏'</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> A B z <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="skolem">w</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊑'</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> A_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> 
    <span class="keyword1"><span class="command">from</span></span> z_ao z A B <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="main">-</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> <span class="skolem">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">≠</span> <span class="skolem">B</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">-</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="skolem">B</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?lhs'</span> <span class="main">⊏'</span> <span class="var">?rhs'</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> A B z z_ao <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def not_less <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> bspec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> neq <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?lhs'</span> <span class="main">⊑'</span> <span class="skolem">B</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> B_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> calculation <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> proper_interval_set_less_eqI <span class="main">=</span> this<span class="main">(</span>1<span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> proper_interval_not_set_less_eq_auxI <span class="main">=</span> this<span class="main">(</span>2<span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ao</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">∪</span> set <span class="free">ys</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> xs ys
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set_less_eq_aux_Compl <span class="skolem">ao</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> set <span class="free">xs</span> <span class="main">⊑'</span> <span class="main">(</span><span class="main">-</span> set <span class="free">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">ao</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_Compl.induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> subset_finite_imp_set_less_eq_aux<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">ao</span> <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> ao <span class="main">=</span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∪</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span>
      <span class="keyword1"><span class="command">hence</span></span> x_ao<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y_ao<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">note</span></span> yys <span class="main">=</span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">hence</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y'</span> <span class="main">∈</span> set <span class="skolem">ys</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="bound">y'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> xxs <span class="main">=</span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">hence</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> x_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x'</span> <span class="main">∈</span> set <span class="skolem">xs</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">x'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊑'</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_Min y_Min <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> proper_interval_set_less_eqI<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">∪</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> True x_Min y_Min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> True xs yys
          <span class="keyword1"><span class="command">have</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"set_less_eq_aux_Compl <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">=</span> 
            <span class="main">(</span>set <span class="skolem">xs</span> <span class="main">⊑'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="quoted">"3.IH"</span><span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> True y_Min x_ao <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="var">?lhs</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_Min x_ao <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="var">?rhs</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> y_Min x_ao False
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">=</span> set <span class="skolem">xs</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> ao x_Min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> False x_ao <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True False IH
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> set_simps<span class="main">)</span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> set_less_eq_aux_rec<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> x_ao<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊑'</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_Min y_Min <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> proper_interval_set_less_eqI<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∪</span> set <span class="skolem">ys</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> x_Min y_Min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> xxs ys
            <span class="keyword1"><span class="command">have</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"set_less_eq_aux_Compl <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="skolem">ys</span> <span class="main">=</span> 
              <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊑'</span> <span class="main">-</span> set <span class="skolem">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="quoted">"3.IH"</span><span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="skolem">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> y_ao False <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> True False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊑'</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_Min y_Min <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> proper_interval_set_less_eqI<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">moreover</span></span>
          <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⊑'</span> <span class="var">?rhs</span>"</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≠</span> <span class="var">?rhs</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span>
              <span class="keyword3"><span class="command">assume</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span>
              <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_ao <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> eq <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span>
              <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> y_ao
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def set_less_aux_def not_le <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bspec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted">None</span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Compl2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ao</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">∪</span> set <span class="free">ys</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> xs ys
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Compl_set_less_eq_aux <span class="skolem">ao</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">-</span> set <span class="free">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊑'</span> set <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">ao</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> Compl_set_less_eq_aux.induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_None2<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">ao</span> <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y'</span> <span class="main">∈</span> set <span class="skolem">ys</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="bound">y'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True 
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">-</span> set <span class="main">[]</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊑'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y_Min
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">erule</span> proper_interval_not_set_less_eq_auxI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">note</span></span> ao <span class="main">=</span> <span class="quoted"><span class="quoted">‹set <span class="main">[]</span> <span class="main">∪</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span> 
        <span class="keyword1"><span class="command">hence</span></span> y_ao<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">from</span></span> ao y_Min <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">[]</span> <span class="main">∪</span> set <span class="skolem">ys</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹sorted <span class="main">[]</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">[]</span>›</span></span> ys
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Compl_set_less_eq_aux <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">[]</span> <span class="skolem">ys</span> <span class="main">⟷</span> <span class="main">-</span> set <span class="main">[]</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">⊑'</span> set <span class="skolem">ys</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="quoted">"2.IH"</span><span class="main">)</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y_ao <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> 
          <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span>set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> y_ao False ao <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 not_less<span class="main">)</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> False y_ao
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">ys</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">=</span> set <span class="skolem">ys</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> y_Min y_ao <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False y_ao
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> set_less_eq_aux_rec<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">ao</span> <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> x_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x'</span><span class="main">∈</span>set <span class="skolem">xs</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">x'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_Min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">note</span></span> ao <span class="main">=</span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∪</span> set <span class="main">[]</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span>
        <span class="keyword1"><span class="command">hence</span></span> x_ao<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">from</span></span> ao <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">∪</span> set <span class="main">[]</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_Min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> xs <span class="quoted"><span class="quoted">‹sorted <span class="main">[]</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">[]</span>›</span></span> 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Compl_set_less_eq_aux <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">[]</span> <span class="main">⟷</span>
          <span class="main">-</span> set <span class="skolem">xs</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">⊑'</span> set <span class="main">[]</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="quoted">"3.IH"</span><span class="main">)</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> <span class="main">-</span> set <span class="skolem">xs</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> False x_ao <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">ao</span> <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> ao <span class="main">=</span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∪</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span>
      <span class="keyword1"><span class="command">hence</span></span> x_ao<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y_ao<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">note</span></span> xxs <span class="main">=</span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">hence</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> x_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x'</span><span class="main">∈</span>set <span class="skolem">xs</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">x'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> yys <span class="main">=</span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">hence</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y'</span><span class="main">∈</span>set <span class="skolem">ys</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="bound">y'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?lhs</span> <span class="main">⊑'</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_Min y_Min <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">erule</span> proper_interval_not_set_less_eq_auxI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">∪</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> ao x_Min y_Min True <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> True xs yys
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Compl_set_less_eq_aux <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⟷</span> 
            <span class="main">-</span> set <span class="skolem">xs</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">⊑'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="quoted">"4.IH"</span><span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="skolem">xs</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="var">?lhs</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> x_ao False <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?lhs</span> <span class="main">⊑'</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_Min y_Min <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">erule</span> proper_interval_not_set_less_eq_auxI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False
            <span class="keyword1"><span class="command">from</span></span> ao True x_Min y_Min 
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∪</span> set <span class="skolem">ys</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> True xxs ys
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Compl_set_less_eq_aux <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="skolem">ys</span> <span class="main">⟷</span>
              <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">⊑'</span> set <span class="skolem">ys</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="quoted">"4.IH"</span><span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> True x_Min y_ao <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="var">?lhs</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> True False x_Min y_ao
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_le not_less proper_interval_Some2<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="var">?rhs</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y_Min y_ao <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="var">?lhs</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> y_ao False <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">ys</span> <span class="main">=</span> set <span class="skolem">ys</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> y_ao y_Min <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True False <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> y_ao
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> set_less_eq_aux_rec<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?lhs</span> <span class="main">⊑'</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_Min y_Min <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">erule</span> proper_interval_not_set_less_eq_auxI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">moreover</span></span>
          <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?lhs</span> <span class="main">⊑'</span> <span class="var">?rhs</span>"</span></span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> ao <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span> 
              <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> x_ao x_Min<span class="main">[</span><span class="operator">unfolded</span> Ball_def<span class="main">]</span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_eq_aux_def set_less_aux_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le not_le <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bspec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span> 
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted">None</span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Compl1</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_Compl_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_less_aux_Compl <span class="free">ao</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> set_less_eq_aux_Compl <span class="free">ao</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">∧</span> <span class="main">¬</span> Compl_set_less_eq_aux <span class="free">ao</span> <span class="free">ys</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ao</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> set_less_aux_Compl.induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less_iff_gr_or_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Compl_set_less_aux_Compl_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Compl_set_less_aux <span class="free">ao</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> Compl_set_less_eq_aux <span class="free">ao</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">∧</span> <span class="main">¬</span> set_less_eq_aux_Compl <span class="free">ao</span> <span class="free">ys</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ao</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> Compl_set_less_aux.induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less_iff_gr_or_eq<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> set_less_aux_Compl2_conv_set_less_aux_Compl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="free">ys</span> <span class="main">⟷</span> set_less_aux_Compl None <span class="free">xs</span> <span class="free">ys</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Compl2</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> Compl1_set_less_aux_conv_Compl_set_less_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="free">xs</span> <span class="main">⊏'</span> set <span class="free">ys</span> <span class="main">⟷</span> Compl_set_less_aux None <span class="free">xs</span> <span class="free">ys</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Compl1</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> set_less_aux_conv_set_less_eq_aux set_less_aux_Compl_iff Compl_set_less_aux_Compl_iff set_less_eq_aux_Compl2_conv_set_less_eq_aux_Compl Compl1_set_less_eq_aux_conv_Compl_set_less_eq_aux<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation of proper intervals for sets›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">length_last</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> nat <span class="main">×</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">length_last</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> last <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> length_last_Nil <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length_last <span class="main">[]</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> undefined<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> length_last_def last_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> length_last_Cons_code <span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">.</span> <span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> length_last <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> length_last_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> proper_intrvl <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">exhaustive_above</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">exhaustive_above</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">[]</span> <span class="main">⟷</span> <span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exhaustive_above</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="free">exhaustive_above</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">exhaustive</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">exhaustive</span> <span class="main">[]</span> <span class="main">=</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">exhaustive</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span> proper_interval None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∧</span> exhaustive_above <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">proper_interval_set_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_set_aux</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">[]</span> <span class="main">⟷</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_set_aux</span> <span class="main">[]</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∨</span> proper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_set_aux</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> False
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> proper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∨</span> <span class="main">¬</span> exhaustive_above <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>
   <span class="keyword1">else</span> <span class="free">proper_interval_set_aux</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">proper_interval_set_Compl_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_set_Compl_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">[]</span> <span class="main">[]</span> <span class="main">⟷</span>
   <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">&gt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">+</span> <span class="main">1</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_set_Compl_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">[]</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="bound">m</span> <span class="main">=</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">;</span> <span class="main">(</span><span class="bound">len_y</span><span class="main">,</span> <span class="bound">y'</span><span class="main">)</span> <span class="main">=</span> length_last <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>
    <span class="keyword1">in</span> <span class="bound">m</span> <span class="main">≠</span> <span class="bound">len_y</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">m</span> <span class="main">=</span> <span class="bound">len_y</span> <span class="main">+</span> <span class="main">1</span> <span class="main">⟶</span> <span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="bound">y'</span><span class="main">)</span> None<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_set_Compl_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="main">⟷</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="bound">m</span> <span class="main">=</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">;</span> <span class="main">(</span><span class="bound">len_x</span><span class="main">,</span> <span class="bound">x'</span><span class="main">)</span> <span class="main">=</span> length_last <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>
    <span class="keyword1">in</span> <span class="bound">m</span> <span class="main">≠</span> <span class="bound">len_x</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">m</span> <span class="main">=</span> <span class="bound">len_x</span> <span class="main">+</span> <span class="main">1</span> <span class="main">⟶</span> <span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="bound">x'</span><span class="main">)</span> None<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_set_Compl_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> 
     proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∨</span> 
     <span class="free">proper_interval_set_Compl_aux</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> 
     proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∨</span> 
     <span class="free">proper_interval_set_Compl_aux</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>
   <span class="keyword1">else</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∧</span> 
     <span class="main">(</span><span class="keyword1">let</span> <span class="bound">m</span> <span class="main">=</span> card <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">in</span> <span class="bound">m</span> <span class="main">-</span> length <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">≠</span> <span class="numeral">2</span> <span class="main">∨</span> <span class="bound">m</span> <span class="main">-</span> length <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="numeral">2</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">proper_interval_Compl_set_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_Compl_set_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> 
     <span class="main">¬</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∧</span> 
     <span class="free">proper_interval_Compl_set_aux</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span>
     <span class="main">¬</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">∧</span>
     <span class="free">proper_interval_Compl_set_aux</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>
   <span class="keyword1">else</span> <span class="main">¬</span> proper_interval <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_Compl_set_aux</span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟷</span> False"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> 
  proper_intrvl.exhaustive_above.simps
  proper_intrvl.exhaustive.simps
  proper_intrvl.proper_interval_set_aux.simps
  proper_intrvl.proper_interval_set_Compl_aux.simps
  proper_intrvl.proper_interval_Compl_set_aux.simps

<span class="keyword1"><span class="command">context</span></span> linorder_proper_interval <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> exhaustive_above_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sorted <span class="free">xs</span><span class="main">;</span> distinct <span class="free">xs</span><span class="main">;</span> <span class="main">∀</span><span class="bound">x'</span><span class="main">∈</span>set <span class="free">xs</span><span class="main">.</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="bound">x'</span> <span class="main">⟧</span> <span class="main">⟹</span> exhaustive_above <span class="free">x</span> <span class="free">xs</span> <span class="main">⟷</span> set <span class="free">xs</span> <span class="main">=</span> <span class="main">{</span><span class="bound">z</span><span class="main">.</span> <span class="bound">z</span> <span class="main">&gt;</span> <span class="free">x</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> exhaustive_above.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_simps<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y'</span><span class="main">∈</span>set <span class="skolem">ys</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="bound">y'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"exhaustive_above <span class="skolem">y</span> <span class="skolem">ys</span> <span class="main">=</span> <span class="main">(</span>set <span class="skolem">ys</span> <span class="main">=</span> <span class="main">{</span><span class="bound">z</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="bound">z</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="quoted">"2.IH"</span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">y'</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">y'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> y 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_simps<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> exhaustive_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"exhaustive <span class="free">xs</span> <span class="main">⟷</span> set <span class="free">xs</span> <span class="main">=</span> UNIV"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> Cons
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Cons exhaustive.simps
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> exhaustive_above_iff<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le proper_interval_simps not_less<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> List.set_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> UNIV_I eq_iff set_ConsD<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> proper_interval_set_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"proper_interval_set_aux <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">A</span><span class="main">.</span> set <span class="free">xs</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> set <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> finite_subset<span class="main">[</span><span class="operator">OF</span> subset_UNIV fin<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> xs ys
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> proper_interval_set_aux.induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y'</span><span class="main">∈</span>set <span class="skolem">ys</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="bound">y'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_simps set_less_aux_singleton_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> psubset_finite_imp_set_less_aux<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x'</span><span class="main">∈</span>set <span class="skolem">xs</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">x'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y'</span><span class="main">∈</span>set <span class="skolem">ys</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="bound">y'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> Minxxs<span class="main">:</span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> xnxs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> set <span class="skolem">xs</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> Minyys<span class="main">:</span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span>set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> ynys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> set <span class="skolem">ys</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> y <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Minxxs Minyys
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> set_less_aux_Min_antimono<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_aux_trans set_less_aux_antisym<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">z</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_simps<span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> set_less_aux_Min_antimono<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">z</span><span class="main">}</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> z y Minyys
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> set_less_aux_Min_antimono<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">A</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">moreover</span></span>
        <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> psubset_finite_imp_set_less_aux<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> False True x
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> set_less_aux_Min_antimono<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">A</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">moreover</span></span>
        <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exhaustive_above <span class="skolem">x</span> <span class="skolem">xs</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&gt;</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> set <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exhaustive_above_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> xs x<span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insert <span class="skolem">z</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="var">?A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> z
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> psubset_finite_imp_set_less_aux<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Minyys False True z x
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> set_less_aux_Min_antimono<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">A</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">moreover</span></span>
        <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">A</span>
          <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> A'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> pi<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> nempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">A</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> A' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> psubset_finite_imp_set_less_aux<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> A' <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_aux_antisym<span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">&lt;</span> Min <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> not_le<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Min <span class="skolem">A</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="skolem">A</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">A</span>›</span></span> nempty <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="skolem">A</span> <span class="main">&lt;</span> Min <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_aux_Min_antimono<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nempty<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> A' <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_aux_antisym<span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">with</span></span> pi nempty <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> Min <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_simps<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span>
          <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≤</span> Min <span class="skolem">A</span>›</span></span> nempty <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> exhaustive_above <span class="skolem">x</span> <span class="skolem">xs</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exhaustive_above_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> xs x<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True False <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> False
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"proper_interval_set_aux <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">A</span><span class="main">.</span> set <span class="skolem">xs</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> set <span class="skolem">ys</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> xs ys <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="quoted">"3.IH"</span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">A</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span> 
            <span class="keyword2"><span class="keyword">and</span></span> A'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> set <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">hence</span></span> nempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insert <span class="skolem">y</span> <span class="skolem">A</span>"</span></span>
          <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Min <span class="skolem">A</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> y nempty <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">&lt;</span> Min <span class="main">(</span>set <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">ys</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_aux_Min_antimono<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nempty<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> A' <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_aux_antisym<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">hence</span></span> MinA<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">&lt;</span> Min <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> not_le<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> nempty <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">moreover</span></span>
          <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> MinA nempty <span class="keyword1"><span class="command">have</span></span> MinyA<span class="main">:</span> <span class="quoted"><span class="quoted">"Min <span class="var">?A</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> Min_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> A1<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="var">?A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> A Minxxs xnxs
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> set_less_aux_rec<span class="main">)</span> <span class="operator">simp_all</span>
          <span class="keyword1"><span class="command">moreover</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> MinyA <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">A</span>›</span></span> A' Minyys ynys
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> set_less_aux_rec<span class="main">)</span> <span class="operator">simp_all</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> A'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> nempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> Min <span class="skolem">A</span>"</span></span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> Min <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Minxxs <span class="keyword1"><span class="command">.</span></span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_aux_Min_antimono<span class="main">)</span> <span class="operator">simp_all</span>
            <span class="keyword1"><span class="command">with</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_aux_antisym<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">moreover</span></span>
          <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Min <span class="skolem">A</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="skolem">A</span> <span class="main">&lt;</span> Min <span class="main">(</span>set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> Minyys <span class="keyword1"><span class="command">.</span></span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_aux_Min_antimono<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nempty<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> A' <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_aux_antisym<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> MinA<span class="main">:</span> <span class="quoted"><span class="quoted">"Min <span class="skolem">A</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> less_linear<span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> nempty <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> Min_in <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span><span class="main">)</span>
          
          <span class="keyword1"><span class="command">from</span></span> A nempty Minxxs xnxs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊏'</span> <span class="var">?A</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> set_less_aux_rec<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MinA<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> A' <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> nempty Minyys MinA ynys <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">⊏'</span> set <span class="skolem">ys</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> set_less_aux_rec<span class="main">)</span> <span class="operator">simp_all</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> proper_interval_set_Compl_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">ys</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"proper_interval_set_Compl_aux None <span class="main">0</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">A</span><span class="main">.</span> set <span class="free">xs</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> finite_subset<span class="main">[</span><span class="operator">OF</span> subset_UNIV fin<span class="main">]</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">above</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="main">=</span> case_option UNIV <span class="main">(</span>Collect <span class="main">∘</span> less<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> above_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> None <span class="main">=</span> UNIV"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> above_upclosed<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">ao</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="bound">ao</span><span class="main">;</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">y</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="bound">ao</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> proper_interval_Some2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">ao</span><span class="main">.</span> proper_interval <span class="bound">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">∈</span><span class="skolem">above</span> <span class="bound">ao</span><span class="main">.</span> <span class="bound">z</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_simps above_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ao</span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">ys</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> xs <span class="quoted"><span class="quoted">‹set <span class="free">xs</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span> ys <span class="quoted"><span class="quoted">‹set <span class="free">ys</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"proper_interval_set_Compl_aux <span class="skolem">ao</span> <span class="main">(</span>card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span>
          <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">A</span></span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">.</span> set <span class="free">xs</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="free">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">ao</span></span> <span class="skolem">n</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> proper_interval_set_Compl_aux.induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">ao</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span> <span class="main">&lt;</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">A</span></span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">.</span> <span class="bound">A</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">-</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Diff_subset<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> card_gt_1D<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> above<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">⊏'</span> <span class="main">{</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">}</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> psubsetI psubset_finite_imp_set_less_aux<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊑'</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> subset_finite_imp_set_less_eq_aux<span class="main">)</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">using</span></span> above <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> nempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">from</span></span> nempty <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?lhs</span>"</span></span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">≥</span> card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> card_mono<span class="main">)</span> <span class="operator">simp_all</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> card_Un_disjoint<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span>"</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less_eq less_Suc_eq_le<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> card_eq_1_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> x subset <span class="keyword1"><span class="command">have</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> less <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">ao</span> <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> ys <span class="main">=</span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> len_ys<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">ys</span> <span class="main">=</span> card <span class="main">(</span>set <span class="skolem">ys</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> ys <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.card_set <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sym<span class="main">)</span>

      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> card_Un_disjoint<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> m_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> m_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≠</span> length <span class="skolem">ys</span> <span class="main">+</span> <span class="main">1</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">m</span> <span class="main">=</span> length <span class="skolem">ys</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">⟶</span> <span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="main">(</span>last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> None<span class="main">)</span> <span class="main">⟷</span>
        <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">A</span></span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">.</span> <span class="bound">A</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
        <span class="keyword1"><span class="command">hence</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≠</span> length <span class="skolem">ys</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> pi<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> length <span class="skolem">ys</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">⟹</span> <span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="main">(</span>last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> None"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">ys</span> <span class="main">+</span> <span class="main">1</span> <span class="main">=</span> card <span class="main">(</span>set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ys len_ys <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> m_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> card_mono<span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ys<span class="main">)</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">ys</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">≤</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> m <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> length <span class="skolem">ys</span> <span class="main">+</span> <span class="numeral">2</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">-</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> ys len_ys
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> card_Diff_subset<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> m_def card_Diff_subset<span class="main">)</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> set <span class="skolem">ys</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> card_eq_1_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="main">(</span>last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> pi<span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≤</span> last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_simps not_less <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> last.simps<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> ly<span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> last_in_set<span class="main">)</span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≠</span> last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">}</span> <span class="main">⊏'</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> z ly ys <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊑'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> z <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> subset_finite_imp_set_less_eq_aux<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">}</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ly ys <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ys <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹length <span class="skolem">ys</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">≤</span> <span class="skolem">m</span>›</span></span> ys len_ys
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">-</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> card_Diff_subset<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Diff_subset m_def<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> card_gt_1D<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
          <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">x'</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> set <span class="skolem">ys</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> x'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∉</span> set <span class="skolem">ys</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">x'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">⊏'</span> <span class="main">{</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x'</span><span class="main">}</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> psubsetI psubset_finite_imp_set_less_aux<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊑'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x x' ys
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> subset_finite_imp_set_less_eq_aux<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> nempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ys<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_mono<span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">ys</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> m_eq <span class="keyword1"><span class="command">using</span></span> ys <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> len_ys<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≠</span> length <span class="skolem">ys</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> length <span class="skolem">ys</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> m_eq <span class="keyword1"><span class="command">using</span></span> ys len_ys <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> card_seteq<span class="main">[</span><span class="operator">OF</span> _ _ this<span class="main">]</span> ys <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> nempty less <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">moreover</span></span>
        <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> length <span class="skolem">ys</span> <span class="main">+</span> <span class="numeral">2</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> ys len_ys m_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Diff_subset<span class="main">)</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> card_eq_1_iff <span class="keyword1"><span class="command">..</span></span>
          <span class="keyword1"><span class="command">hence</span></span> eq_z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> less <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="main">(</span>last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> None"</span></span>
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="main">(</span>last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> None"</span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z'</span></span> <span class="keyword2"><span class="keyword">where</span></span> z'<span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">z'</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_simps<span class="main">)</span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> last_in_set<span class="main">)</span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">with</span></span> ys z' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z'</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z'</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> last.simps sorted.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> sorted_last<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> eq_z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="skolem">z'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
            <span class="keyword1"><span class="command">from</span></span> z' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="skolem">z'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ys
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> sorted_last <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> sorted.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> eq_z <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">=</span> <span class="skolem">z'</span>›</span></span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">≤</span> <span class="skolem">z'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span><span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">A</span> <span class="main">⊏'</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span>›</span></span> nempty <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">=</span> <span class="skolem">z'</span>›</span></span> subset
            <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def<span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> length_last_def m_def Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">ao</span> <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> xs <span class="main">=</span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> len_xs<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">=</span> card <span class="main">(</span>set <span class="skolem">xs</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> xs <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.card_set <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sym<span class="main">)</span>
      
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> card_Un_disjoint<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> m_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> m_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≠</span> length <span class="skolem">xs</span> <span class="main">+</span> <span class="main">1</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">m</span> <span class="main">=</span> length <span class="skolem">xs</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">⟶</span> <span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="main">(</span>last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> None<span class="main">)</span> <span class="main">⟷</span>
        <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">A</span></span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
        <span class="keyword1"><span class="command">hence</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≠</span> length <span class="skolem">xs</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> pi<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> length <span class="skolem">xs</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">⟹</span> <span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="main">(</span>last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> None"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">+</span> <span class="main">1</span> <span class="main">=</span> card <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs len_xs <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> m_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> card_mono<span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> xs<span class="main">)</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">≤</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> m <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> length <span class="skolem">xs</span> <span class="main">+</span> <span class="numeral">2</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">-</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> xs len_xs
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> card_Diff_subset<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> m_def card_Diff_subset<span class="main">)</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≠</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> set <span class="skolem">xs</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> card_eq_1_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> insert <span class="skolem">z</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="skolem">z</span><span class="main">}</span>"</span></span>

          <span class="keyword1"><span class="command">from</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="main">(</span>last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> pi<span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≤</span> last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_simps not_less <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> last.simps<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> lx<span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> last_in_set<span class="main">)</span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≠</span> last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> z xs <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A_def set_less_aux_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">&lt;</span> last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> last.simps<span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊂</span> insert <span class="main">(</span>last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">hence</span></span> less'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> insert <span class="main">(</span>last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="skolem">A</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> psubset_finite_imp_set_less_aux<span class="main">)</span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs lx z
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> last.simps <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A_def<span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span>last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="skolem">A</span> <span class="main">⊑'</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> subset_finite_imp_set_less_eq_aux<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> less' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_trans_set_less_eq<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs z <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A_def<span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹length <span class="skolem">xs</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">≤</span> <span class="skolem">m</span>›</span></span> xs len_xs
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">-</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> card_Diff_subset<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Diff_subset m_def<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> card_gt_1D<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
          <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">y'</span></span> <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≠</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> set <span class="skolem">xs</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> y'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">≠</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">∉</span> set <span class="skolem">xs</span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≠</span> <span class="skolem">y'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> insert <span class="skolem">y</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊂</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y xs <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="main">…</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> psubset_finite_imp_set_less_aux<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊂</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> y y' neq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A_def<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> psubset_finite_imp_set_less_aux<span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> lessA<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> Aless<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_mono<span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> m_eq <span class="keyword1"><span class="command">using</span></span> xs <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> len_xs<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≠</span> length <span class="skolem">xs</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> length <span class="skolem">xs</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> m_eq <span class="keyword1"><span class="command">using</span></span> xs len_xs <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> card_seteq<span class="main">[</span><span class="operator">OF</span> _ _ this<span class="main">]</span> xs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> lessA Aless <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_aux_antisym<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">moreover</span></span>
        <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> length <span class="skolem">xs</span> <span class="main">+</span> <span class="numeral">2</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> xs len_xs m_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Diff_subset<span class="main">)</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> card_eq_1_iff <span class="keyword1"><span class="command">..</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="main">(</span>last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> None"</span></span>
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="main">(</span>last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> None"</span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z'</span></span> <span class="keyword2"><span class="keyword">where</span></span> z'<span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">z'</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_simps<span class="main">)</span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> last_in_set<span class="main">)</span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">with</span></span> xs z' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z'</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z'</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> last.simps sorted.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> sorted_last<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="skolem">z'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
            <span class="keyword1"><span class="command">from</span></span> z' <span class="keyword1"><span class="command">have</span></span> y_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="skolem">z'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> sorted.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> sorted_last<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> z <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">=</span> <span class="skolem">z'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⟹</span> <span class="bound">y</span> <span class="main">≤</span> <span class="skolem">z'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span><span class="main">)</span>
            
            <span class="keyword1"><span class="command">from</span></span> lessA subset <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
              <span class="keyword2"><span class="keyword">and</span></span> min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y'</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">y'</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">;</span> <span class="bound">y'</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">;</span> <span class="bound">y'</span> <span class="main">∉</span> <span class="skolem">A</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">y</span> <span class="main">≤</span> <span class="bound">y'</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> z <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">=</span> <span class="skolem">z'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="skolem">z'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">A</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span>
              <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y'</span>
              <span class="keyword3"><span class="command">assume</span></span> y'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
              <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span>
              <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
                <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">∉</span> <span class="skolem">A</span>"</span></span>
                <span class="keyword1"><span class="command">from</span></span> y' xs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">with</span></span> y' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≤</span> <span class="skolem">y'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y'</span> <span class="main">∉</span> <span class="skolem">A</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> min<span class="main">)</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> y' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">&lt;</span> <span class="skolem">z'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> y_less<span class="main">)</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">=</span> <span class="skolem">z'</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> z xs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> insert <span class="skolem">z</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">=</span> <span class="skolem">z'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">=</span> <span class="skolem">z'</span>›</span></span> subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> Aless <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> length_last_def m_def Let_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> last.simps<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">ao</span> <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> xxs <span class="main">=</span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> yys <span class="main">=</span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> xxs_above <span class="main">=</span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> yys_above <span class="main">=</span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span>
      <span class="keyword1"><span class="command">from</span></span> xxs <span class="keyword1"><span class="command">have</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> x_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x'</span><span class="main">∈</span>set <span class="skolem">xs</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">x'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> yys <span class="keyword1"><span class="command">have</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y'</span><span class="main">∈</span>set <span class="skolem">ys</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="bound">y'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>

      <span class="keyword1"><span class="command">have</span></span> len_xs<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">xs</span> <span class="main">=</span> card <span class="main">(</span>set <span class="skolem">xs</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> xs <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.card_set <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sym<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> len_ys<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">ys</span> <span class="main">=</span> card <span class="main">(</span>set <span class="skolem">ys</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> ys <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.card_set <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sym<span class="main">)</span>

      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True

        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">∨</span>
          proper_interval_set_Compl_aux <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⟷</span>
          <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">A</span></span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> xxs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x'</span><span class="main">∈</span>set <span class="skolem">xs</span><span class="main">.</span> <span class="skolem">z</span> <span class="main">&lt;</span> <span class="bound">x'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
            <span class="keyword1"><span class="command">from</span></span> z yys <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y'</span><span class="main">∈</span>set <span class="skolem">ys</span><span class="main">.</span> <span class="skolem">z</span> <span class="main">&lt;</span> <span class="bound">y'</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
            <span class="keyword1"><span class="command">hence</span></span> subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">z</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> ys <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> z <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> yys xxs <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> xxs_above <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">z</span><span class="main">}</span> <span class="main">⊂</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">z</span><span class="main">}</span> <span class="main">⊏'</span> <span class="main">…</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> psubset_finite_imp_set_less_aux<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">z</span><span class="main">}</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> z <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">hence</span></span> above_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> insert <span class="skolem">x</span> <span class="main">(</span><span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xxs_above
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> psubset_card_mono<span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> card_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span> <span class="main">=</span> card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Diff_subset<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> xxs_above x_Min <span class="keyword1"><span class="command">have</span></span> xs_above<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> y_Min <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> card_eq xs xs_above yys
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"proper_interval_set_Compl_aux <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⟷</span>
               <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">A</span></span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span><span class="main">.</span> set <span class="skolem">xs</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> card_eq<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> 4<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs'</span> <span class="main">⟷</span> <span class="main">_</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs'</span></span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> less_A<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span>
              <span class="keyword2"><span class="keyword">and</span></span> A_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span>
              <span class="keyword2"><span class="keyword">and</span></span> subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insert <span class="skolem">x</span> <span class="skolem">A</span>"</span></span>

            <span class="keyword1"><span class="command">have</span></span> Min_A'<span class="main">:</span> <span class="quoted"><span class="quoted">"Min <span class="var">?A</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xxs_above False subset
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> x_Min <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> Amx<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">A</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> False subset 
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> set <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_Min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> less_A'<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="var">?A</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> less_A xxs_above x_Min <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> set_less_aux_rec<span class="main">)</span> <span class="operator">simp_all</span>
            
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">-</span> insert <span class="skolem">y</span> <span class="main">(</span>set <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> xxs_above y_Min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> insert <span class="skolem">y</span> <span class="main">(</span>set <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="main">-</span> insert <span class="skolem">y</span> <span class="main">(</span>set <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> yys y_Min xxs_above <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> False
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> yys_above False xxs_above
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> A'_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> Min_A' A_less Amx xxs_above <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> set_less_aux_rec<span class="main">)</span> <span class="operator">simp_all</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> subset xxs_above <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">using</span></span> less_A' <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> less_A<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span>
              <span class="keyword2"><span class="keyword">and</span></span> A_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> 
              <span class="keyword2"><span class="keyword">and</span></span> subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span>

            <span class="keyword1"><span class="command">from</span></span> less_A subset xxs_above <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Int_absorb2<span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> False xxs_above subset <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def proper_interval_Some2<span class="main">)</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">A</span>›</span></span> False subset
            <span class="keyword1"><span class="command">have</span></span> Min_A<span class="main">:</span> <span class="quoted"><span class="quoted">"Min <span class="skolem">A</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 not_less<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> x_Min <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> eq_A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> xxs_above False subset 
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 not_less <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> set <span class="skolem">xs</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> x_Min <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> less_A'<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊏'</span> <span class="var">?A</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> xxs_above less_A <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> set_less_aux_rec<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> conj_cong<span class="main">)</span>
            
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">-</span> insert <span class="skolem">y</span> <span class="main">(</span>set <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> xxs_above y_Min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> insert <span class="skolem">y</span> <span class="main">(</span>set <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> yys y_Min xxs_above <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> False
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> above_eq<span class="main">)</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> A_less <span class="quoted"><span class="quoted">‹<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> eq_A Min_A
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> set_less_aux_rec<span class="main">)</span> <span class="operator">simp_all</span>
            
            <span class="keyword1"><span class="command">with</span></span> less_A' eq_A <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs'</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">∨</span> 
                proper_interval_set_Compl_aux <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span>card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="skolem">ys</span> <span class="main">⟷</span>
               <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">A</span></span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
            <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
            <span class="keyword1"><span class="command">from</span></span> xxs <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x'</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="bound">x'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
            <span class="keyword1"><span class="command">hence</span></span> less_A<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span> 
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">⊏'</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> z y_Min <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">z</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊆</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> z y_Min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">z</span><span class="main">}</span> <span class="main">⊑'</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> subset_finite_imp_set_less_eq_aux<span class="main">)</span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">⊏'</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> yys_above <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">using</span></span> less_A <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False
            <span class="keyword1"><span class="command">hence</span></span> above_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> insert <span class="skolem">y</span> <span class="main">(</span><span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> yys_above
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> psubset_card_mono<span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> card_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span> <span class="main">=</span> card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Diff_subset<span class="main">)</span>
            <span class="keyword1"><span class="command">from</span></span> yys_above y_Min <span class="keyword1"><span class="command">have</span></span> ys_above<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">ys</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

            <span class="keyword1"><span class="command">have</span></span> eq_ys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="skolem">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> above_eq<span class="main">)</span>

            <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> x_Min <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> card_eq xxs ys ys_above
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"proper_interval_set_Compl_aux <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span>card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="skolem">ys</span> <span class="main">⟷</span>
              <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">A</span></span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="skolem">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> card_eq<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> 4<span class="main">)</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs'</span> <span class="main">⟷</span> <span class="main">_</span>"</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command">proof</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs'</span></span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span>
                <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="skolem">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> subset <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span>
                <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> eq_ys <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> subset <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> yys_above <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span> 
                <span class="keyword2"><span class="keyword">and</span></span> A_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> 
                <span class="keyword2"><span class="keyword">and</span></span> subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">moreover</span></span>
              <span class="keyword1"><span class="command">from</span></span> A_less False yys_above <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">A</span>"</span></span>
                <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def proper_interval_Some2 not_less<span class="main">)</span>
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span>
                <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="skolem">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> eq_ys <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">A</span>›</span></span> subset above_eq <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs'</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">with</span></span> False True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">∧</span> 
                <span class="main">(</span><span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> length <span class="skolem">ys</span><span class="main">)</span> <span class="main">≠</span> <span class="numeral">2</span> <span class="main">∨</span>
                 <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> length <span class="skolem">xs</span><span class="main">)</span> <span class="main">≠</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">⟷</span>
               <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">A</span></span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
            <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?below</span> <span class="main">∧</span> <span class="var">?card</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="var">?below</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> False
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> yys_above xxs_above y_Min
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less set_less_aux_def proper_interval_Some2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_aux_trans<span class="main">)</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> True
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>

            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?card</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> less_A<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>  <span class="main">⊏'</span> <span class="skolem">A</span>"</span></span>
                <span class="keyword2"><span class="keyword">and</span></span> A_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                <span class="keyword2"><span class="keyword">and</span></span> subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

              <span class="keyword1"><span class="command">{</span></span> 
                <span class="keyword3"><span class="command">assume</span></span> c_ys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> length <span class="skolem">ys</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span>
                  <span class="keyword2"><span class="keyword">and</span></span> c_xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>card <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">+</span> length <span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span>
                <span class="keyword1"><span class="command">from</span></span> c_ys yys_above len_ys y_Min <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">-</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> card_Diff_subset<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Diff_subset<span class="main">)</span>
                <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z'</span></span> <span class="keyword2"><span class="keyword">where</span></span> eq_y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">z'</span><span class="main">}</span>"</span></span>
                  <span class="keyword1"><span class="command">unfolding</span></span> card_eq_1_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> y_Min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z'</span> <span class="main">=</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> z <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
                
                <span class="keyword1"><span class="command">from</span></span> c_xs xxs_above len_xs x_Min <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">-</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> card_Diff_subset<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Diff_subset<span class="main">)</span>
                <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z''</span></span> <span class="keyword2"><span class="keyword">where</span></span> eq_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">z''</span><span class="main">}</span>"</span></span>
                  <span class="keyword1"><span class="command">unfolding</span></span> card_eq_1_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x_Min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z''</span> <span class="main">=</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> z <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

                <span class="keyword1"><span class="command">from</span></span> less_A subset <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def<span class="main">)</span>
                <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> <span class="main">{</span><span class="skolem">z''</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_x<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">=</span> <span class="skolem">z''</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">q</span> <span class="main">∈</span> <span class="skolem">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z'</span> <span class="main">=</span> <span class="skolem">z</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z''</span> <span class="main">=</span> <span class="skolem">z</span>›</span></span> z 
                <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊆</span> <span class="skolem">A</span>"</span></span>
                  <span class="keyword1"><span class="command">unfolding</span></span> eq_y <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊑'</span> <span class="skolem">A</span>"</span></span>
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> subset_finite_imp_set_less_eq_aux<span class="main">)</span>
                <span class="keyword1"><span class="command">with</span></span> A_less <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_trans_set_less_eq<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
              <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?card</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?card</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?card_ys</span> <span class="main">∨</span> <span class="var">?card_xs</span>"</span></span><span class="main">)</span>
              <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
              <span class="keyword1"><span class="command">proof</span></span>
                <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?card_ys</span></span></span>
                <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?YS</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">-</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?card_ys</span>›</span></span> yys_above len_ys y_Min <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="var">?YS</span> <span class="main">≠</span> <span class="main">1</span>"</span></span> 
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> card_Diff_subset<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Diff_subset<span class="main">)</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?YS</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> True y_Min yys_above <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span>
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
                <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="var">?YS</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="var">?YS</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"card <span class="var">?YS</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>
                <span class="keyword1"><span class="command">from</span></span> card_gt_1D<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x'</span></span> <span class="skolem"><span class="skolem">y'</span></span> 
                  <span class="keyword2"><span class="keyword">where</span></span> x'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
                  <span class="keyword2"><span class="keyword">and</span></span> y'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
                  <span class="keyword2"><span class="keyword">and</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">≠</span> <span class="skolem">y'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">z</span><span class="main">}</span>"</span></span>
                <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="var">?A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> z x_Min
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rev_bexI<span class="main">)</span>
                <span class="keyword1"><span class="command">moreover</span></span>
                <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">⊆</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                    <span class="keyword1"><span class="command">using</span></span> z <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> y_Min <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
                  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∉</span> <span class="var">?A</span> <span class="main">∨</span> <span class="skolem">y'</span> <span class="main">∉</span> <span class="var">?A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> neq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">with</span></span> x' y' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">≠</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">⊂</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> psubsetI<span class="main">)</span>
                  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">⊏'</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> psubset_finite_imp_set_less_aux<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span> 
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> z <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">next</span></span>
                <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?card_xs</span></span></span>
                <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?XS</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">-</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?card_xs</span>›</span></span> xxs_above len_xs x_Min <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="var">?XS</span> <span class="main">≠</span> <span class="main">1</span>"</span></span> 
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> card_Diff_subset<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Diff_subset<span class="main">)</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?XS</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> True x_Min xxs_above
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
                <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="var">?XS</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="var">?XS</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"card <span class="var">?XS</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>
                <span class="keyword1"><span class="command">from</span></span> card_gt_1D<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x'</span></span> <span class="skolem"><span class="skolem">y'</span></span> 
                  <span class="keyword2"><span class="keyword">where</span></span> x'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
                  <span class="keyword2"><span class="keyword">and</span></span> y'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
                  <span class="keyword2"><span class="keyword">and</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">≠</span> <span class="skolem">y'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

                <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">A</span></span>
                  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">x'</span> <span class="main">=</span> Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="keyword1">then</span> insert <span class="skolem">y'</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> insert <span class="skolem">x'</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">≠</span> <span class="main">…</span>"</span></span>
                  <span class="keyword1"><span class="command">using</span></span> neq x' y' <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A_def<span class="main">)</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊂</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
                <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊏'</span> <span class="main">…</span>"</span></span>
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> psubset_finite_imp_set_less_aux<span class="main">)</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
                  <span class="keyword1"><span class="command">have</span></span> nempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> z <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="main">{</span>Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span><span class="main">}</span>"</span></span> 
                    <span class="keyword1"><span class="command">using</span></span> z x' y' neq <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> x_Min xxs_above
                    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 6 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def A_def nempty <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rev_bexI Min_eqI<span class="main">)</span>
                  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> z <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
                  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> le_less_trans<span class="main">)</span>
                  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> y_Min <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nempty<span class="main">)</span>
                  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span><span class="main">}</span> <span class="main">⊑'</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> subset_finite_imp_set_less_eq_aux<span class="main">)</span>
                  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊏'</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">.</span></span> <span class="keyword1"><span class="command">}</span></span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xxs_above yys_above x' y' 
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A_def<span class="main">)</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span>            
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted">None</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> proper_interval_Compl_set_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">ys</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"proper_interval_Compl_set_aux None <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">A</span><span class="main">.</span> <span class="main">-</span> set <span class="free">xs</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">⊏'</span> set <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> finite_subset<span class="main">[</span><span class="operator">OF</span> subset_UNIV fin<span class="main">]</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">above</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="main">=</span> case_option UNIV <span class="main">(</span>Collect <span class="main">∘</span> less<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> above_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> None <span class="main">=</span> UNIV"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> above_upclosed<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">ao</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="bound">ao</span><span class="main">;</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">y</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="bound">ao</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> proper_interval_Some2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">ao</span><span class="main">.</span> proper_interval <span class="bound">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">∈</span><span class="skolem">above</span> <span class="bound">ao</span><span class="main">.</span> <span class="bound">z</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_simps above_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ao</span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">ys</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> xs <span class="quoted"><span class="quoted">‹set <span class="free">xs</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span> ys <span class="quoted"><span class="quoted">‹set <span class="free">ys</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"proper_interval_Compl_set_aux <span class="skolem">ao</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span>
          <span class="main">(</span><span class="main">∃</span><span class="bound">A</span><span class="main">.</span> <span class="main">-</span> set <span class="free">xs</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> set <span class="free">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">ao</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> proper_interval_Compl_set_aux.induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span><span class="quoted">"2_1"</span> <span class="skolem">ao</span> <span class="skolem">ys</span><span class="main">)</span>
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">A</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊑'</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> subset_finite_imp_set_less_eq_aux<span class="main">)</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span><span class="quoted">"2_2"</span> <span class="skolem">ao</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">ao</span> <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> xxs <span class="main">=</span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">hence</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> x_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x'</span> <span class="main">∈</span> set <span class="skolem">xs</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">x'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> yys <span class="main">=</span> <span class="quoted"><span class="quoted">‹sorted <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">hence</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">ys</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y'</span><span class="main">∈</span>set <span class="skolem">ys</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="bound">y'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> xxs_above <span class="main">=</span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span>
      <span class="keyword1"><span class="command">note</span></span> yys_above <span class="main">=</span> <span class="quoted"><span class="quoted">‹set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="skolem">ao</span>›</span></span>

      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">∧</span> proper_interval_Compl_set_aux <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⟷</span>
              <span class="main">(</span><span class="main">∃</span><span class="bound">A</span><span class="main">.</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">∧</span> <span class="bound">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> nempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> le_less_trans<span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> y_Min x_Min z <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def nempty <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_aux_trans set_less_aux_antisym<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">hence</span></span> above_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> insert <span class="skolem">x</span> <span class="main">(</span><span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> xxs_above <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> x_Min <span class="keyword1"><span class="command">have</span></span> xs_above<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">xs</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> y_Min <span class="keyword1"><span class="command">have</span></span> ys_above<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

          <span class="keyword1"><span class="command">have</span></span> eq_xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="skolem">xs</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> above_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">have</span></span> eq_ys<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> y_Min <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> xxs_above <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
          
          <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> xs xs_above yys ys_above
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"proper_interval_Compl_set_aux <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">⟷</span>
               <span class="main">(</span><span class="main">∃</span><span class="bound">A</span><span class="main">.</span> <span class="main">-</span> set <span class="skolem">xs</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">∧</span>
                    <span class="bound">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="quoted">"1.IH"</span><span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="main">_</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="skolem">xs</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span>
              <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> above_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="main">(</span><span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> eq_xs eq_ys <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword2"><span class="keyword">and</span></span> A_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="skolem">A</span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span>
              <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> y_Min <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> above_eq set_less_aux_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
              <span class="keyword1"><span class="command">with</span></span> A_less <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_aux_antisym<span class="main">)</span>
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> above_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">using</span></span> eq_xs eq_ys <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
            <span class="keyword1"><span class="command">hence</span></span> nempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> le_less_trans<span class="main">)</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> y_Min x_Min z <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def nempty <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_aux_trans set_less_aux_antisym<span class="main">)</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False
            <span class="keyword1"><span class="command">hence</span></span> above_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> insert <span class="skolem">y</span> <span class="main">(</span><span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> yys_above <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>
            <span class="keyword1"><span class="command">from</span></span> y_Min <span class="keyword1"><span class="command">have</span></span> ys_above<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">ys</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> x_Min <span class="keyword1"><span class="command">have</span></span> xs_above<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> x_Min yys_above <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> nempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">have</span></span> Min_x<span class="main">:</span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> above_eq <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> x_Min <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI<span class="main">)</span>
            <span class="keyword1"><span class="command">have</span></span> Min_y<span class="main">:</span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span>set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> y_Min above_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI<span class="main">)</span>
            <span class="keyword1"><span class="command">have</span></span> eq_xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">=</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> above_eq<span class="main">)</span>
            <span class="keyword1"><span class="command">have</span></span> eq_ys<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">=</span> set <span class="skolem">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> y_Min above_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

            <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> xxs xs_above ys ys_above
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"proper_interval_Compl_set_aux <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="skolem">ys</span> <span class="main">⟷</span>
                 <span class="main">(</span><span class="main">∃</span><span class="bound">A</span><span class="main">.</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">⊏'</span> <span class="bound">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">∧</span>
                      <span class="bound">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">⊏'</span> set <span class="skolem">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="quoted">"1.IH"</span><span class="main">)</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs'</span> <span class="main">⟷</span> <span class="main">_</span>"</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command">proof</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs'</span></span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> less_A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span>
                <span class="keyword2"><span class="keyword">and</span></span> A_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">⊏'</span> set <span class="skolem">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insert <span class="skolem">y</span> <span class="skolem">A</span>"</span></span>

              <span class="keyword1"><span class="command">have</span></span> Min_A<span class="main">:</span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="var">?A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> above_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI<span class="main">)</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> A_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> above_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> less_A'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="var">?A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> nempty yys_above less_A Min_x eq_xs <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> set_less_aux_rec<span class="main">)</span> <span class="operator">simp_all</span>

              <span class="keyword1"><span class="command">have</span></span> A'_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> yys_above nempty Min_A A_eq A_less Min_y eq_ys
                <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> set_less_aux_rec<span class="main">)</span> <span class="operator">simp_all</span>
              
              <span class="keyword1"><span class="command">with</span></span> less_A' <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> less_A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                <span class="keyword2"><span class="keyword">and</span></span> A_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

              <span class="keyword1"><span class="command">from</span></span> less_A <span class="keyword1"><span class="command">have</span></span> nempty'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> A_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> above_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> y_in_xxs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> x_Min yys_above <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span>
              <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
                <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">A</span>"</span></span>
                <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                  <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> x_Min y_in_xxs
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def above_eq <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
                <span class="keyword1"><span class="command">with</span></span> less_A <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_aux_antisym<span class="main">)</span>
              <span class="keyword1"><span class="command">qed</span></span>
              <span class="keyword1"><span class="command">hence</span></span> Min_A<span class="main">:</span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> above_eq y_Min <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI<span class="main">)</span>
              <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> less_A'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">⊏'</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> nempty less_A Min_x eq_xs
                <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> set_less_aux_rec<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> bspec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
              
              <span class="keyword1"><span class="command">have</span></span> A'_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">⊏'</span> set <span class="skolem">ys</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">using</span></span> A_less nempty' yys_above Min_A Min_y A_eq eq_ys
                <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> set_less_aux_rec<span class="main">)</span> <span class="operator">simp_all</span>
              <span class="keyword1"><span class="command">with</span></span> less_A' <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs'</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"proper_interval <span class="skolem">ao</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2<span class="main">)</span>
            <span class="keyword1"><span class="command">hence</span></span> nempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> le_less_trans<span class="main">)</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> y_Min x_Min z <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span>
              <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def nempty <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Min_eqI bexI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Min <span class="main">(</span><span class="skolem">above</span> <span class="skolem">ao</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_less_aux_trans set_less_aux_antisym<span class="main">)</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False
            <span class="keyword1"><span class="command">hence</span></span> above_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">=</span> insert <span class="skolem">x</span> <span class="main">(</span><span class="skolem">above</span> <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> xxs_above <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_Some2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> above_upclosed<span class="main">)</span>

            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">ys</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟶</span> <span class="skolem">xs</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs'</span> <span class="main">⟷</span> <span class="main">_</span>"</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> iffI strip notI<span class="main">)</span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs'</span></span></span>
              <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
              <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
                <span class="keyword3"><span class="command">case</span></span> Nil
                <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs'</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x'</span></span> <span class="skolem"><span class="skolem">xs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> xs_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">x'</span> <span class="main">#</span> <span class="skolem">xs'</span>"</span></span>
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>
                <span class="keyword1"><span class="command">with</span></span> xs <span class="keyword1"><span class="command">have</span></span> x'_Min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x''</span> <span class="main">∈</span> set <span class="skolem">xs'</span><span class="main">.</span> <span class="skolem">x'</span> <span class="main">&lt;</span> <span class="bound">x''</span>"</span></span>
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le<span class="main">)</span>
                <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs'</span><span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊆</span> <span class="var">?A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                  <span class="keyword1"><span class="command">using</span></span> xs_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∉</span> <span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∈</span> <span class="var">?A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                  <span class="keyword1"><span class="command">using</span></span> xs_eq xxs_above x'_Min x_Min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊂</span> <span class="var">?A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
                <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="main">…</span> "</span></span>
                  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> psubset_finite_imp_set_less_aux<span class="main">)</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊏'</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> 
                  <span class="keyword1"><span class="command">using</span></span> Nil <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def above_eq<span class="main">)</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">next</span></span>
                <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">y'</span> <span class="skolem">ys'</span><span class="main">)</span>
                <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span>
                <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> set <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="var">?A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                  <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> x_Min <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def above_eq<span class="main">)</span>
                <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊂</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span>
                  <span class="keyword1"><span class="command">using</span></span> yys_above yys Cons <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
                <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> psubset_finite_imp_set_less_aux<span class="main">)</span>
                <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
              <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">assume</span></span> Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> less_A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> 
                <span class="keyword2"><span class="keyword">and</span></span> A_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊏'</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> above_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A_less <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_less_aux_def above_eq<span class="main">)</span>
              <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊆</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∩</span> <span class="skolem">above</span> <span class="skolem">ao</span> <span class="main">⊑'</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> subset_finite_imp_set_less_eq_aux<span class="main">)</span>
              <span class="keyword1"><span class="command">with</span></span> less_A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊏'</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_less_trans_set_less_eq<span class="main">)</span>
              <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted">None</span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Proper intervals for HOL types›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> unit <span class="main">::</span> <span class="quoted">proper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">proper_interval_unit</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit proper_interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_unit</span> None None <span class="main">=</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_unit</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> False"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> bool <span class="main">::</span> <span class="quoted">proper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">proper_interval_bool</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool proper_interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_bool</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_bool</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> None <span class="main">⟷</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_bool</span> None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_bool</span> None None <span class="main">=</span> True"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> nat <span class="main">::</span> <span class="quoted">proper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">proper_interval_nat</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat proper_interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_nat</span> <span class="free"><span class="bound"><span class="entity">no</span></span></span> None <span class="main">=</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_nat</span> None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_nat</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> int <span class="main">::</span> <span class="quoted">proper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">proper_interval_int</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int proper_interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_int</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_int</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> True"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> less_add_one<span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> less_add_one minus_less_iff<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> integer <span class="main">::</span> <span class="quoted">proper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">proper_interval_integer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer proper_interval"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"proper_interval"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> proper_interval_simps<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">lemma</span></span> proper_interval_integer_simps <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">xo</span> <span class="free">yo</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer option"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="free">x</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">-</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"proper_interval None <span class="free">yo</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"proper_interval <span class="free">xo</span> None <span class="main">=</span> True"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> natural <span class="main">::</span> <span class="quoted">proper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> natural.lifting <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">proper_interval_natural</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"natural proper_interval"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"proper_interval"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> proper_interval_simps<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">lemma</span></span> proper_interval_natural_simps <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> natural.lifting <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted">natural</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">xo</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"natural option"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"proper_interval <span class="free">xo</span> None <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"proper_interval None <span class="main">(</span>Some <span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">y</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="free">x</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">y</span> <span class="main">-</span> <span class="free">x</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> char_less_iff_nat_of_char<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">⟷</span> of_char <span class="free">x</span> <span class="main">&lt;</span> <span class="main">(</span>of_char <span class="free">y</span> <span class="main">::</span> nat<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> less_char_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> nat_of_char_inject <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"of_char <span class="free">x</span> <span class="main">=</span> <span class="main">(</span>of_char <span class="free">y</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> of_char_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> char_le_iff_nat_of_char<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟷</span> of_char <span class="free">x</span> <span class="main">≤</span> <span class="main">(</span>of_char <span class="free">y</span> <span class="main">::</span> nat<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> less_eq_char_def<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> char <span class="main">::</span> <span class="quoted">proper_interval</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">proper_interval_char</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"char proper_interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_char</span> None None <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_char</span> None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="keyword1">CHR</span> <span class="numeral">0x00</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_char</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> None <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="keyword1">CHR</span> <span class="numeral">0xFF</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_char</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span> of_char <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">-</span> of_char <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&gt;</span> <span class="main">(</span><span class="main">1</span> <span class="main">::</span> nat<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted">char</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≠</span> <span class="keyword1">CHR</span> <span class="numeral">0x00</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CHR</span> <span class="numeral">0x00</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="keyword1">CHR</span> <span class="numeral">0x00</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"of_char <span class="skolem">y</span> <span class="main">=</span> <span class="main">(</span>of_char <span class="keyword1">CHR</span> <span class="numeral">0x00</span> <span class="main">::</span> nat<span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less char_le_iff_nat_of_char<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="keyword1">CHR</span> <span class="numeral">0x00</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> nat_of_char_inject <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CHR</span> <span class="numeral">0x00</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">≠</span> <span class="keyword1">CHR</span> <span class="numeral">0x00</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted">char</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="keyword1">CHR</span> <span class="numeral">0x00</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> char_less_iff_nat_of_char of_char_eq_iff <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"proper_interval None <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="bound">z</span> <span class="main">&lt;</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">char</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="keyword1">CHR</span> <span class="numeral">0xFF</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="keyword1">CHR</span> <span class="numeral">0xFF</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neq_iff char_less_iff_nat_of_char<span class="main">)</span>
        <span class="main">(</span><span class="operator">insert</span> nat_of_char_less_256 <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">z</span>"</span></span> <span class="keyword1"><span class="command">..</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="main">::</span> <span class="quoted">char</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CHR</span> <span class="numeral">0xFF</span> <span class="main">&lt;</span> <span class="skolem">z</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"False"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> char_less_iff_nat_of_char<span class="main">)</span>
        <span class="main">(</span><span class="operator">insert</span> nat_of_char_less_256 <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">z</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> None <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">z</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> gt<span class="main">:</span> <span class="quoted"><span class="quoted">"of_char <span class="skolem">y</span> <span class="main">-</span> of_char <span class="skolem">x</span> <span class="main">&gt;</span> <span class="main">(</span><span class="main">1</span> <span class="main">::</span> nat<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?z</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"char_of <span class="main">(</span>of_char <span class="skolem">x</span> <span class="main">+</span> <span class="main">(</span><span class="main">1</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> gt nat_of_char_less_256 <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> 255<span class="main">:</span> <span class="quoted"><span class="quoted">"of_char <span class="skolem">x</span> <span class="main">&lt;</span> <span class="main">(</span><span class="numeral">255</span> <span class="main">::</span> nat<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">arith</span>
    <span class="keyword1"><span class="command">with</span></span> gt <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="var">?z</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?z</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> char_less_iff_nat_of_char<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">z</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">z</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">&lt;</span> of_char <span class="skolem">y</span> <span class="main">-</span> of_char <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> char_less_iff_nat_of_char<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">z</span></span><span class="main">&gt;</span><span class="skolem">x</span><span class="main">.</span> <span class="bound">z</span> <span class="main">&lt;</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_1 <span class="main">::</span> <span class="quoted">proper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">proper_interval_finite_1</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Enum.finite_1 proper_interval"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_finite_1</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> None <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> None"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_finite_1_def less_finite_1_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_2 <span class="main">::</span> <span class="quoted">proper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">proper_interval_finite_2</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Enum.finite_2 proper_interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_finite_2</span> None None <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_finite_2</span> None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> finite_2.a<span class="hidden">⇩</span><sub>2</sub>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_finite_2</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> None <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> finite_2.a<span class="hidden">⇩</span><sub>1</sub>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_finite_2</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span> False"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_finite_2_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_3 <span class="main">::</span> <span class="quoted">proper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">proper_interval_finite_3</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Enum.finite_3 proper_interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_finite_3</span> None None <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_finite_3</span> None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> finite_3.a<span class="hidden">⇩</span><sub>1</sub>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_finite_3</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> None <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> finite_3.a<span class="hidden">⇩</span><sub>3</sub>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_finite_3</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> finite_3.a<span class="hidden">⇩</span><sub>1</sub> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> finite_3.a<span class="hidden">⇩</span><sub>3</sub>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted">Enum.finite_3</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"proper_interval None <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="bound">z</span> <span class="main">&lt;</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_finite_3_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> finite_3.split<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> None <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_finite_3_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">z</span></span><span class="main">&gt;</span><span class="skolem">x</span><span class="main">.</span> <span class="bound">z</span> <span class="main">&lt;</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_finite_3_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> finite_3.split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹List fusion for the order and proper intervals on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">length_last_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> nat <span class="main">×</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">length_last_fusion</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> length_last <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> length_last_fusion_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"length_last_fusion <span class="free">g</span> <span class="free">s</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g</span> <span class="free">s</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g</span> <span class="free">s</span>
     <span class="keyword1">in</span> fold_fusion <span class="free">g</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="bound">s'</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> undefined<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> length_last_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> length_last_Nil length_last_Cons_code fold_fusion_def split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> length_last_fusion_def <span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span>

<span class="keyword1"><span class="command">context</span></span> proper_intrvl <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_less_eq_aux_Compl_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">set_less_eq_aux_Compl_fusion</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span> 
   set_less_eq_aux_Compl <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Compl_set_less_eq_aux_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Compl_set_less_eq_aux_fusion</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span> 
   Compl_set_less_eq_aux <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_less_aux_Compl_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">set_less_aux_Compl_fusion</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span>
   set_less_aux_Compl <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Compl_set_less_aux_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Compl_set_less_aux_fusion</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span>
   Compl_set_less_aux <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">exhaustive_above_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">exhaustive_above_fusion</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> exhaustive_above <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">exhaustive_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">exhaustive_fusion</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> exhaustive <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">proper_interval_set_aux_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_set_aux_fusion</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span>
   proper_interval_set_aux <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">proper_interval_set_Compl_aux_fusion</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_set_Compl_aux_fusion</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span>
   proper_interval_set_Compl_aux <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">proper_interval_Compl_set_aux_fusion</span> <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_Compl_set_aux_fusion</span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span>
   proper_interval_Compl_set_aux <span class="free"><span class="bound"><span class="entity">ao</span></span></span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_eq_aux_Compl_fusion_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_less_eq_aux_Compl_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="free">ao</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">⟷</span>
   <span class="main">(</span>list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="main">⟶</span> list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="main">⟶</span>
    <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span><span class="main">;</span>
         <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
     <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="keyword1">then</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> set_less_eq_aux_Compl_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="bound">s1'</span> <span class="free">s2</span>
        <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="keyword1">then</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="main">∨</span> set_less_eq_aux_Compl_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="free">s1</span> <span class="bound">s2'</span>
        <span class="keyword1">else</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> set_less_eq_aux_Compl_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 4 5<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Compl_set_less_eq_aux_fusion_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Compl_set_less_eq_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="free">ao</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span>
     <span class="keyword1">in</span> <span class="keyword1">if</span> list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="keyword1">then</span>
          <span class="keyword1">let</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
          <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="keyword1">then</span> <span class="main">¬</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> Compl_set_less_eq_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="bound">s1'</span> <span class="free">s2</span>
             <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="main">¬</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> Compl_set_less_eq_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="free">s1</span> <span class="bound">s2'</span>
             <span class="keyword1">else</span> <span class="main">¬</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="main">¬</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> Compl_set_less_eq_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="bound">s1'</span> <span class="free">s2</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
     <span class="keyword1">in</span> <span class="main">¬</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> Compl_set_less_eq_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="free">s1</span> <span class="bound">s2'</span>
   <span class="keyword1">else</span> <span class="main">¬</span> proper_interval <span class="free">ao</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Compl_set_less_eq_aux_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 4 5 8 9<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_less_aux_Compl_fusion_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_less_aux_Compl_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="free">ao</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span>
     <span class="keyword1">in</span> <span class="keyword1">if</span> list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="keyword1">then</span>
          <span class="keyword1">let</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
          <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="keyword1">then</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> set_less_aux_Compl_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="bound">s1'</span> <span class="free">s2</span>
             <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="keyword1">then</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="main">∨</span> set_less_aux_Compl_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="free">s1</span> <span class="bound">s2'</span>
             <span class="keyword1">else</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span>
        <span class="keyword1">else</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> set_less_aux_Compl_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="bound">s1'</span> <span class="free">s2</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
     <span class="keyword1">in</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="main">∨</span> set_less_aux_Compl_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="free">s1</span> <span class="bound">s2'</span>
   <span class="keyword1">else</span> proper_interval <span class="free">ao</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> set_less_aux_Compl_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 4 5 8 9<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Compl_set_less_aux_fusion_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Compl_set_less_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="free">ao</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">⟷</span>
   list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="main">∧</span> list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="main">∧</span>
  <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span><span class="main">;</span>
       <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
   <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="keyword1">then</span> <span class="main">¬</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> Compl_set_less_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="bound">s1'</span> <span class="free">s2</span>
      <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="main">¬</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> Compl_set_less_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="free">s1</span> <span class="bound">s2'</span>
      <span class="keyword1">else</span> <span class="main">¬</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Compl_set_less_aux_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 4 5<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> exhaustive_above_fusion_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"exhaustive_above_fusion <span class="free">g</span> <span class="free">y</span> <span class="free">s</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g</span> <span class="free">s</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g</span> <span class="free">s</span>
     <span class="keyword1">in</span> <span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="free">y</span><span class="main">)</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> exhaustive_above_fusion <span class="free">g</span> <span class="bound">x</span> <span class="bound">s'</span>
   <span class="keyword1">else</span> <span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="free">y</span><span class="main">)</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> exhaustive_above_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> exhaustive_fusion_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"exhaustive_fusion <span class="free">g</span> <span class="free">s</span> <span class="main">=</span>
  <span class="main">(</span>list.has_next <span class="free">g</span> <span class="free">s</span> <span class="main">∧</span> 
   <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g</span> <span class="free">s</span>
    <span class="keyword1">in</span> <span class="main">¬</span> proper_interval None <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> exhaustive_above_fusion <span class="free">g</span> <span class="bound">x</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> exhaustive_fusion_def exhaustive_above_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> proper_interval_set_aux_fusion_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"proper_interval_set_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">⟷</span>
   list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="main">∧</span>
  <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
   <span class="keyword1">in</span> <span class="keyword1">if</span> list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="keyword1">then</span>
        <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span>
        <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="keyword1">then</span> False
           <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="keyword1">then</span> proper_interval <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> list.has_next <span class="free">g2</span> <span class="bound">s2'</span> <span class="main">∨</span> <span class="main">¬</span> exhaustive_above_fusion <span class="free">g1</span> <span class="bound">x</span> <span class="bound">s1'</span>
           <span class="keyword1">else</span> proper_interval_set_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="bound">s1'</span> <span class="bound">s2'</span>
      <span class="keyword1">else</span> list.has_next <span class="free">g2</span> <span class="bound">s2'</span> <span class="main">∨</span> proper_interval <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> proper_interval_set_aux_fusion_def exhaustive_above_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> proper_interval_set_Compl_aux_fusion_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"proper_interval_set_Compl_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="free">ao</span> <span class="free">n</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span>
     <span class="keyword1">in</span> <span class="keyword1">if</span> list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="keyword1">then</span>
          <span class="keyword1">let</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
          <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="keyword1">then</span> 
               proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> 
               proper_interval_set_Compl_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="bound">s1'</span> <span class="free">s2</span>
             <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="keyword1">then</span> 
               proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="main">∨</span> 
               proper_interval_set_Compl_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">s1</span> <span class="bound">s2'</span>
             <span class="keyword1">else</span>
               proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span>
               <span class="main">(</span><span class="keyword1">let</span> <span class="bound">m</span> <span class="main">=</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="free">n</span> 
                <span class="keyword1">in</span> <span class="bound">m</span> <span class="main">-</span> length_fusion <span class="free">g2</span> <span class="bound">s2'</span> <span class="main">≠</span> <span class="numeral">2</span> <span class="main">∨</span> <span class="bound">m</span> <span class="main">-</span> length_fusion <span class="free">g1</span> <span class="bound">s1'</span> <span class="main">≠</span> <span class="numeral">2</span><span class="main">)</span>
        <span class="keyword1">else</span> 
          <span class="keyword1">let</span> <span class="bound">m</span> <span class="main">=</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="free">n</span><span class="main">;</span> <span class="main">(</span><span class="bound">len_x</span><span class="main">,</span> <span class="bound">x'</span><span class="main">)</span> <span class="main">=</span> length_last_fusion <span class="free">g1</span> <span class="free">s1</span>
          <span class="keyword1">in</span> <span class="bound">m</span> <span class="main">≠</span> <span class="bound">len_x</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">m</span> <span class="main">=</span> <span class="bound">len_x</span> <span class="main">+</span> <span class="main">1</span> <span class="main">⟶</span> <span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="bound">x'</span><span class="main">)</span> None<span class="main">)</span>

   <span class="keyword1">else</span> <span class="keyword1">if</span> list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span><span class="main">;</span>
         <span class="bound">m</span> <span class="main">=</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="free">n</span><span class="main">;</span>
         <span class="main">(</span><span class="bound">len_y</span><span class="main">,</span> <span class="bound">y'</span><span class="main">)</span> <span class="main">=</span> length_last_fusion <span class="free">g2</span> <span class="free">s2</span>
     <span class="keyword1">in</span> <span class="bound">m</span> <span class="main">≠</span> <span class="bound">len_y</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">m</span> <span class="main">=</span> <span class="bound">len_y</span> <span class="main">+</span> <span class="main">1</span> <span class="main">⟶</span> <span class="main">¬</span> proper_interval <span class="main">(</span>Some <span class="bound">y'</span><span class="main">)</span> None<span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">&gt;</span> <span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> proper_interval_set_Compl_aux_fusion_def length_last_fusion_def length_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 4 5 9 10<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> proper_interval_Compl_set_aux_fusion_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"proper_interval_Compl_set_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="free">ao</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">⟷</span>
   list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="main">∧</span> list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="main">∧</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span>
    <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="keyword1">then</span>
         <span class="main">¬</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> proper_interval_Compl_set_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="bound">s1'</span> <span class="free">s2</span>
       <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="keyword1">then</span>
         <span class="main">¬</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> proper_interval_Compl_set_aux_fusion <span class="free">g1</span> <span class="free">g2</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">)</span> <span class="free">s1</span> <span class="bound">s2'</span>
       <span class="keyword1">else</span> <span class="main">¬</span> proper_interval <span class="free">ao</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span>list.has_next <span class="free">g2</span> <span class="bound">s2'</span> <span class="main">∨</span> list.has_next <span class="free">g1</span> <span class="bound">s1'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> proper_interval_Compl_set_aux_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 4 5<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  set_less_eq_aux_Compl_fusion_code proper_intrvl.set_less_eq_aux_Compl_fusion_code
  Compl_set_less_eq_aux_fusion_code proper_intrvl.Compl_set_less_eq_aux_fusion_code
  set_less_aux_Compl_fusion_code proper_intrvl.set_less_aux_Compl_fusion_code
  Compl_set_less_aux_fusion_code proper_intrvl.Compl_set_less_aux_fusion_code
  exhaustive_above_fusion_code proper_intrvl.exhaustive_above_fusion_code
  exhaustive_fusion_code proper_intrvl.exhaustive_fusion_code
  proper_interval_set_aux_fusion_code proper_intrvl.proper_interval_set_aux_fusion_code
  proper_interval_set_Compl_aux_fusion_code proper_intrvl.proper_interval_set_Compl_aux_fusion_code
  proper_interval_Compl_set_aux_fusion_code proper_intrvl.proper_interval_Compl_set_aux_fusion_code

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span> <span class="main">=</span>
  set_less_eq_aux_Compl_fusion_def proper_intrvl.set_less_eq_aux_Compl_fusion_def
  Compl_set_less_eq_aux_fusion_def proper_intrvl.Compl_set_less_eq_aux_fusion_def
  set_less_aux_Compl_fusion_def proper_intrvl.set_less_aux_Compl_fusion_def
  Compl_set_less_aux_fusion_def proper_intrvl.Compl_set_less_aux_fusion_def
  exhaustive_above_fusion_def proper_intrvl.exhaustive_above_fusion_def
  exhaustive_fusion_def proper_intrvl.exhaustive_fusion_def
  proper_interval_set_aux_fusion_def proper_intrvl.proper_interval_set_aux_fusion_def
  proper_interval_set_Compl_aux_fusion_def proper_intrvl.proper_interval_set_Compl_aux_fusion_def
  proper_interval_Compl_set_aux_fusion_def proper_intrvl.proper_interval_Compl_set_aux_fusion_def

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Drop notation›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> set_less_aux <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏''</span>"</span> 50<span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> set_less_eq_aux <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑''</span>"</span> 50<span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> set_less_eq_aux' <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑''''</span>"</span> 50<span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> set_less_eq_aux'' <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑''''''</span>"</span> 50<span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> set_less_eq <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑</span>"</span> 50<span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> set_less <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏</span>"</span> 50<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Containers_Generator">
<div class="head">
<h1>Theory Containers_Generator</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Collection_Eq.thy
    Author:     René Thiemann, UIBK *)</span>
<span class="keyword1"><span class="command">theory</span></span> Containers_Generator
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../Deriving/Generator_Aux.html">Deriving.Generator_Aux</a>
  <a href="../Deriving/Derive_Manager.html">Deriving.Derive_Manager</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Phantom_Type.html">HOL-Library.Phantom_Type</a>"</span>
  <a href="Containers_Auxiliary.html">Containers_Auxiliary</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="plain_text">Introduction</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In the following, we provide generators for the major classes 
  of the container framework: \texttt{ceq}, \texttt{corder}, \texttt{cenum},
  \texttt{set-impl}, and \texttt{mapping-impl}. 

  In this file we provide some common infrastructure on the ML-level which will
  be used by the individual generators.
›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹containers_generator.ML›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/containers_generator.ML">
<div class="head">
<h1>File ‹containers_generator.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Author:  René Thiemann, UIBK *)</span>
<span class="comment1">(* The generators have been written as part of the IsaFoR/CeTA formalization. *)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CONTAINERS_GENERATOR</span> <span class="main">=</span> 
<span class="keyword2"><span class="keyword">sig</span></span> 

  <span class="keyword1"><span class="keyword">val</span></span> mk_is_c_dots <span class="main">:</span> typ <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term 
  
  <span class="comment1">(*                        const     sort    choices            *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> derive_set_map_impl <span class="main">:</span> string <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> <span class="main">(</span>string * term<span class="main">)</span> list 
    <span class="main">-&gt;</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="comment1">(*                const_name, sort, mk_none,         typ_name *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> derive_none <span class="main">:</span> string <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> <span class="main">(</span>typ <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="comment1">(*                             const_name  base_name *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> register_is_c_dots_lemma <span class="main">:</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="comment1">(*                           typ    const_name  defs      base_name *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> derive_is_c_dots_lemma <span class="main">:</span> typ <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="keyword1"><span class="keyword">val</span></span> mk_Some <span class="main">:</span> term <span class="main">-&gt;</span> term

  <span class="comment1">(* p1 /\ ... /\ pn *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> HOLogic_list_conj <span class="main">:</span> term list <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> all_tys <span class="main">:</span> term <span class="main">-&gt;</span> typ list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  
  <span class="keyword1"><span class="keyword">val</span></span> is_class_instance <span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> sort <span class="main">-&gt;</span> bool
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Containers_Generator</span> <span class="main">:</span> <span class="entity">CONTAINERS_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span> 

<span class="keyword3"><span class="keyword">open</span></span> Generator_Aux

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_class_instance</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">class</span> <span class="main">=</span>
  Proof_Context.read_type_name <span class="main">{</span>proper <span class="main">=</span> true<span class="main">,</span> strict <span class="main">=</span> true<span class="main">}</span> <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="entity">tname</span>
  |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> Sign.of_sort <span class="entity">thy</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">class</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_tys</span> <span class="entity">comp</span> <span class="entity">free_types</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> fastype_of <span class="entity">comp</span> |&gt; strip_type |&gt; fst |&gt; <span class="entity">drop_last</span> |&gt; List.last |&gt; dest_Type |&gt; snd
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">rename_types</span> <span class="main">(</span><span class="entity">Ts</span> ~~ <span class="entity">free_types</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">HOLogic_list_conj</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">True</span><span class="antiquote">}</span></span>
  <span class="main">|</span> <span class="entity">HOLogic_list_conj</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="main">=</span> <span class="entity">x</span>
  <span class="main">|</span> <span class="entity">HOLogic_list_conj</span> <span class="main">(</span><span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.mk_conj</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">HOLogic_list_conj</span> <span class="entity">xs</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_Some</span> <span class="entity">t</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Some<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ty</span> --&gt; Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> option<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_set_map_impl</span> <span class="entity">choices</span> <span class="entity">ty</span> <span class="entity">choice</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">smi</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">choices</span> <span class="entity">choice</span> <span class="keyword2"><span class="keyword">of</span></span>
      SOME <span class="entity">smi</span> <span class="main">=&gt;</span> <span class="entity">smi</span>
    <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">choice</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> error <span class="inner_quoted">"you must provide some constant as parameter"</span>
        <span class="keyword2"><span class="keyword">else</span></span> Syntax.read_term <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="entity">choice</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">smi_ty</span> <span class="main">=</span> fastype_of <span class="entity">smi</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pty</span> <span class="main">=</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> phantom<span class="antiquote">}</span></span><span class="main">,</span><span class="main">[</span><span class="entity">ty</span><span class="main">,</span><span class="entity">smi_ty</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ph</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> phantom<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">smi_ty</span> --&gt; <span class="entity">pty</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="entity">ph</span> $ <span class="entity">smi</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">res</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">derive_set_map_impl</span> <span class="entity">smi_const</span> <span class="entity">smi_sort</span> <span class="entity">choices</span> <span class="entity">typ_name</span> <span class="entity">choice</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">typ_name</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">smi_name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">smi_const</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"use "</span> ^ <span class="entity">choice</span> ^ <span class="inner_quoted">" as "</span> ^ <span class="entity">smi_name</span> ^ <span class="inner_quoted">" for type "</span> ^ <span class="entity">base_name</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span><span class="entity">vs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Generator_Aux.typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">typ_name</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set_map_impl_rhs</span> <span class="main">=</span> <span class="entity">mk_set_map_impl</span> <span class="entity">choices</span> <span class="entity">ty</span> <span class="entity">choice</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set_map_impl_ty</span> <span class="main">=</span> Term.fastype_of <span class="entity">set_map_impl_rhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set_map_impl_def</span> <span class="main">=</span> <span class="entity">Generator_Aux.mk_def</span> <span class="entity">set_map_impl_ty</span> <span class="entity">smi_const</span> <span class="entity">set_map_impl_rhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">typ_name</span><span class="main">]</span><span class="main">,</span><span class="entity">vs</span><span class="main">,</span><span class="entity">smi_sort</span><span class="main">)</span> <span class="entity">thy</span>
      |&gt; <span class="entity">Generator_Aux.define_overloaded</span> <span class="main">(</span><span class="entity">smi_name</span> ^ <span class="inner_quoted">"_"</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">,</span> <span class="entity">set_map_impl_def</span><span class="main">)</span>     
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'</span> <span class="main">=</span> <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"registered "</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">" in class "</span> ^ <span class="entity">smi_name</span><span class="main">)</span>  
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy'</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">derive_none</span> <span class="entity">const</span> <span class="entity">sort</span> <span class="entity">mk_none</span> <span class="entity">typ_name</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">typ_name</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">const</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort_name</span> <span class="main">=</span> hd <span class="entity">sort</span> |&gt; Long_Name.base_name
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"use None as trivial implementation of "</span> ^ <span class="entity">sort_name</span> ^ <span class="inner_quoted">" for type "</span> ^ <span class="entity">base_name</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span><span class="entity">vs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Generator_Aux.typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">typ_name</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">none_rhs</span> <span class="main">=</span> <span class="entity">mk_none</span> <span class="entity">ty</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">none_ty</span> <span class="main">=</span> Term.fastype_of <span class="entity">none_rhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_def</span> <span class="main">=</span> <span class="entity">Generator_Aux.mk_def</span> <span class="entity">none_ty</span> <span class="entity">const</span> <span class="entity">none_rhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">none_thm</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">typ_name</span><span class="main">]</span><span class="main">,</span><span class="entity">vs</span><span class="main">,</span><span class="entity">sort</span><span class="main">)</span> <span class="entity">thy</span>
      |&gt; <span class="entity">Generator_Aux.define_overloaded</span> <span class="main">(</span><span class="entity">const_name</span> ^ <span class="inner_quoted">"_"</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">,</span> <span class="entity">const_def</span><span class="main">)</span>
     
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'</span> <span class="main">=</span> <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">none_thm</span><span class="main">]</span>
      THEN <span class="main">(</span>REPEAT <span class="main">(</span><span class="entity">force_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"registered "</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">" in class "</span> ^ <span class="entity">sort_name</span><span class="main">)</span>    
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy'</span> <span class="keyword2"><span class="keyword">end</span></span>
 
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_is_c_dots</span> <span class="entity">ty</span> <span class="entity">dots</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ity</span> <span class="main">=</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> itself<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">it</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.type<span class="antiquote">}</span></span><span class="main">,</span><span class="entity">ity</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">dots</span><span class="main">,</span> <span class="entity">ity</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> $ <span class="entity">it</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">res</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_is_c_dots_lemma</span> <span class="entity">const_name</span> <span class="entity">base_name</span> <span class="entity">thm</span> <span class="entity">thy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">const_name</span> ^ <span class="inner_quoted">"_"</span> ^ <span class="entity">base_name</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy_map</span> <span class="main">=</span> Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">,</span> 
          <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">code_post</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span> #&gt; <span class="main">#</span><span class="inner_numeral">2</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'</span> <span class="main">=</span> <span class="entity">Named_Target.theory_map</span> <span class="entity">lthy_map</span> <span class="entity">thy</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"derived "</span> ^ <span class="entity">name</span> ^ <span class="inner_quoted">"-lemma"</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy'</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">derive_is_c_dots_lemma</span> <span class="entity">ty</span> <span class="entity">const_name</span> <span class="entity">defs</span> <span class="entity">base_name</span> <span class="entity">thy</span>  <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_c_dots</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_is_c_dots</span> <span class="entity">ty</span> <span class="entity">const_name</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> Goal.prove_future <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">is_c_dots</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>prems <span class="main">=</span> <span class="main">_</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">}</span> <span class="main">=&gt;</span> 
        <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">defs</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ID_Some option.simps<span class="antiquote">}</span></span></span><span class="main">)</span>
        THEN <span class="entity">blast_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
      <span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">register_is_c_dots_lemma</span> <span class="entity">const_name</span> <span class="entity">base_name</span> <span class="entity">thm</span> <span class="entity">thy</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Collection_Order">
<div class="head">
<h1>Theory Collection_Order</h1>
</div>
<pre class="source"><span class="comment1">(* Title:      Containers/Collection_Order.thy
    Author:     Andreas Lochbihler, KIT
                René Thiemann, UIBK *)</span>

<span class="keyword1"><span class="command">theory</span></span> Collection_Order
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Set_Linorder.html">Set_Linorder</a>
  <a href="Containers_Generator.html">Containers_Generator</a>
  <a href="../Deriving/Compare_Instances.html">Deriving.Compare_Instances</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Light-weight containers›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{chapter:light-weight:containers}›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹A linear order for code generation›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Optional comparators›</span></span>

<span class="keyword1"><span class="command">class</span></span> ccompare <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">ccompare</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator option"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ccompare<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">comp</span><span class="main">.</span> <span class="free">ccompare</span> <span class="main">=</span> Some <span class="bound">comp</span> <span class="main">⟹</span> comparator <span class="bound">comp</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ccomp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ccomp</span> <span class="main">≡</span> the <span class="main">(</span>ID ccompare<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">cless</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cless</span> <span class="main">≡</span> lt_of_comp <span class="main">(</span>the <span class="main">(</span>ID ccompare<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">cless_eq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cless_eq</span> <span class="main">≡</span> le_of_comp <span class="main">(</span>the <span class="main">(</span>ID ccompare<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ccompare<span class="main">)</span> ID_ccompare'<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">c</span><span class="main">.</span> ID ccompare <span class="main">=</span> Some <span class="bound">c</span> <span class="main">⟹</span> comparator <span class="bound">c</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ID_def id_apply <span class="keyword1"><span class="command">using</span></span> ccompare <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ccompare<span class="main">)</span> ID_ccompare<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">c</span><span class="main">.</span> ID ccompare <span class="main">=</span> Some <span class="bound">c</span> <span class="main">⟹</span> class.linorder <span class="main">(</span>le_of_comp <span class="bound">c</span><span class="main">)</span> <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> comparator.linorder<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span><span class="main">)</span>
  
<span class="keyword1"><span class="command">syntax</span></span> <span class="quoted">"_CCOMPARE"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"type <span class="main">=&gt;</span> logic"</span></span>  <span class="main">(</span><span class="quoted">"<span class="keyword3">(1</span><span class="keyword1">CCOMPARE</span><span class="keyword3">/</span><span class="keyword3">(1</span><span class="keyword1">'(</span>_<span class="keyword1">')</span><span class="keyword3">)</span><span class="keyword3">)</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">parse_translation</span></span> <span class="quoted">‹
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ccompare_tr</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span> <span class="main">=</span>
     <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_constrain"<span class="antiquote">}</span></span> $ Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_syntax</span> "ccompare"<span class="antiquote">}</span></span> $
       <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> option<span class="antiquote">}</span></span> $ 
         <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> fun<span class="antiquote">}</span></span> $ <span class="entity">ty</span> $ 
           <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> fun<span class="antiquote">}</span></span> $ <span class="entity">ty</span> $ Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> order<span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">ccompare_tr</span> <span class="entity">ts</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"ccompare_tr"</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="main">[</span><span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_CCOMPARE"<span class="antiquote">}</span></span><span class="main">,</span> K <span class="entity">ccompare_tr</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_ccompare</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare itself <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_ccompare</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟷</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">≠</span> None"</span></span>

<span class="keyword1"><span class="command">context</span></span> ccompare
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lemma</span></span> cless_eq_conv_cless<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">≠</span> None"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cless_eq <span class="free">a</span> <span class="free">b</span> <span class="main">⟷</span> cless <span class="free">a</span> <span class="free">b</span> <span class="main">∨</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">interpret</span></span> linorder <span class="quoted">cless_eq</span> <span class="quoted"><span class="quoted">"cless <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> le_less<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generator for the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccompare<span class="antiquote"><span class="antiquote">}</span></span></span></span>--class›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This generator registers itself at the derive-manager for the class
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccompare<span class="antiquote"><span class="antiquote">}</span></span></span></span>. To be more precise, one can choose whether one does not want to
support a comparator by passing parameter "no", one wants to register an arbitrary type which
is already in class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span> using parameter "compare", or
one wants to generate a new comparator by passing no parameter.
In the last case, one demands that the type is a datatype
and that all non-recursive types of that datatype already provide a comparator,
which can usually be achieved via "derive comparator type" or "derive compare type".


\begin{itemize}
\item \texttt{instantiation type :: (type,\ldots,type) (no) corder}
\item \texttt{instantiation datatype :: (type,\ldots,type) corder}
\item \texttt{instantiation datatype :: (compare,\ldots,compare) (compare) corder}
\end{itemize}

If the parameter "no" is not used, then the corresponding
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> is_ccompare<span class="antiquote"><span class="antiquote">}</span></span></span></span>-theorem is automatically generated and attributed with 
\texttt{[simp, code-post]}.
›</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
To create a new comparator, we just invoke the functionality provided by the generator.
The only difference is the boilerplate-code, which for the generator has to perform
the class instantiation for a comparator, whereas here we have to invoke the methods to 
satisfy the corresponding locale for comparators.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This generator can be used for arbitrary types, not just datatypes. 
When passing no parameters, we get same limitation as for the order generator.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> corder_intro<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder <span class="free">le</span> <span class="free">lt</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">le</span><span class="main">,</span> <span class="free">lt</span><span class="main">)</span><span class="main">⟹</span> <span class="free">a</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">le'</span><span class="main">,</span><span class="free">lt'</span><span class="main">)</span> <span class="main">⟹</span>
  class.linorder <span class="free">le'</span> <span class="free">lt'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> comparator_subst<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c1</span> <span class="main">=</span> <span class="free">c2</span> <span class="main">⟹</span> comparator <span class="free">c1</span> <span class="main">⟹</span> comparator <span class="free">c2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> compare<span class="main">)</span> compare_subst<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">comp</span><span class="main">.</span> compare <span class="main">=</span> <span class="bound">comp</span> <span class="main">⟹</span> comparator <span class="bound">comp</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> comparator_compare <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹ccompare_generator.ML›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Instantiations for HOL types›</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>linorder<span class="main">)</span> compare_order 
  <span class="quoted">Enum.finite_1</span> <span class="quoted">Enum.finite_2</span> <span class="quoted">Enum.finite_3</span> <span class="quoted">natural</span> <span class="quoted">String.literal</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>compare<span class="main">)</span> ccompare 
  <span class="quoted">unit</span> <span class="quoted">bool</span> <span class="quoted">nat</span> <span class="quoted">int</span> <span class="quoted">Enum.finite_1</span> <span class="quoted">Enum.finite_2</span> <span class="quoted">Enum.finite_3</span> <span class="quoted">integer</span> <span class="quoted">natural</span> <span class="quoted">char</span> <span class="quoted">String.literal</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>no<span class="main">)</span> ccompare <span class="quoted">Enum.finite_4</span> <span class="quoted">Enum.finite_5</span>

<span class="keyword1"><span class="command">derive</span></span> ccompare <span class="quoted">sum</span> <span class="quoted">list</span> <span class="quoted">option</span> <span class="quoted">prod</span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>no<span class="main">)</span> ccompare <span class="quoted"><span class="quoted">"fun"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_ccompare_fun <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_ccompare <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_ccompare_def ccompare_fun_def ID_None<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">ccompare</span><span class="main">)</span> <span class="quoted">ccompare</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> set<span class="main">)</span> <span class="main">=</span> 
  map_option <span class="main">(</span><span class="main">λ</span> <span class="bound">c</span><span class="main">.</span> comp_of_ords <span class="main">(</span>ord.set_less_eq <span class="main">(</span>le_of_comp <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ord.set_less <span class="main">(</span>le_of_comp <span class="bound">c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ccompare_set_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> comp_of_ords linorder.set_less_eq_linorder ID_ccompare<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_ccompare_set <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code_post</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_ccompare <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟷</span> is_ccompare <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_ccompare_def ccompare_set_def ID_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cless_eq_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cless_eq_set</span> <span class="main">=</span> le_of_comp <span class="main">(</span>the <span class="main">(</span>ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> set<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cless_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cless_set</span> <span class="main">=</span> lt_of_comp <span class="main">(</span>the <span class="main">(</span>ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> set<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ccompare_set_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare set<span class="main">)</span> <span class="main">=</span> 
    <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> Some <span class="main">(</span>comp_of_ords cless_eq_set cless_set<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ccompare_set_def ID_Some <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>no<span class="main">)</span> ccompare <span class="quoted">Predicate.pred</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Proper intervals›</span></span>

<span class="keyword1"><span class="command">class</span></span> cproper_interval <span class="main">=</span> ccompare <span class="main">+</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">cproper_interval</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cproper_interval<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">≠</span> None<span class="main">;</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> class.proper_interval cless <span class="free">cproper_interval</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ID_ccompare_interval<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> Some <span class="free">c</span><span class="main">;</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> class.linorder_proper_interval <span class="main">(</span>le_of_comp <span class="free">c</span><span class="main">)</span> <span class="main">(</span>lt_of_comp <span class="free">c</span><span class="main">)</span> cproper_interval"</span></span>
<span class="keyword1"><span class="command">using</span></span> cproper_interval
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare class.linorder_proper_interval_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> unit <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">=</span> <span class="main">(</span>proper_interval <span class="main">::</span> unit proper_interval<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> compare_order_class.ord_defs cproper_interval_unit_def ccompare_unit_def ID_Some proper_interval_class.axioms<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> bool <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">=</span> <span class="main">(</span>proper_interval <span class="main">::</span> bool proper_interval<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cproper_interval_bool_def ord_defs ccompare_bool_def ID_Some proper_interval_class.axioms<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> nat <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">=</span> <span class="main">(</span>proper_interval <span class="main">::</span> nat proper_interval<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> int <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">=</span> <span class="main">(</span>proper_interval <span class="main">::</span> int proper_interval<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> 
  <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cproper_interval_int_def ord_defs ccompare_int_def ID_Some proper_interval_class.axioms<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> integer <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">=</span> <span class="main">(</span>proper_interval <span class="main">::</span> integer proper_interval<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> 
  <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cproper_interval_integer_def ord_defs ccompare_integer_def ID_Some proper_interval_class.axioms<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> natural <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">=</span> <span class="main">(</span>proper_interval <span class="main">::</span> natural proper_interval<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cproper_interval_natural_def ord_defs ccompare_natural_def ID_Some proper_interval_class.axioms<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> char <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">=</span> <span class="main">(</span>proper_interval <span class="main">::</span> char proper_interval<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cproper_interval_char_def ord_defs ccompare_char_def ID_Some proper_interval_class.axioms<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_1 <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">=</span> <span class="main">(</span>proper_interval <span class="main">::</span> Enum.finite_1 proper_interval<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cproper_interval_finite_1_def ord_defs ccompare_finite_1_def ID_Some proper_interval_class.axioms<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_2 <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">=</span> <span class="main">(</span>proper_interval <span class="main">::</span> Enum.finite_2 proper_interval<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cproper_interval_finite_2_def ord_defs ccompare_finite_2_def ID_Some proper_interval_class.axioms<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_3 <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">=</span> <span class="main">(</span>proper_interval <span class="main">::</span> Enum.finite_3 proper_interval<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cproper_interval_finite_3_def ord_defs ccompare_finite_3_def ID_Some proper_interval_class.axioms<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_4 <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>cproper_interval <span class="main">::</span> Enum.finite_4 proper_interval<span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord_defs ccompare_finite_4_def ID_None<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_5 <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>cproper_interval <span class="main">::</span> Enum.finite_5 proper_interval<span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord_defs ccompare_finite_5_def ID_None<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lt_of_comp_sum<span class="main">:</span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="main">(</span>comparator_sum <span class="free">ca</span> <span class="free">cb</span><span class="main">)</span> <span class="free">sx</span> <span class="free">sy</span> <span class="main">=</span> <span class="main">(</span>
  <span class="keyword1">case</span> <span class="free">sx</span> <span class="keyword1">of</span> Inl <span class="bound">x</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">sy</span> <span class="keyword1">of</span> Inl <span class="bound">y</span> <span class="main">⇒</span> lt_of_comp <span class="free">ca</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">|</span> Inr <span class="bound">y</span> <span class="main">⇒</span> True<span class="main">)</span>
   <span class="main">|</span> Inr <span class="bound">x</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">sy</span> <span class="keyword1">of</span> Inl <span class="bound">y</span> <span class="main">⇒</span> False <span class="main">|</span> Inr <span class="bound">y</span> <span class="main">⇒</span> lt_of_comp <span class="free">cb</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lt_of_comp_def le_of_comp_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted">cproper_interval</span><span class="main">,</span> <span class="quoted">cproper_interval</span><span class="main">)</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">cproper_interval_sum</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> proper_interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_sum</span> None None <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_sum</span> None <span class="main">(</span>Some <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> cproper_interval None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_sum</span> None <span class="main">(</span>Some <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_sum</span> <span class="main">(</span>Some <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span> None <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_sum</span> <span class="main">(</span>Some <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> cproper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_sum</span> <span class="main">(</span>Some <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> cproper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> None <span class="main">∨</span> cproper_interval None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_sum</span> <span class="main">(</span>Some <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span> None <span class="main">⟷</span> cproper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_sum</span> <span class="main">(</span>Some <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_sum</span> <span class="main">(</span>Some <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> cproper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">≠</span> None"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c_a</span></span> <span class="skolem"><span class="skolem">c_b</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> Some <span class="skolem">c_a</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> Some <span class="skolem">c_b</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ccompare_sum_def ID_Some ID_None <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> proper_interval.proper_interval_simps<span class="main">[</span><span class="operator">OF</span> cproper_interval<span class="main">]</span> 
    lt_of_comp_sum ccompare_sum_def ID_Some
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">split</span><span class="main">]</span> <span class="main">=</span> sum.split
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"class.proper_interval cless <span class="main">(</span>cproper_interval <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> proper_interval<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"cproper_interval None <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> cless <span class="bound">z</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> A B <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">z</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> None <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> cless <span class="skolem">x</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> A B <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">z</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> cless <span class="skolem">x</span> <span class="bound">z</span> <span class="main">∧</span> cless <span class="bound">z</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> A B <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">y</span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">z</span></span></span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">lemma</span></span> lt_of_comp_less_prod<span class="main">:</span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="main">(</span>comparator_prod <span class="free">c_a</span> <span class="free">c_b</span><span class="main">)</span> <span class="main">=</span>
  less_prod <span class="main">(</span>le_of_comp <span class="free">c_a</span><span class="main">)</span> <span class="main">(</span>lt_of_comp <span class="free">c_a</span><span class="main">)</span> <span class="main">(</span>lt_of_comp <span class="free">c_b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> less_prod_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lt_of_comp_def le_of_comp_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.split_asm prod.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lt_of_comp_prod<span class="main">:</span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="main">(</span>comparator_prod <span class="free">c_a</span> <span class="free">c_b</span><span class="main">)</span> <span class="main">(</span><span class="free">x1</span><span class="main">,</span><span class="free">x2</span><span class="main">)</span> <span class="main">(</span><span class="free">y1</span><span class="main">,</span><span class="free">y2</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span>lt_of_comp <span class="free">c_a</span> <span class="free">x1</span> <span class="free">y1</span> <span class="main">∨</span> le_of_comp <span class="free">c_a</span> <span class="free">x1</span> <span class="free">y1</span> <span class="main">∧</span> lt_of_comp <span class="free">c_b</span> <span class="free">x2</span> <span class="free">y2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lt_of_comp_less_prod less_prod_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="main">::</span> <span class="main">(</span><span class="quoted">cproper_interval</span><span class="main">,</span> <span class="quoted">cproper_interval</span><span class="main">)</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">cproper_interval_prod</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> proper_interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_prod</span> None None <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_prod</span> None <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y2</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> cproper_interval None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y1</span></span></span><span class="main">)</span> <span class="main">∨</span> cproper_interval None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y2</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_prod</span> <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x2</span></span></span><span class="main">)</span><span class="main">)</span> None <span class="main">⟷</span> cproper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">)</span> None <span class="main">∨</span> cproper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x2</span></span></span><span class="main">)</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_prod</span> <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x2</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">y2</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> 
   cproper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y1</span></span></span><span class="main">)</span> <span class="main">∨</span> 
   cless <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="free"><span class="bound"><span class="entity">y1</span></span></span> <span class="main">∧</span> <span class="main">(</span>cproper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x2</span></span></span><span class="main">)</span> None <span class="main">∨</span> cproper_interval None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y2</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span>
   <span class="main">¬</span> cless <span class="free"><span class="bound"><span class="entity">y1</span></span></span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="main">∧</span> cproper_interval <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x2</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y2</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">≠</span> None"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c_a</span></span> <span class="skolem"><span class="skolem">c_b</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> Some <span class="skolem">c_a</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> Some <span class="skolem">c_b</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ccompare_prod_def ID_Some ID_None finite_prod <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> a<span class="main">:</span> linorder <span class="quoted"><span class="quoted">"le_of_comp <span class="skolem">c_a</span>"</span></span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="skolem">c_a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ID_ccompare<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> A<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> proper_interval.proper_interval_simps<span class="main">[</span><span class="operator">OF</span> cproper_interval<span class="main">]</span> 
    ccompare_prod_def lt_of_comp_prod ID_Some
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"class.proper_interval cless <span class="main">(</span>cproper_interval <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> proper_interval<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A B
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> 4 4<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">instantiation</span></span> list <span class="main">::</span> <span class="main">(</span><span class="quoted">ccompare</span><span class="main">)</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">cproper_interval_list</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list proper_interval"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_list</span> <span class="free"><span class="bound"><span class="entity">xso</span></span></span> <span class="free"><span class="bound"><span class="entity">yso</span></span></span> <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> infinite_UNIV_listI<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> infinite_UNIV_literal<span class="main">:</span>
  <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>UNIV <span class="main">::</span> String.literal set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> infinite_literal<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> String.literal <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">cproper_interval_literal</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"String.literal proper_interval"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_literal</span> <span class="free"><span class="bound"><span class="entity">xso</span></span></span> <span class="free"><span class="bound"><span class="entity">yso</span></span></span> <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> infinite_UNIV_literal<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lt_of_comp_option<span class="main">:</span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="main">(</span>comparator_option <span class="free">c</span><span class="main">)</span> <span class="free">sx</span> <span class="free">sy</span> <span class="main">=</span> <span class="main">(</span>
  <span class="keyword1">case</span> <span class="free">sx</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">sy</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> True<span class="main">)</span>
   <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">sy</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> lt_of_comp <span class="free">c</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lt_of_comp_def le_of_comp_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>


<span class="keyword1"><span class="command">instantiation</span></span> option <span class="main">::</span> <span class="main">(</span><span class="quoted">cproper_interval</span><span class="main">)</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">cproper_interval_option</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option proper_interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_option</span> None None <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_option</span> None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_option</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> None <span class="main">⟷</span> cproper_interval <span class="free"><span class="bound"><span class="entity">x</span></span></span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_option</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Some None<span class="main">)</span> <span class="main">⟷</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_option</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> cproper_interval <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> option<span class="main">)</span> <span class="main">≠</span> None"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> option set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c_a</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> Some <span class="skolem">c_a</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ccompare_option_def ID_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> proper_interval.proper_interval_simps<span class="main">[</span><span class="operator">OF</span> cproper_interval<span class="main">]</span> 
    ccompare_option_def lt_of_comp_option ID_Some
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"class.proper_interval cless <span class="main">(</span>cproper_interval <span class="main">::</span> <span class="tfree">'a</span> option proper_interval<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> None <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> cless <span class="skolem">x</span> <span class="bound">z</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Some undefined"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">(</span>Some <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>Some <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> cless <span class="skolem">x</span> <span class="bound">z</span> <span class="main">∧</span> cless <span class="bound">z</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> option.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> option.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">instantiation</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">cproper_interval</span><span class="main">)</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">cproper_interval_set</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set proper_interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_set</span> None None <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_set</span> None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_set</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> None <span class="main">⟷</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">≠</span> UNIV<span class="main">)</span>"</span></span>
<span class="main">|</span> cproper_interval_set_Some_Some <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="comment1">― ‹Refine for concrete implementations›</span>
  <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_set</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">⟷</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">C</span><span class="main">.</span> cless <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="bound">C</span> <span class="main">∧</span> cless <span class="bound">C</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> set<span class="main">)</span> <span class="main">≠</span> None"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c_a</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> Some <span class="skolem">c_a</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ccompare_set_def ID_def Finite_Set.finite_set<span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> a<span class="main">:</span> linorder <span class="quoted"><span class="quoted">"le_of_comp <span class="skolem">c_a</span>"</span></span> <span class="quoted"><span class="quoted">"lt_of_comp <span class="skolem">c_a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ID_ccompare<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> A<span class="main">)</span> 
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> proper_interval.proper_interval_simps<span class="main">[</span><span class="operator">OF</span> cproper_interval<span class="main">]</span> ccompare_set_def 
    ID_Some lt_of_comp_of_ords
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"class.proper_interval cless <span class="main">(</span>cproper_interval <span class="main">::</span> <span class="tfree">'a</span> set proper_interval<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> Complement_cproper_interval_set_Complement<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> corder<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">≠</span> None"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">(</span>Some <span class="main">(</span><span class="main">-</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span><span class="main">-</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> cproper_interval <span class="main">(</span>Some <span class="free">B</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ccompare_set_def ID_Some lt_of_comp_of_ords<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> double_complement linorder.Compl_set_less_Compl<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">instantiation</span></span> <span class="quoted">"fun"</span> <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">,</span> <span class="quoted">type</span><span class="main">)</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹No interval checks on functions needed because we have not defined an order on them.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="main">=</span> <span class="main">(</span>undefined <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> proper_interval<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ccompare_fun_def ID_None<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/ccompare_generator.ML">
<div class="head">
<h1>File ‹ccompare_generator.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Author:  René Thiemann, UIBK *)</span>
<span class="comment1">(* This generator was written as part of the IsaFoR/CeTA formalization. *)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CCOMPARE_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>

  <span class="comment1">(* creates a conditional comparator by using the comparator of the Comparator_Generator,
     also is_ccompare (a1,..,an)ty = is_ccompare a1 ∧ ... ∧ is_ccompare an
     is generated. *)</span> 
  <span class="keyword1"><span class="keyword">val</span></span> ccompare_instance_via_comparator <span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
    
  <span class="comment1">(* creates a conditional comparator by demanding that the type is already a member of class compare. 
     Hence, "is_ccompare ty" will always be satisfied. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> ccompare_instance_via_compare <span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  
  <span class="comment1">(* derives a trivial instance (None) for class ccompare *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> derive_no_ccompare <span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">CCompare_Generator</span> <span class="main">:</span> <span class="entity">CCOMPARE_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Generator_Aux
<span class="keyword3"><span class="keyword">open</span></span> Containers_Generator

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ccmpS</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">ccompare</span><span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ccmpN</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> ccompare<span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cmpT</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">order</span><span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ccmpT</span> <span class="entity">T</span> <span class="main">=</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> option<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">cmpT</span> <span class="entity">T</span><span class="main">]</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ccmp_const</span> <span class="entity">T</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">ccmpN</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">generator_type</span> <span class="main">=</span> <span class="entity">Comparator_Generator.BNF</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_comp</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">Comparator_Generator.get_info</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="main">{</span>comp <span class="main">=</span> <span class="entity">c</span><span class="main">,</span> comp_thm <span class="main">=</span> <span class="entity">c_thm</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> fastype_of <span class="entity">c</span> |&gt; strip_type |&gt; fst |&gt; `<span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> - <span class="inner_numeral">2</span><span class="main">)</span> o length<span class="main">)</span> |&gt; uncurry take
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">c_thm</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"no order info for type "</span> ^ quote <span class="entity">tname</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_ID_ccompare</span> <span class="entity">eq_var</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">eq_var</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">oty</span> <span class="main">=</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> option<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ccompare</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">ccmpN</span><span class="main">,</span> <span class="entity">oty</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ID_cc</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> ID<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">oty</span> --&gt; <span class="entity">oty</span><span class="main">)</span> $ <span class="entity">ccompare</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">ID_cc</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_ccmp_rhs</span> <span class="entity">c</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">mk_Some</span> <span class="entity">c</span>
  <span class="main">|</span> <span class="entity">mk_ccmp_rhs</span> <span class="entity">c</span> <span class="main">(</span><span class="entity">T</span> :: <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cmp</span> <span class="main">=</span> <span class="entity">ccmp_const</span> <span class="entity">T</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">idcmp</span> <span class="main">=</span> <span class="entity">mk_ID_ccompare</span> <span class="entity">cmp</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tname</span> <span class="main">=</span> <span class="entity">T</span> |&gt; binder_types |&gt; hd |&gt; dest_TVar |&gt; fst |&gt; fst 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_comp</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"comp_"</span> ^ <span class="entity">tname</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">caseT</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> case_option<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span> 
          $ Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> None<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span>
          $ lambda <span class="entity">arg_comp</span> <span class="main">(</span><span class="entity">mk_ccmp_rhs</span> <span class="main">(</span><span class="entity">c</span> $ <span class="entity">arg_comp</span><span class="main">)</span> <span class="entity">Ts</span><span class="main">)</span>
          $ <span class="entity">idcmp</span>
      <span class="keyword2"><span class="keyword">in</span></span> 
        <span class="entity">caseT</span>
      <span class="keyword2"><span class="keyword">end</span></span>

  
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_ccmp_def</span> <span class="entity">T</span> <span class="entity">rhs</span> <span class="main">=</span>
  Logic.mk_equals <span class="main">(</span>Const <span class="main">(</span><span class="entity">ccmpN</span><span class="main">,</span> <span class="entity">ccmpT</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ccompare_tac</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="entity">Ts</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">c_thm</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_comp</span> <span class="entity">ctxt</span> <span class="entity">tname</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ID_def id_def<span class="antiquote">}</span></span></span> 
    THEN REPEAT_DETERM_N <span class="main">(</span>length <span class="entity">Ts</span><span class="main">)</span> <span class="main">(</span>
      <span class="entity">Splitter.split_asm_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> option.splits<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span> THEN
      <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> option.simps<span class="antiquote">}</span></span></span><span class="main">)</span> 
    THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> option.simps<span class="antiquote">}</span></span></span> 
    THEN resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> comparator_subst<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span> THEN assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span> 
    THEN REPEAT_DETERM <span class="main">(</span>dresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ccompare<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">)</span> 
    THEN <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">c_thm</span><span class="main">]</span> THEN_ALL_NEW assume_tac <span class="entity">ctxt</span><span class="main">)</span> <span class="inner_numeral">1</span>
  <span class="keyword2"><span class="keyword">end</span></span>
    
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ccompare_instance_via_comparator</span> <span class="entity">tname</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">Named_Target.theory_map</span> <span class="main">(</span><span class="entity">Comparator_Generator.ensure_info</span> <span class="entity">generator_type</span> <span class="entity">tname</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"deriving \"ccompare\" instance for type "</span> ^ quote <span class="entity">tname</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">main_ty</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">ccmpS</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">Ts</span><span class="main">,</span> <span class="main">(</span><span class="entity">cmp_thm</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tname</span><span class="main">]</span><span class="main">,</span> <span class="entity">xs</span><span class="main">,</span> <span class="entity">ccmpS</span><span class="main">)</span> <span class="entity">thy</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_comp</span> <span class="entity">ctxt</span> <span class="entity">tname</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_mapping</span> <span class="main">=</span> <span class="entity">all_tys</span> <span class="entity">c</span> <span class="main">(</span>map TFree <span class="entity">xs</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cmp_def</span> <span class="main">=</span> <span class="entity">mk_ccmp_def</span> dummyT <span class="main">(</span><span class="entity">mk_ccmp_rhs</span> <span class="entity">c</span> <span class="entity">Ts</span><span class="main">)</span> |&gt; <span class="entity">typ_mapping</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span><span class="entity">Ts</span><span class="main">,</span> <span class="entity">define_overloaded_generic</span>
           <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="inner_quoted">"ccompare_"</span> ^ Long_Name.base_name <span class="entity">tname</span> ^ <span class="inner_quoted">"_def"</span><span class="main">)</span><span class="main">,</span>
            <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
            <span class="entity">cmp_def</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
      <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">cmp_thm</span><span class="main">]</span>
      THEN <span class="entity">ccompare_tac</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="entity">Ts</span><span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> <span class="entity">Comparator_Generator.get_info</span> <span class="main">(</span><span class="entity">Named_Target.theory_init</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">tname</span> |&gt; the
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">used</span> <span class="main">=</span> <span class="main">#</span>used_positions <span class="entity">info</span>
    
    <span class="comment1">(* is_ccompare (a1,..,an)ty = (is_ccompare a1 ∧ ... ) -thm *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_is_ccompare</span> <span class="entity">ty</span> <span class="main">=</span> <span class="entity">mk_is_c_dots</span> <span class="entity">ty</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> is_ccompare<span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">main_is_ccompare</span> <span class="main">=</span> <span class="entity">mk_is_ccompare</span> <span class="entity">main_ty</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param_tys</span> <span class="main">=</span> dest_Type <span class="entity">main_ty</span> |&gt; snd   
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">filtered_tys</span> <span class="main">=</span> <span class="entity">used</span> ~~ <span class="entity">param_tys</span> |&gt; filter fst |&gt; map snd
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param_is_ccompare</span> <span class="main">=</span> map <span class="entity">mk_is_ccompare</span> <span class="entity">filtered_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_ccompare_thm_trm</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">param_is_ccompare</span> <span class="keyword2"><span class="keyword">of</span></span> 
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">main_is_ccompare</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">main_is_ccompare</span><span class="main">,</span><span class="entity">HOLogic_list_conj</span> <span class="entity">param_is_ccompare</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_ccompare_thm</span> <span class="main">=</span> Goal.prove <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">is_ccompare_thm_trm</span> 
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> prems <span class="main">=</span> <span class="main">_</span><span class="main">}</span> <span class="main">=&gt;</span> 
        <span class="entity">simp_tac</span> <span class="main">(</span><span class="entity">Splitter.add_split</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> option.split<span class="antiquote">}</span></span></span> <span class="entity">ctxt</span> 
          addsimps <span class="main">(</span><span class="entity">cmp_thm</span> :: <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ID_Some ID_None is_ccompare_def<span class="antiquote">}</span></span></span><span class="main">)</span>
        <span class="main">)</span> <span class="inner_numeral">1</span>
      <span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">register_is_c_dots_lemma</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> is_ccompare<span class="antiquote">}</span></span> <span class="main">(</span>Long_Name.base_name <span class="entity">tname</span><span class="main">)</span> 
      <span class="entity">is_ccompare_thm</span> <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_some_compare</span> <span class="entity">ty</span> <span class="main">=</span> <span class="entity">mk_Some</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "compare"<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">cmpT</span> <span class="entity">ty</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ccompare_instance_via_compare</span> <span class="entity">tname</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">tname</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"deriving \"ccompare_order\" instance for type "</span> ^ 
      quote <span class="entity">tname</span> ^ <span class="inner_quoted">" via compare_order"</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span><span class="entity">vs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">compare</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ccompare_rhs</span> <span class="main">=</span> <span class="entity">mk_some_compare</span> <span class="entity">ty</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ccompare_ty</span> <span class="main">=</span> Term.fastype_of <span class="entity">ccompare_rhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ccompare_def</span> <span class="main">=</span> <span class="entity">mk_def</span> <span class="entity">ccompare_ty</span> <span class="entity">ccmpN</span> <span class="entity">ccompare_rhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ccompare_thm</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tname</span><span class="main">]</span><span class="main">,</span><span class="entity">vs</span><span class="main">,</span><span class="entity">ccmpS</span><span class="main">)</span> <span class="entity">thy</span>
      |&gt; <span class="main">(</span><span class="entity">define_overloaded</span> <span class="main">(</span><span class="inner_quoted">"ccompare_"</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">,</span> <span class="entity">ccompare_def</span><span class="main">)</span><span class="main">)</span>
     
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> 
      <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> 
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">ccompare_thm</span><span class="main">]</span>
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> option.simps prod.simps<span class="antiquote">}</span></span></span>
      THEN resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> compare_subst<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span> THEN assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
      <span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">derive_is_c_dots_lemma</span> <span class="entity">ty</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> is_ccompare<span class="antiquote">}</span></span> 
      <span class="main">[</span><span class="entity">ccompare_thm</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> is_ccompare_def<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="entity">base_name</span> <span class="entity">thy</span>

  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_none_ccompare</span> <span class="entity">ty</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> None<span class="antiquote">}</span></span><span class="main">,</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> option<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">cmpT</span> <span class="entity">ty</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">derive_no_ccompare</span> <span class="main">=</span> <span class="entity">derive_none</span> <span class="entity">ccmpN</span> <span class="entity">ccmpS</span> <span class="entity">mk_none_ccompare</span>
  
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ccompare_instance</span> <span class="entity">tname</span> <span class="entity">param</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">is_class_instance</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">ccmpS</span>
      <span class="keyword1"><span class="keyword">andalso</span></span> error <span class="main">(</span><span class="inner_quoted">"type "</span> ^ quote <span class="entity">tname</span> ^ <span class="inner_quoted">" is already an instance of class \"ccompare\""</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ccompare_instance_via_comparator</span> <span class="entity">tname</span> <span class="entity">thy</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">"no"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">derive_no_ccompare</span> <span class="entity">tname</span> <span class="entity">thy</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">"compare"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ccompare_instance_via_compare</span> <span class="entity">tname</span> <span class="entity">thy</span> 
    <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"unknown parameter, supported are (no parameter), \"compare\", and \"no\""</span> 
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup
 <span class="main">(</span><span class="entity">Derive_Manager.register_derive</span> <span class="inner_quoted">"ccompare"</span> 
    <span class="inner_quoted">"generate a conditional comparator; options are (), (no), and (compare)"</span> <span class="main">(</span><span class="entity">ccompare_instance</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="List_Proper_Interval">
<div class="head">
<h1>Theory List_Proper_Interval</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/List_Proper_Interval.thy
    Author:     Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> List_Proper_Interval <span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/List_Lexorder.html">HOL-Library.List_Lexorder</a>"</span>
  <a href="Collection_Order.html">Collection_Order</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Instantiate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> proper_interval<span class="antiquote"><span class="antiquote">}</span></span></span></span> of for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> list"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Nil_less_conv_neq_Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> less_append_same_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> preorder list"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="main">[]</span> <span class="main">&lt;</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> less_append_same2_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> preorder list"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">@</span> <span class="free">zs</span> <span class="main">⟷</span> <span class="free">ys</span> <span class="main">&lt;</span> <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> Cons_less_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> preorder"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">&lt;</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="bound">ys'</span><span class="main">.</span> <span class="free">ys</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">#</span> <span class="bound">ys'</span> <span class="main">∧</span> <span class="main">(</span><span class="free">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">&lt;</span> <span class="bound">ys'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">instantiation</span></span> list <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="main">{</span>proper_interval<span class="main">,</span> order<span class="main">}</span>"</span></span><span class="main">)</span> <span class="quoted">proper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">proper_interval_list_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> proper_interval_list_aux_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_list_aux</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">zs</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">&lt;</span> <span class="bound">zs</span> <span class="main">∧</span> <span class="bound">zs</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> proper_interval_list_aux_simps <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"proper_interval_list_aux <span class="free">xs</span> <span class="main">[]</span> <span class="main">⟷</span> False"</span></span>
  <span class="quoted"><span class="quoted">"proper_interval_list_aux <span class="main">[]</span> <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">ys</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">∨</span> proper_interval None <span class="main">(</span>Some <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"proper_interval_list_aux <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">(</span><span class="free">y</span> <span class="main">#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> proper_interval_list_aux <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_list_aux_correct proper_interval_simps Nil_less_conv_neq_Nil<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cons_less_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> less_trans<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span> <span class="main"><span class="main">#</span></span> <span class="free"><span class="free">xs</span></span> <span class="main"><span class="main">@</span></span> <span class="main"><span class="main">[</span></span>undefined<span class="main"><span class="main">]</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_append_same_iff<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cons_less_iff<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">proper_interval_list</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list option <span class="main">⇒</span> <span class="tfree">'a</span> list option <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">proper_interval_list</span> None None <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_list</span> None <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_list</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> None <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">proper_interval_list</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span> proper_interval_list_aux <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"proper_interval None <span class="main">(</span>Some <span class="skolem">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">zs</span><span class="main">.</span> <span class="bound">zs</span> <span class="main">&lt;</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Nil_less_conv_neq_Nil <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="skolem">xs</span><span class="main">)</span> None <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">zs</span><span class="main">.</span> <span class="skolem">xs</span> <span class="main">&lt;</span> <span class="bound">zs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span>undefined<span class="main">]</span>"</span></span><span class="main"><span class="main">]</span></span> less_append_same_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"proper_interval <span class="main">(</span>Some <span class="skolem">xs</span><span class="main">)</span> <span class="main">(</span>Some <span class="skolem">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">zs</span><span class="main">.</span> <span class="skolem">xs</span> <span class="main">&lt;</span> <span class="bound">zs</span> <span class="main">∧</span> <span class="bound">zs</span> <span class="main">&lt;</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_interval_list_aux_correct<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Collection_Eq">
<div class="head">
<h1>Theory Collection_Eq</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Collection_Eq.thy
    Author:     Andreas Lochbihler, KIT
                René Thiemann, UIBK *)</span>
<span class="keyword1"><span class="command">theory</span></span> Collection_Eq <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Containers_Auxiliary.html">Containers_Auxiliary</a>
  <a href="Containers_Generator.html">Containers_Generator</a>
  <a href="../Deriving/Equality_Instances.html">Deriving.Equality_Instances</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹A type class for optional equality testing›</span></span>

<span class="keyword1"><span class="command">class</span></span> ceq <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">ceq</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> option"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ceq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ceq</span> <span class="main">=</span> Some <span class="free">eq</span> <span class="main">⟹</span> <span class="free">eq</span> <span class="main">=</span> <span class="main">(=)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ceq_equality<span class="main">:</span> <span class="quoted"><span class="quoted">"ceq <span class="main">=</span> Some <span class="free">eq</span> <span class="main">⟹</span> equality <span class="free">eq</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> ceq<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> Equality_Generator.equalityI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ID_ceq<span class="main">:</span> <span class="quoted"><span class="quoted">"ID ceq <span class="main">=</span> Some <span class="free">eq</span> <span class="main">⟹</span> <span class="free">eq</span> <span class="main">=</span> <span class="main">(=)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ID_def id_apply <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ceq<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ceq'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ceq'</span> <span class="main">≡</span> the <span class="main">(</span>ID ceq<span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="quoted">"_CEQ"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"type <span class="main">=&gt;</span> logic"</span></span>  <span class="main">(</span><span class="quoted">"<span class="keyword3">(1</span><span class="keyword1">CEQ</span><span class="keyword3">/</span><span class="keyword3">(1</span><span class="keyword1">'(</span>_<span class="keyword1">')</span><span class="keyword3">)</span><span class="keyword3">)</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">parse_translation</span></span> <span class="quoted">‹
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ceq_tr</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span> <span class="main">=</span>
     <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_constrain"<span class="antiquote">}</span></span> $ Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_syntax</span> "ceq"<span class="antiquote">}</span></span> $
       <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> option<span class="antiquote">}</span></span> $ 
         <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> fun<span class="antiquote">}</span></span> $ <span class="entity">ty</span> $ 
           <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> fun<span class="antiquote">}</span></span> $ <span class="entity">ty</span> $ Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> bool<span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">ceq_tr</span> <span class="entity">ts</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"ceq_tr"</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="main">[</span><span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_CEQ"<span class="antiquote">}</span></span><span class="main">,</span> K <span class="entity">ceq_tr</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">typed_print_translation</span></span> <span class="quoted">‹
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ceq_tr'</span> <span class="entity">ctxt</span>
    <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> option<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> fun<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">ts</span> <span class="main">=</span>
    Term.list_comb <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_CEQ"<span class="antiquote">}</span></span> $ Syntax_Phases.term_of_typ <span class="entity">ctxt</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">ceq_tr'</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Match<span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="main">[</span><span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_syntax</span> ceq<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ceq_tr'</span><span class="main">)</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_ceq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq itself <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_ceq</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟷</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">≠</span> None"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generator for the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span>-class›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This generator registers itself at the derive-manager for the class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
To be more precise, one can choose whether one wants to take <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(=)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as function
for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">ceq</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by passing "eq" as parameter, 
whether equality should not be supported by passing "no" as parameter,
or whether an own definition for equality should be derived by not passing
any parameters. The last possibility only works for datatypes.

\begin{itemize}
\item \texttt{instantiation type :: (type,\ldots,type) (eq) ceq}
\item \texttt{instantiation type :: (type,\ldots,type) (no) ceq}
\item \texttt{instantiation datatype :: (ceq,\ldots,ceq) ceq}
\end{itemize}

If the parameter "no" is not used, then the corresponding
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">is_ceq</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>-theorem is also automatically generated and attributed with 
\texttt{[simp, code-post]}.
›</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This generator can be used for arbitrary types, not just datatypes. 
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> equality_subst<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c1</span> <span class="main">=</span> <span class="free">c2</span> <span class="main">⟹</span> equality <span class="free">c1</span> <span class="main">⟹</span> equality <span class="free">c2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹ceq_generator.ML›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type class instances for HOL types›</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>eq<span class="main">)</span> ceq <span class="quoted">unit</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">CEQ</span><span class="main">(</span>unit<span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ceq_unit_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>eq<span class="main">)</span> ceq
  <span class="quoted">bool</span>
  <span class="quoted">nat</span>
  <span class="quoted">int</span>
  <span class="quoted">Enum.finite_1</span>
  <span class="quoted">Enum.finite_2</span>
  <span class="quoted">Enum.finite_3</span>
  <span class="quoted">Enum.finite_4</span>
  <span class="quoted">Enum.finite_5</span>
  <span class="quoted">integer</span>
  <span class="quoted">natural</span>
  <span class="quoted">char</span>
  <span class="quoted">String.literal</span>
<span class="keyword1"><span class="command">derive</span></span> ceq <span class="quoted">sum</span> <span class="quoted">prod</span> <span class="quoted">list</span> <span class="quoted">option</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>no<span class="main">)</span> ceq <span class="quoted"><span class="quoted">"fun"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_ceq_fun <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_ceq <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_ceq_def ceq_fun_def ID_None<span class="main">)</span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_eq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">set_eq</span> <span class="main">=</span> <span class="main">(=)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_eq_code<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set_eq <span class="free">A</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">⊆</span> <span class="free">B</span> <span class="main">∧</span> <span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(=)</span> <span class="main">=</span> set_eq"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> set_eq_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">ceq</span><span class="main">)</span> <span class="quoted">ceq</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span> set<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> Some set_eq<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ceq_set_def set_eq_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_ceq_set <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_ceq <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟷</span> is_ceq <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ceq<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_ceq_def ceq_set_def ID_None ID_Some <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ID_ceq_set_not_None_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span> set<span class="main">)</span> <span class="main">≠</span> None <span class="main">⟷</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ceq<span class="main">)</span> <span class="main">≠</span> None"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ceq_set_def ID_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Instantiation for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> Predicate.pred"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">eq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">member_pred</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Predicate.pred <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">member_pred</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">eq</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">y</span> <span class="main">∧</span> Predicate.eval <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">member_seq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Predicate.seq <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">member_seq</span> <span class="free"><span class="bound"><span class="entity">xp</span></span></span> <span class="main">=</span> member_pred <span class="main">(</span>Predicate.pred_of_seq <span class="free"><span class="bound"><span class="entity">xp</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> member_seq_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"member_seq seq.Empty <span class="free">x</span> <span class="main">⟷</span> False"</span></span>
  <span class="quoted"><span class="quoted">"member_seq <span class="main">(</span>seq.Insert <span class="free">y</span> <span class="free">P</span><span class="main">)</span> <span class="free">x</span> <span class="main">⟷</span> <span class="free">eq</span> <span class="free">x</span> <span class="free">y</span> <span class="main">∨</span> member_pred <span class="free">P</span> <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"member_seq <span class="main">(</span>seq.Join <span class="free">Q</span> <span class="free">xq</span><span class="main">)</span> <span class="free">x</span> <span class="main">⟷</span> member_pred <span class="free">Q</span> <span class="free">x</span> <span class="main">∨</span> member_seq <span class="free">xq</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> member_seq_def member_pred_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_pred_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"member_pred <span class="main">(</span>Predicate.Seq <span class="free">f</span><span class="main">)</span> <span class="main">=</span> member_seq <span class="main">(</span><span class="free">f</span> <span class="main">()</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> member_seq_def Seq_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">leq_pred</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Predicate.pred <span class="main">⇒</span> <span class="tfree">'a</span> Predicate.pred <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">leq_pred</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> Predicate.eval <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">x</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">eq</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">∧</span> Predicate.eval <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">leq_seq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Predicate.seq <span class="main">⇒</span> <span class="tfree">'a</span> Predicate.pred <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">leq_seq</span> <span class="free"><span class="bound"><span class="entity">xp</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">⟷</span> leq_pred <span class="main">(</span>Predicate.pred_of_seq <span class="free"><span class="bound"><span class="entity">xp</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> leq_seq_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"leq_seq seq.Empty <span class="free">Q</span> <span class="main">⟷</span> True"</span></span>
  <span class="quoted"><span class="quoted">"leq_seq <span class="main">(</span>seq.Insert <span class="free">x</span> <span class="free">P</span><span class="main">)</span> <span class="free">Q</span> <span class="main">⟷</span> member_pred <span class="free">Q</span> <span class="free">x</span> <span class="main">∧</span> leq_pred <span class="free">P</span> <span class="free">Q</span>"</span></span>
  <span class="quoted"><span class="quoted">"leq_seq <span class="main">(</span>seq.Join <span class="free">P</span> <span class="free">xp</span><span class="main">)</span> <span class="free">Q</span> <span class="main">⟷</span> leq_pred <span class="free">P</span> <span class="free">Q</span> <span class="main">∧</span> leq_seq <span class="free">xp</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> leq_seq_def leq_pred_def member_pred_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> leq_pred_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"leq_pred <span class="main">(</span>Predicate.Seq <span class="free">f</span><span class="main">)</span> <span class="free">Q</span> <span class="main">⟷</span> leq_seq <span class="main">(</span><span class="free">f</span> <span class="main">()</span><span class="main">)</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> leq_seq_def Seq_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">predicate_eq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Predicate.pred <span class="main">⇒</span> <span class="tfree">'a</span> Predicate.pred <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">predicate_eq</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">⟷</span> leq_pred <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">∧</span> leq_pred <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">eq</span> <span class="main">=</span> <span class="main">(=)</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> member_pred_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"member_pred <span class="main">=</span> Predicate.eval"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff member_pred_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_seq_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"member_seq <span class="main">=</span> Predicate.member"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> member_seq_def fun_eq_iff eval_member member_pred_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> leq_pred_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"leq_pred <span class="main">=</span> <span class="main">(≤)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff leq_pred_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq less_eq_pred_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> predicate_eq_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"predicate_eq <span class="main">=</span> <span class="main">(=)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> predicate_eq_def fun_eq_iff <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> leq_pred_eq<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Predicate.pred <span class="main">::</span> <span class="main">(</span><span class="quoted">ceq</span><span class="main">)</span> <span class="quoted">ceq</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span> Predicate.pred<span class="main">)</span> <span class="main">=</span> map_option predicate_eq <span class="main">(</span>ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ceq_pred_def predicate_eq_eq <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ID_ceq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/ceq_generator.ML">
<div class="head">
<h1>File ‹ceq_generator.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Author:  René Thiemann, UIBK *)</span>
<span class="comment1">(* This generator was written as part of the IsaFoR/CeTA formalization. *)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CEQ_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>

  <span class="comment1">(* creates a conditional equality by using the equality-functions of the Equality_Generator,
     also is_ceq (a1,..,an)ty = is_ceq a1 ∧ ... ∧ is_ceq an
     is generated. *)</span> 
  <span class="keyword1"><span class="keyword">val</span></span> ceq_instance_via_equality <span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
    
  <span class="comment1">(* creates a conditional equality by implementing it as "Some (op =)". 
     Hence, "is_ceq ty" will always be satisfied. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> ceq_instance_via_eq <span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  
  <span class="comment1">(* derives a trivial instance (None) for class ceq *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> derive_no_ceq <span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Ceq_Generator</span> <span class="main">:</span> <span class="entity">CEQ_GENERATOR</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Generator_Aux
<span class="keyword3"><span class="keyword">open</span></span> Containers_Generator

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ceqS</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">ceq</span><span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ceqN</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> ceq<span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eqT</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ceqT</span> <span class="entity">T</span> <span class="main">=</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> option<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">eqT</span> <span class="entity">T</span><span class="main">]</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ceq_const</span> <span class="entity">T</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">ceqN</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">generator_type</span> <span class="main">=</span> <span class="entity">Equality_Generator.BNF</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_comp</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">Equality_Generator.get_info</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="main">{</span>equality <span class="main">=</span> <span class="entity">e</span><span class="main">,</span> equality_thm <span class="main">=</span> <span class="entity">e_thm</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> fastype_of <span class="entity">e</span> |&gt; strip_type |&gt; fst |&gt; `<span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> - <span class="inner_numeral">2</span><span class="main">)</span> o length<span class="main">)</span> |&gt; uncurry take
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">e</span><span class="main">,</span> <span class="entity">e_thm</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"no equality info for type "</span> ^ quote <span class="entity">tname</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_ID_ceq</span> <span class="entity">eq_var</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty</span> <span class="main">=</span> fastype_of <span class="entity">eq_var</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">oty</span> <span class="main">=</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> option<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ceq</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">ceqN</span><span class="main">,</span> <span class="entity">oty</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ID_cc</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> ID<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">oty</span> --&gt; <span class="entity">oty</span><span class="main">)</span> $ <span class="entity">ceq</span>
  <span class="keyword2"><span class="keyword">in</span></span> 
    <span class="entity">ID_cc</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_ceq_rhs</span> <span class="entity">c</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">mk_Some</span> <span class="entity">c</span>
  <span class="main">|</span> <span class="entity">mk_ceq_rhs</span> <span class="entity">c</span> <span class="main">(</span><span class="entity">T</span> :: <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">ceq_const</span> <span class="entity">T</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ideq</span> <span class="main">=</span> <span class="entity">mk_ID_ceq</span> <span class="entity">eq</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tname</span> <span class="main">=</span> <span class="entity">T</span> |&gt; binder_types |&gt; hd |&gt; dest_TVar |&gt; fst |&gt; fst 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_comp</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"eq_"</span> ^ <span class="entity">tname</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> 
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">caseT</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> case_option<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span> 
          $ Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> None<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span>
          $ lambda <span class="entity">arg_comp</span> <span class="main">(</span><span class="entity">mk_ceq_rhs</span> <span class="main">(</span><span class="entity">c</span> $ <span class="entity">arg_comp</span><span class="main">)</span> <span class="entity">Ts</span><span class="main">)</span>
          $ <span class="entity">ideq</span>
      <span class="keyword2"><span class="keyword">in</span></span> 
        <span class="entity">caseT</span>
      <span class="keyword2"><span class="keyword">end</span></span>

  
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_ceq_def</span> <span class="entity">T</span> <span class="entity">rhs</span> <span class="main">=</span>
  Logic.mk_equals <span class="main">(</span>Const <span class="main">(</span><span class="entity">ceqN</span><span class="main">,</span> <span class="entity">ceqT</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ceq_tac</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="entity">Ts</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">c_thm</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_comp</span> <span class="entity">ctxt</span> <span class="entity">tname</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ID_def id_def<span class="antiquote">}</span></span></span> 
    THEN REPEAT_DETERM_N <span class="main">(</span>length <span class="entity">Ts</span><span class="main">)</span> <span class="main">(</span>
      <span class="entity">Splitter.split_asm_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> option.splits<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span> THEN
      <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> option.simps<span class="antiquote">}</span></span></span><span class="main">)</span> 
    THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> option.simps<span class="antiquote">}</span></span></span> 
    THEN resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> equality_subst<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span> THEN assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span> 
    THEN REPEAT_DETERM <span class="main">(</span>dresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ceq_equality<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">)</span> 
    THEN <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">c_thm</span><span class="main">]</span> THEN_ALL_NEW assume_tac <span class="entity">ctxt</span><span class="main">)</span> <span class="inner_numeral">1</span>
  <span class="keyword2"><span class="keyword">end</span></span>
    
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ceq_instance_via_equality</span> <span class="entity">tname</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">Named_Target.theory_map</span> <span class="main">(</span><span class="entity">Equality_Generator.ensure_info</span> <span class="entity">generator_type</span> <span class="entity">tname</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"deriving \"ceq\" instance for type "</span> ^ quote <span class="entity">tname</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">main_ty</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">ceqS</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">Ts</span><span class="main">,</span> <span class="main">(</span><span class="entity">eq_thm</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tname</span><span class="main">]</span><span class="main">,</span> <span class="entity">xs</span><span class="main">,</span> <span class="entity">ceqS</span><span class="main">)</span> <span class="entity">thy</span>
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_comp</span> <span class="entity">ctxt</span> <span class="entity">tname</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_mapping</span> <span class="main">=</span> <span class="entity">all_tys</span> <span class="entity">c</span> <span class="main">(</span>map TFree <span class="entity">xs</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_def</span> <span class="main">=</span> <span class="entity">mk_ceq_def</span> dummyT <span class="main">(</span><span class="entity">mk_ceq_rhs</span> <span class="entity">c</span> <span class="entity">Ts</span><span class="main">)</span> |&gt; <span class="entity">typ_mapping</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span><span class="entity">Ts</span><span class="main">,</span> <span class="entity">define_overloaded_generic</span>
           <span class="main">(</span><span class="main">(</span>Binding.name <span class="main">(</span><span class="inner_quoted">"ceq_"</span> ^ Long_Name.base_name <span class="entity">tname</span> ^ <span class="inner_quoted">"_def"</span><span class="main">)</span><span class="main">,</span>
            <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
            <span class="entity">eq_def</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
      <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">eq_thm</span><span class="main">]</span>
      THEN resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> equality_imp_eq<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span>
      THEN <span class="entity">ceq_tac</span> <span class="entity">ctxt</span> <span class="entity">tname</span> <span class="entity">Ts</span><span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> <span class="entity">Equality_Generator.get_info</span> <span class="main">(</span><span class="entity">Named_Target.theory_init</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">tname</span> |&gt; the
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">used</span> <span class="main">=</span> <span class="main">#</span>used_positions <span class="entity">info</span>
    
    <span class="comment1">(* is_ceq (a1,..,an)ty = (is_ceq a1 ∧ ... ) -thm *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_is_ceq</span> <span class="entity">ty</span> <span class="main">=</span> <span class="entity">mk_is_c_dots</span> <span class="entity">ty</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> is_ceq<span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">main_is_ceq</span> <span class="main">=</span> <span class="entity">mk_is_ceq</span> <span class="entity">main_ty</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param_tys</span> <span class="main">=</span> dest_Type <span class="entity">main_ty</span> |&gt; snd   
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">filtered_tys</span> <span class="main">=</span> <span class="entity">used</span> ~~ <span class="entity">param_tys</span> |&gt; filter fst |&gt; map snd
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param_is_ceq</span> <span class="main">=</span> map <span class="entity">mk_is_ceq</span> <span class="entity">filtered_tys</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_ceq_thm_trm</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">param_is_ceq</span> <span class="keyword2"><span class="keyword">of</span></span> 
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">main_is_ceq</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">main_is_ceq</span><span class="main">,</span><span class="entity">HOLogic_list_conj</span> <span class="entity">param_is_ceq</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_ceq_thm</span> <span class="main">=</span> Goal.prove <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">is_ceq_thm_trm</span> 
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> prems <span class="main">=</span> <span class="main">_</span><span class="main">}</span> <span class="main">=&gt;</span> 
        <span class="entity">simp_tac</span> <span class="main">(</span><span class="entity">Splitter.add_split</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> option.split<span class="antiquote">}</span></span></span> <span class="entity">ctxt</span> 
          addsimps <span class="main">(</span><span class="entity">eq_thm</span> :: <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ID_Some ID_None is_ceq_def<span class="antiquote">}</span></span></span><span class="main">)</span>
        <span class="main">)</span> <span class="inner_numeral">1</span>
      <span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">register_is_c_dots_lemma</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> is_ceq<span class="antiquote">}</span></span> <span class="main">(</span>Long_Name.base_name <span class="entity">tname</span><span class="main">)</span> 
      <span class="entity">is_ceq_thm</span> <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_some_equality</span> <span class="entity">ty</span> <span class="main">=</span> <span class="entity">mk_Some</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> "HOL.eq"<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">eqT</span> <span class="entity">ty</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ceq_instance_via_eq</span> <span class="entity">tname</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">tname</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"deriving \"ceq\" instance for type "</span> ^ 
      quote <span class="entity">tname</span> ^ <span class="inner_quoted">" via \"=\""</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span><span class="entity">vs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">typ_and_vs_of_typname</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ceq_rhs</span> <span class="main">=</span> <span class="entity">mk_some_equality</span> <span class="entity">ty</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ceq_ty</span> <span class="main">=</span> Term.fastype_of <span class="entity">ceq_rhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ceq_def</span> <span class="main">=</span> <span class="entity">mk_def</span> <span class="entity">ceq_ty</span> <span class="entity">ceqN</span> <span class="entity">ceq_rhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ceq_thm</span><span class="main">,</span><span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">tname</span><span class="main">]</span><span class="main">,</span><span class="entity">vs</span><span class="main">,</span><span class="entity">ceqS</span><span class="main">)</span> <span class="entity">thy</span>
      |&gt; <span class="main">(</span><span class="entity">define_overloaded</span> <span class="main">(</span><span class="inner_quoted">"ceq_"</span> ^ <span class="entity">base_name</span> ^ <span class="inner_quoted">"_def"</span><span class="main">,</span> <span class="entity">ceq_def</span><span class="main">)</span><span class="main">)</span>
     
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> 
      <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> 
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">ceq_thm</span><span class="main">]</span>
      THEN <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> option.simps prod.simps<span class="antiquote">}</span></span></span>
      THEN resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> sym<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span> THEN assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
      <span class="main">)</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">derive_is_c_dots_lemma</span> <span class="entity">ty</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> is_ceq<span class="antiquote">}</span></span> 
      <span class="main">[</span><span class="entity">ceq_thm</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> is_ceq_def<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="entity">base_name</span> <span class="entity">thy</span>

  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_none_ceq</span> <span class="entity">ty</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> None<span class="antiquote">}</span></span><span class="main">,</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> option<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">eqT</span> <span class="entity">ty</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">derive_no_ceq</span> <span class="main">=</span> <span class="entity">derive_none</span> <span class="entity">ceqN</span> <span class="entity">ceqS</span> <span class="entity">mk_none_ceq</span>
  
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ceq_instance</span> <span class="entity">tname</span> <span class="entity">param</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">is_class_instance</span> <span class="entity">thy</span> <span class="entity">tname</span> <span class="entity">ceqS</span>
      <span class="keyword1"><span class="keyword">andalso</span></span> error <span class="main">(</span><span class="inner_quoted">"type "</span> ^ quote <span class="entity">tname</span> ^ <span class="inner_quoted">" is already an instance of class \"ceq\""</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ceq_instance_via_equality</span> <span class="entity">tname</span> <span class="entity">thy</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">"no"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">derive_no_ceq</span> <span class="entity">tname</span> <span class="entity">thy</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">"eq"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ceq_instance_via_eq</span> <span class="entity">tname</span> <span class="entity">thy</span> 
    <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"unknown parameter, supported are (no parameter), \"eq\", and \"no\""</span> 
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup
 <span class="main">(</span><span class="entity">Derive_Manager.register_derive</span> <span class="inner_quoted">"ceq"</span> 
    <span class="inner_quoted">"generate a conditional equality function; options are (), (no), and (eq)"</span> <span class="entity">ceq_instance</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Collection_Enum">
<div class="head">
<h1>Theory Collection_Enum</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Collection_Enum.thy
    Author:     Andreas Lochbihler, KIT
                René Thiemann, UIBK *)</span>

<span class="keyword1"><span class="command">theory</span></span> Collection_Enum <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Containers_Auxiliary.html">Containers_Auxiliary</a>
  <a href="Containers_Generator.html">Containers_Generator</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹A type class for optional enumerations›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definition›</span></span>

<span class="keyword1"><span class="command">class</span></span> cenum <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">cEnum</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> list <span class="main">×</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool<span class="main">)</span><span class="main">)</span> option"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UNIV_cenum<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cEnum</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">enum</span><span class="main">,</span> <span class="free">enum_all</span><span class="main">,</span> <span class="free">enum_ex</span><span class="main">)</span> <span class="main">⟹</span> UNIV <span class="main">=</span> set <span class="free">enum</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> cenum_all_UNIV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cEnum</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">enum</span><span class="main">,</span> <span class="free">enum_all</span><span class="main">,</span> <span class="free">enum_ex</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">enum_all</span> <span class="free">P</span> <span class="main">=</span> Ball UNIV <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> cenum_ex_UNIV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cEnum</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">enum</span><span class="main">,</span> <span class="free">enum_all</span><span class="main">,</span> <span class="free">enum_ex</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">enum_ex</span> <span class="free">P</span> <span class="main">=</span> Bex UNIV <span class="free">P</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ID_cEnum<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ID cEnum <span class="main">=</span> Some <span class="main">(</span><span class="free">enum</span><span class="main">,</span> <span class="free">enum_all</span><span class="main">,</span> <span class="free">enum_ex</span><span class="main">)</span>
  <span class="main">⟹</span> UNIV <span class="main">=</span> set <span class="free">enum</span> <span class="main">∧</span> <span class="free">enum_all</span> <span class="main">=</span> Ball UNIV <span class="main">∧</span> <span class="free">enum_ex</span> <span class="main">=</span> Bex UNIV"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ID_def id_apply fun_eq_iff
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> conjI allI UNIV_cenum cenum_all_UNIV cenum_ex_UNIV fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> in_cenum<span class="main">:</span> <span class="quoted"><span class="quoted">"ID cEnum <span class="main">=</span> Some <span class="main">(</span><span class="free">enum</span><span class="main">,</span> <span class="free">rest</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∈</span> set <span class="free">enum</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">rest</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ID_cEnum<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">cenum</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cenum</span> <span class="main">≡</span> fst <span class="main">(</span>the <span class="main">(</span>ID cEnum<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">cenum_all</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cenum_all</span> <span class="main">≡</span> fst <span class="main">(</span>snd <span class="main">(</span>the <span class="main">(</span>ID cEnum<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">cenum_ex</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cenum_ex</span> <span class="main">≡</span> snd <span class="main">(</span>snd <span class="main">(</span>the <span class="main">(</span>ID cEnum<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="quoted">"_CENUM"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"type <span class="main">=&gt;</span> logic"</span></span>  <span class="main">(</span><span class="quoted">"<span class="keyword3">(1</span><span class="keyword1">CENUM</span><span class="keyword3">/</span><span class="keyword3">(1</span><span class="keyword1">'(</span>_<span class="keyword1">')</span><span class="keyword3">)</span><span class="keyword3">)</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">parse_translation</span></span> <span class="quoted">‹
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cenum_tr</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span> <span class="main">=</span>
     <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_constrain"<span class="antiquote">}</span></span> $ Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_syntax</span> "cEnum"<span class="antiquote">}</span></span> $
       <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> option<span class="antiquote">}</span></span> $ 
         <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> prod<span class="antiquote">}</span></span> $
           <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> list<span class="antiquote">}</span></span> $ <span class="entity">ty</span><span class="main">)</span> $
           <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> prod<span class="antiquote">}</span></span> $
             <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> fun<span class="antiquote">}</span></span> $
               <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> fun<span class="antiquote">}</span></span> $ <span class="entity">ty</span> $ <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> bool<span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span> $
               <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> bool<span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span> $
             <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> fun<span class="antiquote">}</span></span> $
               <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> fun<span class="antiquote">}</span></span> $ <span class="entity">ty</span> $ <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> bool<span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span> $
               <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> bool<span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">cenum_tr</span> <span class="entity">ts</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"cenum_tr"</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="main">[</span><span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_CENUM"<span class="antiquote">}</span></span><span class="main">,</span> K <span class="entity">cenum_tr</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">typed_print_translation</span></span> <span class="quoted">‹
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cenum_tr'</span> <span class="entity">ctxt</span>
    <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> option<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> prod<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> list<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">ts</span> <span class="main">=</span>
    Term.list_comb <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_CENUM"<span class="antiquote">}</span></span> $ Syntax_Phases.term_of_typ <span class="entity">ctxt</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">cenum_tr'</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Match<span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="main">[</span><span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_syntax</span> cEnum<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">cenum_tr'</span><span class="main">)</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generator for the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cenum<span class="antiquote"><span class="antiquote">}</span></span></span></span>-class›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This generator registers itself at the derive-manager for the class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cenum<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
To be more precise, one can currently only choose to not support enumeration 
by passing "no" as parameter.  

\begin{itemize}
\item \texttt{instantiation type :: (type,\ldots,type) (no) cenum}
\end{itemize}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This generator can be used for arbitrary types, not just datatypes. 
›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹cenum_generator.ML›</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Instantiations›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">cenum_all</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">all_n_lists</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> list <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">all_n_lists</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">[]</span> <span class="keyword1">else</span> <span class="free">cenum_all</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">all_n_lists</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span><span class="bound">x</span> <span class="main">#</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">cenum_ex</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ex_n_lists</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> list <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">ex_n_lists</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">[]</span> <span class="keyword1">else</span> <span class="free">cenum_ex</span> <span class="main">(</span><span class="main">%</span><span class="bound">x</span><span class="main">.</span> <span class="free">ex_n_lists</span> <span class="main">(</span><span class="main">%</span><span class="bound">xs</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span><span class="bound">x</span> <span class="main">#</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> all_n_lists_iff<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">cenum</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"all_n_lists <span class="main">(</span>Ball <span class="main">(</span>set <span class="free">cenum</span><span class="main">)</span><span class="main">)</span> <span class="free">P</span> <span class="free">n</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">xs</span> <span class="main">∈</span> set <span class="main">(</span>List.n_lists <span class="free">n</span> <span class="free">cenum</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> all_n_lists.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">P</span> <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> all_n_lists.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n'</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"1"</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> all_n_lists.simps<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ex_n_lists_iff<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">cenum</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"ex_n_lists <span class="main">(</span>Bex <span class="main">(</span>set <span class="free">cenum</span><span class="main">)</span><span class="main">)</span> <span class="free">P</span> <span class="free">n</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">xs</span> <span class="main">∈</span> set <span class="main">(</span>List.n_lists <span class="free">n</span> <span class="free">cenum</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ex_n_lists.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">P</span> <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ex_n_lists.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n'</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"1"</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> ex_n_lists.simps<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> <span class="quoted">"fun"</span> <span class="main">::</span> <span class="main">(</span><span class="quoted">cenum</span><span class="main">,</span> <span class="quoted">cenum</span><span class="main">)</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> 
  <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">enum_a</span><span class="main">,</span> <span class="bound">enum_all_a</span><span class="main">,</span> <span class="bound">enum_ex_a</span><span class="main">)</span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">enum_b</span><span class="main">,</span> <span class="bound">enum_all_b</span><span class="main">,</span> <span class="bound">enum_ex_b</span><span class="main">)</span> <span class="main">⇒</span> Some 
       <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> the <span class="keyword1">o</span> map_of <span class="main">(</span>zip <span class="bound">enum_a</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>List.n_lists <span class="main">(</span>length <span class="bound">enum_a</span><span class="main">)</span> <span class="bound">enum_b</span><span class="main">)</span><span class="main">,</span>
        <span class="main">λ</span><span class="bound">P</span><span class="main">.</span> all_n_lists <span class="bound">enum_all_b</span> <span class="main">(</span><span class="main">λ</span><span class="bound">bs</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span>the <span class="keyword1">o</span> map_of <span class="main">(</span>zip <span class="bound">enum_a</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>length <span class="bound">enum_a</span><span class="main">)</span><span class="main">,</span>
        <span class="main">λ</span><span class="bound">P</span><span class="main">.</span> ex_n_lists <span class="bound">enum_ex_b</span> <span class="main">(</span><span class="main">λ</span><span class="bound">bs</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span>the <span class="keyword1">o</span> map_of <span class="main">(</span>zip <span class="bound">enum_a</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>length <span class="bound">enum_a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">enum</span> <span class="skolem">enum_all</span> <span class="skolem">enum_ex</span> <span class="skolem">P</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">enum</span><span class="main">,</span> <span class="skolem">enum_all</span><span class="main">,</span> <span class="skolem">enum_ex</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">enum_a</span></span> <span class="skolem"><span class="skolem">enum_all_a</span></span> <span class="skolem"><span class="skolem">enum_ex_a</span></span> <span class="skolem"><span class="skolem">enum_b</span></span> <span class="skolem"><span class="skolem">enum_all_b</span></span> <span class="skolem"><span class="skolem">enum_ex_b</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">enum_a</span><span class="main">,</span> <span class="skolem">enum_all_a</span><span class="main">,</span> <span class="skolem">enum_ex_a</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">enum_b</span><span class="main">,</span> <span class="skolem">enum_all_b</span><span class="main">,</span> <span class="skolem">enum_ex_b</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> enum<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">enum</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> the <span class="keyword1">o</span> map_of <span class="main">(</span>zip <span class="skolem">enum_a</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>List.n_lists <span class="main">(</span>length <span class="skolem">enum_a</span><span class="main">)</span> <span class="skolem">enum_b</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> enum_all<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">enum_all</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">P</span><span class="main">.</span> all_n_lists <span class="skolem">enum_all_b</span> <span class="main">(</span><span class="main">λ</span><span class="bound">bs</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span>the <span class="keyword1">o</span> map_of <span class="main">(</span>zip <span class="skolem">enum_a</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>length <span class="skolem">enum_a</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> enum_ex<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">enum_ex</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">P</span><span class="main">.</span> ex_n_lists <span class="skolem">enum_ex_b</span> <span class="main">(</span><span class="main">λ</span><span class="bound">bs</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span>the <span class="keyword1">o</span> map_of <span class="main">(</span>zip <span class="skolem">enum_a</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>length <span class="skolem">enum_a</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_fun_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"UNIV <span class="main">=</span> set <span class="skolem">enum</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> UNIV_eq_I<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">=</span> the <span class="main">∘</span> map_of <span class="main">(</span>zip <span class="skolem">enum_a</span> <span class="main">(</span>map <span class="skolem">f</span> <span class="skolem">enum_a</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_of_zip_map fun_eq_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> in_cenum<span class="main"><span class="main">[</span></span><span class="operator">OF</span> a<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">∈</span> set <span class="skolem">enum</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enum set_n_lists <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> in_cenum<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">enum_all</span> <span class="skolem">P</span> <span class="main">=</span> Ball UNIV <span class="skolem">P</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">enum_all</span> <span class="skolem">P</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Ball UNIV <span class="skolem">P</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">=</span> the <span class="main">∘</span> map_of <span class="main">(</span>zip <span class="main">(</span><span class="skolem">enum_a</span><span class="main">)</span> <span class="main">(</span>map <span class="skolem">f</span> <span class="skolem">enum_a</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_of_zip_map fun_eq_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> in_cenum<span class="main"><span class="main">[</span></span><span class="operator">OF</span> a<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">enum_all</span> <span class="skolem">P</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="main">(</span>the <span class="main">∘</span> map_of <span class="main">(</span>zip <span class="skolem">enum_a</span> <span class="main">(</span>map <span class="skolem">f</span> <span class="skolem">enum_a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enum_all ID_cEnum<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b<span class="main"><span class="main">]</span></span> all_n_lists_iff set_n_lists<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> allE<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> mp<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_cenum<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">with</span></span> f <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Ball UNIV <span class="skolem">P</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> this <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">enum_all</span> <span class="skolem">P</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enum_all ID_cEnum<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b<span class="main"><span class="main">]</span></span> all_n_lists_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">enum_ex</span> <span class="skolem">P</span> <span class="main">=</span> Bex UNIV <span class="skolem">P</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">enum_ex</span> <span class="skolem">P</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> this <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Bex UNIV <span class="skolem">P</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enum_ex ID_cEnum<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b<span class="main"><span class="main">]</span></span> ex_n_lists_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Bex UNIV <span class="skolem">P</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> this <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">=</span> the <span class="main">∘</span> map_of <span class="main">(</span>zip <span class="main">(</span><span class="skolem">enum_a</span><span class="main">)</span> <span class="main">(</span>map <span class="skolem">f</span> <span class="skolem">enum_a</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_of_zip_map fun_eq_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> in_cenum<span class="main"><span class="main">[</span></span><span class="operator">OF</span> a<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">enum_ex</span> <span class="skolem">P</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> enum_ex ID_cEnum<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b<span class="main"><span class="main">]</span></span> ex_n_lists_iff o_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> bexI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_n_lists <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> in_cenum<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">cenum</span><span class="main">)</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span> set<span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">enum_a</span><span class="main">,</span> <span class="bound">enum_all_a</span><span class="main">,</span> <span class="bound">enum_ex_a</span><span class="main">)</span> <span class="main">⇒</span> Some 
    <span class="main">(</span>map set <span class="main">(</span>subseqs <span class="bound">enum_a</span><span class="main">)</span><span class="main">,</span>
     <span class="main">λ</span><span class="bound">P</span><span class="main">.</span> list_all <span class="bound">P</span> <span class="main">(</span>map set <span class="main">(</span>subseqs <span class="bound">enum_a</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
     <span class="main">λ</span><span class="bound">P</span><span class="main">.</span> list_ex <span class="bound">P</span> <span class="main">(</span>map set <span class="main">(</span>subseqs <span class="bound">enum_a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_set_def subseqs_powset list_ex_iff list_all_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ID_cEnum<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> unit <span class="main">::</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span>unit<span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>enum_class.enum<span class="main">,</span> enum_class.enum_all<span class="main">,</span> enum_class.enum_ex<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_unit_def enum_UNIV enum_all_UNIV enum_ex_UNIV<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> bool <span class="main">::</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span>bool<span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>enum_class.enum<span class="main">,</span> enum_class.enum_all<span class="main">,</span> enum_class.enum_ex<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_bool_def enum_UNIV enum_all_UNIV enum_ex_UNIV<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="main">::</span> <span class="main">(</span><span class="quoted">cenum</span><span class="main">,</span> <span class="quoted">cenum</span><span class="main">)</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> 
  <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">enum_a</span><span class="main">,</span> <span class="bound">enum_all_a</span><span class="main">,</span> <span class="bound">enum_ex_a</span><span class="main">)</span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">enum_b</span><span class="main">,</span> <span class="bound">enum_all_b</span><span class="main">,</span> <span class="bound">enum_ex_b</span><span class="main">)</span> <span class="main">⇒</span> Some 
       <span class="main">(</span>List.product <span class="bound">enum_a</span> <span class="bound">enum_b</span><span class="main">,</span>
        <span class="main">λ</span><span class="bound">P</span><span class="main">.</span> <span class="bound">enum_all_a</span> <span class="main">(</span><span class="main">%</span><span class="bound">x</span><span class="main">.</span> <span class="bound">enum_all_b</span> <span class="main">(</span><span class="main">%</span><span class="bound">y</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
        <span class="main">λ</span><span class="bound">P</span><span class="main">.</span> <span class="bound">enum_ex_a</span> <span class="main">(</span><span class="main">%</span><span class="bound">x</span><span class="main">.</span> <span class="bound">enum_ex_b</span> <span class="main">(</span><span class="main">%</span><span class="bound">y</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_prod_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ID_cEnum<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted">cenum</span><span class="main">,</span> <span class="quoted">cenum</span><span class="main">)</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> 
  <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">enum_a</span><span class="main">,</span> <span class="bound">enum_all_a</span><span class="main">,</span> <span class="bound">enum_ex_a</span><span class="main">)</span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">enum_b</span><span class="main">,</span> <span class="bound">enum_all_b</span><span class="main">,</span> <span class="bound">enum_ex_b</span><span class="main">)</span> <span class="main">⇒</span> Some 
       <span class="main">(</span>map Inl <span class="bound">enum_a</span> <span class="main">@</span> map Inr <span class="bound">enum_b</span><span class="main">,</span>
        <span class="main">λ</span><span class="bound">P</span><span class="main">.</span> <span class="bound">enum_all_a</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span>Inl <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">enum_all_b</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span>Inr <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
        <span class="main">λ</span><span class="bound">P</span><span class="main">.</span> <span class="bound">enum_ex_a</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span>Inl <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">enum_ex_b</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span>Inr <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_sum_def UNIV_sum <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ID_cEnum<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> option <span class="main">::</span> <span class="main">(</span><span class="quoted">cenum</span><span class="main">)</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span> option<span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">enum_a</span><span class="main">,</span> <span class="bound">enum_all_a</span><span class="main">,</span> <span class="bound">enum_ex_a</span><span class="main">)</span> <span class="main">⇒</span> Some 
    <span class="main">(</span>None <span class="main">#</span> map Some <span class="bound">enum_a</span><span class="main">,</span>
     <span class="main">λ</span><span class="bound">P</span><span class="main">.</span> <span class="bound">P</span> None <span class="main">∧</span> <span class="bound">enum_all_a</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
     <span class="main">λ</span><span class="bound">P</span><span class="main">.</span> <span class="bound">P</span> None <span class="main">∨</span> <span class="bound">enum_ex_a</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">P</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_option_def UNIV_option_conv <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ID_cEnum<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_1 <span class="main">::</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span>Enum.finite_1<span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>enum_class.enum<span class="main">,</span> enum_class.enum_all<span class="main">,</span> enum_class.enum_ex<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_finite_1_def enum_UNIV enum_all_UNIV enum_ex_UNIV<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_2 <span class="main">::</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span>Enum.finite_2<span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>enum_class.enum<span class="main">,</span> enum_class.enum_all<span class="main">,</span> enum_class.enum_ex<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_finite_2_def enum_UNIV enum_all_UNIV enum_ex_UNIV<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_3 <span class="main">::</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span>Enum.finite_3<span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>enum_class.enum<span class="main">,</span> enum_class.enum_all<span class="main">,</span> enum_class.enum_ex<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_finite_3_def enum_UNIV enum_all_UNIV enum_ex_UNIV<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_4 <span class="main">::</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span>Enum.finite_4<span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>enum_class.enum<span class="main">,</span> enum_class.enum_all<span class="main">,</span> enum_class.enum_ex<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_finite_4_def enum_UNIV enum_all_UNIV enum_ex_UNIV<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Enum.finite_5 <span class="main">::</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span>Enum.finite_5<span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>enum_class.enum<span class="main">,</span> enum_class.enum_all<span class="main">,</span> enum_class.enum_ex<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_finite_5_def enum_UNIV enum_all_UNIV enum_ex_UNIV<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> char <span class="main">::</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span>char<span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>enum_class.enum<span class="main">,</span> enum_class.enum_all<span class="main">,</span> enum_class.enum_ex<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_char_def enum_UNIV enum_all_UNIV enum_ex_UNIV<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>no<span class="main">)</span> cenum <span class="quoted">list</span> <span class="quoted">nat</span> <span class="quoted">int</span> <span class="quoted">integer</span> <span class="quoted">natural</span> <span class="quoted">String.literal</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/cenum_generator.ML">
<div class="head">
<h1>File ‹cenum_generator.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Author:  René Thiemann, UIBK *)</span>
<span class="comment1">(* This generator was written as part of the IsaFoR/CeTA formalization. *)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CENUM_GENERATOR</span> <span class="main">=</span> 
<span class="keyword2"><span class="keyword">sig</span></span> 
  
  <span class="comment1">(* derives a trivial instance (None) for class enum and any type *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> derive_no_cenum <span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Cenum_Generator</span> <span class="main">:</span> <span class="entity">CENUM_GENERATOR</span> <span class="main">=</span> 
<span class="keyword2"><span class="keyword">struct</span></span>
<span class="keyword3"><span class="keyword">open</span></span> Containers_Generator<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_none_cenum</span> <span class="entity">ty</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> 
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lty</span> <span class="main">=</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> list<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fty</span> <span class="main">=</span> <span class="main">(</span><span class="entity">ty</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">oty</span> <span class="main">=</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> option<span class="antiquote">}</span></span><span class="main">,</span><span class="main">[</span>
      Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> prod<span class="antiquote">}</span></span><span class="main">,</span><span class="main">[</span><span class="entity">lty</span><span class="main">,</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> prod<span class="antiquote">}</span></span><span class="main">,</span><span class="main">[</span><span class="entity">fty</span><span class="main">,</span><span class="entity">fty</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> None<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">oty</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">res</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">derive_no_cenum</span> <span class="main">=</span> 
  <span class="entity">derive_none</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> cEnum<span class="antiquote">}</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">cenum</span><span class="antiquote">}</span></span> <span class="entity">mk_none_cenum</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">derive_cenum</span> <span class="entity">typ_name</span> <span class="entity">param</span> <span class="entity">thy</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">(</span><span class="entity">param</span> <span class="main">=</span> <span class="inner_quoted">"no"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> false <span class="keyword2"><span class="keyword">else</span></span>  
      error <span class="inner_quoted">"currently only parameter 'no' is accepted for class cenum"</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">derive_no_cenum</span> <span class="entity">typ_name</span> <span class="entity">thy</span> 
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup  
  <span class="main">(</span><span class="entity">Derive_Manager.register_derive</span> <span class="inner_quoted">"cenum"</span> <span class="inner_quoted">"use (no) enumeration for class cenum"</span> <span class="entity">derive_cenum</span><span class="main">)</span> 
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Equal">
<div class="head">
<h1>Theory Equal</h1>
</div>
<pre class="source"><span class="comment1">(* Title:  Containers/Equal.thy
   Author: Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> Equal <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Locales to abstract over HOL equality›</span></span>

<span class="keyword1"><span class="command">locale</span></span> equal_base <span class="main">=</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">equal</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>

<span class="keyword1"><span class="command">locale</span></span> equal <span class="main">=</span> equal_base <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> equal_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">equal</span> <span class="main">=</span> <span class="main">(=)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> equal_conv_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">equal</span> <span class="free">x</span> <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_eq<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="RBT_ext">
<div class="head">
<h1>Theory RBT_ext</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/RBT_ext.thy
    Author:     Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> RBT_ext
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/RBT_Impl.html">HOL-Library.RBT_Impl</a>"</span>
  <a href="Containers_Auxiliary.html">Containers_Auxiliary</a>
  <a href="List_Fusion.html">List_Fusion</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹More on red-black trees›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹More lemmas›</span></span>

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_rbt_fold_rbt_insert_impl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_rbt <span class="free">t</span> <span class="main">⟹</span> is_rbt <span class="main">(</span>RBT_Impl.fold rbt_insert <span class="free">t'</span> <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rbt_insert_def is_rbt_fold_rbt_insertwk<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rbt_sorted_fold_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_sorted <span class="free">t</span> <span class="main">⟹</span> rbt_sorted <span class="main">(</span>RBT_Impl.fold rbt_insert <span class="free">t'</span> <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t'</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rbt_insert_rbt_sorted<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rbt_lookup_rbt_insert'<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_sorted <span class="free">t</span> <span class="main">⟹</span> rbt_lookup <span class="main">(</span>rbt_insert <span class="free">k</span> <span class="free">v</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> rbt_lookup <span class="free">t</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rbt_insert_def rbt_lookup_rbt_insertwk fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rbt_lookup_fold_rbt_insert_impl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"rbt_sorted <span class="free">t2</span> <span class="main">⟹</span> 
  rbt_lookup <span class="main">(</span>RBT_Impl.fold rbt_insert <span class="free">t1</span> <span class="free">t2</span><span class="main">)</span> <span class="main">=</span> rbt_lookup <span class="free">t2</span> <span class="main">++</span> map_of <span class="main">(</span>rev <span class="main">(</span>RBT_Impl.entries <span class="free">t1</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t1</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t2</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Empty <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Branch <span class="skolem">c</span> <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">k</span> <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> Branch.prems
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_add_def Branch.IH rbt_insert_rbt_sorted rbt_sorted_fold_insert rbt_lookup_rbt_insert' fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Build the cross product of two RBTs›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'e</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alist_product</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">×</span> <span class="tfree">'d</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'e</span><span class="main">)</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">alist_product</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> alist_product_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"alist_product <span class="main">[]</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="quoted"><span class="quoted">"alist_product <span class="free">xs</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="quoted"><span class="quoted">"alist_product <span class="main">(</span><span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="free">a</span> <span class="free">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span> <span class="main">@</span> alist_product <span class="free">xs</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alist_product_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> append_alist_product_conv_fold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">zs</span> <span class="main">@</span> alist_product <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> rev <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span> <span class="bound">rest</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span> <span class="main">#</span> <span class="bound">rest</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="free">xs</span> <span class="main">(</span>rev <span class="free">zs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">zs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">zs</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(#)</span> <span class="main">(</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span> <span class="bound">zs</span> <span class="main">=</span>
    rev <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="main">@</span> <span class="bound">zs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> Cons.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">zs</span> <span class="main">@</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span>"</span></span><span class="main">]</span> x
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> alist_product_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"alist_product <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span>
  rev <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span> <span class="bound">rest</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span> <span class="main">#</span> <span class="bound">rest</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="free">xs</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> append_alist_product_conv_fold<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> set_alist_product<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>alist_product <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span>set <span class="free">xs</span> <span class="main">×</span> set <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alist_product_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI rev_bexI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_alist_product<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> distinct <span class="main">(</span>map fst <span class="free">xs</span><span class="main">)</span><span class="main">;</span> distinct <span class="main">(</span>map fst <span class="free">ys</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> distinct <span class="main">(</span>map fst <span class="main">(</span>alist_product <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map <span class="main">(</span>fst <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span>map fst <span class="free">ys</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> Cons x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_alist_product <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_alist_product<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>alist_product <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> map_of <span class="free">xs</span> <span class="free">a</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None
   <span class="main">|</span> Some <span class="bound">b</span> <span class="main">⇒</span> map_option <span class="main">(</span><span class="free">f</span> <span class="free">a</span> <span class="bound">b</span> <span class="free">c</span><span class="main">)</span> <span class="main">(</span>map_of <span class="free">ys</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?map</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of <span class="var">?map</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> map_option <span class="main">(</span><span class="free">f</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="free">c</span><span class="main">)</span> <span class="main">(</span>map_of <span class="free">ys</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a'</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a'</span> <span class="main">≠</span> <span class="skolem">a</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"map_of <span class="var">?map</span> <span class="main">(</span><span class="skolem">a'</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> None"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> x Cons.IH
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_add_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rbt_product</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'e</span><span class="main">)</span> rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_product</span> <span class="free"><span class="bound"><span class="entity">rbt1</span></span></span> <span class="free"><span class="bound"><span class="entity">rbt2</span></span></span> <span class="main">=</span> rbtreeify <span class="main">(</span>alist_product <span class="main">(</span>RBT_Impl.entries <span class="free"><span class="bound"><span class="entity">rbt1</span></span></span><span class="main">)</span> <span class="main">(</span>RBT_Impl.entries <span class="free"><span class="bound"><span class="entity">rbt2</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rbt_product_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rbt_product <span class="free">rbt1</span> <span class="free">rbt2</span> <span class="main">=</span>
   rbtreeify <span class="main">(</span>rev <span class="main">(</span>RBT_Impl.fold <span class="main">(</span><span class="main">λ</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> RBT_Impl.fold <span class="main">(</span><span class="main">λ</span><span class="bound">c</span> <span class="bound">d</span> <span class="bound">rest</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span> <span class="main">#</span> <span class="bound">rest</span><span class="main">)</span> <span class="free">rbt2</span><span class="main">)</span> <span class="free">rbt1</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> rbt_product_def alist_product_code RBT_Impl.fold_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">leq_a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑<span class="hidden">⇩</span><sub>a</sub></span>"</span> 50<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">less_a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏<span class="hidden">⇩</span><sub>a</sub></span>"</span> 50<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">leq_b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑<span class="hidden">⇩</span><sub>b</sub></span>"</span> 50<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">less_b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏<span class="hidden">⇩</span><sub>b</sub></span>"</span> 50<span class="main">)</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> lin_a<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder <span class="free">leq_a</span> <span class="free">less_a</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> lin_b<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder <span class="free">leq_b</span> <span class="free">less_b</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">less_eq_prod'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">less_eq_prod'</span> <span class="main">≡</span> less_eq_prod <span class="free">leq_a</span> <span class="free">less_a</span> <span class="free">leq_b</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">less_prod'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊏</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">less_prod'</span> <span class="main">≡</span> less_prod <span class="free">leq_a</span> <span class="free">less_a</span> <span class="free">less_b</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> linorder_prod <span class="main">=</span> linorder_prod<span class="main">[</span><span class="operator">OF</span> lin_a lin_b<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_alist_product<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"linorder.sorted <span class="free">leq_a</span> <span class="main">(</span>map fst <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"linorder.sorted <span class="keyword1"><span class="free">(⊑<span class="hidden">⇩</span><sub>b</sub>)</span></span> <span class="main">(</span>map fst <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"linorder.sorted <span class="main">(⊑)</span> <span class="main">(</span>map fst <span class="main">(</span>alist_product <span class="free">f</span> <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> a<span class="main">:</span> linorder <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">(⊑<span class="hidden">⇩</span><sub>a</sub>)</span></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">(⊏<span class="hidden">⇩</span><sub>a</sub>)</span></span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> lin_a<span class="main">)</span>

  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> 
    linorder.sorted.simps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> linorder_prod<span class="main">]</span> linorder.sorted.simps<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> linorder_prod<span class="main">]</span>
    linorder.sorted_append<span class="main">[</span><span class="operator">OF</span> linorder_prod<span class="main">]</span>
    linorder.sorted.simps<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> lin_b<span class="main">]</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> xs
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"linorder.sorted <span class="main">(⊑)</span> <span class="main">(</span>map fst <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ys <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> x Cons
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_alist_product a.not_less <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> bspec a.antisym <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_rbt_rbt_product<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ord.is_rbt <span class="keyword1"><span class="free">(⊏<span class="hidden">⇩</span><sub>a</sub>)</span></span> <span class="free">rbt1</span><span class="main">;</span> ord.is_rbt <span class="keyword1"><span class="free">(⊏<span class="hidden">⇩</span><sub>b</sub>)</span></span> <span class="free">rbt2</span> <span class="main">⟧</span>
  <span class="main">⟹</span> ord.is_rbt <span class="main">(⊏)</span> <span class="main">(</span>rbt_product <span class="free">f</span> <span class="free">rbt1</span> <span class="free">rbt2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> rbt_product_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> linorder.is_rbt_rbtreeify<span class="main"><span class="main">[</span></span><span class="operator">OF</span> linorder_prod<span class="main"><span class="main">]</span></span> sorted_alist_product linorder.rbt_sorted_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lin_a<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted linorder.distinct_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lin_a<span class="main"><span class="main">]</span></span> linorder.rbt_sorted_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lin_b<span class="main"><span class="main">]</span></span> distinct_alist_product linorder.distinct_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lin_b<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rbt_lookup_rbt_product<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ord.is_rbt <span class="keyword1"><span class="free">(⊏<span class="hidden">⇩</span><sub>a</sub>)</span></span> <span class="free">rbt1</span><span class="main">;</span> ord.is_rbt <span class="keyword1"><span class="free">(⊏<span class="hidden">⇩</span><sub>b</sub>)</span></span> <span class="free">rbt2</span> <span class="main">⟧</span>
  <span class="main">⟹</span> ord.rbt_lookup <span class="main">(⊏)</span> <span class="main">(</span>rbt_product <span class="free">f</span> <span class="free">rbt1</span> <span class="free">rbt2</span><span class="main">)</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword1">case</span> ord.rbt_lookup <span class="keyword1"><span class="free">(⊏<span class="hidden">⇩</span><sub>a</sub>)</span></span> <span class="free">rbt1</span> <span class="free">a</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None
      <span class="main">|</span> Some <span class="bound">b</span> <span class="main">⇒</span> map_option <span class="main">(</span><span class="free">f</span> <span class="free">a</span> <span class="bound">b</span> <span class="free">c</span><span class="main">)</span> <span class="main">(</span>ord.rbt_lookup <span class="keyword1"><span class="free">(⊏<span class="hidden">⇩</span><sub>b</sub>)</span></span> <span class="free">rbt2</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rbt_product_def linorder.rbt_lookup_rbtreeify<span class="main"><span class="main">[</span></span><span class="operator">OF</span> linorder_prod<span class="main"><span class="main">]</span></span> linorder.is_rbt_rbtreeify<span class="main"><span class="main">[</span></span><span class="operator">OF</span> linorder_prod<span class="main"><span class="main">]</span></span> sorted_alist_product linorder.rbt_sorted_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lin_a<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted linorder.distinct_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lin_a<span class="main"><span class="main">]</span></span> linorder.rbt_sorted_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lin_b<span class="main"><span class="main">]</span></span> distinct_alist_product linorder.distinct_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lin_b<span class="main"><span class="main">]</span></span> map_of_alist_product linorder.map_of_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lin_a<span class="main"><span class="main">]</span></span> linorder.map_of_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lin_b<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> less_eq_prod' less_prod'

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Build an RBT where keys are paired with themselves›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">RBT_Impl_diag</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">RBT_Impl_diag</span> rbt.Empty <span class="main">=</span> rbt.Empty"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">RBT_Impl_diag</span> <span class="main">(</span>rbt.Branch <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> rbt.Branch <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">(</span><span class="free">RBT_Impl_diag</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="free">RBT_Impl_diag</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> entries_RBT_Impl_diag<span class="main">:</span>
  <span class="quoted"><span class="quoted">"RBT_Impl.entries <span class="main">(</span>RBT_Impl_diag <span class="free">t</span><span class="main">)</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">k</span><span class="main">)</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>RBT_Impl.entries <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> keys_RBT_Impl_diag<span class="main">:</span>
  <span class="quoted"><span class="quoted">"RBT_Impl.keys <span class="main">(</span>RBT_Impl_diag <span class="free">t</span><span class="main">)</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>RBT_Impl.keys <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_Impl.keys_def entries_RBT_Impl_diag split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rbt_sorted_RBT_Impl_diag<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ord.rbt_sorted <span class="free">lt</span> <span class="free">t</span> <span class="main">⟹</span> ord.rbt_sorted <span class="main">(</span>less_prod <span class="free">leq</span> <span class="free">lt</span> <span class="free">lt</span><span class="main">)</span> <span class="main">(</span>RBT_Impl_diag <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord.rbt_sorted.simps ord.rbt_less_prop ord.rbt_greater_prop keys_RBT_Impl_diag<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bheight_RBT_Impl_diag<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bheight <span class="main">(</span>RBT_Impl_diag <span class="free">t</span><span class="main">)</span> <span class="main">=</span> bheight <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> inv_RBT_Impl_diag<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"inv1 <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"inv2 <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inv1 <span class="main">(</span>RBT_Impl_diag <span class="free">t</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"inv2 <span class="main">(</span>RBT_Impl_diag <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"color_of <span class="free">t</span> <span class="main">=</span> color.B <span class="main">⟹</span> color_of <span class="main">(</span>RBT_Impl_diag <span class="free">t</span><span class="main">)</span> <span class="main">=</span> color.B"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bheight_RBT_Impl_diag<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> is_rbt_RBT_Impl_diag<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ord.is_rbt <span class="free">lt</span> <span class="free">t</span> <span class="main">⟹</span> ord.is_rbt <span class="main">(</span>less_prod <span class="free">leq</span> <span class="free">lt</span> <span class="free">lt</span><span class="main">)</span> <span class="main">(</span>RBT_Impl_diag <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord.is_rbt_def rbt_sorted_RBT_Impl_diag inv_RBT_Impl_diag<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> linorder<span class="main">)</span> rbt_lookup_RBT_Impl_diag<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ord.rbt_lookup <span class="main">(</span>less_prod <span class="main">(≤)</span> <span class="main">(&lt;)</span> <span class="main">(&lt;)</span><span class="main">)</span> <span class="main">(</span>RBT_Impl_diag <span class="free">t</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">k'</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">k</span> <span class="main">=</span> <span class="bound">k'</span> <span class="keyword1">then</span> ord.rbt_lookup <span class="main">(&lt;)</span> <span class="free">t</span> <span class="bound">k</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord.rbt_lookup.simps fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Folding and quantifiers over RBTs›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">RBT_Impl_fold1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> unit<span class="main">)</span> RBT_Impl.rbt <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">RBT_Impl_fold1</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">rbt</span></span></span> <span class="main">=</span> fold <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>tl <span class="main">(</span>RBT_Impl.keys <span class="free"><span class="bound"><span class="entity">rbt</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>RBT_Impl.keys <span class="free"><span class="bound"><span class="entity">rbt</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> RBT_Impl_fold1_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"RBT_Impl_fold1 <span class="free">f</span> rbt.Empty <span class="main">=</span> undefined"</span></span>
  <span class="quoted"><span class="quoted">"RBT_Impl_fold1 <span class="free">f</span> <span class="main">(</span>Branch <span class="free">c</span> rbt.Empty <span class="free">k</span> <span class="free">v</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> RBT_Impl.fold <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">v</span><span class="main">.</span> <span class="free">f</span> <span class="bound">k</span><span class="main">)</span> <span class="free">r</span> <span class="free">k</span>"</span></span>
  <span class="quoted"><span class="quoted">"RBT_Impl_fold1 <span class="free">f</span> <span class="main">(</span>Branch <span class="free">c</span> <span class="main">(</span>Branch <span class="free">c'</span> <span class="free">l'</span> <span class="free">k'</span> <span class="free">v'</span> <span class="free">r'</span><span class="main">)</span> <span class="free">k</span> <span class="free">v</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> 
   RBT_Impl.fold <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">v</span><span class="main">.</span> <span class="free">f</span> <span class="bound">k</span><span class="main">)</span> <span class="free">r</span> <span class="main">(</span><span class="free">f</span> <span class="free">k</span> <span class="main">(</span>RBT_Impl_fold1 <span class="free">f</span> <span class="main">(</span>Branch <span class="free">c'</span> <span class="free">l'</span> <span class="free">k'</span> <span class="free">v'</span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_Impl_fold1_def RBT_Impl.keys_def fold_map RBT_Impl.fold_def split_def o_def tl_append hd_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.split<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">RBT_Impl_rbt_all</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">RBT_Impl_rbt_all</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">rbt</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>RBT_Impl.entries <span class="free"><span class="bound"><span class="entity">rbt</span></span></span><span class="main">)</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">k</span> <span class="bound">v</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> RBT_Impl_rbt_all_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"RBT_Impl_rbt_all <span class="free">P</span> rbt.Empty <span class="main">⟷</span> True"</span></span>
  <span class="quoted"><span class="quoted">"RBT_Impl_rbt_all <span class="free">P</span> <span class="main">(</span>Branch <span class="free">c</span> <span class="free">l</span> <span class="free">k</span> <span class="free">v</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">P</span> <span class="free">k</span> <span class="free">v</span> <span class="main">∧</span> RBT_Impl_rbt_all <span class="free">P</span> <span class="free">l</span> <span class="main">∧</span> RBT_Impl_rbt_all <span class="free">P</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_Impl_rbt_all_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">RBT_Impl_rbt_ex</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">RBT_Impl_rbt_ex</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">rbt</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span>RBT_Impl.entries <span class="free"><span class="bound"><span class="entity">rbt</span></span></span><span class="main">)</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">k</span> <span class="bound">v</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> RBT_Impl_rbt_ex_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"RBT_Impl_rbt_ex <span class="free">P</span> rbt.Empty <span class="main">⟷</span> False"</span></span>
  <span class="quoted"><span class="quoted">"RBT_Impl_rbt_ex <span class="free">P</span> <span class="main">(</span>Branch <span class="free">c</span> <span class="free">l</span> <span class="free">k</span> <span class="free">v</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">P</span> <span class="free">k</span> <span class="free">v</span> <span class="main">∨</span> RBT_Impl_rbt_ex <span class="free">P</span> <span class="free">l</span> <span class="main">∨</span> RBT_Impl_rbt_ex <span class="free">P</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_Impl_rbt_ex_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹List fusion for RBTs›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> rbt_generator_state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> RBT_Impl.rbt<span class="main">)</span> list <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> RBT_Impl.rbt"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">rbt_has_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> rbt_generator_state <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_has_next</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span> rbt.Empty<span class="main">)</span> <span class="main">=</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">rbt_has_next</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">rbt_keys_next</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> rbt_generator_state <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> rbt_generator_state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_keys_next</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">kts</span></span></span><span class="main">,</span> rbt.Empty<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">kts</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">rbt_keys_next</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">kts</span></span></span><span class="main">,</span> rbt.Branch <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">rbt_keys_next</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">kts</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rbt_generator_induct <span class="main">[</span><span class="operator">case_names</span> empty split shuffle<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span> rbt.Empty<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">k</span> <span class="bound">t</span> <span class="bound">kts</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="bound">kts</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">#</span> <span class="bound">kts</span><span class="main">,</span> rbt.Empty<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">kts</span> <span class="bound">c</span> <span class="bound">l</span> <span class="bound">k</span> <span class="bound">v</span> <span class="bound">r</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span> <span class="main">#</span> <span class="bound">kts</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="bound">kts</span><span class="main">,</span> Branch <span class="bound">c</span> <span class="bound">l</span> <span class="bound">k</span> <span class="bound">v</span> <span class="bound">r</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">ktst</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction_schema</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">pat_completeness</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">kts</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">.</span> size_list <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">.</span> size_rbt <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">1</span><span class="main">)</span> <span class="bound">t</span><span class="main">)</span> <span class="bound">kts</span> <span class="main">+</span> size_rbt <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">1</span><span class="main">)</span> <span class="bound">t</span><span class="main">)</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> terminates_rbt_keys_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"terminates <span class="main">(</span>rbt_has_next<span class="main">,</span> rbt_keys_next<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ktst</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt<span class="main">)</span> list <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ktst</span> <span class="main">∈</span> terminates_on <span class="main">(</span>rbt_has_next<span class="main">,</span> rbt_keys_next<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">ktst</span></span> <span class="quasi_keyword">taking</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">k</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">k</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rbt_generator_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> terminates_on.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> terminates_on.cases<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> rbt_keys_generator <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> rbt_generator_state<span class="main">)</span> generator"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rbt_has_next<span class="main">,</span> rbt_keys_next<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> terminates_rbt_keys_generator<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rbt_init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> rbt_generator_state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rbt_init</span> <span class="main">=</span> Pair <span class="main">[]</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> has_next_rbt_keys_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.has_next rbt_keys_generator <span class="main">=</span> rbt_has_next"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> next_rbt_keys_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.next rbt_keys_generator <span class="main">=</span> rbt_keys_next"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_rbt_keys_generator_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr rbt_keys_generator <span class="main">(</span><span class="free">kts</span><span class="main">,</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> 
  RBT_Impl.keys <span class="free">t</span> <span class="main">@</span> concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">.</span> <span class="bound">k</span> <span class="main">#</span> RBT_Impl.keys <span class="bound">t</span><span class="main">)</span> <span class="free">kts</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">kts</span><span class="main">,</span> <span class="free">t</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">kts</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">taking</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">k</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">k</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rbt_generator_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> empty <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list.unfoldr.simps<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> split <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> shuffle <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> unfoldr_rbt_keys_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr rbt_keys_generator <span class="main">(</span>rbt_init <span class="free">t</span><span class="main">)</span> <span class="main">=</span> RBT_Impl.keys <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unfoldr_rbt_keys_generator_aux rbt_init_def<span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">rbt_entries_next</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> rbt_generator_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> rbt_generator_state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_entries_next</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">kv</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">kts</span></span></span><span class="main">,</span> rbt.Empty<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">kv</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">kts</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">rbt_entries_next</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">kts</span></span></span><span class="main">,</span> rbt.Branch <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">rbt_entries_next</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">kts</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> terminates_rbt_entries_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"terminates <span class="main">(</span>rbt_has_next<span class="main">,</span> rbt_entries_next<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> terminatesI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ktst</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> rbt_generator_state"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ktst</span> <span class="main">∈</span> terminates_on <span class="main">(</span>rbt_has_next<span class="main">,</span> rbt_entries_next<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">ktst</span></span> <span class="quasi_keyword">taking</span><span class="main"><span class="main">:</span></span> <span class="quoted">Pair</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rbt_generator_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> terminates_on.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> terminates_on.cases<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> rbt_entries_generator <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> rbt_generator_state<span class="main">)</span> generator"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rbt_has_next<span class="main">,</span> rbt_entries_next<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> terminates_rbt_entries_generator<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> has_next_rbt_entries_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.has_next rbt_entries_generator <span class="main">=</span> rbt_has_next"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> next_rbt_entries_generator <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.next rbt_entries_generator <span class="main">=</span> rbt_entries_next"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_rbt_entries_generator_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr rbt_entries_generator <span class="main">(</span><span class="free">kts</span><span class="main">,</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> 
  RBT_Impl.entries <span class="free">t</span> <span class="main">@</span> concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">.</span> <span class="bound">k</span> <span class="main">#</span> RBT_Impl.entries <span class="bound">t</span><span class="main">)</span> <span class="free">kts</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">kts</span><span class="main">,</span> <span class="free">t</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">kts</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">taking</span><span class="main"><span class="main">:</span></span> <span class="quoted">Pair</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rbt_generator_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> empty <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list.unfoldr.simps<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> split <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> shuffle <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> unfoldr_rbt_entries_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr rbt_entries_generator <span class="main">(</span>rbt_init <span class="free">t</span><span class="main">)</span> <span class="main">=</span> RBT_Impl.entries <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unfoldr_rbt_entries_generator_aux rbt_init_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="RBT_Mapping2">
<div class="head">
<h1>Theory RBT_Mapping2</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/RBT_Mapping2.thy
    Author:     Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> RBT_Mapping2
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Collection_Order.html">Collection_Order</a>
  <a href="RBT_ext.html">RBT_ext</a>
  <a href="../Deriving/RBT_Comparator_Impl.html">Deriving.RBT_Comparator_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Mappings implemented by red-black trees›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_map_filterI<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> distinct <span class="main">(</span>map <span class="free">f</span> <span class="main">(</span>filter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_filter_apply<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">xs</span><span class="main">)</span>
  <span class="main">⟹</span> map_of <span class="main">(</span>filter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> map_of <span class="free">xs</span> <span class="free">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="keyword1">then</span> Some <span class="bound">v</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_of_eq_None_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type definition›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">t</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> RBT_Impl.rbt<span class="main">.</span> ord.is_rbt cless <span class="bound">t</span> <span class="main">∨</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None<span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">morphisms</span></span> impl_of Mapping_RBT'
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"RBT_Impl.Empty <span class="main">∈</span> <span class="var">?mapping_rbt</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord.Empty_is_rbt<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Mapping_RBT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Mapping_RBT</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> Mapping_RBT'
  <span class="main">(</span><span class="keyword1">if</span> ord.is_rbt cless <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">∨</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span>
   <span class="keyword1">else</span> RBT_Impl.fold <span class="main">(</span>ord.rbt_insert cless<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> rbt.Empty<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Mapping_RBT_inverse<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">t</span><span class="main">.</span> ord.is_rbt cless <span class="bound">t</span> <span class="main">∨</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None<span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"impl_of <span class="main">(</span>Mapping_RBT <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping_RBT_def Mapping_RBT'_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> impl_of_inverse<span class="main">:</span> <span class="quoted"><span class="quoted">"Mapping_RBT <span class="main">(</span>impl_of <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping_RBT'_inverse Mapping_RBT_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> type_definition_mapping_rbt'<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"type_definition impl_of Mapping_RBT 
    <span class="main">{</span><span class="bound">t</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt<span class="main">.</span> ord.is_rbt cless <span class="bound">t</span> <span class="main">∨</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">)</span> <span class="main">=</span> None<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">rule</span> mapping_rbt.impl_of impl_of_inverse Mapping_RBT_inverse<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> Mapping_RBT_cases<span class="main">[</span><span class="operator">cases</span> <span class="quasi_keyword">type</span><span class="main"><span class="main">:</span></span> mapping_rbt<span class="main">]</span> <span class="main">=</span> 
  type_definition.Abs_cases<span class="main">[</span><span class="operator">OF</span> type_definition_mapping_rbt'<span class="main">]</span> 
  <span class="keyword2"><span class="keyword">and</span></span> Mapping_RBT_induct<span class="main">[</span><span class="operator">induct</span> <span class="quasi_keyword">type</span><span class="main"><span class="main">:</span></span> mapping_rbt<span class="main">]</span> <span class="main">=</span>
  type_definition.Abs_induct<span class="main">[</span><span class="operator">OF</span> type_definition_mapping_rbt'<span class="main">]</span> <span class="keyword2"><span class="keyword">and</span></span>
  Mapping_RBT_inject <span class="main">=</span> type_definition.Abs_inject<span class="main">[</span><span class="operator">OF</span> type_definition_mapping_rbt'<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> rbt_eq_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">t1</span> <span class="main">=</span> <span class="free">t2</span> <span class="main">⟷</span> impl_of <span class="free">t1</span> <span class="main">=</span> impl_of <span class="free">t2</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> impl_of_inject<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rbt_eqI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"impl_of <span class="free">t1</span> <span class="main">=</span> impl_of <span class="free">t2</span> <span class="main">⟹</span> <span class="free">t1</span> <span class="main">=</span> <span class="free">t2</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rbt_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Mapping_RBT_impl_of <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Mapping_RBT <span class="main">(</span>impl_of <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> impl_of_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Operations›</span></span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_mapping_rbt'

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dummy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> lookup <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇀</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"rbt_comp_lookup ccomp"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> empty <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"RBT_Impl.Empty"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord.Empty_is_rbt<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> insert <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"rbt_comp_insert ccomp"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> linorder.rbt_insert_is_rbt ID_ccompare <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_insert<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> delete <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"rbt_comp_delete ccomp"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> linorder.rbt_delete_is_rbt ID_ccompare <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_delete<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> bulkload <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"rbt_comp_bulkload ccomp"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> linorder.rbt_bulkload_is_rbt ID_ccompare <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_bulkload<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> map_entry <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"rbt_comp_map_entry ccomp"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ord.rbt_map_entry_is_rbt rbt_comp_map_entry<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> map <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"RBT_Impl.map"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord.map_is_rbt<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> entries <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"RBT_Impl.entries"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> keys <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"set <span class="main">∘</span> RBT_Impl.keys"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> fold <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'c</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"RBT_Impl.fold"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> is_empty <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"case_rbt True <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> filter <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">P</span> <span class="bound">t</span><span class="main">.</span> rbtreeify <span class="main">(</span>List.filter <span class="bound">P</span> <span class="main">(</span>RBT_Impl.entries <span class="bound">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> linorder.is_rbt_rbtreeify ID_ccompare linorder.sorted_filter linorder.rbt_sorted_entries ord.is_rbt_rbt_sorted linorder.distinct_entries distinct_map_filterI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> filter_map<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> join <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"rbt_comp_union_with_key ccomp"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> linorder.is_rbt_rbt_unionwk ID_ccompare <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_union_with_key<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> meet <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> 
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"rbt_comp_inter_with_key ccomp"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> linorder.rbt_interwk_is_rbt ID_ccompare ord.is_rbt_rbt_sorted <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_inter_with_key<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> all <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> bool"</span></span> 
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"RBT_Impl_rbt_all"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> ex <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"RBT_Impl_rbt_ex"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> product <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'e</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt
  <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'e</span><span class="main">)</span> mapping_rbt"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"rbt_product"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> is_rbt_rbt_product ID_ccompare <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lt_of_comp_less_prod ccompare_prod_def ID_Some ID_None <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> diag <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"RBT_Impl_diag"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lt_of_comp_less_prod ccompare_prod_def ID_Some ID_None is_rbt_RBT_Impl_diag <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> init <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> rbt_generator_state"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"rbt_init"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_rbt_entries_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr rbt_entries_generator <span class="main">(</span>init <span class="free">t</span><span class="main">)</span> <span class="main">=</span> entries <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unfoldr_rbt_entries_generator<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_RBT<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ord.is_rbt cless <span class="free">t</span> <span class="main">⟹</span>
  lookup <span class="main">(</span>Mapping_RBT <span class="free">t</span><span class="main">)</span> <span class="main">=</span> rbt_comp_lookup ccomp <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lookup_def Mapping_RBT_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_impl_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"rbt_comp_lookup ccomp <span class="main">(</span>impl_of <span class="free">t</span><span class="main">)</span> <span class="main">=</span> lookup <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> entries_impl_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"RBT_Impl.entries <span class="main">(</span>impl_of <span class="free">t</span><span class="main">)</span> <span class="main">=</span> entries <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> keys_impl_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>RBT_Impl.keys <span class="main">(</span>impl_of <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> keys <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> keys_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup empty <span class="main">=</span> Map.empty"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff ord.rbt_lookup.simps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fold_conv_fold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fold <span class="free">f</span> <span class="free">t</span> <span class="main">=</span> List.fold <span class="main">(</span>case_prod <span class="free">f</span><span class="main">)</span> <span class="main">(</span>entries <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_Impl.fold_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> is_empty_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_empty <span class="free">t</span> <span class="main">⟷</span> <span class="free">t</span> <span class="main">=</span> empty"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> rbt.split<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> ID_ccompare_neq_None<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">)</span> <span class="main">≠</span> None"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mapping_linorder<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder <span class="main">(</span>cless_eq <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> cless"</span></span>
<span class="keyword1"><span class="command">using</span></span> ID_ccompare_neq_None <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> ID_ccompare<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mapping_comparator<span class="main">:</span> <span class="quoted"><span class="quoted">"comparator <span class="main">(</span>ccomp <span class="main">::</span> <span class="tfree">'a</span> comparator<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> ID_ccompare_neq_None <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> ID_ccompare'<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> rbt_comp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> rbt_comp_simps<span class="main">[</span><span class="operator">OF</span> mapping_comparator<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> is_rbt_impl_of <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ord.is_rbt cless <span class="main">(</span>impl_of <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> ID_ccompare_neq_None impl_of <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_insert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>insert <span class="main">(</span><span class="free">k</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="free">v</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lookup <span class="free">t</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None 
  linorder.rbt_lookup_rbt_insert<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_delete <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>delete <span class="main">(</span><span class="free">k</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lookup <span class="free">t</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">:=</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None linorder.rbt_lookup_rbt_delete<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> restrict_complement_singleton_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_entries <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>entries <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt<span class="main">)</span><span class="main">)</span> <span class="main">=</span> lookup <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None linorder.map_of_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> entries_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"entries <span class="main">(</span><span class="free">t1</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt<span class="main">)</span> <span class="main">=</span> entries <span class="free">t2</span> <span class="main">⟷</span> lookup <span class="free">t1</span> <span class="main">=</span> lookup <span class="free">t2</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None linorder.entries_rbt_lookup<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_bulkload <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>bulkload <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> map_of <span class="main">(</span><span class="free">xs</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linorder.rbt_lookup_rbt_bulkload<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_map_entry <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>map_entry <span class="main">(</span><span class="free">k</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="free">f</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lookup <span class="free">t</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">:=</span> map_option <span class="free">f</span> <span class="main">(</span>lookup <span class="free">t</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None linorder.rbt_lookup_rbt_map_entry<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_map <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>map <span class="free">f</span> <span class="free">t</span><span class="main">)</span> <span class="main">(</span><span class="free">k</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> map_option <span class="main">(</span><span class="free">f</span> <span class="free">k</span><span class="main">)</span> <span class="main">(</span>lookup <span class="free">t</span> <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linorder.rbt_lookup_map<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> RBT_lookup_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ord.rbt_lookup cless <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> RBT_Impl.rbt<span class="main">)</span> <span class="main">=</span> Map.empty <span class="main">⟷</span> <span class="free">t</span> <span class="main">=</span> RBT_Impl.Empty"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> linorder <span class="quoted"><span class="quoted">"cless_eq <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="quoted">cless</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mapping_linorder<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_empty_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup <span class="free">t</span> <span class="main">=</span> Map.empty <span class="main">⟷</span> <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt<span class="main">)</span> <span class="main">=</span> empty"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_dom_lookup <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>dom <span class="main">(</span>lookup <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linorder.finite_dom_rbt_lookup<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> card_com_lookup <span class="main">[</span><span class="operator">unfolded</span> length_map<span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"card <span class="main">(</span>dom <span class="main">(</span>lookup <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span>List.map fst <span class="main">(</span>entries <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linorder.rbt_lookup_keys<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> linorder.distinct_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> RBT_Impl.keys_def ord.is_rbt_rbt_sorted ID_ccompare_neq_None List.card_set <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> set_map length_map<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_join<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>join <span class="free">f</span> <span class="main">(</span><span class="free">t1</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt<span class="main">)</span> <span class="free">t2</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="keyword1">case</span> lookup <span class="free">t1</span> <span class="bound">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> lookup <span class="free">t2</span> <span class="bound">k</span> <span class="main">|</span> Some <span class="bound">v1</span> <span class="main">⇒</span> Some <span class="main">(</span><span class="keyword1">case</span> lookup <span class="free">t2</span> <span class="bound">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="bound">v1</span> <span class="main">|</span> Some <span class="bound">v2</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">k</span> <span class="bound">v1</span> <span class="bound">v2</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff linorder.rbt_lookup_rbt_unionwk<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted ID_ccompare_neq_None <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_meet<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>meet <span class="free">f</span> <span class="main">(</span><span class="free">t1</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt<span class="main">)</span> <span class="free">t2</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="keyword1">case</span> lookup <span class="free">t1</span> <span class="bound">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="bound">v1</span> <span class="main">⇒</span> <span class="keyword1">case</span> lookup <span class="free">t2</span> <span class="bound">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="bound">v2</span> <span class="main">⇒</span> Some <span class="main">(</span><span class="free">f</span> <span class="bound">k</span> <span class="bound">v1</span> <span class="bound">v2</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff linorder.rbt_lookup_rbt_interwk<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted ID_ccompare_neq_None <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_filter <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>filter <span class="free">P</span> <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt<span class="main">)</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> lookup <span class="free">t</span> <span class="free">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="keyword1">then</span> Some <span class="bound">v</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None linorder.rbt_lookup_rbtreeify<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> linorder.sorted_filter<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted linorder.rbt_sorted_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> distinct_map_filterI linorder.distinct_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> map_of_filter_apply linorder.map_of_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> all_conv_all_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"all <span class="free">P</span> <span class="free">t</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">k</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="bound">v</span><span class="main">.</span> lookup <span class="free">t</span> <span class="bound">k</span> <span class="main">=</span> Some <span class="bound">v</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None linorder.rbt_lookup_keys<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted RBT_Impl.keys_def RBT_Impl_rbt_all_def linorder.map_of_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> linorder.distinct_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> map_of_SomeD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_of_is_SomeI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ex_conv_ex_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ex <span class="free">P</span> <span class="free">t</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="main">(</span><span class="bound">k</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="bound">v</span><span class="main">.</span> lookup <span class="free">t</span> <span class="bound">k</span> <span class="main">=</span> Some <span class="bound">v</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None linorder.rbt_lookup_keys<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted RBT_Impl.keys_def RBT_Impl_rbt_ex_def linorder.map_of_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> linorder.distinct_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_linorder<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_of_is_SomeI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> diag_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>diag <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">,</span> <span class="bound">k'</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">k</span> <span class="main">=</span> <span class="bound">k'</span> <span class="keyword1">then</span> lookup <span class="free">t</span> <span class="bound">k</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> linorder.rbt_lookup_RBT_Impl_diag<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'b</span><span class="main"><span class="main">=</span></span><span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span><span class="main">,</span> <span class="operator">OF</span> mapping_linorder<span class="main">]</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None ccompare_prod_def lt_of_comp_less_prod<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> 
  rbt_comp_lookup<span class="main"><span class="main">[</span></span><span class="operator">OF</span> comparator_prod<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> mapping_comparator mapping_comparator<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
  ID_Some <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> rbt_comp_lookup<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_comparator<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> ID_ccompare_neq_None'<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span> <span class="main">::</span> ccompare<span class="main">)</span> <span class="main">≠</span> None"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mapping_linorder'<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder <span class="main">(</span>cless_eq <span class="main">::</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> cless"</span></span>
<span class="keyword1"><span class="command">using</span></span> ID_ccompare_neq_None' <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> ID_ccompare<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mapping_comparator'<span class="main">:</span> <span class="quoted"><span class="quoted">"comparator <span class="main">(</span>ccomp <span class="main">::</span> <span class="tfree">'b</span> comparator<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> ID_ccompare_neq_None' <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> ID_ccompare'<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> rbt_comp'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> rbt_comp_simps<span class="main">[</span><span class="operator">OF</span> mapping_comparator'<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> ccomp_comparator_prod<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ccomp <span class="main">=</span> <span class="main">(</span>comparator_prod ccomp ccomp <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span>comparator<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ccompare_prod_def lt_of_comp_less_prod ID_ccompare_neq_None ID_ccompare_neq_None' ID_Some <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_product<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>product <span class="free">f</span> <span class="free">rbt1</span> <span class="free">rbt2</span><span class="main">)</span> <span class="main">(</span><span class="free">a</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">,</span> <span class="free">b</span> <span class="main">::</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> lookup <span class="free">rbt1</span> <span class="free">a</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None
   <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span> map_option <span class="main">(</span><span class="free">f</span> <span class="free">a</span> <span class="bound">c</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span>lookup <span class="free">rbt2</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> mapping_linorder mapping_linorder'
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ccomp_comparator_prod rbt_comp_lookup<span class="main"><span class="main">[</span></span><span class="operator">OF</span> comparator_prod<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mapping_comparator mapping_comparator'<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span>
  rbt_comp rbt_comp' lt_of_comp_less_prod<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None ID_ccompare_neq_None' rbt_lookup_rbt_product<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> impl_of lookup empty insert delete
  entries keys bulkload map_entry map fold join meet filter all ex product diag init

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="AssocList">
<div class="head">
<h1>Theory AssocList</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/AssocList.thy
    Author:     Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> AssocList <span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/DAList.html">HOL-Library.DAList</a>"</span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Additional operations for associative lists›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Operations on the raw type›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">update_with_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'val</span> <span class="main">⇒</span> <span class="tfree">'key</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'val</span> <span class="main">⇒</span> <span class="tfree">'val</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'key</span> <span class="main">×</span> <span class="tfree">'val</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'key</span> <span class="main">×</span> <span class="tfree">'val</span><span class="main">)</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">update_with_aux</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">update_with_aux</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">#</span> <span class="free">update_with_aux</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Do not use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"AList.delete"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because this traverses all the list even if it has found the key.
  We do not have to keep going because we use the invariant that keys are distinct.
›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">delete_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'key</span> <span class="main">×</span> <span class="tfree">'val</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'key</span> <span class="main">×</span> <span class="tfree">'val</span><span class="main">)</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">delete_aux</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">delete_aux</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k'</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">k'</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k'</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free">delete_aux</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">zip_with_index_from</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">zip_with_index_from</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> zip <span class="main">[</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">..&lt;</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">+</span> length <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">]</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">zip_with_index</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">zip_with_index</span> <span class="main">≡</span> zip_with_index_from <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> update_conv_update_with_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"AList.update <span class="free">k</span> <span class="free">v</span> <span class="free">xs</span> <span class="main">=</span> update_with_aux <span class="free">v</span> <span class="free">k</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">v</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_update_with_aux'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>update_with_aux <span class="free">v</span> <span class="free">k</span> <span class="free">f</span> <span class="free">ps</span><span class="main">)</span> <span class="free">k'</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>map_of <span class="free">ps</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="main">(</span><span class="keyword1">case</span> map_of <span class="free">ps</span> <span class="free">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">f</span> <span class="free">v</span> <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">k'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ps</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_update_with_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>update_with_aux <span class="free">v</span> <span class="free">k</span> <span class="free">f</span> <span class="free">ps</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>map_of <span class="free">ps</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="main">(</span><span class="keyword1">case</span> map_of <span class="free">ps</span> <span class="free">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">f</span> <span class="free">v</span> <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff map_of_update_with_aux'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dom_update_with_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="main">`</span> set <span class="main">(</span>update_with_aux <span class="free">v</span> <span class="free">k</span> <span class="free">f</span> <span class="free">ps</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span> <span class="main">∪</span> fst <span class="main">`</span> set <span class="free">ps</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ps</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_update_with_aux <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span>update_with_aux <span class="free">v</span> <span class="free">k</span> <span class="free">f</span> <span class="free">ps</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> distinct <span class="main">(</span>map fst <span class="free">ps</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ps</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dom_update_with_aux<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_update_with_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">xs</span><span class="main">)</span> 
  <span class="main">⟹</span> set <span class="main">(</span>update_with_aux <span class="free">v</span> <span class="free">k</span> <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>set <span class="free">xs</span> <span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span> <span class="main">×</span> UNIV <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">f</span> <span class="main">(</span><span class="keyword1">case</span> map_of <span class="free">xs</span> <span class="free">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">v</span> <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_delete_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> set <span class="main">(</span>delete_aux <span class="free">k</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span> <span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span> <span class="main">×</span> UNIV"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> dom_delete_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">ps</span><span class="main">)</span> <span class="main">⟹</span> fst <span class="main">`</span> set <span class="main">(</span>delete_aux <span class="free">k</span> <span class="free">ps</span><span class="main">)</span> <span class="main">=</span> fst <span class="main">`</span> set <span class="free">ps</span> <span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_delete_aux<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_delete_aux <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">ps</span><span class="main">)</span> <span class="main">⟹</span> distinct <span class="main">(</span>map fst <span class="main">(</span>delete_aux <span class="free">k</span> <span class="free">ps</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ps</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">ps</span><span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">k'</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">k'</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">=</span> <span class="free">k</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> Cons a <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">with</span></span> Cons a <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">∉</span> fst <span class="main">`</span> set <span class="skolem">ps</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="skolem">ps</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">with</span></span> False a <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">∉</span> fst <span class="main">`</span> set <span class="main">(</span>delete_aux <span class="free">k</span> <span class="skolem">ps</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> dom_delete_aux<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> k<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">k</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Cons a <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_delete_aux'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> map_of <span class="main">(</span>delete_aux <span class="free">k</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>map_of <span class="free">xs</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">:=</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_of_eq_None_iff fun_upd_twist<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_delete_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> map_of <span class="main">(</span>delete_aux <span class="free">k</span> <span class="free">xs</span><span class="main">)</span> <span class="free">k'</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>map_of <span class="free">xs</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">)</span> <span class="free">k'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_of_delete_aux'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> delete_aux_eq_Nil_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"delete_aux <span class="free">k</span> <span class="free">ts</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟷</span> <span class="free">ts</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="free">ts</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ts</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> zip_with_index_from_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"zip_with_index_from <span class="free">n</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="quoted"><span class="quoted">"zip_with_index_from <span class="free">n</span> <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">n</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">#</span> zip_with_index_from <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zip_with_index_from_def upt_rec <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> upt.upt_Suc<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> zip_with_index_from_append <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"zip_with_index_from <span class="free">n</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> zip_with_index_from <span class="free">n</span> <span class="free">xs</span> <span class="main">@</span> zip_with_index_from <span class="main">(</span><span class="free">n</span> <span class="main">+</span> length <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zip_with_index_from_def zip_append<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> upt_add_eq_append<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> zip_append<span class="main">)</span>
    <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.assoc<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> zip_with_index_from_conv_nth<span class="main">:</span>
  <span class="quoted"><span class="quoted">"zip_with_index_from <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="bound">i</span><span class="main">,</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">xs</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_zip_with_index_from <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>zip_with_index_from <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="free">i</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">i</span> <span class="main">≥</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">+</span> length <span class="free">xs</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="main">(</span><span class="free">i</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zip_with_index_from_def set_zip <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">-</span> <span class="free">n</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_map'<span class="main">:</span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="free">f</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> map_option <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>map_of <span class="free">xs</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Operations on the abstract type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> alist"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> update_with <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> alist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> alist"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"update_with_aux"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lift_definition</span></span> delete <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> alist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> alist"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"delete_aux"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lift_definition</span></span> keys <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> alist <span class="main">⇒</span> <span class="tfree">'k</span> set"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"set <span class="main">∘</span> map fst"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> set <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'key</span><span class="main">,</span> <span class="tfree">'val</span><span class="main">)</span> alist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'key</span> <span class="main">×</span> <span class="tfree">'val</span><span class="main">)</span> set"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"List.set"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> map_values <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'key</span> <span class="main">⇒</span> <span class="tfree">'val</span> <span class="main">⇒</span> <span class="tfree">'val'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'key</span><span class="main">,</span> <span class="tfree">'val</span><span class="main">)</span> alist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'key</span><span class="main">,</span> <span class="tfree">'val'</span><span class="main">)</span> alist"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">f</span><span class="main">.</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def split_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_update_with <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"DAList.lookup <span class="main">(</span>update_with <span class="free">v</span> <span class="free">k</span> <span class="free">f</span> <span class="free">al</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>DAList.lookup <span class="free">al</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="keyword1">case</span> DAList.lookup <span class="free">al</span> <span class="free">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">f</span> <span class="free">v</span> <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_of_update_with_aux<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_delete <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"DAList.lookup <span class="main">(</span>delete <span class="free">k</span> <span class="free">al</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>DAList.lookup <span class="free">al</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">:=</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_of_delete_aux'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_dom_lookup <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>dom <span class="main">(</span>DAList.lookup <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_dom_map_of<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> update_conv_update_with<span class="main">:</span> <span class="quoted"><span class="quoted">"DAList.update <span class="free">k</span> <span class="free">v</span> <span class="main">=</span> update_with <span class="free">v</span> <span class="free">k</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_conv_update_with_aux<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_update <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"DAList.lookup <span class="main">(</span>DAList.update <span class="free">k</span> <span class="free">v</span> <span class="free">al</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>DAList.lookup <span class="free">al</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_conv_update_with <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dom_lookup_keys<span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span>DAList.lookup <span class="free">al</span><span class="main">)</span> <span class="main">=</span> keys <span class="free">al</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dom_map_of_conv_image_fst<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keys_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keys DAList.empty <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> keys_update_with <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keys <span class="main">(</span>update_with <span class="free">v</span> <span class="free">k</span> <span class="free">f</span> <span class="free">al</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">k</span> <span class="main">(</span>keys <span class="free">al</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dom_lookup_keys<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keys_update <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keys <span class="main">(</span>DAList.update <span class="free">k</span> <span class="free">v</span> <span class="free">al</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">k</span> <span class="main">(</span>keys <span class="free">al</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_conv_update_with<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keys_delete <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keys <span class="main">(</span>delete <span class="free">k</span> <span class="free">al</span><span class="main">)</span> <span class="main">=</span> keys <span class="free">al</span> <span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dom_lookup_keys<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set DAList.empty <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> set_update_with<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>update_with <span class="free">v</span> <span class="free">k</span> <span class="free">f</span> <span class="free">al</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span>set <span class="free">al</span> <span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span> <span class="main">×</span> UNIV <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">f</span> <span class="main">(</span><span class="keyword1">case</span> DAList.lookup <span class="free">al</span> <span class="free">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">v</span> <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_update_with_aux<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_update<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>DAList.update <span class="free">k</span> <span class="free">v</span> <span class="free">al</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>set <span class="free">al</span> <span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span> <span class="main">×</span> UNIV <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_conv_update_with set_update_with<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_delete<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>delete <span class="free">k</span> <span class="free">al</span><span class="main">)</span> <span class="main">=</span> set <span class="free">al</span> <span class="main">-</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span> <span class="main">×</span> UNIV"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_delete_aux<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> size_dalist_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_alist <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> length size"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> size_alist_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">lemma</span></span> size_eq_card_dom_lookup<span class="main">:</span> <span class="quoted"><span class="quoted">"size <span class="free">al</span> <span class="main">=</span> card <span class="main">(</span>dom <span class="main">(</span>DAList.lookup <span class="free">al</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">metis</span> comp_apply distinct_card dom_map_of_conv_image_fst image_set length_map<span class="main">)</span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> update_with keys set delete

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="DList_Set">
<div class="head">
<h1>Theory DList_Set</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/DList_Set.thy
    Author:     Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> DList_Set <span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Collection_Eq.html">Collection_Eq</a>
  <a href="Equal.html">Equal</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Sets implemented by distinct lists›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Operations on the raw type with parametrised equality›</span></span>

<span class="keyword1"><span class="command">context</span></span> equal_base <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">list_member</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list_member</span> <span class="main">[]</span>       <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">list_member</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> <span class="free">equal</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">∨</span> <span class="free">list_member</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">list_distinct</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">list_distinct</span> <span class="main">[]</span>       <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">list_distinct</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span> list_member <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∧</span> <span class="free">list_distinct</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">list_insert</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list_insert</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> list_member <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">list_remove1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list_remove1</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">list_remove1</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">equal</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free">list_remove1</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">list_remdups</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list_remdups</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">list_remdups</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> list_member <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="free">list_remdups</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free">list_remdups</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> list_member_filterD<span class="main">:</span> <span class="quoted"><span class="quoted">"list_member <span class="main">(</span>filter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="free">x</span> <span class="main">⟹</span> list_member <span class="free">xs</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> list_distinct_filter <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"list_distinct <span class="free">xs</span> <span class="main">⟹</span> list_distinct <span class="main">(</span>filter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> list_member_filterD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> list_distinct_tl <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"list_distinct <span class="free">xs</span> <span class="main">⟹</span> list_distinct <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  equal_base.list_member.simps
  equal_base.list_distinct.simps
  equal_base.list_insert_def
  equal_base.list_remove1.simps
  equal_base.list_remdups.simps

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span>
  equal_base.list_member.simps
  equal_base.list_distinct.simps
  equal_base.list_remove1.simps
  equal_base.list_remdups.simps

<span class="keyword1"><span class="command">lemma</span></span> list_member_conv_member <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"equal_base.list_member <span class="main">(=)</span> <span class="main">=</span> List.member"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"equal_base.list_member <span class="main">(=)</span> <span class="skolem">xs</span> <span class="skolem">x</span> <span class="main">=</span> List.member <span class="skolem">xs</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.member_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> list_distinct_conv_distinct <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"equal_base.list_distinct <span class="main">(=)</span> <span class="main">=</span> List.distinct"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"equal_base.list_distinct <span class="main">(=)</span> <span class="skolem">xs</span> <span class="main">=</span> distinct <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.member_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> list_insert_conv_insert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"equal_base.list_insert <span class="main">(=)</span> <span class="main">=</span> List.insert"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> equal_base.list_insert_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> List.insert_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.member_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> list_remove1_conv_remove1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"equal_base.list_remove1 <span class="main">(=)</span> <span class="main">=</span> List.remove1"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> equal_base.list_remove1_def List.remove1_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> list_remdups_conv_remdups <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"equal_base.list_remdups <span class="main">(=)</span> <span class="main">=</span> List.remdups"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> equal_base.list_remdups_def List.remdups_def list_member_conv_member List.member_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">context</span></span> equal <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> member_insert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"list_member <span class="main">(</span>list_insert <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="free">y</span> <span class="main">⟷</span> <span class="free">equal</span> <span class="free">x</span> <span class="free">y</span> <span class="main">∨</span> list_member <span class="free">xs</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_eq List.member_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_remove1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">equal</span> <span class="free">x</span> <span class="free">y</span> <span class="main">⟹</span> list_member <span class="main">(</span>list_remove1 <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="free">y</span> <span class="main">=</span> list_member <span class="free">xs</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_eq List.member_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_remove1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list_distinct <span class="free">xs</span> <span class="main">⟹</span> list_distinct <span class="main">(</span>list_remove1 <span class="free">x</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_member_remove1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list_distinct <span class="free">xs</span> <span class="main">⟹</span> list_member <span class="main">(</span>list_remove1 <span class="free">x</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>list_member <span class="free">xs</span><span class="main">)</span><span class="main">(</span><span class="free">x</span> <span class="main">:=</span> False<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_eq List.member_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">lemma</span></span> ID_ceq<span class="main">:</span> <span class="comment1">(* FIXME: Adapt Set_Impl to directly use above equal class! *)</span>
  <span class="quoted"><span class="quoted">"ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ceq<span class="main">)</span> <span class="main">=</span> Some <span class="free">eq</span> <span class="main">⟹</span> equal <span class="free">eq</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ceq<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The type of distinct lists›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span> <span class="main">::</span> <span class="quoted">ceq</span> set_dlist <span class="main">=</span>
  <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">xs</span><span class="main">::</span><span class="tfree">'a</span> list<span class="main">.</span> equal_base.list_distinct ceq' <span class="bound">xs</span> <span class="main">∨</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None<span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">morphisms</span></span> list_of_dlist Abs_dlist'
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span> <span class="main">∈</span> <span class="var">?set_dlist</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Abs_dlist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq list <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">Abs_dlist</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> Abs_dlist' 
  <span class="main">(</span><span class="keyword1">if</span> equal_base.list_distinct ceq' <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">∨</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> 
   <span class="keyword1">else</span> equal_base.list_remdups ceq' <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Abs_dlist_inverse<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq list"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> equal_base.list_distinct ceq' <span class="bound">xs</span> <span class="main">∨</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None<span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"list_of_dlist <span class="main">(</span>Abs_dlist <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_dlist_def Abs_dlist'_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> list_of_dlist_inverse<span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_dlist <span class="main">(</span>list_of_dlist <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span> <span class="free">dxs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">dxs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_dlist'_inverse Abs_dlist_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> type_definition_set_dlist'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"type_definition list_of_dlist Abs_dlist
  <span class="main">{</span><span class="bound">xs</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> ceq list<span class="main">.</span> equal_base.list_distinct ceq' <span class="bound">xs</span> <span class="main">∨</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> set_dlist.list_of_dlist Abs_dlist_inverse list_of_dlist_inverse<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> Abs_dlist_cases<span class="main">[</span><span class="operator">cases</span> <span class="quasi_keyword">type</span><span class="main"><span class="main">:</span></span> set_dlist<span class="main">]</span> <span class="main">=</span> 
  type_definition.Abs_cases<span class="main">[</span><span class="operator">OF</span> type_definition_set_dlist'<span class="main">]</span> 
  <span class="keyword2"><span class="keyword">and</span></span> Abs_dlist_induct<span class="main">[</span><span class="operator">induct</span> <span class="quasi_keyword">type</span><span class="main"><span class="main">:</span></span> set_dlist<span class="main">]</span> <span class="main">=</span>
  type_definition.Abs_induct<span class="main">[</span><span class="operator">OF</span> type_definition_set_dlist'<span class="main">]</span> <span class="keyword2"><span class="keyword">and</span></span>
  Abs_dlist_inject <span class="main">=</span> type_definition.Abs_inject<span class="main">[</span><span class="operator">OF</span> type_definition_set_dlist'<span class="main">]</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_set_dlist'

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Operations›</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> empty <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lift_definition</span></span> insert <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist"</span></span> <span class="keyword2"><span class="keyword">is</span></span> 
  <span class="quoted"><span class="quoted">"equal_base.list_insert ceq'"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_base.list_insert_def<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> remove <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist"</span></span> <span class="keyword2"><span class="keyword">is</span></span> 
  <span class="quoted"><span class="quoted">"equal_base.list_remove1 ceq'"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> equal.distinct_remove1 ID_ceq<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> filter <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ceq <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">List.filter</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_base.list_distinct_filter<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Derived operations:›</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> null <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">List.null</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> member <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"equal_base.list_member ceq'"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> length <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">List.length</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> fold <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ceq <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">List.fold</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> foldr <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ceq <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">List.foldr</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> hd <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"List.hd"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> tl <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"List.tl"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_base.list_distinct_tl<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> dlist_all <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"list_all"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> dlist_ex <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"list_ex"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">union</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">union</span> <span class="main">=</span> fold insert"</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> product <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> rev <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> map <span class="main">(</span>Pair <span class="bound">x</span><span class="main">)</span> <span class="bound">ys</span><span class="main">)</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"equal_base.list_distinct ceq' <span class="skolem">xs</span> <span class="main">∨</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None"</span></span>
    <span class="quoted"><span class="quoted">"equal_base.list_distinct ceq' <span class="skolem">ys</span> <span class="main">∨</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?product</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> map <span class="main">(</span>Pair <span class="bound">x</span><span class="main">)</span> <span class="skolem">ys</span><span class="main">)</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> neq<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">≠</span> None"</span></span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="main">≠</span> None"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> ceq'<span class="main">:</span> <span class="quoted"><span class="quoted">"ceq' <span class="main">=</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"ceq' <span class="main">=</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">::</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ceq<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> * neq <span class="keyword1"><span class="command">have</span></span> dist<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">ys</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"distinct <span class="var">?product</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> <span class="main">[]</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_map map_replicate_const <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> inj_onI distinct_concat<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>rev <span class="var">?product</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ceq' <span class="main">=</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> bool<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> neq ceq' <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ceq_prod_def ID_Some fun_eq_iff list_all_eq_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"equal_base.list_distinct ceq' <span class="main">(</span>rev <span class="var">?product</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> * 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"equal_base.list_distinct ceq' <span class="main">(</span>rev <span class="var">?product</span><span class="main">)</span> <span class="main">∨</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> None"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ceq_prod_def ID_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> Id_on <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set_dlist"</span></span>
 <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> ceq<span class="main">:</span> <span class="quoted"><span class="quoted">"equal_base.list_distinct ceq' <span class="skolem">xs</span> <span class="main">∨</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">{</span></span> 
    <span class="keyword3"><span class="command">assume</span></span> ceq<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">≠</span> None"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"equal_base.list_distinct ceq' <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> ceq <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">≠</span> None"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"ceq' <span class="main">=</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"ceq' <span class="main">=</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ceq<span class="main"><span class="main">]</span></span> ceq_prod_def ID_None ID_Some <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?thesis</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_map <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> inj_onI<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="var">?thesis</span> <span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ceq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ceq<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ceq_prod_def ID_None<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> member_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"member empty <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> null_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"null <span class="free">xs</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> empty"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.null_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> list_of_dlist_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"list_of_dlist DList_Set.empty <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> empty.rep_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> list_of_dlist_insert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> member <span class="free">dxs</span> <span class="free">x</span> <span class="main">⟹</span> list_of_dlist <span class="main">(</span>insert <span class="free">x</span> <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="main">#</span> list_of_dlist <span class="free">dxs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">dxs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_Set.insert_def DList_Set.member_def Abs_dlist_inverse Abs_dlist_inject equal_base.list_insert_def List.member_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Abs_dlist_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> list_of_dlist_eq_Nil_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"list_of_dlist <span class="free">dxs</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟷</span> <span class="free">dxs</span> <span class="main">=</span> empty"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">dxs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_dlist_inverse Abs_dlist_inject DList_Set.empty_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fold_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"DList_Set.fold <span class="free">f</span> empty <span class="free">b</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> fold_insert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> member <span class="free">dxs</span> <span class="free">x</span> <span class="main">⟹</span> DList_Set.fold <span class="free">f</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">dxs</span><span class="main">)</span> <span class="free">b</span> <span class="main">=</span> DList_Set.fold <span class="free">f</span> <span class="free">dxs</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_base.list_insert_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> no_memb_fold_insert<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> member <span class="free">dxs</span> <span class="free">x</span> <span class="main">⟹</span> fold <span class="free">f</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">dxs</span><span class="main">)</span> <span class="free">b</span> <span class="main">=</span> fold <span class="free">f</span> <span class="free">dxs</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_base.list_insert_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_fold_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>List.fold List.insert <span class="free">xs1</span> <span class="free">xs2</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs1</span> <span class="main">∪</span> set <span class="free">xs2</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs1</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs2</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> list_of_dlist_eq_singleton_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list_of_dlist <span class="free">dxs</span> <span class="main">=</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span> <span class="main">⟷</span> <span class="free">dxs</span> <span class="main">=</span> DList_Set.insert <span class="free">x</span> DList_Set.empty"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">dxs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_base.list_insert_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> product_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"list_of_dlist <span class="main">(</span>product <span class="free">dxs1</span> <span class="free">dxs2</span><span class="main">)</span> <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">c</span> <span class="bound">rest</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">#</span> <span class="bound">rest</span><span class="main">)</span> <span class="free">dxs2</span><span class="main">)</span> <span class="free">dxs1</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">zs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rev <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> map <span class="main">(</span>Pair <span class="bound">x</span><span class="main">)</span> <span class="skolem">ys</span><span class="main">)</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">@</span> <span class="skolem">zs</span> <span class="main">=</span> 
          List.fold <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> List.fold <span class="main">(</span><span class="main">λ</span><span class="bound">c</span> <span class="bound">rest</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">#</span> <span class="bound">rest</span><span class="main">)</span> <span class="skolem">ys</span><span class="main">)</span> <span class="skolem">xs</span> <span class="skolem">zs</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">zs</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"List.fold <span class="main">(</span><span class="main">λ</span><span class="bound">c</span> <span class="bound">rest</span><span class="main">.</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">#</span> <span class="bound">rest</span><span class="main">)</span> <span class="skolem">ys</span> <span class="skolem">zs</span> <span class="main">=</span> rev <span class="main">(</span>map <span class="main">(</span>Pair <span class="skolem">x</span><span class="main">)</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">@</span> <span class="skolem">zs</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">zs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">with</span></span> Cons.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"rev <span class="main">(</span>map <span class="main">(</span>Pair <span class="skolem">x</span><span class="main">)</span> <span class="skolem">ys</span><span class="main">)</span> <span class="main">@</span> <span class="skolem">zs</span>"</span></span><span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"list_of_dlist <span class="free">dxs2</span>"</span></span> <span class="quoted"><span class="quoted">"list_of_dlist <span class="free">dxs1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> product.rep_eq fold.rep_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_list_of_dlist_Abs_dlist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>list_of_dlist <span class="main">(</span>Abs_dlist <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_dlist_def Abs_dlist'_inverse<span class="main">)</span><span class="main">(</span><span class="operator">subst</span> Abs_dlist'_inverse<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ceq<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> ID_ceq_neq_None<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ceq<span class="main">)</span> <span class="main">≠</span> None"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> equal_ceq<span class="main">:</span> <span class="quoted"><span class="quoted">"equal <span class="main">(</span>ceq' <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> ID_ceq_neq_None <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> ID_ceq<span class="main">)</span>

<span class="comment1">(* workaround for the next theorem *)</span>
<span class="keyword1"><span class="command">declare</span></span> Domainp_forall_transfer<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"pcr_set_dlist <span class="main">(=)</span>"</span></span><span class="main">,</span> <span class="operator">simplified</span> set_dlist.domain_eq<span class="main">,</span> <span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> set_dlist_induct <span class="main">[</span><span class="operator">case_names</span> Nil insert<span class="main">,</span> <span class="operator">induct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">type</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> set_dlist<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Nil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> empty"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">dxs</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">¬</span> member <span class="bound">dxs</span> <span class="bound">a</span><span class="main">;</span> <span class="free">P</span> <span class="bound">dxs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>insert <span class="bound">a</span> <span class="bound">dxs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">dxs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">transfer</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> NIL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> Insert<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> equal_base.list_distinct ceq' <span class="bound">xs</span> <span class="main">∨</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None
                 <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">¬</span> equal_base.list_member ceq' <span class="bound">xs</span> <span class="bound">x</span><span class="main">;</span> <span class="skolem">P</span> <span class="bound">xs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">P</span> <span class="main">(</span>equal_base.list_insert ceq' <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> Eq<span class="main">:</span> <span class="quoted"><span class="quoted">"equal_base.list_distinct ceq' <span class="skolem">xs</span> <span class="main">∨</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">from</span></span> Eq <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> NIL<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> Insert<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> equal.equal_eq<span class="main">[</span><span class="operator">OF</span> equal_ceq<span class="main">]</span> ID_ceq_neq_None
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.member_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> not_None_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fold_transfer2 <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_equality <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> pcr_set_dlist <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_set_dlist <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span>
    <span class="main">(</span>pcr_set_dlist <span class="main">(=)</span> <span class="main">::</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> set_dlist <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">===&gt;</span> pcr_set_dlist <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_set_dlist <span class="main">(=)</span><span class="main">)</span>
     List.fold DList_Set.fold"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Transfer.Rel_def set_dlist.pcr_cr_eq
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> list <span class="main">⇒</span> <span class="tfree">'b</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">ys</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">c</span>
  <span class="keyword3"><span class="command">assume</span></span> fg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> cr_set_dlist <span class="main">===&gt;</span> cr_set_dlist<span class="main">)</span> <span class="skolem">f</span> <span class="skolem">g</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"cr_set_dlist <span class="skolem">xs</span> <span class="skolem">ys</span>"</span></span> <span class="quoted"><span class="quoted">"cr_set_dlist <span class="skolem">b</span> <span class="skolem">c</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"cr_set_dlist <span class="main">(</span>List.fold <span class="skolem">f</span> <span class="skolem">xs</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">(</span>DList_Set.fold <span class="skolem">g</span> <span class="skolem">ys</span> <span class="skolem">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="skolem">b</span></span> <span class="quoted"><span class="skolem">c</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> set_dlist_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_set_dlist_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">y</span> <span class="skolem">dxs</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="skolem">y</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cr_set_dlist <span class="main">(</span>list_of_dlist <span class="skolem">c</span><span class="main">)</span> <span class="skolem">c</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_set_dlist_def is_equality_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> fg <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cr_set_dlist <span class="main">(</span><span class="skolem">f</span> <span class="skolem">y</span> <span class="main">(</span>list_of_dlist <span class="skolem">c</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="skolem">y</span> <span class="skolem">c</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> rel_funD<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> insert <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_set_dlist_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_list_of_dlist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>list_of_dlist <span class="main">(</span><span class="free">dxs</span> <span class="main">::</span> <span class="tfree">'a</span> set_dlist<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> list_of_dlist<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">dxs</span></span><span class="main">]</span> equal.equal_eq<span class="main">[</span><span class="operator">OF</span> equal_ceq<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ceq_neq_None<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_empty_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">.</span> <span class="main">¬</span> member <span class="free">dxs</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">dxs</span> <span class="main">=</span> empty"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equal_ceq<span class="main"><span class="main">]</span></span> List.member_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Collect_member<span class="main">:</span> <span class="quoted"><span class="quoted">"Collect <span class="main">(</span>member <span class="main">(</span><span class="free">dxs</span> <span class="main">::</span> <span class="tfree">'a</span> set_dlist<span class="main">)</span><span class="main">)</span> <span class="main">=</span> set <span class="main">(</span>list_of_dlist <span class="free">dxs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> member_def equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equal_ceq<span class="main"><span class="main">]</span></span> List.member_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"member <span class="main">(</span>insert <span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>member <span class="free">xs</span><span class="main">)</span><span class="main">(</span><span class="free">x</span> <span class="main">:=</span> True<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff List.member_def ID_ceq_neq_None equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equal_ceq<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_remove<span class="main">:</span>
  <span class="quoted"><span class="quoted">"member <span class="main">(</span>remove <span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>member <span class="free">xs</span><span class="main">)</span><span class="main">(</span><span class="free">x</span> <span class="main">:=</span> False<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff ID_ceq_neq_None equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equal_ceq<span class="main"><span class="main">]</span></span> List.member_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_union<span class="main">:</span> <span class="quoted"><span class="quoted">"member <span class="main">(</span>union <span class="main">(</span><span class="free">xs1</span> <span class="main">::</span> <span class="tfree">'a</span> set_dlist<span class="main">)</span> <span class="free">xs2</span><span class="main">)</span> <span class="free">x</span> <span class="main">⟷</span> member <span class="free">xs1</span> <span class="free">x</span> <span class="main">∨</span> member <span class="free">xs2</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> union_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equal_ceq<span class="main"><span class="main">]</span></span> List.member_def set_fold_insert<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_fold_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"member <span class="main">(</span>List.fold insert <span class="free">xs</span> <span class="free">dxs</span><span class="main">)</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⟷</span> member <span class="free">dxs</span> <span class="free">x</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ceq_neq_None equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equal_ceq<span class="main"><span class="main">]</span></span> List.member_def set_fold_insert<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> card_eq_length <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"card <span class="main">(</span>Collect <span class="main">(</span>member <span class="main">(</span><span class="free">dxs</span> <span class="main">::</span> <span class="tfree">'a</span> set_dlist<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> length <span class="free">dxs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ceq_neq_None equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equal_ceq<span class="main"><span class="main">]</span></span> List.member_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> distinct_card<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_member <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Collect <span class="main">(</span>member <span class="main">(</span><span class="free">dxs</span> <span class="main">::</span> <span class="tfree">'a</span> set_dlist<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ceq_neq_None equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equal_ceq<span class="main"><span class="main">]</span></span> List.member_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_filter <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"member <span class="main">(</span>filter <span class="free">P</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">.</span> member <span class="free">xs</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ceq_neq_None equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equal_ceq<span class="main"><span class="main">]</span></span> List.member_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dlist_all_conv_member<span class="main">:</span> <span class="quoted"><span class="quoted">"dlist_all <span class="free">P</span> <span class="free">dxs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">.</span> member <span class="free">dxs</span> <span class="bound">x</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ceq_neq_None equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equal_ceq<span class="main"><span class="main">]</span></span> list_all_iff List.member_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dlist_ex_conv_member<span class="main">:</span> <span class="quoted"><span class="quoted">"dlist_ex <span class="free">P</span> <span class="free">dxs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">.</span> member <span class="free">dxs</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ceq_neq_None equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> equal_ceq<span class="main"><span class="main">]</span></span> list_ex_iff List.member_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_Id_on<span class="main">:</span> <span class="quoted"><span class="quoted">"member <span class="main">(</span>Id_on <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">∧</span> member <span class="free">dxs</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(=)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> equal.equal_eq<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span><span class="main"><span class="main">=</span></span><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">,</span> <span class="operator">OF</span> equal_ceq<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ceq_prod_def list_all_eq_def ID_ceq_neq_None ID_Some fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> equal.equal_eq<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span><span class="main"><span class="main">=</span></span><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">,</span> <span class="operator">OF</span> equal_ceq<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ceq_neq_None List.member_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> ID_Some <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> product_member<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ceq<span class="main">)</span> <span class="main">≠</span> None"</span></span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span> <span class="main">::</span> ceq<span class="main">)</span> <span class="main">≠</span> None"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"member <span class="main">(</span>product <span class="free">dxs1</span> <span class="free">dxs2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">,</span> <span class="bound">b</span> <span class="main">::</span> <span class="tfree">'b</span><span class="main">)</span><span class="main">.</span> member <span class="free">dxs1</span> <span class="bound">a</span> <span class="main">∧</span> member <span class="free">dxs2</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ceq' <span class="main">=</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"ceq' <span class="main">=</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">::</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ceq<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ceq' <span class="main">=</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> bool<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ceq_prod_def list_all_eq_def ID_Some fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.member_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> empty insert remove null member length fold foldr union filter hd tl dlist_all product Id_on

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="RBT_Set2">
<div class="head">
<h1>Theory RBT_Set2</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/RBT_Set2.thy
    Author:     Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> RBT_Set2 
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="RBT_Mapping2.html">RBT_Mapping2</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Sets implemented by red-black trees›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_map_Pair_const<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="keyword1">then</span> Some <span class="free">v</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_rev_unit <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">*</span> unit<span class="main">)</span> list"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> map_of <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_add_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fold_split_conv_map_fst<span class="main">:</span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> fold <span class="free">f</span> <span class="main">(</span>map fst <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fold_map o_def split_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> foldr_split_conv_map_fst<span class="main">:</span> <span class="quoted"><span class="quoted">"foldr <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> foldr <span class="free">f</span> <span class="main">(</span>map fst <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> foldr_map o_def split_def fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_foldr_Cons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>foldr <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="main">#</span> <span class="bound">xs</span> <span class="keyword1">else</span> <span class="bound">xs</span><span class="main">)</span> <span class="free">as</span> <span class="main">[]</span><span class="main">)</span> <span class="main">⊆</span> set <span class="free">as</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">as</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_fst_foldr_Cons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map <span class="free">f</span> <span class="free">as</span><span class="main">)</span> <span class="main">⟹</span> distinct <span class="main">(</span>map <span class="free">f</span> <span class="main">(</span>foldr <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="main">#</span> <span class="bound">xs</span> <span class="keyword1">else</span> <span class="bound">xs</span><span class="main">)</span> <span class="free">as</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">as</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">as</span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> set_foldr_Cons<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="skolem">as</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> filter_conv_foldr<span class="main">:</span>
  <span class="quoted"><span class="quoted">"filter <span class="free">P</span> <span class="free">xs</span> <span class="main">=</span> foldr <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="main">#</span> <span class="bound">xs</span> <span class="keyword1">else</span> <span class="bound">xs</span><span class="main">)</span> <span class="free">xs</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_filter<span class="main">:</span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>fst <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> map_of <span class="free">xs</span> <span class="main">|`</span> Collect <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff restrict_map_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_of_map_Pair_key<span class="main">:</span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="free">f</span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> neq_Empty_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≠</span> rbt.Empty <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">c</span> <span class="bound">l</span> <span class="bound">k</span> <span class="bound">v</span> <span class="bound">r</span><span class="main">.</span> <span class="free">t</span> <span class="main">=</span> Branch <span class="bound">c</span> <span class="bound">l</span> <span class="bound">k</span> <span class="bound">v</span> <span class="bound">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_rbt_RBT_fold_rbt_insert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_rbt <span class="free">t</span> <span class="main">⟹</span> is_rbt <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> rbt_insert <span class="bound">k</span> <span class="bound">v</span><span class="main">)</span> <span class="free">xs</span> <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rbt_lookup_RBT_fold_rbt_insert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"is_rbt <span class="free">t</span> <span class="main">⟹</span> rbt_lookup <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> rbt_insert <span class="bound">k</span> <span class="bound">v</span><span class="main">)</span> <span class="free">xs</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> rbt_lookup <span class="free">t</span> <span class="main">++</span> map_of <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta fun_eq_iff rbt_lookup_rbt_insert<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_rbt_fold_rbt_delete <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_rbt <span class="free">t</span> <span class="main">⟹</span> is_rbt <span class="main">(</span>fold rbt_delete <span class="free">xs</span> <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rbt_lookup_fold_rbt_delete <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"is_rbt <span class="free">t</span> <span class="main">⟹</span> rbt_lookup <span class="main">(</span>fold rbt_delete <span class="free">xs</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> rbt_lookup <span class="free">t</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span> set <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rbt_lookup_rbt_delete ext<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> Un_insert_right compl_sup sup_bot_right<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_rbt_fold_rbt_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"is_rbt <span class="free">t</span> <span class="main">⟹</span> is_rbt <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> rbt_insert <span class="bound">k</span> <span class="main">(</span><span class="free">f</span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> rbt_lookup_fold_rbt_insert<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"is_rbt <span class="free">t</span> <span class="main">⟹</span> 
  rbt_lookup <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> rbt_insert <span class="bound">k</span> <span class="main">(</span><span class="free">f</span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> 
  rbt_lookup <span class="free">t</span> <span class="main">++</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="free">f</span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rbt_lookup_rbt_insert map_add_def fun_eq_iff map_of_map_Pair_key <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fold_rev</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> rbt <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'c</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fold_rev</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> List.foldr <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">k</span> <span class="bound">v</span><span class="main">)</span> <span class="main">(</span>RBT_Impl.entries <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fold_rev_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fold_rev <span class="free">f</span> RBT_Impl.Empty <span class="main">=</span> id"</span></span>
  <span class="quoted"><span class="quoted">"fold_rev <span class="free">f</span> <span class="main">(</span>Branch <span class="free">c</span> <span class="free">l</span> <span class="free">k</span> <span class="free">v</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> fold_rev <span class="free">f</span> <span class="free">l</span> <span class="keyword1">o</span> <span class="free">f</span> <span class="free">k</span> <span class="free">v</span> <span class="keyword1">o</span> fold_rev <span class="free">f</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fold_rev_def fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_fst_foldr_Cons<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>map <span class="free">f</span> <span class="free">as</span><span class="main">)</span> <span class="main">⟹</span> sorted <span class="main">(</span>map <span class="free">f</span> <span class="main">(</span>foldr <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">xs</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="main">#</span> <span class="bound">xs</span> <span class="keyword1">else</span> <span class="bound">xs</span><span class="main">)</span> <span class="free">as</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">as</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">as</span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> set_foldr_Cons<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">P</span></span> <span class="quoted"><span class="skolem">as</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type and operations›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> set_rbt <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> unit<span class="main">)</span> mapping_rbt"</span></span>

<span class="keyword1"><span class="command">translations</span></span> 
  <span class="main">(</span>type<span class="main">)</span> <span class="quoted">"<span class="tfree"><span class="free">'a</span></span> set_rbt"</span> <span class="main">&lt;=</span> <span class="main">(</span>type<span class="main">)</span> <span class="quoted">"<span class="main">(</span><span class="tfree"><span class="free">'a</span></span><span class="main">,</span> unit<span class="main">)</span> mapping_rbt"</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">Set_RBT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> unit<span class="main">)</span> RBT_Impl.rbt <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Set_RBT</span> <span class="main">≡</span> Mapping_RBT"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Primitive operations›</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> member <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">t</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> dom <span class="main">(</span>rbt_comp_lookup ccomp <span class="bound">t</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">empty</span> <span class="main">≡</span> RBT_Mapping2.empty"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">insert</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">insert</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≡</span> RBT_Mapping2.insert <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">()</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">remove</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">remove</span> <span class="main">≡</span> RBT_Mapping2.delete"</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> bulkload <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare list <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"rbt_comp_bulkload ccomp <span class="main">∘</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> linorder.rbt_bulkload_is_rbt ID_ccompare <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_bulkload<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">is_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_empty</span> <span class="main">≡</span> RBT_Mapping2.is_empty"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">union</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">union</span> <span class="main">≡</span> RBT_Mapping2.join <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> id<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">inter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">inter</span> <span class="main">≡</span> RBT_Mapping2.meet <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> id<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> inter_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">t</span> <span class="bound">xs</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> rbt_comp_insert ccomp <span class="bound">k</span> <span class="main">()</span><span class="main">)</span> <span class="main">[</span><span class="bound">x</span> <span class="main">←</span> <span class="bound">xs</span><span class="main">.</span> rbt_comp_lookup ccomp <span class="bound">t</span> <span class="bound">x</span> <span class="main">≠</span> None<span class="main">]</span> RBT_Impl.Empty"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ID_ccompare linorder.is_rbt_fold_rbt_insert ord.Empty_is_rbt <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_simps<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> minus <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt"</span></span> <span class="keyword2"><span class="keyword">is</span></span> 
  <span class="quoted"><span class="quoted">"rbt_comp_minus ccomp"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> linorder.rbt_minus_is_rbt ID_ccompare <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comp_minus<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">filter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">filter</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> RBT_Mapping2.filter <span class="main">(</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">∘</span> fst<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> fold <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">f</span><span class="main">.</span> RBT_Impl.fold <span class="main">(</span><span class="main">λ</span><span class="bound">a</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">f</span> <span class="bound">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> fold1 <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"RBT_Impl_fold1"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> keys <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"RBT_Impl.keys"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">all</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">all</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> RBT_Mapping2.all <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">k</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ex</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set_rbt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ex</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> RBT_Mapping2.ex <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">k</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">product</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set_rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">product</span> <span class="free"><span class="bound"><span class="entity">rbt1</span></span></span> <span class="free"><span class="bound"><span class="entity">rbt2</span></span></span> <span class="main">=</span> RBT_Mapping2.product <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">()</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">rbt1</span></span></span> <span class="free"><span class="bound"><span class="entity">rbt2</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Id_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set_rbt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Id_on</span> <span class="main">≡</span> RBT_Mapping2.diag"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> unit<span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> rbt_generator_state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">init</span> <span class="main">≡</span> RBT_Mapping2.init"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> member_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"member empty <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> member_def empty_def Mapping_RBT_inverse ord.Empty_is_rbt ord.rbt_lookup.simps fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fold_conv_fold_keys<span class="main">:</span> <span class="quoted"><span class="quoted">"RBT_Set2.fold <span class="free">f</span> <span class="free">rbt</span> <span class="free">b</span> <span class="main">=</span> List.fold <span class="free">f</span> <span class="main">(</span>RBT_Set2.keys <span class="free">rbt</span><span class="main">)</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_Set2.fold_def RBT_Set2.keys_def RBT_Impl.fold_def RBT_Impl.keys_def fold_map o_def split_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fold_conv_fold_keys'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fold <span class="free">f</span> <span class="free">t</span> <span class="main">=</span> List.fold <span class="free">f</span> <span class="main">(</span>RBT_Impl.keys <span class="main">(</span>RBT_Mapping2.impl_of <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fold.rep_eq RBT_Impl.fold_def RBT_Impl.keys_def fold_map o_def split_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_lookup <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"member <span class="free">t</span> <span class="free">x</span> <span class="main">⟷</span> RBT_Mapping2.lookup <span class="free">t</span> <span class="free">x</span> <span class="main">=</span> Some <span class="main">()</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> unfoldr_rbt_keys_generator<span class="main">:</span>
  <span class="quoted"><span class="quoted">"list.unfoldr rbt_keys_generator <span class="main">(</span>init <span class="free">t</span><span class="main">)</span> <span class="main">=</span> keys <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unfoldr_rbt_keys_generator<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keys_eq_Nil_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keys <span class="free">rbt</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟷</span> <span class="free">rbt</span> <span class="main">=</span> empty"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">rbt</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fold1_conv_fold<span class="main">:</span> <span class="quoted"><span class="quoted">"fold1 <span class="free">f</span> <span class="free">rbt</span> <span class="main">=</span> List.fold <span class="free">f</span> <span class="main">(</span>tl <span class="main">(</span>keys <span class="free">rbt</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>hd <span class="main">(</span>keys <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_Impl_fold1_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> ID_ccompare_neq_None<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">)</span> <span class="main">≠</span> None"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_linorder<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder <span class="main">(</span>cless_eq <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> cless"</span></span>
<span class="keyword1"><span class="command">using</span></span> ID_ccompare_neq_None <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> ID_ccompare<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ccomp_comparator<span class="main">:</span> <span class="quoted"><span class="quoted">"comparator <span class="main">(</span>ccomp <span class="main">::</span> <span class="tfree">'a</span> comparator<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ID_ccompare_neq_None <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> ID_ccompare'<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemmas</span></span> rbt_comps <span class="main">=</span> rbt_comp_simps<span class="main">[</span><span class="operator">OF</span> ccomp_comparator<span class="main">]</span> rbt_comp_minus<span class="main">[</span><span class="operator">OF</span> ccomp_comparator<span class="main">]</span> 

<span class="keyword1"><span class="command">lemma</span></span> is_rbt_impl_of <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ord.is_rbt cless <span class="main">(</span>RBT_Mapping2.impl_of <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ID_ccompare_neq_None impl_of <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> member_RBT<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ord.is_rbt cless <span class="free">t</span> <span class="main">⟹</span> member <span class="main">(</span>Set_RBT <span class="free">t</span><span class="main">)</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⟷</span> ord.rbt_lookup cless <span class="free">t</span> <span class="free">x</span> <span class="main">=</span> Some <span class="main">()</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> member_def Mapping_RBT_inverse rbt_comps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_impl_of<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ord.rbt_lookup cless <span class="main">(</span>RBT_Mapping2.impl_of <span class="free">t</span><span class="main">)</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">()</span> <span class="main">⟷</span> member <span class="free">t</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rbt_comps<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_insert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"member <span class="main">(</span>insert <span class="free">x</span> <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="tfree">'a</span> set_rbt<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>member <span class="free">t</span><span class="main">)</span><span class="main">(</span><span class="free">x</span> <span class="main">:=</span> True<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff linorder.rbt_lookup_rbt_insert<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_linorder<span class="main"><span class="main">]</span></span> ID_ccompare_neq_None<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_fold_insert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"member <span class="main">(</span>List.fold insert <span class="free">xs</span> <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="tfree">'a</span> set_rbt<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> member <span class="free">t</span> <span class="bound">x</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> member_remove <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"member <span class="main">(</span>remove <span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>member <span class="free">t</span><span class="main">)</span><span class="main">(</span><span class="free">x</span> <span class="main">:=</span> False<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linorder.rbt_lookup_rbt_delete<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_linorder<span class="main"><span class="main">]</span></span> ID_ccompare_neq_None fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_bulkload <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"member <span class="main">(</span>bulkload <span class="free">xs</span><span class="main">)</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linorder.rbt_lookup_rbt_bulkload<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_linorder<span class="main"><span class="main">]</span></span> rbt_comps map_of_map_Pair_const <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_conv_keys<span class="main">:</span> <span class="quoted"><span class="quoted">"member <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="main">(</span>keys <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None linorder.rbt_lookup_keys<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_linorder<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> is_empty_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_empty <span class="free">t</span> <span class="main">⟷</span> <span class="free">t</span> <span class="main">=</span> empty"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> rbt.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> RBT_lookup_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ord.rbt_lookup cless <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> unit<span class="main">)</span> rbt<span class="main">)</span> <span class="main">=</span> Map.empty <span class="main">⟷</span> <span class="free">t</span> <span class="main">=</span> RBT_Impl.Empty"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> linorder <span class="quoted"><span class="quoted">"cless_eq <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="quoted">cless</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> set_linorder<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> member_empty_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"member <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="tfree">'a</span> set_rbt<span class="main">)</span> <span class="main">=</span> empty"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None fun_eq_iff RBT_lookup_empty<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_union <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"member <span class="main">(</span>union <span class="main">(</span><span class="free">t1</span> <span class="main">::</span> <span class="tfree">'a</span> set_rbt<span class="main">)</span> <span class="free">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> member <span class="free">t1</span> <span class="bound">x</span> <span class="main">∨</span> member <span class="free">t2</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> member_lookup fun_eq_iff lookup_join<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare_neq_None<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_minus <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"member <span class="main">(</span>minus <span class="main">(</span><span class="free">t1</span> <span class="main">::</span> <span class="tfree">'a</span> set_rbt<span class="main">)</span> <span class="free">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> member <span class="free">t1</span> <span class="bound">x</span> <span class="main">∧</span> <span class="main">¬</span> member <span class="free">t2</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None fun_eq_iff rbt_comps linorder.rbt_lookup_rbt_minus<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_linorder<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_inter <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"member <span class="main">(</span>inter <span class="main">(</span><span class="free">t1</span> <span class="main">::</span> <span class="tfree">'a</span> set_rbt<span class="main">)</span> <span class="free">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> member <span class="free">t1</span> <span class="bound">x</span> <span class="main">∧</span> member <span class="free">t2</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> member_lookup fun_eq_iff lookup_meet<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare_neq_None<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_inter_list <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"member <span class="main">(</span>inter_list <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="tfree">'a</span> set_rbt<span class="main">)</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> member <span class="free">t</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None fun_eq_iff linorder.rbt_lookup_fold_rbt_insert<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_linorder<span class="main"><span class="main">]</span></span> ord.Empty_is_rbt map_of_map_Pair_key ord.rbt_lookup.simps rel_option_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm option.split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_filter <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"member <span class="main">(</span>filter <span class="free">P</span> <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="tfree">'a</span> set_rbt<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> member <span class="free">t</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> member_lookup fun_eq_iff lookup_filter<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare_neq_None<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_keys <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>keys <span class="main">(</span><span class="free">rbt</span> <span class="main">::</span> <span class="tfree">'a</span> set_rbt<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_ccompare_neq_None RBT_Impl.keys_def ord.is_rbt_rbt_sorted linorder.distinct_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_linorder<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> all_conv_all_member<span class="main">:</span>
  <span class="quoted"><span class="quoted">"all <span class="free">P</span> <span class="free">t</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">.</span> member <span class="free">t</span> <span class="bound">x</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> member_lookup all_conv_all_lookup<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare_neq_None<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ex_conv_ex_member<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ex <span class="free">P</span> <span class="free">t</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">.</span> member <span class="free">t</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> member_lookup ex_conv_ex_lookup<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare_neq_None<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_member<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Collect <span class="main">(</span>RBT_Set2.member <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="tfree">'a</span> set_rbt<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rbt_comps linorder.finite_dom_rbt_lookup<span class="main"><span class="main">[</span></span><span class="operator">OF</span> set_linorder<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_Id_on<span class="main">:</span> <span class="quoted"><span class="quoted">"member <span class="main">(</span>Id_on <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">,</span> <span class="bound">k'</span><span class="main">)</span><span class="main">.</span> <span class="bound">k</span> <span class="main">=</span> <span class="bound">k'</span> <span class="main">∧</span> member <span class="free">t</span> <span class="bound">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> member_lookup<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> diag_lookup<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare_neq_None<span class="main"><span class="main">]</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> ID_ccompare_neq_None'<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span> <span class="main">::</span> ccompare<span class="main">)</span> <span class="main">≠</span> None"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_linorder'<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder <span class="main">(</span>cless_eq <span class="main">::</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> cless"</span></span>
<span class="keyword1"><span class="command">using</span></span> ID_ccompare_neq_None' <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> ID_ccompare<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> member_product<span class="main">:</span>
  <span class="quoted"><span class="quoted">"member <span class="main">(</span>product <span class="free">rbt1</span> <span class="free">rbt2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ab</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">.</span> <span class="bound">ab</span> <span class="main">∈</span> Collect <span class="main">(</span>member <span class="free">rbt1</span><span class="main">)</span> <span class="main">×</span> Collect <span class="main">(</span>member <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff member_lookup product_def RBT_Mapping2.lookup_product ID_ccompare_neq_None ID_ccompare_neq_None' <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_RBT_Set_keys<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">)</span> <span class="main">=</span> Some <span class="free">c</span> 
  <span class="main">⟹</span> linorder.sorted <span class="main">(</span>le_of_comp <span class="free">c</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.keys <span class="free">rbt</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_Set2.keys.rep_eq RBT_Impl.keys_def linorder.rbt_sorted_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> ID_ccompare_neq_None<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>ccompare<span class="main">,</span> lattice<span class="main">}</span><span class="main">)</span> <span class="main">≠</span> None"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_linorder2<span class="main">:</span> <span class="quoted"><span class="quoted">"class.linorder <span class="main">(</span>cless_eq <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> cless"</span></span>
<span class="keyword1"><span class="command">using</span></span> ID_ccompare_neq_None <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> ID_ccompare<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_keys_Mapping_RBT<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>keys <span class="main">(</span>Mapping_RBT <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> set <span class="main">(</span>RBT_Impl.keys <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Empty <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping_RBT_def keys.rep_eq is_ccompare_def Mapping_RBT'_inverse ord.is_rbt_def ord.rbt_sorted.simps<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Branch <span class="skolem">c</span> <span class="skolem">l</span> <span class="skolem">k</span> <span class="skolem">v</span> <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"is_ccompare <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">∧</span> <span class="main">¬</span> ord.is_rbt cless <span class="main">(</span>Branch <span class="skolem">c</span> <span class="skolem">l</span> <span class="skolem">k</span> <span class="skolem">v</span> <span class="skolem">r</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Branch
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping_RBT_def keys.rep_eq is_ccompare_def Mapping_RBT'_inverse <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> not_None_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Branch
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping_RBT_def keys.rep_eq is_ccompare_def Mapping_RBT'_inverse RBT_ext.linorder.is_rbt_fold_rbt_insert_impl<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> linorder.rbt_insert_is_rbt<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> ord.Empty_is_rbt<span class="main">)</span><span class="main">(</span><span class="operator">subst</span> linorder.rbt_lookup_keys<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linorder.rbt_sorted_fold_insert<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> RBT_ext.linorder.rbt_lookup_fold_rbt_insert_impl<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> RBT_ext.linorder.rbt_lookup_rbt_insert'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> linorder.rbt_insert_rbt_sorted<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted ord.Empty_is_rbt dom_map_of_conv_image_fst RBT_Impl.keys_def ord.rbt_lookup.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> member empty insert remove bulkload union minus
  keys fold fold_rev filter all ex product Id_on init

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Closure_Set">
<div class="head">
<h1>Theory Closure_Set</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Closure_set.thy
    Author:     Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> Closure_Set <span class="keyword2"><span class="keyword">imports</span></span> <a href="Equal.html">Equal</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Sets implemented as Closures›</span></span>

<span class="keyword1"><span class="command">context</span></span> equal_base <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fun_upd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> fun_upd_apply<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fun_upd</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">a'</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">equal</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">a'</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a'</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> equal_base.fun_upd_apply
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> equal_base.fun_upd_apply

<span class="keyword1"><span class="command">lemma</span></span> fun_upd_conv_fun_upd<span class="main">:</span> <span class="quoted"><span class="quoted">"equal_base.fun_upd <span class="main">(=)</span> <span class="main">=</span> fun_upd"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Set_Impl">
<div class="head">
<h1>Theory Set_Impl</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Set_Impl.thy
    Author:     Andreas Lochbihler, KIT
                René Thiemann, UIBK *)</span>

<span class="keyword1"><span class="command">theory</span></span> Set_Impl <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Collection_Enum.html">Collection_Enum</a>
  <a href="DList_Set.html">DList_Set</a>
  <a href="RBT_Set2.html">RBT_Set2</a>
  <a href="Closure_Set.html">Closure_Set</a>
  <a href="Containers_Generator.html">Containers_Generator</a>
  <a href="../../HOL/HOL/Complex_Main.html">Complex_Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Different implementations of sets›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary functions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A simple quicksort implementation›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>sequential<span class="main">)</span> <span class="entity">quicksort_acc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">quicksort_part</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">quicksort_acc</span> <span class="free"><span class="bound"><span class="entity">ac</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ac</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">quicksort_acc</span> <span class="free"><span class="bound"><span class="entity">ac</span></span></span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ac</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">quicksort_acc</span> <span class="free"><span class="bound"><span class="entity">ac</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">quicksort_part</span> <span class="free"><span class="bound"><span class="entity">ac</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">[]</span> <span class="main">[]</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">quicksort_part</span> <span class="free"><span class="bound"><span class="entity">ac</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">lts</span></span></span> <span class="free"><span class="bound"><span class="entity">eqs</span></span></span> <span class="free"><span class="bound"><span class="entity">gts</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="free">quicksort_acc</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">eqs</span></span></span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free">quicksort_acc</span> <span class="free"><span class="bound"><span class="entity">ac</span></span></span> <span class="free"><span class="bound"><span class="entity">gts</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">lts</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">quicksort_part</span> <span class="free"><span class="bound"><span class="entity">ac</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">lts</span></span></span> <span class="free"><span class="bound"><span class="entity">eqs</span></span></span> <span class="free"><span class="bound"><span class="entity">gts</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">&gt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="free">quicksort_part</span> <span class="free"><span class="bound"><span class="entity">ac</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">lts</span></span></span> <span class="free"><span class="bound"><span class="entity">eqs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">gts</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="free">quicksort_part</span> <span class="free"><span class="bound"><span class="entity">ac</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">lts</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">eqs</span></span></span> <span class="free"><span class="bound"><span class="entity">gts</span></span></span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span>
   <span class="keyword1">else</span> <span class="free">quicksort_part</span> <span class="free"><span class="bound"><span class="entity">ac</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">lts</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">eqs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">gts</span></span></span> <span class="free"><span class="bound"><span class="entity">zs</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> length_quicksort_accp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"quicksort_acc_quicksort_part_dom <span class="main">(</span>Inl <span class="main">(</span><span class="free">ac</span><span class="main">,</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> length <span class="main">(</span>quicksort_acc <span class="free">ac</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> length <span class="free">ac</span> <span class="main">+</span> length <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> length_quicksort_partp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"quicksort_acc_quicksort_part_dom <span class="main">(</span>Inr <span class="main">(</span><span class="free">ac</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">lts</span><span class="main">,</span> <span class="free">eqs</span><span class="main">,</span> <span class="free">gts</span><span class="main">,</span> <span class="free">zs</span><span class="main">)</span><span class="main">)</span> 
  <span class="main">⟹</span> length <span class="main">(</span>quicksort_part <span class="free">ac</span> <span class="free">x</span> <span class="free">lts</span> <span class="free">eqs</span> <span class="free">gts</span> <span class="free">zs</span><span class="main">)</span> <span class="main">=</span> length <span class="free">ac</span> <span class="main">+</span> <span class="main">1</span> <span class="main">+</span> length <span class="free">lts</span> <span class="main">+</span> length <span class="free">eqs</span> <span class="main">+</span> length <span class="free">gts</span> <span class="main">+</span> length <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> quicksort_acc_quicksort_part.pinduct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> quicksort_acc.psimps quicksort_part.psimps<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">termination</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>case_sum <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">xs</span><span class="main">)</span><span class="main">.</span> <span class="numeral">2</span> <span class="main">*</span> length <span class="bound">xs</span> <span class="main">^</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">lts</span><span class="main">,</span> <span class="bound">eqs</span><span class="main">,</span> <span class="bound">gts</span><span class="main">,</span> <span class="bound">zs</span><span class="main">)</span><span class="main">.</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span>length <span class="bound">lts</span> <span class="main">+</span> length <span class="bound">eqs</span> <span class="main">+</span> length <span class="bound">gts</span> <span class="main">+</span> length <span class="bound">zs</span><span class="main">)</span> <span class="main">^</span> <span class="numeral">2</span> <span class="main">+</span> length <span class="bound">zs</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> power2_eq_square add_mult_distrib add_mult_distrib2 length_quicksort_accp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">quicksort</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">quicksort</span> <span class="main">=</span> quicksort_acc <span class="main">[]</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_quicksort_acc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>quicksort_acc <span class="free">ac</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">ac</span> <span class="main">∪</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> set_quicksort_part <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>quicksort_part <span class="free">ac</span> <span class="free">x</span> <span class="free">lts</span> <span class="free">eqs</span> <span class="free">gts</span> <span class="free">zs</span><span class="main">)</span> <span class="main">=</span>
  set <span class="free">ac</span> <span class="main">∪</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">∪</span> set <span class="free">lts</span> <span class="main">∪</span> set <span class="free">eqs</span> <span class="main">∪</span> set <span class="free">gts</span> <span class="main">∪</span> set <span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ac</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">ac</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">lts</span></span> <span class="quoted"><span class="free">eqs</span></span> <span class="quoted"><span class="free">gts</span></span> <span class="quoted"><span class="free">zs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> quicksort_acc_quicksort_part.induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_quicksort <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>quicksort <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> quicksort_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_quicksort_acc<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>quicksort_acc <span class="free">ac</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> distinct <span class="main">(</span><span class="free">ac</span> <span class="main">@</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> distinct_quicksort_part<span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>quicksort_part <span class="free">ac</span> <span class="free">x</span> <span class="free">lts</span> <span class="free">eqs</span> <span class="free">gts</span> <span class="free">zs</span><span class="main">)</span> <span class="main">=</span> distinct <span class="main">(</span><span class="free">ac</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span> <span class="main">@</span> <span class="free">lts</span> <span class="main">@</span> <span class="free">eqs</span> <span class="main">@</span> <span class="free">gts</span> <span class="main">@</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ac</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">ac</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">lts</span></span> <span class="quoted"><span class="free">eqs</span></span> <span class="quoted"><span class="free">gts</span></span> <span class="quoted"><span class="free">zs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> quicksort_acc_quicksort_part.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_quicksort <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>quicksort <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> distinct <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> quicksort_def distinct_quicksort_acc<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  ord.quicksort_acc.simps quicksort_acc.simps
  ord.quicksort_part.simps quicksort_part.simps
  ord.quicksort_def quicksort_def

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_quicksort_acc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sorted <span class="free">ac</span><span class="main">;</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set <span class="free">xs</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> set <span class="free">ac</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">a</span> <span class="main">⟧</span>
  <span class="main">⟹</span> sorted <span class="main">(</span>quicksort_acc <span class="free">ac</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> sorted_quicksort_part<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sorted <span class="free">ac</span><span class="main">;</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> set <span class="free">lts</span> <span class="main">∪</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">∪</span> set <span class="free">eqs</span> <span class="main">∪</span> set <span class="free">gts</span> <span class="main">∪</span> set <span class="free">zs</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> set <span class="free">ac</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">a</span><span class="main">;</span>
     <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> set <span class="free">lts</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="free">x</span><span class="main">;</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> set <span class="free">eqs</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">x</span><span class="main">;</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> set <span class="free">gts</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="free">x</span> <span class="main">⟧</span>
  <span class="main">⟹</span> sorted <span class="main">(</span>quicksort_part <span class="free">ac</span> <span class="free">x</span> <span class="free">lts</span> <span class="free">eqs</span> <span class="free">gts</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ac</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">ac</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">lts</span></span> <span class="quoted"><span class="free">eqs</span></span> <span class="quoted"><span class="free">gts</span></span> <span class="quoted"><span class="free">zs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> quicksort_acc_quicksort_part.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 3 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">ac</span> <span class="skolem">x</span> <span class="skolem">lts</span> <span class="skolem">eqs</span> <span class="skolem">gts</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> ac_greater <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="skolem">lts</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∪</span> set <span class="skolem">eqs</span> <span class="main">∪</span> set <span class="skolem">gts</span> <span class="main">∪</span> set <span class="main">[]</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>set <span class="skolem">ac</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">a</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">eqs</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">eqs</span> <span class="main">⊆</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="skolem">eqs</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="skolem">x</span>›</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">eqs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> set <span class="skolem">ac</span> <span class="main">∪</span> set <span class="skolem">gts</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="bound">y</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>set <span class="skolem">gts</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">a</span>›</span></span> ac_greater <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>quicksort_acc <span class="skolem">ac</span> <span class="skolem">gts</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹sorted <span class="skolem">ac</span>›</span></span> ac_greater <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> <span class="quoted">"4.IH"</span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span><span class="skolem">eqs</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> quicksort_acc <span class="skolem">ac</span> <span class="skolem">gts</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_append<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="skolem">lts</span><span class="main">.</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">eqs</span> <span class="main">@</span> <span class="skolem">x</span> <span class="main">#</span> quicksort_acc <span class="skolem">ac</span> <span class="skolem">gts</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">a</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="skolem">lts</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="skolem">x</span>›</span></span> ac_greater <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>set <span class="skolem">gts</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="bound">a</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="skolem">eqs</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="skolem">x</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted">"4.IH"</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 5 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_quicksort <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>quicksort <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> quicksort_def sorted_quicksort_acc<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> insort_key_append1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> set <span class="free">ys</span><span class="main">.</span> <span class="free">f</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="bound">y</span> <span class="main">⟹</span> insort_key <span class="free">f</span> <span class="free">x</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> insort_key <span class="free">f</span> <span class="free">x</span> <span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> insort_key_append2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> set <span class="free">xs</span><span class="main">.</span> <span class="free">f</span> <span class="free">x</span> <span class="main">&gt;</span> <span class="free">f</span> <span class="bound">y</span> <span class="main">⟹</span> insort_key <span class="free">f</span> <span class="free">x</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">@</span> insort_key <span class="free">f</span> <span class="free">x</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> sort_key_append<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="free">xs</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="free">ys</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="bound">y</span> <span class="main">⟹</span> sort_key <span class="free">f</span> <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> sort_key <span class="free">f</span> <span class="free">xs</span> <span class="main">@</span> sort_key <span class="free">f</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insort_key_append1<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">single_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">single_list</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> to_single_list<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">#</span> <span class="free">xs</span> <span class="main">=</span> single_list <span class="free">x</span> <span class="main">@</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> single_list_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sort_snoc<span class="main">:</span> <span class="quoted"><span class="quoted">"sort <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> insort <span class="free">x</span> <span class="main">(</span>sort <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insort_left_comm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sort_append_swap<span class="main">:</span> <span class="quoted"><span class="quoted">"sort <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> sort <span class="main">(</span><span class="free">ys</span> <span class="main">@</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sort_snoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sort_append_swap2<span class="main">:</span> <span class="quoted"><span class="quoted">"sort <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span> <span class="main">@</span> <span class="free">zs</span><span class="main">)</span> <span class="main">=</span> sort <span class="main">(</span><span class="free">ys</span> <span class="main">@</span> <span class="free">xs</span> <span class="main">@</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> sort_append_swap<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> sort_Cons_append_swap<span class="main">:</span> <span class="quoted"><span class="quoted">"sort <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sort <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> sort_append_swap<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> sort_append_Cons_swap<span class="main">:</span> <span class="quoted"><span class="quoted">"sort <span class="main">(</span><span class="free">ys</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sort <span class="main">(</span><span class="free">ys</span> <span class="main">@</span> <span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> append.simps sort_Cons_append_swap<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> quicksort_acc_conv_sort<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"quicksort_acc <span class="free">ac</span> <span class="free">xs</span> <span class="main">=</span> sort <span class="free">xs</span> <span class="main">@</span> <span class="free">ac</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> quicksort_part_conv_sort<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> set <span class="free">lts</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="free">x</span><span class="main">;</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> set <span class="free">eqs</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">x</span><span class="main">;</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> set <span class="free">gts</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="free">x</span> <span class="main">⟧</span> 
  <span class="main">⟹</span> quicksort_part <span class="free">ac</span> <span class="free">x</span> <span class="free">lts</span> <span class="free">eqs</span> <span class="free">gts</span> <span class="free">zs</span> <span class="main">=</span> sort <span class="main">(</span><span class="free">lts</span> <span class="main">@</span> <span class="free">eqs</span> <span class="main">@</span> <span class="free">gts</span> <span class="main">@</span> <span class="free">x</span> <span class="main">#</span> <span class="free">zs</span><span class="main">)</span> <span class="main">@</span> <span class="free">ac</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ac</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">ac</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">lts</span></span> <span class="quoted"><span class="free">eqs</span></span> <span class="quoted"><span class="free">gts</span></span> <span class="quoted"><span class="free">zs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> quicksort_acc_quicksort_part.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 3 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">ac</span> <span class="skolem">x</span> <span class="skolem">lts</span> <span class="skolem">eqs</span> <span class="skolem">gts</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> eqs <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="skolem">eqs</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="skolem">x</span>›</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">eqs</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="skolem">eqs</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"insort <span class="skolem">x</span> <span class="skolem">eqs</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">eqs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">eqs</span></span><span class="main">)</span> <span class="operator">simp_all</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> this
  <span class="keyword1"><span class="command">from</span></span> eqs <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sort <span class="skolem">eqs</span> <span class="main">=</span> <span class="skolem">eqs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">eqs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">from</span></span> eqs <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">eqs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">#</span> <span class="skolem">eqs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">eqs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> 4
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> sort_key_append<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> bspec<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> append_assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> sort_snoc <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> append_assoc<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> sort_key_append<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insort_key_append1 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> bspec<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>5 <span class="skolem">ac</span> <span class="skolem">x</span> <span class="skolem">lts</span> <span class="skolem">eqs</span> <span class="skolem">gts</span> <span class="skolem">z</span> <span class="skolem">zs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">¬</span> <span class="skolem">z</span> <span class="main">&lt;</span> <span class="skolem">x</span><span class="main">;</span> <span class="main">¬</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">z</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">z</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> 5
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> sort_key_simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> sort_key_simps <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> to_single_list<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> sort_append_swap<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">fold</span> append_assoc<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> sort_append_swap<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> sort_append_swap2<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> append_assoc<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 5<span class="main"><span class="main">)</span></span> append_assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> sort_append_swap<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> append_assoc<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> sort_append_swap2<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> sort_append_swap<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold</span> append_assoc<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> sort_append_swap2<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2 6<span class="main"><span class="main">)</span></span> append_assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2 5<span class="main"><span class="main">)</span></span> append_assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> sort_append_swap2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> append_assoc<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> sort_append_swap2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> quicksort_conv_sort<span class="main">:</span> <span class="quoted"><span class="quoted">"quicksort <span class="free">xs</span> <span class="main">=</span> sort <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> quicksort_def quicksort_acc_conv_sort<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sort_remdups<span class="main">:</span> <span class="quoted"><span class="quoted">"sort <span class="main">(</span>remdups <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> remdups <span class="main">(</span>sort <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> sorted_distinct_set_unique<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Removing duplicates from a sorted list›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">remdups_sorted</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">remdups_sorted</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">remdups_sorted</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">remdups_sorted</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free">remdups_sorted</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">remdups_sorted</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> ord.remdups_sorted.simps

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> sorted_remdups_sorted<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>remdups_sorted <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> set_remdups_sorted<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>remdups_sorted <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> remdups_sorted.induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_remdups_sorted <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span> <span class="main">⟹</span> distinct <span class="main">(</span>remdups_sorted <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> remdups_sorted.induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> remdups_sorted_conv_remdups<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span> <span class="main">⟹</span> remdups_sorted <span class="free">xs</span> <span class="main">=</span> remdups <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> remdups_sorted.induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An specialised operation to convert a finite set into a sorted list›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">csorted_list_of_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">csorted_list_of_set</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None <span class="main">∨</span> <span class="main">¬</span> finite <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> undefined <span class="keyword1">else</span> linorder.sorted_list_of_set cless_eq <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> csorted_list_of_set_set <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">)</span> <span class="main">=</span> Some <span class="free">c</span><span class="main">;</span> linorder.sorted <span class="main">(</span>le_of_comp <span class="free">c</span><span class="main">)</span> <span class="free">xs</span><span class="main">;</span> distinct <span class="free">xs</span> <span class="main">⟧</span> 
  <span class="main">⟹</span> linorder.sorted_list_of_set <span class="main">(</span>le_of_comp <span class="free">c</span><span class="main">)</span> <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_remdups_id linorder.sorted_list_of_set_sort_remdups<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> linorder.sorted_sort_id<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> csorted_list_of_set_split<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>csorted_list_of_set <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="main">∀</span><span class="bound">xs</span><span class="main">.</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">≠</span> None <span class="main">⟶</span> finite <span class="free">A</span> <span class="main">⟶</span> <span class="free">A</span> <span class="main">=</span> set <span class="bound">xs</span> <span class="main">⟶</span> distinct <span class="bound">xs</span> <span class="main">⟶</span> linorder.sorted cless_eq <span class="bound">xs</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">∧</span> 
  <span class="main">(</span>ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> None <span class="main">∨</span> <span class="main">¬</span> finite <span class="free">A</span> <span class="main">⟶</span> <span class="free">P</span> undefined<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> csorted_list_of_set_def linorder.sorted_list_of_set<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">code_identifier</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Set <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> Set_Impl
  <span class="main">|</span> <span class="keyword2"><span class="keyword">code_module</span></span> Set_Impl <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> Set_Impl

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Delete code equation with set as constructor›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_empty_unfold <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_eq <span class="free">A</span> <span class="main">{}</span> <span class="main">=</span> Set.is_empty <span class="free">A</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_eq <span class="main">{}</span> <span class="free">A</span> <span class="main">=</span> Set.is_empty <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Set.is_empty_def set_eq_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_UNIV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">is_UNIV</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> UNIV"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_UNIV_unfold <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> UNIV <span class="main">⟷</span> is_UNIV <span class="free">A</span>"</span></span> 
  <span class="quoted"><span class="quoted">"UNIV <span class="main">=</span> <span class="free">A</span> <span class="main">⟷</span> is_UNIV <span class="free">A</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_eq <span class="free">A</span> UNIV <span class="main">⟷</span> is_UNIV <span class="free">A</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_eq UNIV <span class="free">A</span> <span class="main">⟷</span> is_UNIV <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_UNIV_def set_eq_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code_unfold</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_post</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">≡</span> List.member <span class="free">xs</span> <span class="free">x</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.member_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code_unfold</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_post</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">≡</span> Cardinality.finite'"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code_unfold</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_post</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"card <span class="main">≡</span> Cardinality.card'"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span>
  <span class="quoted">Set.empty</span>
  <span class="quoted">Set.is_empty</span>
  <span class="quoted">uminus_set_inst.uminus_set</span>
  <span class="quoted">Set.member</span>
  <span class="quoted">Set.insert</span>
  <span class="quoted">Set.remove</span>
  <span class="quoted">UNIV</span>
  <span class="quoted">Set.filter</span>
  <span class="quoted">image</span>
  <span class="quoted">Set.subset_eq</span>
  <span class="quoted">Ball</span>
  <span class="quoted">Bex</span>
  <span class="quoted">Set.union</span>
  <span class="quoted">minus_set_inst.minus_set</span>
  <span class="quoted">Set.inter</span>
  <span class="quoted">card</span>
  <span class="quoted">Set.bind</span>
  <span class="quoted">the_elem</span>
  <span class="quoted">Pow</span>
  <span class="quoted">sum</span>
  <span class="quoted">Gcd</span>
  <span class="quoted">Lcm</span>
  <span class="quoted">Product_Type.product</span>
  <span class="quoted">Id_on</span>
  <span class="quoted">Image</span>
  <span class="quoted">trancl</span>
  <span class="quoted">relcomp</span>
  <span class="quoted">wf</span>
  <span class="quoted">Min</span>
  <span class="quoted">Inf_fin</span>
  <span class="quoted">Max</span>
  <span class="quoted">Sup_fin</span>
  <span class="quoted"><span class="quoted">"Inf <span class="main">::</span> <span class="tfree">'a</span> set set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
  <span class="quoted"><span class="quoted">"Sup <span class="main">::</span> <span class="tfree">'a</span> set set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
  <span class="quoted">sorted_list_of_set</span>
  <span class="quoted">List.map_project</span>
  <span class="quoted">Sup_pred_inst.Sup_pred</span>
  <span class="quoted">finite</span>
  <span class="quoted">Cardinality.finite'</span>
  <span class="quoted">card</span>
  <span class="quoted">Cardinality.card'</span>
  <span class="quoted">Inf_pred_inst.Inf_pred</span>
  <span class="quoted">pred_of_set</span>
  <span class="quoted">Cardinality.subset'</span>
  <span class="quoted">Cardinality.eq_set</span>
  <span class="quoted">Wellfounded.acc</span>
  <span class="quoted">Bleast</span>
  <span class="quoted">can_select</span>
  <span class="quoted"><span class="quoted">"set_eq <span class="main">::</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span>
  <span class="quoted">irrefl</span>
  <span class="quoted">bacc</span>
  <span class="quoted">set_of_pred</span>
  <span class="quoted">set_of_seq</span>
  <span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> 
  Cardinality.finite'_def<span class="main">[</span><span class="operator">code</span><span class="main">]</span>
  Cardinality.card'_def<span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Set implementations›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Collect_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Collect_set</span> <span class="main">=</span> Collect"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">DList_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">DList_set</span> <span class="main">=</span> Collect <span class="keyword1">o</span> DList_Set.member"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">RBT_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">RBT_set</span> <span class="main">=</span> Collect <span class="keyword1">o</span> RBT_Set2.member"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Complement</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Complement</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Set_Monad</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Set_Monad</span> <span class="main">=</span> set"</span></span>

<span class="keyword1"><span class="command">code_datatype</span></span> <span class="quoted">Collect_set</span> <span class="quoted">DList_set</span> <span class="quoted">RBT_set</span> <span class="quoted">Set_Monad</span> <span class="quoted">Complement</span>

<span class="keyword1"><span class="command">lemma</span></span> DList_set_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"DList_set DList_Set.empty <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> RBT_set_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"RBT_set RBT_Set2.empty <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> RBT_set_conv_keys<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">)</span> <span class="main">≠</span> None 
  <span class="main">⟹</span> RBT_set <span class="main">(</span><span class="free">t</span> <span class="main">::</span> <span class="tfree">'a</span> set_rbt<span class="main">)</span> <span class="main">=</span> set <span class="main">(</span>RBT_Set2.keys <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def member_conv_keys<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Set operations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A collection of all the theorems about <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Complement<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Set_Complement_Eqs</span> <span class="main">=</span> <span class="entity">Named_Thms</span>
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> set_complement_code<span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">description</span> <span class="main">=</span> <span class="inner_quoted">"Code equations involving set complement"</span>
<span class="main">)</span>
›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Set_Complement_Eqs.setup</span>›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Various fold operations over sets›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> comp_fun_commute <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">f</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">.</span> comp_fun_commute <span class="bound">f</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">morphisms</span></span> comp_fun_commute_apply Abs_comp_fun_commute
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> id"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_comp_fun_commute

<span class="keyword1"><span class="command">lemma</span></span> comp_fun_commute_apply' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"comp_fun_commute <span class="main">(</span>comp_fun_commute_apply <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> comp_fun_commute_apply<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lift_definition</span></span> set_fold_cfc <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> comp_fun_commute <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">set_fold_cfc</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> set_fold_cfc_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq list"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> set_fold_cfc_Complement<span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_fold_cfc <span class="free">f'''</span> <span class="free">b</span> <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span> <span class="main">=</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold_cfc not supported on Complement''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold_cfc <span class="free">f'''</span> <span class="free">b</span> <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted"><span class="quoted">"set_fold_cfc <span class="free">f'''</span> <span class="free">b</span> <span class="main">(</span>Collect_set <span class="free">P</span><span class="main">)</span> <span class="main">=</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold_cfc not supported on Collect_set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold_cfc <span class="free">f'''</span> <span class="free">b</span> <span class="main">(</span>Collect_set <span class="free">P</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_fold_cfc <span class="free">f</span> <span class="free">b</span> <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold_cfc Set_Monad: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold_cfc <span class="free">f</span> <span class="free">b</span> <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> List.fold <span class="main">(</span>comp_fun_commute_apply <span class="free">f</span><span class="main">)</span> <span class="main">(</span>equal_base.list_remdups <span class="bound">eq</span> <span class="free">xs</span><span class="main">)</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"set_fold_cfc <span class="free">f'</span> <span class="free">b</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold_cfc DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold_cfc <span class="free">f'</span> <span class="free">b</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.fold <span class="main">(</span>comp_fun_commute_apply <span class="free">f'</span><span class="main">)</span> <span class="free">dxs</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"set_fold_cfc <span class="free">f''</span> <span class="free">b</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold_cfc RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold_cfc <span class="free">f''</span> <span class="free">b</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.fold <span class="main">(</span>comp_fun_commute_apply <span class="free">f''</span><span class="main">)</span> <span class="free">rbt</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Collection_Eq.ID_ceq <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_fold_cfc_def comp_fun_commute.fold_set_fold_remdups<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Collection_Eq.ID_ceq <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.member_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> comp_fun_commute.fold_set_fold_remdups distinct_remdups_id<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_conv_keys fold_conv_fold_keys<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_fun_commute.fold_set_fold_remdups distinct_remdups_id linorder.distinct_keys<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> comp_fun_idem <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">f</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">.</span> comp_fun_idem <span class="bound">f</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">morphisms</span></span> comp_fun_idem_apply Abs_comp_fun_idem
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> id"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_comp_fun_idem

<span class="keyword1"><span class="command">lemma</span></span> comp_fun_idem_apply' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"comp_fun_idem <span class="main">(</span>comp_fun_idem_apply <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> comp_fun_idem_apply<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lift_definition</span></span> set_fold_cfi <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> comp_fun_idem <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">set_fold_cfi</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> set_fold_cfi_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ceq set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">::</span> ccompare set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"set_fold_cfi <span class="free">f</span> <span class="free">b</span> <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span> <span class="main">=</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold_cfi not supported on Complement''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold_cfi <span class="free">f</span> <span class="free">b</span> <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_fold_cfi <span class="free">f</span> <span class="free">b</span> <span class="main">(</span>Collect_set <span class="free">P</span><span class="main">)</span> <span class="main">=</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold_cfi not supported on Collect_set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold_cfi <span class="free">f</span> <span class="free">b</span> <span class="main">(</span>Collect_set <span class="free">P</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_fold_cfi <span class="free">f</span> <span class="free">b</span> <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> List.fold <span class="main">(</span>comp_fun_idem_apply <span class="free">f</span><span class="main">)</span> <span class="free">xs</span> <span class="free">b</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"set_fold_cfi <span class="free">f'</span> <span class="free">b</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold_cfi DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold_cfi <span class="free">f'</span> <span class="free">b</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.fold <span class="main">(</span>comp_fun_idem_apply <span class="free">f'</span><span class="main">)</span> <span class="free">dxs</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"set_fold_cfi <span class="free">f''</span> <span class="free">b</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold_cfi RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold_cfi <span class="free">f''</span> <span class="free">b</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.fold <span class="main">(</span>comp_fun_idem_apply <span class="free">f''</span><span class="main">)</span> <span class="free">rbt</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Collection_Eq.ID_ceq <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_fold_cfi_def comp_fun_idem.fold_set_fold<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Collection_Eq.ID_ceq <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.member_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> comp_fun_idem.fold_set_fold<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_conv_keys fold_conv_fold_keys<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_fun_idem.fold_set_fold<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'a</span> semilattice_set <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">f</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">.</span> semilattice_set <span class="bound">f</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">morphisms</span></span> semilattice_set_apply Abs_semilattice_set
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="keyword1">else</span> undefined<span class="main">)</span> <span class="main">∈</span> <span class="var">?semilattice_set</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mem_Collect_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_semilattice_set

<span class="keyword1"><span class="command">lemma</span></span> semilattice_set_apply' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"semilattice_set <span class="main">(</span>semilattice_set_apply <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> semilattice_set_apply<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> comp_fun_idem_semilattice_set_apply <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"comp_fun_idem <span class="main">(</span>semilattice_set_apply <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> semilattice_set <span class="quoted"><span class="quoted">"semilattice_set_apply <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff left_commute<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> 

<span class="keyword1"><span class="command">lift_definition</span></span> set_fold1 <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> semilattice_set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"semilattice_set.F"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> semilattice_set<span class="main">)</span> F_set_conv_fold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> F <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> Finite_Set.fold <span class="free">f</span> <span class="main">(</span>hd <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>set <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> neq_Nil_conv eq_fold<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_fold1_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>ccompare<span class="main">,</span> lattice<span class="main">}</span> set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> <span class="main">{</span>ceq<span class="main">,</span> lattice<span class="main">}</span> set_dlist"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  set_fold1_Complement<span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_fold1 <span class="free">f</span> <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span> <span class="main">=</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold1: Complement''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold1 <span class="free">f</span> <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"set_fold1 <span class="free">f</span> <span class="main">(</span>Collect_set <span class="free">P</span><span class="main">)</span> <span class="main">=</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold1: Collect_set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold1 <span class="free">f</span> <span class="main">(</span>Collect_set <span class="free">P</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"set_fold1 <span class="free">f</span> <span class="main">(</span>Set_Monad <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> fold <span class="main">(</span>semilattice_set_apply <span class="free">f</span><span class="main">)</span> <span class="free">xs</span> <span class="free">x</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Set_Monad</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted"><span class="quoted">"set_fold1 <span class="free">f'</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold1 DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold1 <span class="free">f'</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="keyword1">if</span> DList_Set.null <span class="free">dxs</span> <span class="keyword1">then</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold1 DList_set: empty set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold1 <span class="free">f'</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                              <span class="keyword1">else</span> DList_Set.fold <span class="main">(</span>semilattice_set_apply <span class="free">f'</span><span class="main">)</span> <span class="main">(</span>DList_Set.tl <span class="free">dxs</span><span class="main">)</span> <span class="main">(</span>DList_Set.hd <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?DList_set</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted"><span class="quoted">"set_fold1 <span class="free">f''</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold1 RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold1 <span class="free">f''</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="keyword1">if</span> RBT_Set2.is_empty <span class="free">rbt</span> <span class="keyword1">then</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_fold1 RBT_set: empty set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_fold1 <span class="free">f''</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                                 <span class="keyword1">else</span> RBT_Set2.fold1 <span class="main">(</span>semilattice_set_apply <span class="free">f''</span><span class="main">)</span> <span class="free">rbt</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?RBT_set</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_fold1_def semilattice_set.eq_fold comp_fun_idem.fold_set_fold<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_fold1_def semilattice_set.F_set_conv_fold comp_fun_idem.fold_set_fold DList_set_def DList_Set.Collect_member <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_fold1_def semilattice_set.F_set_conv_fold comp_fun_idem.fold_set_fold RBT_set_def RBT_Set2.member_conv_keys RBT_Set2.fold1_conv_fold <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Implementation of set operations›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Collect_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> cenum <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Collect <span class="free">P</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Collect_set <span class="free">P</span>
            <span class="main">|</span> Some <span class="main">(</span><span class="bound">enum</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> Set_Monad <span class="main">(</span>filter <span class="free">P</span> <span class="bound">enum</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_cenum<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">::</span> finite_UNIV set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''finite DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> finite <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''finite RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> finite <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> finite_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> of_phantom <span class="main">(</span>finite_UNIV <span class="main">::</span> <span class="tfree">'c</span> finite_UNIV<span class="main">)</span> <span class="keyword1">then</span> True
   <span class="keyword1">else</span> <span class="keyword1">if</span> finite <span class="free">A</span> <span class="keyword1">then</span> False
   <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''finite Complement: infinite set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> finite <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Collect_set <span class="free">P</span><span class="main">)</span> <span class="main">⟷</span>
  of_phantom <span class="main">(</span>finite_UNIV <span class="main">::</span> <span class="tfree">'c</span> finite_UNIV<span class="main">)</span> <span class="main">∨</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''finite Collect_set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> finite <span class="main">(</span>Collect_set <span class="free">P</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def RBT_set_def member_conv_keys card_gt_0_iff finite_UNIV <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">rotated</span> 1<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> card_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">::</span> card_UNIV set"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"card <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''card DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> card <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.length <span class="free">dxs</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"card <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''card RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> card <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                    <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> length <span class="main">(</span>RBT_Set2.keys <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"card <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''card Set_Monad: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> card <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> length <span class="main">(</span>equal_base.list_remdups <span class="bound">eq</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> card_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"card <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> card <span class="free">A</span><span class="main">;</span> <span class="bound">s</span> <span class="main">=</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span>
    <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">s</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="bound">s</span> <span class="main">-</span> <span class="bound">a</span> 
       <span class="keyword1">else</span> <span class="keyword1">if</span> finite <span class="free">A</span> <span class="keyword1">then</span> <span class="main">0</span>
       <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''card Complement: infinite''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> card <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def member_conv_keys distinct_card DList_set_def Let_def card_UNIV Compl_eq_Diff_UNIV card_Diff_subset_Int card_gt_0_iff finite_subset<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">A</span></span> <span class="quoted">UNIV</span><span class="main"><span class="main">]</span></span> List.card_set <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Collection_Eq.ID_ceq <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> is_UNIV_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>cproper_interval<span class="main">,</span> finite_UNIV<span class="main">}</span> set_rbt"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> card_UNIV set"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"is_UNIV <span class="free">A</span> <span class="main">⟷</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">b</span> <span class="main">=</span> card <span class="free">A</span>
    <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">a</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">b</span>
       <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span> False
       <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''is_UNIV called on infinite type and set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> is_UNIV <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?generic</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"is_UNIV <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''is_UNIV RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> is_UNIV <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> of_phantom <span class="main">(</span>finite_UNIV <span class="main">::</span> <span class="tfree">'a</span> finite_UNIV<span class="main">)</span> <span class="main">∧</span> proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator <span class="main">(</span>RBT_Set2.init <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">c</span>
    <span class="keyword3"><span class="command">assume</span></span> linorder<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> Some <span class="skolem">c</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_UNIV <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span>finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∧</span> proper_intrvl.exhaustive cproper_interval <span class="main">(</span>RBT_Set2.keys <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟷</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span><span class="main">[</span><span class="operator">unfolded</span> is_UNIV_def<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
        <span class="keyword1"><span class="command">using</span></span> linorder 
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_code<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"proper_intrvl.exhaustive cproper_interval <span class="main">(</span>RBT_Set2.keys <span class="free">rbt</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> linorder <span class="quoted"><span class="quoted">‹<span class="var">?lhs</span>›</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linorder_proper_interval.exhaustive_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare_interval<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> linorder<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span> sorted_RBT_Set_keys is_UNIV_def RBT_set_conv_keys<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">using</span></span> linorder
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linorder_proper_interval.exhaustive_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare_interval<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> linorder<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span> sorted_RBT_Set_keys is_UNIV_def RBT_set_conv_keys<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rbt</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_UNIV proper_intrvl.exhaustive_fusion_def unfoldr_rbt_keys_generator is_UNIV_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?generic</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def is_UNIV_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> card_seteq<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted">UNIV</span> <span class="quoted"><span class="free">A</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> card_ge_0_finite<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_empty_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> set"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Set.is_empty <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="quoted"><span class="quoted">"Set.is_empty <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''is_empty DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set.is_empty <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.null <span class="free">dxs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"Set.is_empty <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''is_empty RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set.is_empty <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.is_empty <span class="free">rbt</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> is_empty_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Set.is_empty <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> is_UNIV <span class="free">A</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Complement</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def Set.is_empty_def DList_Set.member_empty_empty <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def Set.is_empty_def RBT_Set2.member_empty_empty<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> fun_eq_iff <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> RBT_Set2.member_empty_empty <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Complement</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_UNIV_def Set.is_empty_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Set.is_empty_def List.null_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Set_insert_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> Set.insert <span class="bound">x</span> <span class="main">(</span>Collect_set <span class="free">A</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''insert Collect_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set.insert <span class="bound">x</span> <span class="main">(</span>Collect_set <span class="free">A</span><span class="main">)</span><span class="main">)</span>
                <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> Collect_set <span class="main">(</span>equal_base.fun_upd <span class="bound">eq</span> <span class="free">A</span> <span class="bound">x</span> True<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> Set.insert <span class="bound">x</span> <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> Set_Monad <span class="main">(</span><span class="bound">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> Set.insert <span class="bound">x</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''insert DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set.insert <span class="bound">x</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_set <span class="main">(</span>DList_Set.insert <span class="bound">x</span> <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> Set.insert <span class="bound">x</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''insert RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set.insert <span class="bound">x</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.insert <span class="bound">x</span> <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> insert_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> Set.insert <span class="bound">x</span> <span class="main">(</span>Complement <span class="free">X</span><span class="main">)</span> <span class="main">=</span> Complement <span class="main">(</span>Set.remove <span class="bound">x</span> <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ceq<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def DList_Set.member_insert RBT_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Set_member_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq list"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> Collect_set <span class="free">A</span> <span class="main">⟷</span> <span class="free">A</span> <span class="bound">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> DList_set <span class="free">dxs</span> <span class="main">⟷</span> DList_Set.member <span class="free">dxs</span> <span class="bound">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> RBT_set <span class="free">rbt</span> <span class="main">⟷</span> RBT_Set2.member <span class="free">rbt</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> mem_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> Complement <span class="free">X</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> Set_Monad <span class="free">xs</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''member Set_Monad: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> Set_Monad <span class="free">xs</span><span class="main">)</span>
                 <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> equal_base.list_member <span class="bound">eq</span> <span class="free">xs</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def RBT_set_def List.member_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Collection_Eq.ID_ceq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Set_remove_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ceq set_dlist"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> Set.remove <span class="bound">x</span> <span class="main">(</span>Collect_set <span class="free">A</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''remove Collect: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set.remove <span class="bound">x</span> <span class="main">(</span>Collect_set <span class="free">A</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> Collect_set <span class="main">(</span>equal_base.fun_upd <span class="bound">eq</span> <span class="free">A</span> <span class="bound">x</span> False<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> Set.remove <span class="bound">x</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''remove DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set.remove <span class="bound">x</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_set <span class="main">(</span>DList_Set.remove <span class="bound">x</span> <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> Set.remove <span class="bound">x</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''remove RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set.remove <span class="bound">x</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.remove <span class="bound">x</span> <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> remove_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">A</span><span class="main">.</span> Set.remove <span class="bound">x</span> <span class="main">(</span>Complement <span class="bound">A</span><span class="main">)</span> <span class="main">=</span> Complement <span class="main">(</span>Set.insert <span class="bound">x</span> <span class="bound">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split if_split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ceq<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def DList_Set.member_remove RBT_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Set_uminus_code <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">A</span> <span class="main">=</span> Complement <span class="free">A</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="main">(</span>Collect_set <span class="free">P</span><span class="main">)</span> <span class="main">=</span> Collect_set <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="main">(</span>Complement <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  These equations represent complements as true complements.
  If you want that the complement operations returns an explicit enumeration of the elements, use the following set of equations which use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cenum<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Set_uminus_cenum<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> cenum set"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="free">A</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CENUM</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Complement <span class="free">A</span>
            <span class="main">|</span> Some <span class="main">(</span><span class="bound">enum</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> Set_Monad <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">A</span><span class="main">)</span> <span class="bound">enum</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="main">(</span>Complement <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ID_cEnum<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Set_minus_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt1</span> <span class="free">rbt2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">-</span> <span class="free">B</span> <span class="main">=</span> <span class="free">A</span> <span class="main">∩</span> <span class="main">(</span><span class="main">-</span> <span class="free">B</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt1</span> <span class="main">-</span> RBT_set <span class="free">rbt2</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''minus RBT_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="main">-</span> RBT_set <span class="free">rbt2</span><span class="main">)</span>
    <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.minus <span class="free">rbt1</span> <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Set_member_code<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Set_union_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt1</span> <span class="free">rbt2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> <span class="main">{</span>ccompare<span class="main">,</span> ceq<span class="main">}</span> set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs1</span> <span class="free">dxs2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">::</span> ceq set_dlist"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt1</span> <span class="main">∪</span> RBT_set <span class="free">rbt2</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''union RBT_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="main">∪</span> RBT_set <span class="free">rbt2</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.union <span class="free">rbt1</span> <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set_RBT_set</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt</span> <span class="main">∪</span> DList_set <span class="free">dxs</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''union RBT_set DList_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt</span> <span class="main">∪</span> DList_set <span class="free">dxs</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
       <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''union RBT_set DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt</span> <span class="main">∪</span> DList_set <span class="free">dxs</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>DList_Set.fold RBT_Set2.insert <span class="free">dxs</span> <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set_DList_set</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs</span> <span class="main">∪</span> RBT_set <span class="free">rbt</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''union DList_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt</span> <span class="main">∪</span> DList_set <span class="free">dxs</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
       <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''union DList_set RBT_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt</span> <span class="main">∪</span> DList_set <span class="free">dxs</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>DList_Set.fold RBT_Set2.insert <span class="free">dxs</span> <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set_RBT_set</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs1</span> <span class="main">∪</span> DList_set <span class="free">dxs2</span> <span class="main">=</span> 
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''union DList_set DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs1</span> <span class="main">∪</span> DList_set <span class="free">dxs2</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_set <span class="main">(</span>DList_Set.union <span class="free">dxs1</span> <span class="free">dxs2</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set_DList_set</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"Set_Monad <span class="free">zs</span> <span class="main">∪</span> RBT_set <span class="free">rbt2</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''union Set_Monad RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set_Monad <span class="free">zs</span> <span class="main">∪</span> RBT_set <span class="free">rbt2</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>fold RBT_Set2.insert <span class="free">zs</span> <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad_RBT_set</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt1</span> <span class="main">∪</span> Set_Monad <span class="free">zs</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''union RBT_set Set_Monad: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="main">∪</span> Set_Monad <span class="free">zs</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>fold RBT_Set2.insert <span class="free">zs</span> <span class="free">rbt1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set_Set_Monad</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"Set_Monad <span class="free">ws</span> <span class="main">∪</span> DList_set <span class="free">dxs2</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''union Set_Monad DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set_Monad <span class="free">ws</span> <span class="main">∪</span> DList_set <span class="free">dxs2</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_set <span class="main">(</span>fold DList_Set.insert <span class="free">ws</span> <span class="free">dxs2</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad_DList_set</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs1</span> <span class="main">∪</span> Set_Monad <span class="free">ws</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''union DList_set Set_Monad: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs1</span> <span class="main">∪</span> Set_Monad <span class="free">ws</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_set <span class="main">(</span>fold DList_Set.insert <span class="free">ws</span> <span class="free">dxs1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set_Set_Monad</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"Set_Monad <span class="free">xs</span> <span class="main">∪</span> Set_Monad <span class="free">ys</span> <span class="main">=</span> Set_Monad <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Collect_set <span class="free">A</span> <span class="main">∪</span> <span class="free">B</span> <span class="main">=</span> Collect_set <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">A</span> <span class="bound">x</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">∪</span> Collect_set <span class="free">A</span> <span class="main">=</span> Collect_set <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">A</span> <span class="bound">x</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Set_union_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Complement <span class="free">B</span> <span class="main">∪</span> <span class="free">B'</span> <span class="main">=</span> Complement <span class="main">(</span><span class="free">B</span> <span class="main">∩</span> <span class="main">-</span> <span class="free">B'</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">B'</span> <span class="main">∪</span> Complement <span class="free">B</span> <span class="main">=</span> Complement <span class="main">(</span><span class="main">-</span> <span class="free">B'</span> <span class="main">∩</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set_RBT_set</span></span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad_RBT_set</span></span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set_Set_Monad</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set_DList_set</span></span></span> <span class="var"><span class="quoted"><span class="var">?DList_set_RBT_set</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def DList_set_def DList_Set.fold_def DList_Set.member_def List.member_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ceq<span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set_Set_Monad</span></span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad_DList_set</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def DList_Set.member_fold_insert<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set_DList_set</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def DList_Set.member_union<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Set_inter_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt1</span> <span class="free">rbt2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> <span class="main">{</span>ccompare<span class="main">,</span> ceq<span class="main">}</span> set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs1</span> <span class="free">dxs2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">::</span> ceq set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">xs1</span> <span class="free">xs2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> list"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Collect_set <span class="free">A''</span> <span class="main">∩</span> <span class="free">J</span> <span class="main">=</span> Collect_set <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">A''</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">J</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?collect1</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">J</span> <span class="main">∩</span> Collect_set <span class="free">A''</span> <span class="main">=</span> Collect_set <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">A''</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">J</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?collect2</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"Set_Monad <span class="free">xs''</span> <span class="main">∩</span> <span class="free">I</span> <span class="main">=</span> Set_Monad <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">I</span><span class="main">)</span> <span class="free">xs''</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?monad1</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">∩</span> Set_Monad <span class="free">xs''</span> <span class="main">=</span> Set_Monad <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">I</span><span class="main">)</span> <span class="free">xs''</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?monad2</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs1</span> <span class="main">∩</span> <span class="free">H</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter DList_set1: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs1</span> <span class="main">∩</span> <span class="free">H</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> DList_set <span class="main">(</span>DList_Set.filter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">H</span><span class="main">)</span> <span class="free">dxs1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?dlist1</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">H</span> <span class="main">∩</span> DList_set <span class="free">dxs2</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter DList_set2: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">H</span> <span class="main">∩</span> DList_set <span class="free">dxs2</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> DList_set <span class="main">(</span>DList_Set.filter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">H</span><span class="main">)</span> <span class="free">dxs2</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?dlist2</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt1</span> <span class="main">∩</span> <span class="free">G</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter RBT_set1: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="main">∩</span> <span class="free">G</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.filter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">G</span><span class="main">)</span> <span class="free">rbt1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt1</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">∩</span> RBT_set <span class="free">rbt2</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter RBT_set2: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">G</span> <span class="main">∩</span> RBT_set <span class="free">rbt2</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.filter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">G</span><span class="main">)</span> <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt2</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> Set_inter_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Complement <span class="free">B''</span> <span class="main">∩</span> Complement <span class="free">B'''</span> <span class="main">=</span> Complement <span class="main">(</span><span class="free">B''</span> <span class="main">∪</span> <span class="free">B'''</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?complement</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted"><span class="quoted">"Set_Monad <span class="free">xs</span> <span class="main">∩</span> RBT_set <span class="free">rbt1</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter Set_Monad RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="main">∩</span> Set_Monad <span class="free">xs</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.inter_list <span class="free">rbt1</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?monad_rbt</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"Set_Monad <span class="free">xs'</span> <span class="main">∩</span> DList_set <span class="free">dxs2</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter Set_Monad DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set_Monad <span class="free">xs'</span> <span class="main">∩</span> DList_set <span class="free">dxs2</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> DList_set <span class="main">(</span>DList_Set.filter <span class="main">(</span>equal_base.list_member <span class="bound">eq</span> <span class="free">xs'</span><span class="main">)</span> <span class="free">dxs2</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?monad_dlist</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"Set_Monad <span class="free">xs1</span> <span class="main">∩</span> Set_Monad <span class="free">xs2</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter Set_Monad Set_Monad: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set_Monad <span class="free">xs1</span> <span class="main">∩</span> Set_Monad <span class="free">xs2</span><span class="main">)</span>
                 <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> Set_Monad <span class="main">(</span>filter <span class="main">(</span>equal_base.list_member <span class="bound">eq</span> <span class="free">xs2</span><span class="main">)</span> <span class="free">xs1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?monad</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs</span> <span class="main">∩</span> RBT_set <span class="free">rbt</span> <span class="main">=</span> 
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter DList_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs</span> <span class="main">∩</span> RBT_set <span class="free">rbt</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
       <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter DList_set RBT_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs</span> <span class="main">∩</span> RBT_set <span class="free">rbt</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.inter_list <span class="free">rbt</span> <span class="main">(</span>list_of_dlist <span class="free">dxs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?dlist_rbt</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs1</span> <span class="main">∩</span> DList_set <span class="free">dxs2</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter DList_set DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs1</span> <span class="main">∩</span> DList_set <span class="free">dxs2</span><span class="main">)</span>
                   <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_set <span class="main">(</span>DList_Set.filter <span class="main">(</span>DList_Set.member <span class="free">dxs2</span><span class="main">)</span> <span class="free">dxs1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?dlist</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs1</span> <span class="main">∩</span> Set_Monad <span class="free">xs'</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter DList_set Set_Monad: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs1</span> <span class="main">∩</span> Set_Monad <span class="free">xs'</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> DList_set <span class="main">(</span>DList_Set.filter <span class="main">(</span>equal_base.list_member <span class="bound">eq</span> <span class="free">xs'</span><span class="main">)</span> <span class="free">dxs1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?dlist_monad</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt1</span> <span class="main">∩</span> RBT_set <span class="free">rbt2</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter RBT_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="main">∩</span> RBT_set <span class="free">rbt2</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.inter <span class="free">rbt1</span> <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt</span> <span class="main">∩</span> DList_set <span class="free">dxs</span> <span class="main">=</span> 
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter RBT_set DList_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt</span> <span class="main">∩</span> DList_set <span class="free">dxs</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
       <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter RBT_set DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt</span> <span class="main">∩</span> DList_set <span class="free">dxs</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.inter_list <span class="free">rbt</span> <span class="main">(</span>list_of_dlist <span class="free">dxs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_dlist</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt1</span> <span class="main">∩</span> Set_Monad <span class="free">xs</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''inter RBT_set Set_Monad: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="main">∩</span> Set_Monad <span class="free">xs</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.inter_list <span class="free">rbt1</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_monad</span></span></span><span class="main">)</span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span> <span class="var"><span class="quoted"><span class="var">?rbt1</span></span></span> <span class="var"><span class="quoted"><span class="var">?rbt2</span></span></span> <span class="var"><span class="quoted"><span class="var">?rbt_dlist</span></span></span> <span class="var"><span class="quoted"><span class="var">?rbt_monad</span></span></span> <span class="var"><span class="quoted"><span class="var">?dlist_rbt</span></span></span> <span class="var"><span class="quoted"><span class="var">?monad_rbt</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def DList_set_def DList_Set.member_def List.member_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ceq<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?dlist</span></span></span> <span class="var"><span class="quoted"><span class="var">?dlist1</span></span></span> <span class="var"><span class="quoted"><span class="var">?dlist2</span></span></span> <span class="var"><span class="quoted"><span class="var">?dlist_monad</span></span></span> <span class="var"><span class="quoted"><span class="var">?monad_dlist</span></span></span> <span class="var"><span class="quoted"><span class="var">?monad</span></span></span> <span class="var"><span class="quoted"><span class="var">?monad1</span></span></span> <span class="var"><span class="quoted"><span class="var">?monad2</span></span></span> <span class="var"><span class="quoted"><span class="var">?collect1</span></span></span> <span class="var"><span class="quoted"><span class="var">?collect2</span></span></span> <span class="var"><span class="quoted"><span class="var">?complement</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def List.member_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Collection_Eq.ID_ceq <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Set_bind_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Set.bind <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> fold <span class="main">(</span><span class="main">(∪)</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="free">xs</span> <span class="main">(</span>Set_Monad <span class="main">[]</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"Set.bind <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="free">f'</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''bind DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set.bind <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="free">f'</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.fold <span class="main">(</span>union <span class="main">∘</span> <span class="free">f'</span><span class="main">)</span> <span class="free">dxs</span> <span class="main">{}</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?DList</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"Set.bind <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="free">f''</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''bind RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set.bind <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="free">f''</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.fold <span class="main">(</span>union <span class="main">∘</span> <span class="free">f''</span><span class="main">)</span> <span class="free">rbt</span> <span class="main">{}</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?RBT</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bind_conv_fold<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?DList</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def DList_Set.member_def List.member_def List.member_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> set_bind_conv_fold DList_Set.fold_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ceq<span class="main"><span class="main">]</span></span> ID_ceq<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?RBT</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def RBT_Set2.fold_conv_fold_keys RBT_Set2.member_conv_keys set_bind_conv_fold<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> UNIV_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">=</span> <span class="main">-</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> inf_sls <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> lattice semilattice_set"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"inf"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">lemma</span></span> Inf_fin_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Inf_fin <span class="free">A</span> <span class="main">=</span> set_fold1 inf_sls <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_fin_def<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> sup_sls <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> lattice semilattice_set"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"sup"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">lemma</span></span> Sup_fin_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Sup_fin <span class="free">A</span> <span class="main">=</span> set_fold1 sup_sls <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_fin_def<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> inf_cfi <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> lattice<span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> comp_fun_idem"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"inf"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> comp_fun_idem_inf<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Inf_code<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> complete_lattice set"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Inf <span class="free">A</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">A</span> <span class="keyword1">then</span> set_fold_cfi inf_cfi top <span class="free">A</span> <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Inf: infinite''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Inf <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_fold_inf<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> sup_cfi <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> lattice<span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> comp_fun_idem"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"sup"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> comp_fun_idem_sup<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Sup_code<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> complete_lattice set"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Sup <span class="free">A</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">A</span> <span class="keyword1">then</span> set_fold_cfi sup_cfi bot <span class="free">A</span> <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Sup: infinite''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Sup <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_fold_sup<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> Inter_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> Inf_code<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">::</span> type set"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Union_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> Sup_code<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">::</span> type set"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Predicate_Inf_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> Inf_code<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">::</span> type Predicate.pred"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Predicate_Sup_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> Sup_code<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">::</span> type Predicate.pred"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Inf_fun_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> Inf_code<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">::</span> type <span class="main">⇒</span> <span class="main">_</span> <span class="main">::</span> complete_lattice"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Sup_fun_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> Sup_code<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">::</span> type <span class="main">⇒</span> <span class="main">_</span> <span class="main">::</span> complete_lattice"</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">lift_definition</span></span> min_sls <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> linorder semilattice_set"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">min</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">lemma</span></span> Min_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Min <span class="free">A</span> <span class="main">=</span> set_fold1 min_sls <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Min_def<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> max_sls <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> linorder semilattice_set"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">max</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">lemma</span></span> Max_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Max <span class="free">A</span> <span class="main">=</span> set_fold1 max_sls <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Max_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We do not implement <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Ball</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Bex</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">sorted_list_of_set</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Collect_set</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">cEnum</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  because it should already have been converted to an explicit list of elements if that is possible.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Ball_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ceq set_dlist"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="free">P</span> <span class="main">=</span> list_all <span class="free">P</span> <span class="free">xs</span>"</span></span>
  <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="free">P'</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Ball DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Ball <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="free">P'</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.dlist_all <span class="free">P'</span> <span class="free">dxs</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="free">P''</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Ball RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Ball <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="free">P''</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.all <span class="free">P''</span> <span class="free">rbt</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def RBT_set_def list_all_iff dlist_all_conv_member RBT_Set2.all_conv_all_member <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Bex_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ceq set_dlist"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Bex <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="free">P</span> <span class="main">=</span> list_ex <span class="free">P</span> <span class="free">xs</span>"</span></span>
  <span class="quoted"><span class="quoted">"Bex <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="free">P'</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Bex DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Bex <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="free">P'</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.dlist_ex <span class="free">P'</span> <span class="free">dxs</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Bex <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="free">P''</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Bex RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Bex <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="free">P''</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.ex <span class="free">P''</span> <span class="free">rbt</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def RBT_set_def list_ex_iff dlist_ex_conv_member RBT_Set2.ex_conv_ex_member <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> csorted_list_of_set_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> <span class="main">{</span>ccompare<span class="main">,</span> ceq<span class="main">}</span> set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare list"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"csorted_list_of_set <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''csorted_list_of_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> csorted_list_of_set <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.keys <span class="free">rbt</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"csorted_list_of_set <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''csorted_list_of_set DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> csorted_list_of_set <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
              <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''csorted_list_of_set DList_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> csorted_list_of_set <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span> ord.quicksort <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> <span class="main">(</span>list_of_dlist <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"csorted_list_of_set <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''csorted_list_of_set Set_Monad: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> csorted_list_of_set <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span><span class="main">)</span>
              <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span> ord.remdups_sorted <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> <span class="main">(</span>ord.quicksort <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def DList_set_def DList_Set.Collect_member member_conv_keys sorted_RBT_Set_keys linorder.sorted_list_of_set_sort_remdups<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> linorder.quicksort_conv_sort<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> distinct_remdups_id distinct_list_of_dlist linorder.remdups_sorted_conv_remdups<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> linorder.sorted_sort<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> linorder.sort_remdups<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> csorted_list_of_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> cless_set_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt</span> <span class="free">rbt'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt1</span> <span class="free">rbt2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> cproper_interval set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A</span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A'</span> <span class="free">B'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"cless_set <span class="free">A</span> <span class="free">B</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_set <span class="free">A</span> <span class="free">B</span><span class="main">)</span>
              <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
     <span class="keyword1">if</span> finite <span class="free">A</span> <span class="main">∧</span> finite <span class="free">B</span> <span class="keyword1">then</span> ord.lexordp <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> lt_of_comp <span class="bound">c</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>csorted_list_of_set <span class="free">A</span><span class="main">)</span> <span class="main">(</span>csorted_list_of_set <span class="free">B</span><span class="main">)</span>
     <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_set: infinite set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_set <span class="free">A</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?fin_fin</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cless_set_Complement2 <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cless_set <span class="free">A'</span> <span class="main">(</span>Complement <span class="free">B'</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_set Complement2: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_set <span class="free">A'</span> <span class="main">(</span>Complement <span class="free">B'</span><span class="main">)</span><span class="main">)</span>
              <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
     <span class="keyword1">if</span> finite <span class="free">A'</span> <span class="main">∧</span> finite <span class="free">B'</span> <span class="keyword1">then</span>
        finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">⟶</span>
        proper_intrvl.set_less_aux_Compl <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval None <span class="main">(</span>csorted_list_of_set <span class="free">A'</span><span class="main">)</span> <span class="main">(</span>csorted_list_of_set <span class="free">B'</span><span class="main">)</span>
     <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_set Complement2: infinite set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_set <span class="free">A'</span> <span class="main">(</span>Complement <span class="free">B'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?fin_Compl_fin</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cless_set_Complement1 <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cless_set <span class="main">(</span>Complement <span class="free">A'</span><span class="main">)</span> <span class="free">B'</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_set Complement1: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_set <span class="main">(</span>Complement <span class="free">A'</span><span class="main">)</span> <span class="free">B'</span><span class="main">)</span>
              <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
      <span class="keyword1">if</span> finite <span class="free">A'</span> <span class="main">∧</span> finite <span class="free">B'</span> <span class="keyword1">then</span>
        finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">∧</span>
        proper_intrvl.Compl_set_less_aux <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval None <span class="main">(</span>csorted_list_of_set <span class="free">A'</span><span class="main">)</span> <span class="main">(</span>csorted_list_of_set <span class="free">B'</span><span class="main">)</span>
      <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_set Complement1: infinite set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_set <span class="main">(</span>Complement <span class="free">A'</span><span class="main">)</span> <span class="free">B'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Compl_fin_fin</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cless_set_Complement12 <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cless_set <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span> <span class="main">(</span>Complement <span class="free">B</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_set Complement Complement: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_set <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span> <span class="main">(</span>Complement <span class="free">B</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> cless <span class="free">B</span> <span class="free">A</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_Compl</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted"><span class="quoted">"cless_set <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt'</span><span class="main">)</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_set RBT_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_set <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt'</span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span> ord.lexord_fusion <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> lt_of_comp <span class="bound">c</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span> rbt_keys_generator rbt_keys_generator <span class="main">(</span>RBT_Set2.init <span class="free">rbt</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt'</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cless_set_rbt_Complement2 <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cless_set <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>Complement <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_set RBT_set (Complement RBT_set): ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_set <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>Complement <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
     finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">⟶</span>
     proper_intrvl.set_less_aux_Compl_fusion <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval rbt_keys_generator rbt_keys_generator None <span class="main">(</span>RBT_Set2.init <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_Compl</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cless_set_rbt_Complement1 <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cless_set <span class="main">(</span>Complement <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_set (Complement RBT_set) RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_set <span class="main">(</span>Complement <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
     finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">∧</span> 
     proper_intrvl.Compl_set_less_aux_fusion <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval rbt_keys_generator rbt_keys_generator None <span class="main">(</span>RBT_Set2.init <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_rbt</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">split</span><span class="main">]</span> <span class="main">=</span> option.split csorted_list_of_set_split
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> 
    le_of_comp_of_ords_linorder<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">]</span>
    lt_of_comp_of_ords
    finite_subset<span class="main">[</span><span class="operator">OF</span> subset_UNIV<span class="main">]</span> ccompare_set_def ID_Some
    ord.lexord_fusion_def 
    proper_intrvl.Compl_set_less_aux_fusion_def
    proper_intrvl.set_less_aux_Compl_fusion_def
    unfoldr_rbt_keys_generator
    RBT_set_def sorted_RBT_Set_keys member_conv_keys
    linorder.set_less_finite_iff<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">]</span>
    linorder.set_less_aux_code<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
    linorder.Compl_set_less_Compl<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">]</span>
    linorder.infinite_set_less_Complement<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">]</span>
    linorder.infinite_Complement_set_less<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">]</span>
    linorder_proper_interval.set_less_aux_Compl2_conv_set_less_aux_Compl<span class="main">[</span><span class="operator">OF</span> ID_ccompare_interval<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
    linorder_proper_interval.Compl1_set_less_aux_conv_Compl_set_less_aux<span class="main">[</span><span class="operator">OF</span> ID_ccompare_interval<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_Compl</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
   <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_Compl</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_rbt</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?fin_fin</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?fin_Compl_fin</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_fin_fin</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> le_of_comp_set_less_eq<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"le_of_comp <span class="main">(</span>comp_of_ords <span class="main">(</span>ord.set_less_eq <span class="free">le</span><span class="main">)</span> <span class="main">(</span>ord.set_less <span class="free">le</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ord.set_less_eq <span class="free">le</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> le_of_comp_of_ords_gen<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord.set_less_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> cless_eq_set_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt</span> <span class="free">rbt'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt1</span> <span class="free">rbt2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> cproper_interval set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A</span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A'</span> <span class="free">B'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"cless_eq_set <span class="free">A</span> <span class="free">B</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_eq_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_eq_set <span class="free">A</span> <span class="free">B</span><span class="main">)</span>
              <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
     <span class="keyword1">if</span> finite <span class="free">A</span> <span class="main">∧</span> finite <span class="free">B</span> <span class="keyword1">then</span> 
        ord.lexordp_eq <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> lt_of_comp <span class="bound">c</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>csorted_list_of_set <span class="free">A</span><span class="main">)</span> <span class="main">(</span>csorted_list_of_set <span class="free">B</span><span class="main">)</span>
     <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_eq_set: infinite set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_eq_set <span class="free">A</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?fin_fin</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cless_eq_set_Complement2 <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cless_eq_set <span class="free">A'</span> <span class="main">(</span>Complement <span class="free">B'</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_eq_set Complement2: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_eq_set <span class="free">A'</span> <span class="main">(</span>Complement <span class="free">B'</span><span class="main">)</span><span class="main">)</span>
              <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
     <span class="keyword1">if</span> finite <span class="free">A'</span> <span class="main">∧</span> finite <span class="free">B'</span> <span class="keyword1">then</span> 
        finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">⟶</span>
        proper_intrvl.set_less_eq_aux_Compl <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval None <span class="main">(</span>csorted_list_of_set <span class="free">A'</span><span class="main">)</span> <span class="main">(</span>csorted_list_of_set <span class="free">B'</span><span class="main">)</span>
     <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_eq_set Complement2: infinite set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_eq_set <span class="free">A'</span> <span class="main">(</span>Complement <span class="free">B'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?fin_Compl_fin</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cless_eq_set_Complement1 <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cless_eq_set <span class="main">(</span>Complement <span class="free">A'</span><span class="main">)</span> <span class="free">B'</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_eq_set Complement1: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_eq_set <span class="main">(</span>Complement <span class="free">A'</span><span class="main">)</span> <span class="free">B'</span><span class="main">)</span>
              <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
    <span class="keyword1">if</span> finite <span class="free">A'</span> <span class="main">∧</span> finite <span class="free">B'</span> <span class="keyword1">then</span> 
      finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">∧</span>
      proper_intrvl.Compl_set_less_eq_aux <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval None <span class="main">(</span>csorted_list_of_set <span class="free">A'</span><span class="main">)</span> <span class="main">(</span>csorted_list_of_set <span class="free">B'</span><span class="main">)</span>
    <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_eq_set Complement1: infinite set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_eq_set <span class="main">(</span>Complement <span class="free">A'</span><span class="main">)</span> <span class="free">B'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Compl_fin_fin</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cless_eq_set_Complement12 <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cless_eq_set <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span> <span class="main">(</span>Complement <span class="free">B</span><span class="main">)</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_eq_set Complement Complement: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_eq <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span> <span class="main">(</span>Complement <span class="free">B</span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span> cless_eq_set <span class="free">B</span> <span class="free">A</span><span class="main">)</span>"</span></span> 
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_Compl</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"cless_eq_set <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt'</span><span class="main">)</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_eq_set RBT_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_eq_set <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt'</span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span> ord.lexord_eq_fusion <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> lt_of_comp <span class="bound">c</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span> rbt_keys_generator rbt_keys_generator <span class="main">(</span>RBT_Set2.init <span class="free">rbt</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt'</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cless_eq_set_rbt_Complement2 <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cless_eq_set <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>Complement <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_eq_set RBT_set (Complement RBT_set): ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_eq_set <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>Complement <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
     finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">⟶</span>
     proper_intrvl.set_less_eq_aux_Compl_fusion <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval rbt_keys_generator rbt_keys_generator None <span class="main">(</span>RBT_Set2.init <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_Compl</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cless_eq_set_rbt_Complement1 <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cless_eq_set <span class="main">(</span>Complement <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cless_eq_set (Complement RBT_set) RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cless_eq_set <span class="main">(</span>Complement <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
     finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">∧</span> 
     proper_intrvl.Compl_set_less_eq_aux_fusion <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval rbt_keys_generator rbt_keys_generator None <span class="main">(</span>RBT_Set2.init <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_rbt</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">split</span><span class="main">]</span> <span class="main">=</span> option.split csorted_list_of_set_split
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> 
    le_of_comp_set_less_eq
    finite_subset<span class="main">[</span><span class="operator">OF</span> subset_UNIV<span class="main">]</span> ccompare_set_def ID_Some
    ord.lexord_eq_fusion_def proper_intrvl.Compl_set_less_eq_aux_fusion_def
    proper_intrvl.set_less_eq_aux_Compl_fusion_def
    unfoldr_rbt_keys_generator
    RBT_set_def sorted_RBT_Set_keys member_conv_keys
    linorder.set_less_eq_finite_iff<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">]</span>
    linorder.set_less_eq_aux_code<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
    linorder.Compl_set_less_eq_Compl<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">]</span>
    linorder.infinite_set_less_eq_Complement<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">]</span>
    linorder.infinite_Complement_set_less_eq<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">]</span>
    linorder_proper_interval.set_less_eq_aux_Compl2_conv_set_less_eq_aux_Compl<span class="main">[</span><span class="operator">OF</span> ID_ccompare_interval<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
    linorder_proper_interval.Compl1_set_less_eq_aux_conv_Compl_set_less_eq_aux<span class="main">[</span><span class="operator">OF</span> ID_ccompare_interval<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_Compl</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span>
    
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_Compl</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_rbt</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?fin_fin</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?fin_Compl_fin</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_fin_fin</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cproper_interval_set_Some_Some_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt1</span> <span class="free">rbt2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> cproper_interval set_rbt"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A</span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>

  <span class="quoted"><span class="quoted">"cproper_interval <span class="main">(</span>Some <span class="free">A</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">B</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cproper_interval: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cproper_interval <span class="main">(</span>Some <span class="free">A</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">B</span><span class="main">)</span><span class="main">)</span>
              <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
       finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∧</span> proper_intrvl.proper_interval_set_aux <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval <span class="main">(</span>csorted_list_of_set <span class="free">A</span><span class="main">)</span> <span class="main">(</span>csorted_list_of_set <span class="free">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?fin_fin</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cproper_interval_set_Some_Some_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cproper_interval <span class="main">(</span>Some <span class="free">A</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>Complement <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cproper_interval Complement2: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cproper_interval <span class="main">(</span>Some <span class="free">A</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>Complement <span class="free">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
              <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
       finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∧</span> proper_intrvl.proper_interval_set_Compl_aux <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval None <span class="main">0</span> <span class="main">(</span>csorted_list_of_set <span class="free">A</span><span class="main">)</span> <span class="main">(</span>csorted_list_of_set <span class="free">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?fin_Compl_fin</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cproper_interval_set_Some_Complement_Some <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cproper_interval <span class="main">(</span>Some <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">B</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cproper_interval Complement1: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cproper_interval <span class="main">(</span>Some <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">B</span><span class="main">)</span><span class="main">)</span>
              <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
       finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∧</span> proper_intrvl.proper_interval_Compl_set_aux <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval None <span class="main">(</span>csorted_list_of_set <span class="free">A</span><span class="main">)</span> <span class="main">(</span>csorted_list_of_set <span class="free">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_fin_fin</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cproper_interval_set_Some_Complement_Some_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cproper_interval <span class="main">(</span>Some <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>Complement <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cproper_interval Complement Complement: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cproper_interval <span class="main">(</span>Some <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>Complement <span class="free">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> cproper_interval <span class="main">(</span>Some <span class="free">B</span><span class="main">)</span> <span class="main">(</span>Some <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_Compl</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"cproper_interval <span class="main">(</span>Some <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cproper_interval RBT_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cproper_interval <span class="main">(</span>Some <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
     finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∧</span> proper_intrvl.proper_interval_set_aux_fusion <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval rbt_keys_generator rbt_keys_generator <span class="main">(</span>RBT_Set2.init <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cproper_interval_set_Some_rbt_Some_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cproper_interval <span class="main">(</span>Some <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>Complement <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cproper_interval RBT_set (Complement RBT_set): ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cproper_interval <span class="main">(</span>Some <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>Complement <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
     finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∧</span> proper_intrvl.proper_interval_set_Compl_aux_fusion <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval rbt_keys_generator rbt_keys_generator None <span class="main">0</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_Compl_rbt</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cproper_interval_set_Some_Complement_Some_rbt <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cproper_interval <span class="main">(</span>Some <span class="main">(</span>Complement <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''cproper_interval (Complement RBT_set) RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> cproper_interval <span class="main">(</span>Some <span class="main">(</span>Complement <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Some <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span>
     finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∧</span> proper_intrvl.proper_interval_Compl_set_aux_fusion <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> cproper_interval rbt_keys_generator rbt_keys_generator None <span class="main">(</span>RBT_Set2.init <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_rbt_rbt</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">split</span><span class="main">]</span> <span class="main">=</span> option.split csorted_list_of_set_split
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> 
    lt_of_comp_of_ords
    finite_subset<span class="main">[</span><span class="operator">OF</span> subset_UNIV<span class="main">]</span> ccompare_set_def ID_Some
    linorder.set_less_finite_iff<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">]</span>
    RBT_set_def sorted_RBT_Set_keys member_conv_keys
    linorder.distinct_entries<span class="main">[</span><span class="operator">OF</span> ID_ccompare<span class="main">]</span>
    unfoldr_rbt_keys_generator
    proper_intrvl.proper_interval_set_aux_fusion_def
    proper_intrvl.proper_interval_set_Compl_aux_fusion_def
    proper_intrvl.proper_interval_Compl_set_aux_fusion_def 
    linorder_proper_interval.proper_interval_set_aux<span class="main">[</span><span class="operator">OF</span> ID_ccompare_interval<span class="main">]</span>
    linorder_proper_interval.proper_interval_set_Compl_aux<span class="main">[</span><span class="operator">OF</span> ID_ccompare_interval<span class="main">]</span>
    linorder_proper_interval.proper_interval_Compl_set_aux<span class="main">[</span><span class="operator">OF</span> ID_ccompare_interval<span class="main">]</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">cong</span><span class="main">]</span> <span class="main">=</span> conj_cong

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Compl_Compl</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Complement_cproper_interval_set_Complement <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> cproper_interval_set_Some_Some<span class="main">)</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span> <span class="var"><span class="quoted"><span class="var">?rbt_Compl_rbt</span></span></span> <span class="var"><span class="quoted"><span class="var">?Compl_rbt_rbt</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?fin_fin</span></span></span> <span class="var"><span class="quoted"><span class="var">?fin_Compl_fin</span></span></span> <span class="var"><span class="quoted"><span class="var">?Compl_fin_fin</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> ord <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">sorted_list_subset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sorted_list_subset</span> <span class="free"><span class="bound"><span class="entity">eq</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">sorted_list_subset</span> <span class="free"><span class="bound"><span class="entity">eq</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="main">=</span> False"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">sorted_list_subset</span> <span class="free"><span class="bound"><span class="entity">eq</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">eq</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> <span class="free">sorted_list_subset</span> <span class="free"><span class="bound"><span class="entity">eq</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>
   <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&gt;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">∧</span> <span class="free">sorted_list_subset</span> <span class="free"><span class="bound"><span class="entity">eq</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> linorder <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_list_subset_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> sorted <span class="free">xs</span><span class="main">;</span> distinct <span class="free">xs</span><span class="main">;</span> sorted <span class="free">ys</span><span class="main">;</span> distinct <span class="free">ys</span> <span class="main">⟧</span> 
  <span class="main">⟹</span> sorted_list_subset <span class="main">(=)</span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> set <span class="free">xs</span> <span class="main">⊆</span> set <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="main">(=)</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sorted_list_subset.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> 6 2<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> eq_iff insert_iff subsetD<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> ord <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sorted_list_subset_fusion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s1</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s2</span><span class="main">)</span> generator <span class="main">⇒</span> <span class="tfree">'s1</span> <span class="main">⇒</span> <span class="tfree">'s2</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sorted_list_subset_fusion</span> <span class="free"><span class="bound"><span class="entity">eq</span></span></span> <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span> sorted_list_subset <span class="free"><span class="bound"><span class="entity">eq</span></span></span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g1</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span><span class="main">)</span> <span class="main">(</span>list.unfoldr <span class="free"><span class="bound"><span class="entity">g2</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_list_subset_fusion_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sorted_list_subset_fusion <span class="free">eq</span> <span class="free">g1</span> <span class="free">g2</span> <span class="free">s1</span> <span class="free">s2</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> list.has_next <span class="free">g1</span> <span class="free">s1</span> <span class="keyword1">then</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g1</span> <span class="free">s1</span>
     <span class="keyword1">in</span> list.has_next <span class="free">g2</span> <span class="free">s2</span> <span class="main">∧</span> <span class="main">(</span>
        <span class="keyword1">let</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">=</span> list.next <span class="free">g2</span> <span class="free">s2</span> 
        <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="free">eq</span> <span class="bound">x</span> <span class="bound">y</span> <span class="keyword1">then</span> sorted_list_subset_fusion <span class="free">eq</span> <span class="free">g1</span> <span class="free">g2</span> <span class="bound">s1'</span> <span class="bound">s2'</span> 
           <span class="keyword1">else</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="main">∧</span> sorted_list_subset_fusion <span class="free">eq</span> <span class="free">g1</span> <span class="free">g2</span> <span class="free">s1</span> <span class="bound">s2'</span><span class="main">)</span>
   <span class="keyword1">else</span> True<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> sorted_list_subset_fusion_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 5<span class="main"><span class="main">)</span></span> list.unfoldr.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta Let_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> ord.sorted_list_subset_fusion_code

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Define a new constant for the subset operation
  because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="../../HOL/HOL-Library/Cardinality.html"></a><a href="../../HOL/HOL-Library/Cardinality.html">HOL-Library.Cardinality</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span> introduces <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Cardinality.subset'"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
  and rewrites <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "subset"<span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Cardinality.subset'"<span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  based on the sort of the element type.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">subset_eq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">subset_eq</span> <span class="main">=</span> <span class="main">(⊆)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> subseteq_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(⊆)</span> <span class="main">=</span> subset_eq"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> subset'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Cardinality.subset' <span class="main">=</span> subset_eq"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> subset_eq_code <span class="main">[</span><span class="operator">folded</span> subset_eq_def<span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A1</span> <span class="free">A2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt1</span> <span class="free">rbt2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> <span class="main">::</span> <span class="main">{</span>ccompare<span class="main">,</span> ceq<span class="main">}</span> set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">::</span> ceq set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> list"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt</span> <span class="main">⊆</span> <span class="free">B</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''subset RBT_set1: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt</span> <span class="main">⊆</span> <span class="free">B</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> list_all_fusion rbt_keys_generator <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">B</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs</span> <span class="main">⊆</span> <span class="free">C</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''subset DList_set1: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs</span> <span class="main">⊆</span> <span class="free">C</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.dlist_all <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">C</span><span class="main">)</span> <span class="free">dxs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?dlist</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"Set_Monad <span class="free">xs</span> <span class="main">⊆</span> <span class="free">C</span> <span class="main">⟷</span> list_all <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">C</span><span class="main">)</span> <span class="free">xs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> Collect_subset_eq_Complement <span class="main">[</span><span class="operator">folded</span> subset_eq_def<span class="main">,</span> <span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Collect_set <span class="free">P</span> <span class="main">⊆</span> Complement <span class="free">A</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Collect_set_Compl</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> Complement_subset_eq_Complement <span class="main">[</span><span class="operator">folded</span> subset_eq_def<span class="main">,</span> <span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Complement <span class="free">A1</span> <span class="main">⊆</span> Complement <span class="free">A2</span> <span class="main">⟷</span> <span class="free">A2</span> <span class="main">⊆</span> <span class="free">A1</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Compl</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt1</span> <span class="main">⊆</span> RBT_set <span class="free">rbt2</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'d</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''subset RBT_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="main">⊆</span> RBT_set <span class="free">rbt2</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span> 
    <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'d</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> ord.sorted_list_subset_fusion <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">c</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">=</span> Eq<span class="main">)</span> rbt_keys_generator rbt_keys_generator <span class="main">(</span>RBT_Set2.init <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt2</span><span class="main">)</span>
                   <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> ord.sorted_list_subset_fusion <span class="main">(</span>lt_of_comp <span class="bound">c</span><span class="main">)</span> <span class="bound">eq</span> rbt_keys_generator rbt_keys_generator <span class="main">(</span>RBT_Set2.init <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comparator.eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span> RBT_set_def member_conv_keys unfoldr_rbt_keys_generator ord.sorted_list_subset_fusion_def linorder.sorted_list_subset_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> sorted_RBT_Set_keys <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ID_ceq<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equal.equal_eq<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rbt</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def member_conv_keys list_all_fusion_def unfoldr_rbt_keys_generator keys.rep_eq list_all_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?dlist</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def dlist_all_conv_member <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Collect_set_Compl</span></span></span> <span class="var"><span class="quoted"><span class="var">?Compl</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> subset_eq
<span class="keyword1"><span class="command">hide_fact</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> subset_eq_def

<span class="keyword1"><span class="command">lemma</span></span> eq_set_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Cardinality.eq_set <span class="main">=</span> set_eq"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_eq_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_eq_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt1</span> <span class="free">rbt2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> <span class="main">{</span>ccompare<span class="main">,</span> ceq<span class="main">}</span> set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"set_eq <span class="free">A</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">⊆</span> <span class="free">B</span> <span class="main">∧</span> <span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> set_eq_Complement_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_eq <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span> <span class="main">(</span>Complement <span class="free">B</span><span class="main">)</span> <span class="main">=</span> set_eq <span class="free">A</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted"><span class="quoted">"set_eq <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_eq RBT_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_eq <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span> 
     <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> list_all2_fusion <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">c</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">=</span> Eq<span class="main">)</span> rbt_keys_generator rbt_keys_generator <span class="main">(</span>RBT_Set2.init <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt2</span><span class="main">)</span>
                    <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> list_all2_fusion <span class="bound">eq</span> rbt_keys_generator rbt_keys_generator <span class="main">(</span>RBT_Set2.init <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comparator.eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span> sorted_RBT_Set_keys list_all2_fusion_def unfoldr_rbt_keys_generator RBT_set_conv_keys set_eq_def list.rel_eq <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ID_ceq<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equal.equal_eq<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> linorder.sorted_distinct_set_unique<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_eq_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Set_project_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Set.filter <span class="free">P</span> <span class="free">A</span> <span class="main">=</span> <span class="free">A</span> <span class="main">∩</span> Collect_set <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Set.filter_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Set_image_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"image <span class="free">f</span> <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> Set_Monad <span class="main">(</span>map <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"image <span class="free">f</span> <span class="main">(</span>Collect_set <span class="free">A</span><span class="main">)</span> <span class="main">=</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''image Collect_set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> image <span class="free">f</span> <span class="main">(</span>Collect_set <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> image_Complement_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"image <span class="free">f</span> <span class="main">(</span>Complement <span class="main">(</span>Complement <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> image <span class="free">f</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted"><span class="quoted">"image <span class="free">g</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''image DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> image <span class="free">g</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.fold <span class="main">(</span>insert <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="free">dxs</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?dlist</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"image <span class="free">h</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''image RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> image <span class="free">h</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.fold <span class="main">(</span>insert <span class="main">∘</span> <span class="free">h</span><span class="main">)</span> <span class="free">rbt</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span>insert <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">{}</span> <span class="main">=</span> <span class="free">g</span> <span class="main">`</span> set <span class="skolem">xs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="operator">simp_all</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?dlist</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def DList_Set.fold_def DList_Set.Collect_member <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span>insert <span class="main">∘</span> <span class="free">h</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">{}</span> <span class="main">=</span> <span class="free">h</span> <span class="main">`</span> set <span class="skolem">xs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="operator">simp_all</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rbt</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def fold_conv_fold_keys member_conv_keys <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> the_elem_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"the_elem <span class="main">(</span>Set_Monad <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"the_elem <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''the_elem DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> the_elem <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> 
     <span class="keyword1">case</span> list_of_dlist <span class="free">dxs</span> <span class="keyword1">of</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span> <span class="main">⇒</span> <span class="bound">x</span> 
       <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''the_elem DList_set: not unique''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> the_elem <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"the_elem <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''the_elem RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> the_elem <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> 
     <span class="keyword1">case</span> RBT_Mapping2.impl_of <span class="free">rbt</span> <span class="keyword1">of</span> RBT_Impl.Branch <span class="main"><span class="bound">_</span></span> RBT_Impl.Empty <span class="bound">x</span> <span class="main"><span class="bound">_</span></span> RBT_Impl.Empty <span class="main">⇒</span> <span class="bound">x</span>
       <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''the_elem RBT_set: not unique''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> the_elem <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def DList_set_def DList_Set.Collect_member the_elem_def member_conv_keys <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split list.split rbt.split<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_Set2.keys_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Pow_set_conv_fold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Pow <span class="main">(</span>set <span class="free">xs</span> <span class="main">∪</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">∪</span> insert <span class="bound">x</span> <span class="main">`</span> <span class="bound">A</span><span class="main">)</span> <span class="free">xs</span> <span class="main">(</span>Pow <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Pow_insert<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Pow_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Pow <span class="free">A</span> <span class="main">=</span> Collect_set <span class="main">(</span><span class="main">λ</span><span class="bound">B</span><span class="main">.</span> <span class="bound">B</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Pow <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">∪</span> insert <span class="bound">x</span> <span class="main">`</span> <span class="bound">A</span><span class="main">)</span> <span class="free">xs</span> <span class="main">{</span><span class="main">{}</span><span class="main">}</span>"</span></span>
  <span class="quoted"><span class="quoted">"Pow <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Pow DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Pow <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">∪</span> insert <span class="bound">x</span> <span class="main">`</span> <span class="bound">A</span><span class="main">)</span> <span class="free">dxs</span> <span class="main">{</span><span class="main">{}</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Pow <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Pow RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Pow <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">∪</span> insert <span class="bound">x</span> <span class="main">`</span> <span class="bound">A</span><span class="main">)</span> <span class="free">rbt</span> <span class="main">{</span><span class="main">{}</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def DList_Set.Collect_member DList_Set.fold_def RBT_set_def fold_conv_fold_keys member_conv_keys Pow_set_conv_fold<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fold_singleton<span class="main">:</span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">f</span> <span class="free">x</span> <span class="main">{</span><span class="free">y</span><span class="main">}</span> <span class="main">=</span> <span class="free">f</span> <span class="free">y</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Finite_Set.fold_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> fold_graph.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> fold_graph.cases<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> sum_cfc <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">::</span> comm_monoid_add<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> comp_fun_commute"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">f</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">.</span> plus <span class="main">∘</span> <span class="bound">f</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff add.left_commute<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sum_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sum <span class="free">f</span> <span class="free">A</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">A</span> <span class="keyword1">then</span> set_fold_cfc <span class="main">(</span>sum_cfc <span class="free">f</span><span class="main">)</span> <span class="main">0</span> <span class="free">A</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum.eq_fold<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> product_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ceq set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> <span class="main">::</span> ccompare set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Product_Type.product <span class="free">A</span> <span class="free">B</span> <span class="main">=</span> Collect_set <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">B</span><span class="main">)</span>"</span></span>

  <span class="quoted"><span class="quoted">"Product_Type.product <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Set_Monad <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> 
   Set_Monad <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">y</span> <span class="bound">rest</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">#</span> <span class="bound">rest</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="free">xs</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"Product_Type.product <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="free">B1</span> <span class="main">=</span> 
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''product DList_set1: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Product_Type.product <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="free">B1</span><span class="main">)</span>
                   <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>  DList_Set.fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">rest</span><span class="main">.</span> Pair <span class="bound">x</span> <span class="main">`</span> <span class="free">B1</span> <span class="main">∪</span> <span class="bound">rest</span><span class="main">)</span> <span class="free">dxs</span> <span class="main">{}</span><span class="main">)</span>"</span></span> 
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dlist1</span>"</span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"Product_Type.product <span class="free">A1</span> <span class="main">(</span>DList_set <span class="free">dys</span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''product DList_set2: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Product_Type.product <span class="free">A1</span> <span class="main">(</span>DList_set <span class="free">dys</span><span class="main">)</span><span class="main">)</span>
                   <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.fold <span class="main">(</span><span class="main">λ</span><span class="bound">y</span> <span class="bound">rest</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">A1</span> <span class="main">∪</span> <span class="bound">rest</span><span class="main">)</span> <span class="free">dys</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?dlist2</span>"</span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"Product_Type.product <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">(</span>DList_set <span class="free">dys</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''product DList_set DList_set: ceq1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Product_Type.product <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">(</span>DList_set <span class="free">dys</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> 
     <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''product DList_set DList_set: ceq2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Product_Type.product <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">(</span>DList_set <span class="free">dys</span><span class="main">)</span><span class="main">)</span>
                    <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_set <span class="main">(</span>DList_Set.product <span class="free">dxs</span> <span class="free">dys</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="quoted"><span class="quoted">"Product_Type.product <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span> <span class="free">B2</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''product RBT_set: ccompare1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Product_Type.product <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span> <span class="free">B2</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">rest</span><span class="main">.</span> Pair <span class="bound">x</span> <span class="main">`</span> <span class="free">B2</span> <span class="main">∪</span> <span class="bound">rest</span><span class="main">)</span> <span class="free">rbt1</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rbt1</span>"</span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"Product_Type.product <span class="free">A2</span> <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'d</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''product RBT_set: ccompare2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Product_Type.product <span class="free">A2</span> <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.fold <span class="main">(</span><span class="main">λ</span><span class="bound">y</span> <span class="bound">rest</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">A2</span> <span class="main">∪</span> <span class="bound">rest</span><span class="main">)</span> <span class="free">rbt2</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rbt2</span>"</span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"Product_Type.product <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''product RBT_set RBT_set: ccompare1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Product_Type.product <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'d</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''product RBT_set RBT_set: ccompare2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Product_Type.product <span class="main">(</span>RBT_set <span class="free">rbt1</span><span class="main">)</span> <span class="main">(</span>RBT_set <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>
                       <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.product <span class="free">rbt1</span> <span class="free">rbt2</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">zs</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="main">(#)</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="free">ys</span> <span class="bound">zs</span> <span class="main">=</span> rev <span class="main">(</span>map <span class="main">(</span>Pair <span class="bound">a</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="main">@</span> <span class="bound">zs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">zs</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">y</span> <span class="bound">rest</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">#</span> <span class="bound">rest</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="free">xs</span> <span class="bound">zs</span> <span class="main">=</span> rev <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> map <span class="main">(</span>Pair <span class="bound">x</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">@</span> <span class="bound">zs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Product_Type.product_def<span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(∪)</span> <span class="main">(</span>Pair <span class="bound">x</span> <span class="main">`</span> <span class="free">B1</span><span class="main">)</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">{}</span> <span class="main">=</span> set <span class="skolem">xs</span> <span class="main">×</span> <span class="free">B1</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="operator">auto</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?dlist1</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Product_Type.product_def DList_set_def DList_Set.fold.rep_eq DList_Set.Collect_member <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span> 

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="main">(∪)</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">A1</span><span class="main">)</span><span class="main">)</span> <span class="skolem">ys</span> <span class="main">{}</span> <span class="main">=</span> <span class="free">A1</span> <span class="main">×</span> set <span class="skolem">ys</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="operator">auto</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?dlist2</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Product_Type.product_def DList_set_def DList_Set.fold.rep_eq DList_Set.Collect_member <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> list"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(∪)</span> <span class="main">(</span>Pair <span class="bound">x</span> <span class="main">`</span> <span class="free">B2</span><span class="main">)</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">{}</span> <span class="main">=</span> set <span class="skolem">xs</span> <span class="main">×</span> <span class="free">B2</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="operator">auto</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rbt1</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Product_Type.product_def RBT_set_def RBT_Set2.member_product RBT_Set2.member_conv_keys fold_conv_fold_keys <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> list"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="main">(∪)</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">A2</span><span class="main">)</span><span class="main">)</span> <span class="skolem">ys</span> <span class="main">{}</span> <span class="main">=</span> <span class="free">A2</span> <span class="main">×</span> set <span class="skolem">ys</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="operator">auto</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rbt2</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Product_Type.product_def RBT_set_def RBT_Set2.member_product RBT_Set2.member_conv_keys fold_conv_fold_keys <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def DList_set_def Product_Type.product_def DList_Set.product_member RBT_Set2.member_product <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Id_on_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Id_on <span class="free">B</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Id_on_Complement <span class="main">[</span><span class="operator">set_complement_code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Id_on <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Id_on Complement: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Id_on <span class="main">(</span>Complement <span class="free">A</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> Collect_set <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">eq</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted"><span class="quoted">"Id_on <span class="main">(</span>Collect_set <span class="free">P</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Id_on Collect_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Id_on <span class="main">(</span>Collect_set <span class="free">P</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> Collect_set <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">eq</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Id_on <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Id_on DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Id_on <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_set <span class="main">(</span>DList_Set.Id_on <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Id_on <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Id_on RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Id_on <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_set <span class="main">(</span>RBT_Set2.Id_on <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def RBT_set_def DList_Set.member_Id_on RBT_Set2.member_Id_on <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ceq<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Image_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ceq <span class="main">×</span> <span class="tfree">'b</span> <span class="main">::</span> ceq<span class="main">)</span> set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span> <span class="main">::</span> ccompare <span class="main">×</span> <span class="tfree">'d</span> <span class="main">::</span> ccompare<span class="main">)</span> set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">``</span> <span class="free">Y</span> <span class="main">=</span> snd <span class="main">`</span> Set.filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">Y</span><span class="main">)</span> <span class="free">X</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?generic</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"Set_Monad <span class="free">rxs</span> <span class="main">``</span> <span class="free">A</span> <span class="main">=</span> Set_Monad <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">rest</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="keyword1">then</span> <span class="bound">y</span> <span class="main">#</span> <span class="bound">rest</span> <span class="keyword1">else</span> <span class="bound">rest</span><span class="main">)</span> <span class="free">rxs</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs</span> <span class="main">``</span> <span class="free">B</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Image DList_set: ceq1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs</span> <span class="main">``</span> <span class="free">B</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Image DList_set: ceq2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs</span> <span class="main">``</span> <span class="free">B</span><span class="main">)</span>
                    <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
        DList_Set.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">acc</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">B</span> <span class="keyword1">then</span> insert <span class="bound">y</span> <span class="bound">acc</span> <span class="keyword1">else</span> <span class="bound">acc</span><span class="main">)</span> <span class="free">dxs</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt</span> <span class="main">``</span> <span class="free">C</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Image RBT_set: ccompare1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt</span> <span class="main">``</span> <span class="free">C</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
      <span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'d</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Image RBT_set: ccompare2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt</span> <span class="main">``</span> <span class="free">C</span><span class="main">)</span>
                        <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
        RBT_Set2.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">acc</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">C</span> <span class="keyword1">then</span> insert <span class="bound">y</span> <span class="bound">acc</span> <span class="keyword1">else</span> <span class="bound">acc</span><span class="main">)</span> <span class="free">rbt</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?generic</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">rest</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="keyword1">then</span> <span class="bound">y</span> <span class="main">#</span> <span class="bound">rest</span> <span class="keyword1">else</span> <span class="bound">rest</span><span class="main">)</span> <span class="free">rxs</span> <span class="main">[]</span><span class="main">)</span> <span class="main">=</span> set <span class="free">rxs</span> <span class="main">``</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">rxs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">acc</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">B</span> <span class="keyword1">then</span> insert <span class="bound">y</span> <span class="bound">acc</span> <span class="keyword1">else</span> <span class="bound">acc</span><span class="main">)</span> <span class="skolem">dxs</span> <span class="main">{}</span> <span class="main">=</span> set <span class="skolem">dxs</span> <span class="main">``</span> <span class="free">B</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">dxs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?DList_set</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def Collect_member ceq_prod_def ID_Some DList_Set.fold.rep_eq <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>


  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'c</span> <span class="main">×</span> <span class="tfree">'d</span><span class="main">)</span> <span class="main">×</span> unit<span class="main">)</span> list"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">a</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">λ</span><span class="bound">acc</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">C</span> <span class="keyword1">then</span> insert <span class="bound">y</span> <span class="bound">acc</span> <span class="keyword1">else</span> <span class="bound">acc</span><span class="main">)</span> <span class="skolem">rbt</span> <span class="main">{}</span> <span class="main">=</span> <span class="main">(</span>fst <span class="main">`</span> set <span class="skolem">rbt</span><span class="main">)</span> <span class="main">``</span> <span class="free">C</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">rbt</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?RBT_set</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def ccompare_prod_def ID_Some RBT_Set2.fold.rep_eq member_conv_keys RBT_Set2.keys.rep_eq RBT_Impl.fold_def RBT_Impl.keys_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> insert_relcomp<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="free">A</span> <span class="keyword1">O</span> <span class="free">B</span> <span class="main">=</span> <span class="free">A</span> <span class="keyword1">O</span> <span class="free">B</span> <span class="main">∪</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">×</span> <span class="main">{</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">b</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> <span class="free">B</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> trancl_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"trancl <span class="free">A</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">A</span> <span class="keyword1">then</span> ntrancl <span class="main">(</span>card <span class="free">A</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">A</span> <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''trancl: infinite set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> trancl <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_trancl_ntranl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_relcomp_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="keyword1">O</span> set <span class="free">ys</span> <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">=</span> <span class="bound">y'</span> <span class="keyword1">then</span> insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span> <span class="keyword1">else</span> <span class="bound">A</span><span class="main">)</span> <span class="free">ys</span><span class="main">)</span> <span class="free">xs</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snoc <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">show_types</span><span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">b</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'c</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">if</span> <span class="skolem">b</span> <span class="main">=</span> <span class="bound">y'</span> <span class="keyword1">then</span> insert <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span> <span class="keyword1">else</span> <span class="bound">A</span><span class="main">)</span> <span class="free">ys</span> <span class="skolem">X</span> <span class="main">=</span> <span class="skolem">X</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">a</span><span class="main">}</span> <span class="main">×</span> <span class="main">{</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">ys</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">X</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> snoc <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_relcomp<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> If_not<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> <span class="main">¬</span> <span class="free">a</span> <span class="keyword1">then</span> <span class="free">b</span> <span class="keyword1">else</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">a</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="keyword1">else</span> <span class="free">b</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> relcomp_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare <span class="main">×</span> <span class="tfree">'b</span> <span class="main">::</span> ccompare<span class="main">)</span> set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">×</span> <span class="tfree">'c</span> <span class="main">::</span> ccompare<span class="main">)</span> set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt3</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'d</span> <span class="main">::</span> <span class="main">{</span>ccompare<span class="main">,</span> ceq<span class="main">}</span><span class="main">)</span> set_rbt"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt4</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'d</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt5</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'d</span> <span class="main">×</span> <span class="tfree">'e</span> <span class="main">::</span> ceq<span class="main">)</span> set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'e</span> <span class="main">×</span> <span class="tfree">'d</span><span class="main">)</span> set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs3</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'e</span> <span class="main">×</span> <span class="tfree">'f</span> <span class="main">::</span> ceq<span class="main">)</span> set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs4</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span> <span class="main">×</span> <span class="tfree">'g</span> <span class="main">::</span> ceq<span class="main">)</span> set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">xs1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'h</span> <span class="main">×</span> <span class="tfree">'i</span> <span class="main">::</span> ceq<span class="main">)</span> list"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">xs2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span> <span class="main">×</span> <span class="tfree">'j</span><span class="main">)</span> list"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">xs3</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">×</span> <span class="tfree">'h</span><span class="main">)</span> list"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">xs4</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'h</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> list"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">xs5</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span> <span class="main">×</span> <span class="tfree">'h</span><span class="main">)</span> list"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">xs6</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'h</span> <span class="main">×</span> <span class="tfree">'f</span><span class="main">)</span> list"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt1</span> <span class="keyword1">O</span> RBT_set <span class="free">rbt2</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp RBT_set RBT_set: ccompare1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="keyword1">O</span> RBT_set <span class="free">rbt2</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp RBT_set RBT_set: ccompare2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="keyword1">O</span> RBT_set <span class="free">rbt2</span><span class="main">)</span>
           <span class="main">|</span> Some <span class="bound">c_b</span> <span class="main">⇒</span>
       <span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp RBT_set RBT_set: ccompare3 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="keyword1">O</span> RBT_set <span class="free">rbt2</span><span class="main">)</span>
                         <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> RBT_Set2.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">c_b</span> <span class="bound">y</span> <span class="bound">y'</span> <span class="main">≠</span> Eq <span class="keyword1">then</span> <span class="bound">A</span> <span class="keyword1">else</span> insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">)</span> <span class="free">rbt2</span><span class="main">)</span> <span class="free">rbt1</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt3</span> <span class="keyword1">O</span> DList_set <span class="free">dxs1</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp RBT_set DList_set: ccompare1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt3</span> <span class="keyword1">O</span> DList_set <span class="free">dxs1</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'d</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp RBT_set DList_set: ccompare2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt3</span> <span class="keyword1">O</span> DList_set <span class="free">dxs1</span><span class="main">)</span>
                       <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
       <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'d</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp RBT_set DList_set: ceq2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt3</span> <span class="keyword1">O</span> DList_set <span class="free">dxs1</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span>
         <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'e</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp RBT_set DList_set: ceq3 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt3</span> <span class="keyword1">O</span> DList_set <span class="free">dxs1</span><span class="main">)</span>
                        <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> DList_Set.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">eq</span> <span class="bound">y</span> <span class="bound">y'</span> <span class="keyword1">then</span> insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span> <span class="keyword1">else</span> <span class="bound">A</span><span class="main">)</span> <span class="free">dxs1</span><span class="main">)</span> <span class="free">rbt3</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_dlist</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs2</span> <span class="keyword1">O</span> RBT_set <span class="free">rbt4</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'e</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp DList_set RBT_set: ceq1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs2</span> <span class="keyword1">O</span> RBT_set <span class="free">rbt4</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'d</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp DList_set RBT_set: ceq2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs2</span> <span class="keyword1">O</span> RBT_set <span class="free">rbt4</span><span class="main">)</span>
                       <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
       <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'d</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp DList_set RBT_set: ccompare2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs2</span> <span class="keyword1">O</span> RBT_set <span class="free">rbt4</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span>
         <span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp DList_set RBT_set: ccompare3 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs2</span> <span class="keyword1">O</span> RBT_set <span class="free">rbt4</span><span class="main">)</span>
                           <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> RBT_Set2.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">eq</span> <span class="bound">y</span> <span class="bound">y'</span> <span class="keyword1">then</span> insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span> <span class="keyword1">else</span> <span class="bound">A</span><span class="main">)</span> <span class="free">rbt4</span><span class="main">)</span> <span class="free">dxs2</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?dlist_rbt</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs3</span> <span class="keyword1">O</span> DList_set <span class="free">dxs4</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'e</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp DList_set DList_set: ceq1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs3</span> <span class="keyword1">O</span> DList_set <span class="free">dxs4</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'f</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp DList_set DList_set: ceq2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs3</span> <span class="keyword1">O</span> DList_set <span class="free">dxs4</span><span class="main">)</span>
                   <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span>
       <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'g</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp DList_set DList_set: ceq3 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs3</span> <span class="keyword1">O</span> DList_set <span class="free">dxs4</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> DList_Set.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">eq</span> <span class="bound">y</span> <span class="bound">y'</span> <span class="keyword1">then</span> insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span> <span class="keyword1">else</span> <span class="bound">A</span><span class="main">)</span> <span class="free">dxs4</span><span class="main">)</span> <span class="free">dxs3</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?dlist_dlist</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"Set_Monad <span class="free">xs1</span> <span class="keyword1">O</span> Set_Monad <span class="free">xs2</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'i</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp Set_Monad Set_Monad: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set_Monad <span class="free">xs1</span> <span class="keyword1">O</span> Set_Monad <span class="free">xs2</span><span class="main">)</span>
                 <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">eq</span> <span class="bound">y</span> <span class="bound">y'</span> <span class="keyword1">then</span> insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span> <span class="keyword1">else</span> <span class="bound">A</span><span class="main">)</span> <span class="free">xs2</span><span class="main">)</span> <span class="free">xs1</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?monad_monad</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"RBT_set <span class="free">rbt1</span> <span class="keyword1">O</span> Set_Monad <span class="free">xs3</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp RBT_set Set_Monad: ccompare1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="keyword1">O</span> Set_Monad <span class="free">xs3</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp RBT_set Set_Monad: ccompare2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> RBT_set <span class="free">rbt1</span> <span class="keyword1">O</span> Set_Monad <span class="free">xs3</span><span class="main">)</span>
           <span class="main">|</span> Some <span class="bound">c_b</span> <span class="main">⇒</span> RBT_Set2.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">c_b</span> <span class="bound">y</span> <span class="bound">y'</span> <span class="main">≠</span> Eq <span class="keyword1">then</span> <span class="bound">A</span> <span class="keyword1">else</span> insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">)</span> <span class="free">xs3</span><span class="main">)</span> <span class="free">rbt1</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_monad</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"Set_Monad <span class="free">xs4</span> <span class="keyword1">O</span> RBT_set <span class="free">rbt5</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp Set_Monad RBT_set: ccompare1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set_Monad <span class="free">xs4</span> <span class="keyword1">O</span> RBT_set <span class="free">rbt5</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp Set_Monad RBT_set: ccompare2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set_Monad <span class="free">xs4</span> <span class="keyword1">O</span> RBT_set <span class="free">rbt5</span><span class="main">)</span>
           <span class="main">|</span> Some <span class="bound">c_b</span> <span class="main">⇒</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> RBT_Set2.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">c_b</span> <span class="bound">y</span> <span class="bound">y'</span> <span class="main">≠</span> Eq <span class="keyword1">then</span> <span class="bound">A</span> <span class="keyword1">else</span> insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">)</span> <span class="free">rbt5</span><span class="main">)</span> <span class="free">xs4</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?monad_rbt</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs3</span> <span class="keyword1">O</span> Set_Monad <span class="free">xs5</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'e</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp DList_set Set_Monad: ceq1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs3</span> <span class="keyword1">O</span> Set_Monad <span class="free">xs5</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'f</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp DList_set Set_Monad: ceq2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> DList_set <span class="free">dxs3</span> <span class="keyword1">O</span> Set_Monad <span class="free">xs5</span><span class="main">)</span>
                   <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> DList_Set.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">eq</span> <span class="bound">y</span> <span class="bound">y'</span> <span class="keyword1">then</span> insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span> <span class="keyword1">else</span> <span class="bound">A</span><span class="main">)</span> <span class="free">xs5</span><span class="main">)</span> <span class="free">dxs3</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?dlist_monad</span></span></span><span class="main">)</span>

  <span class="quoted"><span class="quoted">"Set_Monad <span class="free">xs6</span> <span class="keyword1">O</span> DList_set <span class="free">dxs4</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'f</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp Set_Monad DList_set: ceq1 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set_Monad <span class="free">xs6</span> <span class="keyword1">O</span> DList_set <span class="free">dxs4</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span>
     <span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'g</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''relcomp Set_Monad DList_set: ceq2 = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Set_Monad <span class="free">xs6</span> <span class="keyword1">O</span> DList_set <span class="free">dxs4</span><span class="main">)</span>
                   <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> DList_Set.fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">eq</span> <span class="bound">y</span> <span class="bound">y'</span> <span class="keyword1">then</span> insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">A</span> <span class="keyword1">else</span> <span class="bound">A</span><span class="main">)</span> <span class="free">dxs4</span><span class="main">)</span> <span class="free">xs6</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?monad_dlist</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_rbt</span></span></span> <span class="var"><span class="quoted"><span class="var">?rbt_monad</span></span></span> <span class="var"><span class="quoted"><span class="var">?monad_rbt</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comparator.eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span> RBT_set_def ccompare_prod_def member_conv_keys ID_Some RBT_Set2.fold_conv_fold_keys' RBT_Set2.keys.rep_eq If_not set_relcomp_set <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> equalityI<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rbt_dlist</span></span></span> <span class="var"><span class="quoted"><span class="var">?dlist_rbt</span></span></span> <span class="var"><span class="quoted"><span class="var">?dlist_dlist</span></span></span> <span class="var"><span class="quoted"><span class="var">?monad_monad</span></span></span> <span class="var"><span class="quoted"><span class="var">?dlist_monad</span></span></span> <span class="var"><span class="quoted"><span class="var">?monad_dlist</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def DList_set_def member_conv_keys ID_Some ccompare_prod_def ceq_prod_def Collect_member RBT_Set2.fold_conv_fold_keys' RBT_Set2.keys.rep_eq DList_Set.fold.rep_eq set_relcomp_set <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> equal.equal_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ceq<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> irrefl_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>ceq<span class="main">,</span> ccompare<span class="main">}</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"irrefl <span class="free">r</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> Some <span class="bound">eq</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main">.</span> <span class="main">¬</span> <span class="bound">eq</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">|</span> None <span class="main">⇒</span>
    <span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''irrefl: ceq = None &amp; ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> irrefl <span class="free">r</span><span class="main">)</span>
                <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main">.</span> <span class="bound">c</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">≠</span> Eq<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> irrefl_distinct comparator.eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare'<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ID_ceq<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equal.equal_eq<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> wf_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set_rbt"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">::</span> ceq <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set_dlist"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"wf <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> acyclic <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"wf <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''wf RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> wf <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> acyclic <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"wf <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''wf DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> wf <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> acyclic <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wf_iff_acyclic_if_finite <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> iffI<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wf_iff_acyclic_if_finite finite_code ccompare_prod_def ceq_prod_def ID_Some<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bacc_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bacc <span class="free">R</span> <span class="main">0</span> <span class="main">=</span> <span class="main">-</span> snd <span class="main">`</span> <span class="free">R</span>"</span></span>
  <span class="quoted"><span class="quoted">"bacc <span class="free">R</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">rec</span> <span class="main">=</span> bacc <span class="free">R</span> <span class="free">n</span> <span class="keyword1">in</span> <span class="bound">rec</span> <span class="main">∪</span> <span class="main">-</span> snd <span class="main">`</span> <span class="main">(</span>Set.filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∉</span> <span class="bound">rec</span><span class="main">)</span> <span class="free">R</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="comment1">(* TODO: acc could also be computed for infinite universes if r is finite *)</span>

<span class="keyword1"><span class="command">lemma</span></span> acc_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>finite<span class="main">,</span> card_UNIV<span class="main">}</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Wellfounded.acc <span class="free">A</span> <span class="main">=</span> bacc <span class="free">A</span> <span class="main">(</span>of_phantom <span class="main">(</span>card_UNIV <span class="main">::</span> <span class="tfree">'a</span> card_UNIV<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_UNIV acc_bacc_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_list_of_set_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>linorder<span class="main">,</span> ceq<span class="main">}</span> set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> <span class="main">{</span>linorder<span class="main">,</span> ccompare<span class="main">}</span> set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"sorted_list_of_set <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sort <span class="main">(</span>remdups <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"sorted_list_of_set <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''sorted_list_of_set DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> sorted_list_of_set <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> sort <span class="main">(</span>list_of_dlist <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"sorted_list_of_set <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''sorted_list_of_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> sorted_list_of_set <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> sort <span class="main">(</span>RBT_Set2.keys <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="comment1">― ‹We must sort the keys because <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">ccompare</span><span class="antiquote">}</span></span>'s ordering need not coincide with <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">linorder</span></span><span class="antiquote">}</span></span>'s.›</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DList_set_def RBT_set_def sorted_list_of_set_sort_remdups Collect_member distinct_remdups_id distinct_list_of_dlist member_conv_keys <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_project_set<span class="main">:</span> <span class="quoted"><span class="quoted">"List.map_project <span class="free">f</span> <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="main">(</span>List.map_filter <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.map_project_def List.map_filter_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_project_simps<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> map_project_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"List.map_project <span class="free">f</span> <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> map_project_insert<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"List.map_project <span class="free">f</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">f</span> <span class="free">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> List.map_project <span class="free">f</span> <span class="free">A</span> 
   <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> insert <span class="bound">y</span> <span class="main">(</span>List.map_project <span class="free">f</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.map_project_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_project_conv_fold<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"List.map_project <span class="free">f</span> <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> 
   fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">f</span> <span class="bound">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="bound">A</span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> insert <span class="bound">y</span> <span class="bound">A</span><span class="main">)</span> <span class="free">xs</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_project_simps <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_project_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"List.map_project <span class="free">f</span> <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> Set_Monad <span class="main">(</span>List.map_filter <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"List.map_project <span class="free">g</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''map_project DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> List.map_project <span class="free">g</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                   <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">g</span> <span class="bound">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="bound">A</span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> insert <span class="bound">y</span> <span class="bound">A</span><span class="main">)</span> <span class="free">dxs</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?dlist</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"List.map_project <span class="free">h</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span> 
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''map_project RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> List.map_project <span class="free">h</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">A</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">h</span> <span class="bound">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="bound">A</span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> insert <span class="bound">y</span> <span class="bound">A</span><span class="main">)</span> <span class="free">rbt</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?dlist</span></span></span> <span class="var"><span class="quoted"><span class="var">?rbt</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def DList_set_def DList_Set.fold.rep_eq Collect_member map_project_conv_fold RBT_Set2.fold_conv_fold_keys member_conv_keys <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.map_project_def List.map_filter_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Bleast_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Bleast <span class="free">A</span> <span class="free">P</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">A</span> <span class="keyword1">then</span> <span class="keyword1">case</span> filter <span class="free">P</span> <span class="main">(</span>sorted_list_of_set <span class="free">A</span><span class="main">)</span> <span class="keyword1">of</span> <span class="main">[]</span> <span class="main">⇒</span> abort_Bleast <span class="free">A</span> <span class="free">P</span> <span class="main">|</span> <span class="bound">x</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="bound">x</span> 
   <span class="keyword1">else</span> abort_Bleast <span class="free">A</span> <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> set <span class="main">(</span>sorted_list_of_set <span class="free">A</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_list_of_set<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 3<span class="main"><span class="main">)</span></span> *<span class="main">)</span><span class="main">(</span><span class="operator">unfold</span> Bleast_code<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_sort_id<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abort_Bleast_def Bleast_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> can_select_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq list"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"can_select <span class="free">P</span> <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''can_select Set_Monad: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> can_select <span class="free">P</span> <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> <span class="keyword1">case</span> filter <span class="free">P</span> <span class="free">xs</span> <span class="keyword1">of</span> Nil <span class="main">⇒</span> False <span class="main">|</span> <span class="bound">x</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">⇒</span> list_all <span class="main">(</span><span class="bound">eq</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"can_select <span class="free">Q</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''can_select DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> can_select <span class="free">Q</span> <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.length <span class="main">(</span>DList_Set.filter <span class="free">Q</span> <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?dlist</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"can_select <span class="free">R</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''can_select RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> can_select <span class="free">R</span> <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> singleton_list_fusion <span class="main">(</span>filter_generator <span class="free">R</span> rbt_keys_generator<span class="main">)</span> <span class="main">(</span>RBT_Set2.init <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?rbt</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Set_Monad</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split list.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ID_ceq<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equal.equal_eq<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> filter_eq_ConsD <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> can_select_def filter_empty_conv list_all_iff<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> filter_eq_ConsD<span class="main"><span class="keyword3">,</span></span> <span class="operator">fastforce</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> filter_eq_ConsD<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?dlist</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> can_select_def card_eq_length<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> Set_member_code card_eq_Suc_0_ex1 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> card_eq_length <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> distinct_keys
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rbt</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> distinct_keys<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">rbt</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> can_select_def singleton_list_fusion_def unfoldr_filter_generator unfoldr_rbt_keys_generator Set_member_code member_conv_keys filter_empty_conv empty_filter_conv <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split list.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> filter_eq_ConsD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> filter_eq_ConsD<span class="main"><span class="keyword3">,</span></span> <span class="operator">fastforce</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> filter_eq_ConsD<span class="main"><span class="keyword3">,</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_filter_conv<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> filter_eq_ConsD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> Cons_eq_filterD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_use</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> pred_of_set_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rbt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">::</span> ccompare set_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"pred_of_set <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> fold <span class="main">(</span>sup <span class="main">∘</span> Predicate.single<span class="main">)</span> <span class="free">xs</span> bot"</span></span>
  <span class="quoted"><span class="quoted">"pred_of_set <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''pred_of_set DList_set: ceq = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> pred_of_set <span class="main">(</span>DList_set <span class="free">dxs</span><span class="main">)</span><span class="main">)</span>
                   <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_Set.fold <span class="main">(</span>sup <span class="main">∘</span> Predicate.single<span class="main">)</span> <span class="free">dxs</span> bot<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"pred_of_set <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''pred_of_set RBT_set: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> pred_of_set <span class="main">(</span>RBT_set <span class="free">rbt</span><span class="main">)</span><span class="main">)</span>
                      <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Set2.fold <span class="main">(</span>sup <span class="main">∘</span> Predicate.single<span class="main">)</span> <span class="free">rbt</span> bot<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pred_of_set_set_fold_sup fold_map DList_set_def RBT_set_def Collect_member member_conv_keys DList_Set.fold.rep_eq fold_conv_fold_keys <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> Predicate.pred"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is implemented as a monad, 
  so we keep the monad when converting to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. 
  For this case, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">insert_monad</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">union_monad</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  avoid the unnecessary dictionary construction.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">insert_monad</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">insert_monad</span> <span class="main">=</span> insert"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">union_monad</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">union_monad</span> <span class="main">=</span> <span class="main">(∪)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> insert_monad_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"insert_monad <span class="free">x</span> <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> Set_Monad <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> union_monad_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"union_monad <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>Set_Monad <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> Set_Monad <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_of_pred_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_of_pred <span class="main">(</span>Predicate.Seq <span class="free">f</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">f</span> <span class="main">()</span> <span class="keyword1">of</span> seq.Empty <span class="main">⇒</span> Set_Monad <span class="main">[]</span>
   <span class="main">|</span> seq.Insert <span class="bound">x</span> <span class="bound">P</span> <span class="main">⇒</span> insert_monad <span class="bound">x</span> <span class="main">(</span>set_of_pred <span class="bound">P</span><span class="main">)</span>
   <span class="main">|</span> seq.Join <span class="bound">P</span> <span class="bound">xq</span> <span class="main">⇒</span> union_monad <span class="main">(</span>set_of_pred <span class="bound">P</span><span class="main">)</span> <span class="main">(</span>set_of_seq <span class="bound">xq</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_pred_code <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> seq.case_cong<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_of_seq_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_of_seq seq.Empty <span class="main">=</span> Set_Monad <span class="main">[]</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_of_seq <span class="main">(</span>seq.Insert <span class="free">x</span> <span class="free">P</span><span class="main">)</span> <span class="main">=</span> insert_monad <span class="free">x</span> <span class="main">(</span>set_of_pred <span class="free">P</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_of_seq <span class="main">(</span>seq.Join <span class="free">P</span> <span class="free">xq</span><span class="main">)</span> <span class="main">=</span> union_monad <span class="main">(</span>set_of_pred <span class="free">P</span><span class="main">)</span> <span class="main">(</span>set_of_seq <span class="free">xq</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_seq_code<span class="main">)</span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> insert_monad union_monad

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type class instantiations›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> set_impl <span class="main">=</span> Set_IMPL
<span class="keyword1"><span class="command">declare</span></span>
  set_impl.eq.simps <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  set_impl.size <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span>
  set_impl.rec <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  set_impl.case <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">set_impl</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"size <span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"size_set_impl <span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_Choose</span> <span class="main">::</span> <span class="quoted">set_impl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">set_Choose</span> <span class="main">=</span> Set_IMPL"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_Collect</span> <span class="main">::</span> <span class="quoted">set_impl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">set_Collect</span> <span class="main">=</span> Set_IMPL"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_DList</span> <span class="main">::</span> <span class="quoted">set_impl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">set_DList</span> <span class="main">=</span> Set_IMPL"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_RBT</span> <span class="main">::</span> <span class="quoted">set_impl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">set_RBT</span> <span class="main">=</span> Set_IMPL"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_Monad</span> <span class="main">::</span> <span class="quoted">set_impl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">set_Monad</span> <span class="main">=</span> Set_IMPL"</span></span>

<span class="keyword1"><span class="command">code_datatype</span></span> <span class="quoted">set_Choose</span> <span class="quoted">set_Collect</span> <span class="quoted">set_DList</span> <span class="quoted">set_RBT</span> <span class="quoted">set_Monad</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_empty_choose</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">set_empty_choose</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_empty_choose_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>set_empty_choose <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>ceq<span class="main">,</span> ccompare<span class="main">}</span> set<span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> Some <span class="main"><span class="bound">_</span></span>  <span class="main">⇒</span> RBT_set RBT_Set2.empty
    <span class="main">|</span> None <span class="main">⇒</span> <span class="keyword1">case</span> <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Set_Monad <span class="main">[]</span> <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> DList_set <span class="main">(</span>DList_Set.empty<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_impl_choose2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"set_impl <span class="main">⇒</span> set_impl <span class="main">⇒</span> set_impl"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">set_impl_choose2</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> Set_IMPL<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_impl_choose2_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_impl_choose2 <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> set_Choose"</span></span>
  <span class="quoted"><span class="quoted">"set_impl_choose2 set_Collect set_Collect <span class="main">=</span> set_Collect"</span></span>
  <span class="quoted"><span class="quoted">"set_impl_choose2 set_DList set_DList <span class="main">=</span> set_DList"</span></span>
  <span class="quoted"><span class="quoted">"set_impl_choose2 set_RBT set_RBT <span class="main">=</span> set_RBT"</span></span>
  <span class="quoted"><span class="quoted">"set_impl_choose2 set_Monad set_Monad <span class="main">=</span> set_Monad"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"set_impl <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">set_empty</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_empty_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_empty set_Collect <span class="main">=</span> Collect_set <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_empty set_DList <span class="main">=</span> DList_set DList_Set.empty"</span></span>
  <span class="quoted"><span class="quoted">"set_empty set_RBT <span class="main">=</span> RBT_set RBT_Set2.empty"</span></span>
  <span class="quoted"><span class="quoted">"set_empty set_Monad <span class="main">=</span> Set_Monad <span class="main">[]</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_empty set_Choose <span class="main">=</span> set_empty_choose"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">class</span></span> set_impl <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">set_impl</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> set_impl<span class="main">)</span> phantom"</span></span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="main">(</span>input<span class="main">)</span>
  <span class="quoted">"_SET_IMPL"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"type <span class="main">=&gt;</span> logic"</span></span>  <span class="main">(</span><span class="quoted">"<span class="keyword3">(1</span><span class="keyword1">SET'_IMPL</span><span class="keyword3">/</span><span class="keyword3">(1</span><span class="keyword1">'(</span>_<span class="keyword1">')</span><span class="keyword3">)</span><span class="keyword3">)</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">parse_translation</span></span> <span class="quoted">‹
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">set_impl_tr</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span> <span class="main">=</span>
     <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_constrain"<span class="antiquote">}</span></span> $ Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_syntax</span> "set_impl"<span class="antiquote">}</span></span> $
       <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> phantom<span class="antiquote">}</span></span> $ <span class="entity">ty</span> $ Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> set_impl<span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">set_impl_tr</span> <span class="entity">ts</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"set_impl_tr"</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="main">[</span><span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_SET_IMPL"<span class="antiquote">}</span></span><span class="main">,</span> K <span class="entity">set_impl_tr</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> empty_code <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">{}</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> set_impl set<span class="main">)</span> <span class="main">=</span> set_empty <span class="main">(</span>of_phantom <span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generator for the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> set_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span>-class›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This generator registers itself at the derive-manager for the classes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> set_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Here, one can choose
the desired implementation via the parameter.

\begin{itemize}
\item \texttt{instantiation type :: (type,\ldots,type) (rbt,dlist,collect,monad,choose, or arbitrary constant name) set-impl}
\end{itemize}
›</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This generator can be used for arbitrary types, not just datatypes. 
›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹set_impl_generator.ML›</span> 

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>dlist<span class="main">)</span> set_impl <span class="quoted">unit</span> <span class="quoted">bool</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> set_impl <span class="quoted">nat</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>set_RBT<span class="main">)</span> set_impl <span class="quoted">int</span> <span class="comment1">(* shows usage of constant names *)</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>dlist<span class="main">)</span> set_impl <span class="quoted">Enum.finite_1</span> <span class="quoted">Enum.finite_2</span> <span class="quoted">Enum.finite_3</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> set_impl <span class="quoted">integer</span> <span class="quoted">natural</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> set_impl <span class="quoted">char</span>

<span class="keyword1"><span class="command">instantiation</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted">set_impl</span><span class="main">,</span> <span class="quoted">set_impl</span><span class="main">)</span> <span class="quoted">set_impl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> 
  <span class="main">(</span>set_impl_choose2 <span class="main">(</span>of_phantom <span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>of_phantom <span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="main">::</span> <span class="main">(</span><span class="quoted">set_impl</span><span class="main">,</span> <span class="quoted">set_impl</span><span class="main">)</span> <span class="quoted">set_impl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">*</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">*</span> <span class="tfree">'b</span><span class="main">)</span> 
  <span class="main">(</span>set_impl_choose2 <span class="main">(</span>of_phantom <span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>of_phantom <span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>choose<span class="main">)</span> set_impl <span class="quoted">list</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> set_impl <span class="quoted">String.literal</span>

<span class="keyword1"><span class="command">instantiation</span></span> option <span class="main">::</span> <span class="main">(</span><span class="quoted">set_impl</span><span class="main">)</span> <span class="quoted">set_impl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'a</span> option<span class="main">)</span> <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span><span class="tfree">'a</span> option<span class="main">)</span> <span class="main">(</span>of_phantom <span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>monad<span class="main">)</span> set_impl <span class="quoted"><span class="quoted">"fun"</span></span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>choose<span class="main">)</span> set_impl <span class="quoted">set</span>

<span class="keyword1"><span class="command">instantiation</span></span> phantom <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">,</span> <span class="quoted">set_impl</span><span class="main">)</span> <span class="quoted">set_impl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> phantom<span class="main">)</span> <span class="main">=</span> <span class="keyword1">Phantom</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> phantom<span class="main">)</span> <span class="main">(</span>of_phantom <span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We enable automatic implementation selection for sets constructed by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> set<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  although they could be directly converted using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Set_Monad<span class="antiquote"><span class="antiquote">}</span></span></span></span> in constant time.
  However, then it is more likely that the parameters of binary operators have 
  different implementations, which can lead to less efficient execution.

  However, we test whether automatic selection picks <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Set_Monad<span class="antiquote"><span class="antiquote">}</span></span></span></span> anyway and
  take a short-cut.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"set_impl <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">set_aux</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> set"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_aux_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">conv</span> <span class="main">≡</span> foldl <span class="main">(</span><span class="main">λ</span><span class="bound">s</span> <span class="main">(</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span><span class="main">.</span> insert <span class="bound">x</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"set_aux <span class="free">impl</span> <span class="main">=</span> <span class="free">conv</span> <span class="main">(</span>set_empty <span class="free">impl</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?thesis1</span>"</span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"set_aux set_Choose <span class="main">=</span> 
   <span class="main">(</span><span class="keyword1">case</span> <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>ccompare<span class="main">,</span> ceq<span class="main">}</span><span class="main">)</span> <span class="keyword1">of</span> Some <span class="main"><span class="bound">_</span></span>  <span class="main">⇒</span> <span class="free">conv</span> <span class="main">(</span>RBT_set RBT_Set2.empty<span class="main">)</span>
    <span class="main">|</span> None <span class="main">⇒</span> <span class="keyword1">case</span> <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Set_Monad
              <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free">conv</span> <span class="main">(</span>DList_set DList_Set.empty<span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?thesis2</span>"</span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"set_aux set_Monad <span class="main">=</span> Set_Monad"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">conv</span> <span class="main">{}</span> <span class="main">=</span> set"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span><span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> conv_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis1</span></span></span> <span class="var"><span class="quoted"><span class="var">?thesis2</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> set_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> set_impl list"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">=</span> set_aux <span class="main">(</span>of_phantom <span class="main">(</span>ID <span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Pretty printing for sets›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">code_post</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> marks contexts (as hypothesis) in which we use code\_post as a
  decision procedure rather than a pretty-printing engine. 
  The intended use is to enable more rules when proving assumptions of rewrite rules.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">code_post</span> <span class="main">::</span> <span class="quoted">bool</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">code_post</span> <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> conj_code_post <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted">code_post</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"True <span class="main">&amp;</span> <span class="free">x</span> <span class="main">⟷</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"False <span class="main">&amp;</span> <span class="free">x</span> <span class="main">⟷</span> False"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A flag to switch post-processing of sets on and off.
  Use \verb$declare pretty_sets[code_post del]$ to disable pretty printing of sets in value.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">code_post_set</span> <span class="main">::</span> <span class="quoted">bool</span>
<span class="keyword2"><span class="keyword">where</span></span> pretty_sets <span class="main">[</span><span class="operator">code_post</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">code_post_set</span> <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">collapse_RBT_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set_rbt <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> ccompare set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">collapse_RBT_set</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span> set <span class="main">(</span>RBT_Set2.keys <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> RBT_set_collapse_RBT_set <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare set_rbt"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"code_post <span class="main">⟹</span> is_ccompare <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">code_post_set</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RBT_set <span class="free">r</span> <span class="main">=</span> collapse_RBT_set <span class="free">r</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> code_post_def is_ccompare_def RBT_set_def member_conv_keys collapse_RBT_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> collapse_RBT_set_Branch <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"collapse_RBT_set <span class="main">(</span>Mapping_RBT <span class="main">(</span>Branch <span class="free">c</span> <span class="free">l</span> <span class="free">x</span> <span class="free">v</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span> <span class="free">M</span> <span class="main">=</span>
   collapse_RBT_set <span class="main">(</span>Mapping_RBT <span class="free">l</span><span class="main">)</span> <span class="main">(</span>insert <span class="free">x</span> <span class="main">(</span>collapse_RBT_set <span class="main">(</span>Mapping_RBT <span class="free">r</span><span class="main">)</span> <span class="free">M</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> collapse_RBT_set_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_ccompare_def set_keys_Mapping_RBT<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> collapse_RBT_set_Empty <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"collapse_RBT_set <span class="main">(</span>Mapping_RBT rbt.Empty<span class="main">)</span> <span class="free">M</span> <span class="main">=</span> <span class="free">M</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collapse_RBT_set_def set_keys_Mapping_RBT<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">collapse_DList_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">collapse_DList_set</span> <span class="free"><span class="bound"><span class="entity">dxs</span></span></span> <span class="main">=</span> set <span class="main">(</span>DList_Set.list_of_dlist <span class="free"><span class="bound"><span class="entity">dxs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> DList_set_collapse_DList_set <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dxs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq set_dlist"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"code_post <span class="main">⟹</span> is_ceq <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">code_post_set</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"DList_set <span class="free">dxs</span> <span class="main">=</span> collapse_DList_set <span class="free">dxs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> code_post_def DList_set_def is_ceq_def collapse_DList_set_def Collect_member<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> collapse_DList_set_empty <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"collapse_DList_set <span class="main">(</span>Abs_dlist <span class="main">[]</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collapse_DList_set_def Abs_dlist_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> collapse_DList_set_Cons <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"collapse_DList_set <span class="main">(</span>Abs_dlist <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">x</span> <span class="main">(</span>collapse_DList_set <span class="main">(</span>Abs_dlist <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collapse_DList_set_def set_list_of_dlist_Abs_dlist<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Set_Monad_code_post <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted">code_post_set</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Set_Monad <span class="main">[]</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Set_Monad <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">x</span> <span class="main">(</span>Set_Monad <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/set_impl_generator.ML">
<div class="head">
<h1>File ‹set_impl_generator.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Author:  René Thiemann, UIBK *)</span>
<span class="comment1">(* This generator was written as part of the IsaFoR/CeTA formalization. *)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">SET_IMPL_GENERATOR</span> <span class="main">=</span> 
<span class="keyword2"><span class="keyword">sig</span></span> 
  
  <span class="comment1">(* chooses a set implementation for a given type *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> derive_set_impl <span class="main">:</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Set_Impl_Generator</span> <span class="main">:</span> <span class="entity">SET_IMPL_GENERATOR</span> <span class="main">=</span> 
<span class="keyword2"><span class="keyword">struct</span></span>
<span class="keyword3"><span class="keyword">open</span></span> Containers_Generator<span class="main">;</span> 

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">supported_set_impl</span> <span class="main">=</span> <span class="main">[</span>
  <span class="main">(</span><span class="inner_quoted">"rbt"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">set_RBT</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"dlist"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">set_DList</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"monad"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">set_Monad</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"collect"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">set_Collect</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"choose"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">set_Choose</span><span class="antiquote">}</span></span><span class="main">)</span>
  <span class="main">]</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">derive_set_impl</span> <span class="main">=</span> <span class="entity">derive_set_map_impl</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> set_impl<span class="antiquote">}</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">set_impl</span><span class="antiquote">}</span></span> 
  <span class="entity">supported_set_impl</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup  
  <span class="main">(</span><span class="entity">Derive_Manager.register_derive</span> <span class="inner_quoted">"set_impl"</span> 
    <span class="main">(</span><span class="inner_quoted">"choose "</span> ^ <span class="entity">Generator_Aux.alist_to_string</span> <span class="entity">supported_set_impl</span> ^ 
     <span class="inner_quoted">" or any constant of type set_impl for a datatype"</span><span class="main">)</span> <span class="entity">derive_set_impl</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Mapping_Impl">
<div class="head">
<h1>Theory Mapping_Impl</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Mapping_Impl.thy
    Author:     Andreas Lochbihler, KIT
                René Thiemann, UIBK *)</span>

<span class="keyword1"><span class="command">theory</span></span> Mapping_Impl <span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="RBT_Mapping2.html">RBT_Mapping2</a>
  <a href="AssocList.html">AssocList</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Mapping.html">HOL-Library.Mapping</a>"</span>
  <a href="Set_Impl.html">Set_Impl</a>
  <a href="Containers_Generator.html">Containers_Generator</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Different implementations of maps›</span></span>

<span class="keyword1"><span class="command">code_identifier</span></span>
  <span class="keyword2"><span class="keyword">code_module</span></span> Mapping <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> Mapping_Impl
<span class="main">|</span> <span class="keyword2"><span class="keyword">code_module</span></span> Mapping_Impl <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> Mapping_Impl

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Map implementations›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Assoc_List_Mapping</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> alist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Assoc_List_Mapping</span> <span class="free"><span class="bound"><span class="entity">al</span></span></span> <span class="main">=</span> Mapping.Mapping <span class="main">(</span>DAList.lookup <span class="free"><span class="bound"><span class="entity">al</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">RBT_Mapping</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">RBT_Mapping</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> Mapping.Mapping <span class="main">(</span>RBT_Mapping2.lookup <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">code_datatype</span></span> <span class="quoted">Assoc_List_Mapping</span> <span class="quoted">RBT_Mapping</span> <span class="quoted">Mapping</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Map operations›</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.lookup</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_Mapping_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Mapping.lookup <span class="main">(</span>Assoc_List_Mapping <span class="free">al</span><span class="main">)</span> <span class="main">=</span> DAList.lookup <span class="free">al</span>"</span></span>
  <span class="quoted"><span class="quoted">"Mapping.lookup <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">=</span> RBT_Mapping2.lookup <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.is_empty</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> is_empty_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_mapping <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="bound">m</span> <span class="main">=</span> Map.empty<span class="main">)</span> Mapping.is_empty"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mapping.pcr_cr_eq
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">y</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping.is_empty_def cr_mapping_def Mapping_inverse Mapping.keys.rep_eq<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_empty_Mapping <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Mapping.is_empty <span class="main">(</span>Assoc_List_Mapping <span class="free">al</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">al</span> <span class="main">=</span> DAList.empty"</span></span>
  <span class="quoted"><span class="quoted">"Mapping.is_empty <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''is_empty RBT_Mapping: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Mapping.is_empty <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Mapping2.is_empty <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">al</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.update</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> update_Mapping <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Mapping.update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span>Mapping <span class="free">m</span><span class="main">)</span> <span class="main">=</span> Mapping <span class="main">(</span><span class="free">m</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Mapping.update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span>Assoc_List_Mapping <span class="free">al</span><span class="main">)</span> <span class="main">=</span> Assoc_List_Mapping <span class="main">(</span>DAList.update <span class="free">k</span> <span class="free">v</span> <span class="free">al</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Mapping.update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''update RBT_Mapping: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Mapping.update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Mapping <span class="main">(</span>RBT_Mapping2.insert <span class="free">k</span> <span class="free">v</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?RBT</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.delete</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> delete_Mapping <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Mapping.delete <span class="free">k</span> <span class="main">(</span>Mapping <span class="free">m</span><span class="main">)</span> <span class="main">=</span> Mapping <span class="main">(</span><span class="free">m</span><span class="main">(</span><span class="free">k</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Mapping.delete <span class="free">k</span> <span class="main">(</span>Assoc_List_Mapping <span class="free">al</span><span class="main">)</span> <span class="main">=</span> Assoc_List_Mapping <span class="main">(</span>AssocList.delete <span class="free">k</span> <span class="free">al</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Mapping.delete <span class="free">k</span> <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''delete RBT_Mapping: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Mapping.delete <span class="free">k</span> <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Mapping <span class="main">(</span>RBT_Mapping2.delete <span class="free">k</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.keys</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">theorem</span></span> rbt_comp_lookup_map_const<span class="main">:</span> <span class="quoted"><span class="quoted">"rbt_comp_lookup <span class="free">c</span> <span class="main">(</span>RBT_Impl.map <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">f</span><span class="main">)</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> map_option <span class="free">f</span> <span class="main">∘</span> rbt_comp_lookup <span class="free">c</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keys_Mapping <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Mapping.keys <span class="main">(</span>Mapping <span class="free">m</span><span class="main">)</span> <span class="main">=</span> Collect <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="free">m</span> <span class="bound">k</span> <span class="main">≠</span> None<span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Mapping</span>"</span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"Mapping.keys <span class="main">(</span>Assoc_List_Mapping <span class="free">al</span><span class="main">)</span> <span class="main">=</span> AssocList.keys <span class="free">al</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Assoc_List</span>"</span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"Mapping.keys <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">=</span> RBT_set <span class="main">(</span>RBT_Mapping2.map <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">()</span><span class="main">)</span> <span class="free">t</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?RBT</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Mapping</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?Assoc_List</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?RBT</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RBT_set_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rbt_comp_lookup_map_const o_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.size</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> Mapping_size_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_mapping <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span>card <span class="main">∘</span> dom<span class="main">)</span> Mapping.size"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">y</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping.size_def Mapping.keys.rep_eq Mapping_inverse mapping.pcr_cr_eq cr_mapping_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> size_Mapping <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Mapping.size <span class="main">(</span>Assoc_List_Mapping <span class="free">al</span><span class="main">)</span> <span class="main">=</span> size <span class="free">al</span>"</span></span>
  <span class="quoted"><span class="quoted">"Mapping.size <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''size RBT_Mapping: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Mapping.size <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> length <span class="main">(</span>RBT_Mapping2.entries <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dom_map_of_conv_image_fst set_map<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> distinct_card <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> set_map<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> size_eq_card_dom_lookup<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linorder.rbt_lookup_keys<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> ord.is_rbt_rbt_sorted RBT_Impl.keys_def distinct_card linorder.distinct_entries<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ID_ccompare<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> set_map<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.tabulate</span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> tabulate_fold <span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.ordered_keys</span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> ordered_keys_def<span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.lookup_default</span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> Mapping.lookup_default_def<span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.filter</span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span> filter_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Mapping.filter <span class="free">P</span> <span class="main">(</span>Mapping <span class="free">m</span><span class="main">)</span> <span class="main">=</span> Mapping <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">m</span> <span class="bound">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">k</span> <span class="bound">v</span> <span class="keyword1">then</span> Some <span class="bound">v</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Mapping.filter <span class="free">P</span> <span class="main">(</span>Assoc_List_Mapping <span class="free">al</span><span class="main">)</span> <span class="main">=</span> Assoc_List_Mapping <span class="main">(</span>DAList.filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">)</span> <span class="free">al</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Mapping.filter <span class="free">P</span> <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''filter RBT_Mapping: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Mapping.filter <span class="free">P</span> <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span><span class="main">)</span>
                         <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Mapping <span class="main">(</span>RBT_Mapping2.filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">k</span> <span class="bound">v</span><span class="main">)</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_of_filter_apply fun_eq_iff <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong option.case_cong<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping_inject Mapping.filter.abs_eq fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.map</span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span> map_values_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Mapping.map_values <span class="free">f</span> <span class="main">(</span>Mapping <span class="free">m</span><span class="main">)</span> <span class="main">=</span> Mapping <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> map_option <span class="main">(</span><span class="free">f</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(</span><span class="free">m</span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Mapping.map_values <span class="free">f</span> <span class="main">(</span>Assoc_List_Mapping <span class="free">al</span><span class="main">)</span> <span class="main">=</span> Assoc_List_Mapping <span class="main">(</span>AssocList.map_values <span class="free">f</span> <span class="free">al</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Mapping.map_values <span class="free">f</span> <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''map_values RBT_Mapping: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Mapping.map_values <span class="free">f</span> <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span><span class="main">)</span>
                         <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Mapping <span class="main">(</span>RBT_Mapping2.map <span class="free">f</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff map_of_map'<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping_inject Mapping.map_values.abs_eq fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.combine_with_key</span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.combine</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">datatype</span></span> mapping_impl <span class="main">=</span> Mapping_IMPL
<span class="keyword1"><span class="command">declare</span></span>
  mapping_impl.eq.simps <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  mapping_impl.rec <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  mapping_impl.case <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">mapping_impl</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"size <span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"size_mapping_impl <span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mapping_Choose</span> <span class="main">::</span> <span class="quoted">mapping_impl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mapping_Choose</span> <span class="main">=</span> Mapping_IMPL"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mapping_Assoc_List</span> <span class="main">::</span> <span class="quoted">mapping_impl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mapping_Assoc_List</span> <span class="main">=</span> Mapping_IMPL"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mapping_RBT</span> <span class="main">::</span> <span class="quoted">mapping_impl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mapping_RBT</span> <span class="main">=</span> Mapping_IMPL"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mapping_Mapping</span> <span class="main">::</span> <span class="quoted">mapping_impl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mapping_Mapping</span> <span class="main">=</span> Mapping_IMPL"</span></span>

<span class="keyword1"><span class="command">code_datatype</span></span> <span class="quoted">mapping_Choose</span> <span class="quoted">mapping_Assoc_List</span> <span class="quoted">mapping_RBT</span> <span class="quoted">mapping_Mapping</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mapping_empty_choose</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mapping_empty_choose</span> <span class="main">=</span> Mapping.empty"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mapping_empty_choose_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>mapping_empty_choose <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping<span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> Some <span class="main"><span class="bound">_</span></span>  <span class="main">⇒</span> RBT_Mapping RBT_Mapping2.empty
    <span class="main">|</span> None <span class="main">⇒</span> Assoc_List_Mapping DAList.empty<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DAList.lookup_empty<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> Mapping.empty_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mapping_impl_choose2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"mapping_impl <span class="main">⇒</span> mapping_impl <span class="main">⇒</span> mapping_impl"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mapping_impl_choose2</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> Mapping_IMPL<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mapping_impl_choose2_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mapping_impl_choose2 <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> mapping_Choose"</span></span>
  <span class="quoted"><span class="quoted">"mapping_impl_choose2 mapping_Mapping mapping_Mapping <span class="main">=</span> mapping_Mapping"</span></span>
  <span class="quoted"><span class="quoted">"mapping_impl_choose2 mapping_Assoc_List mapping_Assoc_List <span class="main">=</span> mapping_Assoc_List"</span></span>
  <span class="quoted"><span class="quoted">"mapping_impl_choose2 mapping_RBT mapping_RBT <span class="main">=</span> mapping_RBT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mapping_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"mapping_impl <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mapping_empty</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Mapping.empty<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mapping_empty_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mapping_empty mapping_Choose <span class="main">=</span> mapping_empty_choose"</span></span>
  <span class="quoted"><span class="quoted">"mapping_empty mapping_Mapping <span class="main">=</span> Mapping <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> None<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"mapping_empty mapping_Assoc_List <span class="main">=</span> Assoc_List_Mapping DAList.empty"</span></span>
  <span class="quoted"><span class="quoted">"mapping_empty mapping_RBT <span class="main">=</span> RBT_Mapping RBT_Mapping2.empty"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping.empty_def DAList.lookup_empty<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type classes›</span></span>

<span class="keyword1"><span class="command">class</span></span> mapping_impl <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">mapping_impl</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> mapping_impl<span class="main">)</span> phantom"</span></span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="main">(</span>input<span class="main">)</span>
  <span class="quoted">"_MAPPING_IMPL"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"type <span class="main">=&gt;</span> logic"</span></span>  <span class="main">(</span><span class="quoted">"<span class="keyword3">(1</span><span class="keyword1">MAPPING'_IMPL</span><span class="keyword3">/</span><span class="keyword3">(1</span><span class="keyword1">'(</span>_<span class="keyword1">')</span><span class="keyword3">)</span><span class="keyword3">)</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">parse_translation</span></span> <span class="quoted">‹
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mapping_impl_tr</span> <span class="main">[</span><span class="entity">ty</span><span class="main">]</span> <span class="main">=</span>
     <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_constrain"<span class="antiquote">}</span></span> $ Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_syntax</span> "mapping_impl"<span class="antiquote">}</span></span> $
       <span class="main">(</span>Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> phantom<span class="antiquote">}</span></span> $ <span class="entity">ty</span> $ Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_syntax</span> mapping_impl<span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">mapping_impl_tr</span> <span class="entity">ts</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"mapping_impl_tr"</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="main">[</span><span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_MAPPING_IMPL"<span class="antiquote">}</span></span><span class="main">,</span> K <span class="entity">mapping_impl_tr</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.empty</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> Mapping_empty_code <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>Mapping.empty <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> mapping_impl<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping<span class="main">)</span> <span class="main">=</span>
   mapping_empty <span class="main">(</span>of_phantom <span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generator for the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> mapping_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span>-class›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This generator registers itself at the derive-manager for the classes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> mapping_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Here, one can choose
the desired implementation via the parameter. 

\begin{itemize}
\item \texttt{instantiation type :: (type,\ldots,type) (rbt,assoclist,mapping,choose, or arbitrary constant name) mapping-impl}
\end{itemize}
›</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This generator can be used for arbitrary types, not just datatypes. 
›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹mapping_impl_generator.ML›</span> 

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>assoclist<span class="main">)</span> mapping_impl <span class="quoted">unit</span> <span class="quoted">bool</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> mapping_impl <span class="quoted">nat</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>mapping_RBT<span class="main">)</span> mapping_impl <span class="quoted">int</span> <span class="comment1">(* shows usage of constant names *)</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>assoclist<span class="main">)</span> mapping_impl <span class="quoted">Enum.finite_1</span> <span class="quoted">Enum.finite_2</span> <span class="quoted">Enum.finite_3</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> mapping_impl <span class="quoted">integer</span> <span class="quoted">natural</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> mapping_impl <span class="quoted">char</span>

<span class="keyword1"><span class="command">instantiation</span></span> sum <span class="main">::</span> <span class="main">(</span><span class="quoted">mapping_impl</span><span class="main">,</span> <span class="quoted">mapping_impl</span><span class="main">)</span> <span class="quoted">mapping_impl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> 
  <span class="main">(</span>mapping_impl_choose2 <span class="main">(</span>of_phantom <span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>of_phantom <span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> prod <span class="main">::</span> <span class="main">(</span><span class="quoted">mapping_impl</span><span class="main">,</span> <span class="quoted">mapping_impl</span><span class="main">)</span> <span class="quoted">mapping_impl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">*</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">*</span> <span class="tfree">'b</span><span class="main">)</span> 
  <span class="main">(</span>mapping_impl_choose2 <span class="main">(</span>of_phantom <span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>of_phantom <span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>choose<span class="main">)</span> mapping_impl <span class="quoted">list</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> mapping_impl <span class="quoted">String.literal</span>

<span class="keyword1"><span class="command">instantiation</span></span> option <span class="main">::</span> <span class="main">(</span><span class="quoted">mapping_impl</span><span class="main">)</span> <span class="quoted">mapping_impl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="tfree">'a</span> option<span class="main">)</span> <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span><span class="tfree">'a</span> option<span class="main">)</span> <span class="main">(</span>of_phantom <span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>choose<span class="main">)</span> mapping_impl <span class="quoted">set</span>

<span class="keyword1"><span class="command">instantiation</span></span> phantom <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">,</span> <span class="quoted">mapping_impl</span><span class="main">)</span> <span class="quoted">mapping_impl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> phantom<span class="main">)</span> <span class="main">=</span> <span class="keyword1">Phantom</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> phantom<span class="main">)</span> 
  <span class="main">(</span>of_phantom <span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">Mapping.bulkload</span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span> bulkload_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Mapping.bulkload <span class="free">vs</span> <span class="main">=</span> RBT_Mapping <span class="main">(</span>RBT_Mapping2.bulkload <span class="main">(</span>zip_with_index <span class="free">vs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping.bulkload.abs_eq Mapping_inject ccompare_nat_def ID_def fun_eq_iff<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/mapping_impl_generator.ML">
<div class="head">
<h1>File ‹mapping_impl_generator.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Author:  René Thiemann, UIBK *)</span>
<span class="comment1">(* This generator was written as part of the IsaFoR/CeTA formalization. *)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MAPPING_IMPL_GENERATOR</span> <span class="main">=</span> 
<span class="keyword2"><span class="keyword">sig</span></span> 
  
  <span class="comment1">(* chooses a mapping implementation for a given type *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> derive_mapping_impl <span class="main">:</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Mapping_Impl_Generator</span> <span class="main">:</span> <span class="entity">MAPPING_IMPL_GENERATOR</span> <span class="main">=</span> 
<span class="keyword2"><span class="keyword">struct</span></span>
<span class="keyword3"><span class="keyword">open</span></span> Containers_Generator<span class="main">;</span> 

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">supported_mapping_impl</span> <span class="main">=</span> <span class="main">[</span>
  <span class="main">(</span><span class="inner_quoted">"rbt"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">mapping_RBT</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"assoclist"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">mapping_Assoc_List</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"mapping"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">mapping_Mapping</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"choose"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">mapping_Choose</span><span class="antiquote">}</span></span><span class="main">)</span>
  <span class="main">]</span> 

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">derive_mapping_impl</span> <span class="main">=</span> <span class="entity">derive_set_map_impl</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> mapping_impl<span class="antiquote">}</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">mapping_impl</span><span class="antiquote">}</span></span>
  <span class="entity">supported_mapping_impl</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup 
  <span class="main">(</span><span class="entity">Derive_Manager.register_derive</span> <span class="inner_quoted">"mapping_impl"</span> 
    <span class="main">(</span><span class="inner_quoted">"choose "</span> ^ <span class="entity">Generator_Aux.alist_to_string</span> <span class="entity">supported_mapping_impl</span> ^ 
     <span class="inner_quoted">" or any constant of type mapping_impl for a datatype"</span><span class="main">)</span> <span class="entity">derive_mapping_impl</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Map_To_Mapping">
<div class="head">
<h1>Theory Map_To_Mapping</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Map_To_Mapping.thy
    Author:     Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Map_To_Mapping <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Mapping_Impl.html">Mapping_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Infrastructure for operation identification›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  To convert theorems from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'b</span></span> option"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> using lifting / transfer,
  we first introduce constants for the empty map and map lookup, then apply lifting / transfer,
  and finally eliminate the non-converted constants again.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Dynamic theorem list of rewrite rules that are applied before Transfer.transferred›</span></span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Containers_Pre</span> <span class="main">=</span> <span class="entity">Named_Thms</span>
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> containers_pre<span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">description</span> <span class="main">=</span> <span class="inner_quoted">"Preprocessing rewrite rules in operation identification for Containers"</span>
<span class="main">)</span>
›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Containers_Pre.setup</span>›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Dynamic theorem list of rewrite rules that are applied after Transfer.transferred›</span></span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Containers_Post</span> <span class="main">=</span> <span class="entity">Named_Thms</span>
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> containers_post<span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">description</span> <span class="main">=</span> <span class="inner_quoted">"Postprocessing rewrite rules in operation identification for Containers"</span>
<span class="main">)</span>
›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Containers_Post.setup</span>›</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">map_empty</span> <span class="main">=</span> Map.empty"</span></span>

<span class="keyword1"><span class="command">declare</span></span> map_empty_def<span class="main">[</span><span class="operator">containers_post</span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">,</span> <span class="operator">containers_pre</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> Mapping.empty.transfer<span class="main">[</span><span class="operator">transfer_rule</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> map_empty_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_mapping <span class="free">A</span> <span class="free">B</span><span class="main">)</span> map_empty Mapping.empty"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> map_empty_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Mapping.empty.transfer<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_apply</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> option<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">map_apply</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="bound">m</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> eq_map_apply<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="free">x</span> <span class="main">≡</span> map_apply <span class="free">m</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_apply_def<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> eq_map_apply<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">abs_def</span><span class="main">,</span> <span class="operator">containers_post</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We cannot use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] eq_map_apply<span class="antiquote"><span class="antiquote">}</span></span></span></span> as a fold rule for operator identification,
  because it would loop. We use a simproc instead.›</span></span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_apply_simproc</span> <span class="main">=</span> 
  <span class="entity">Simplifier.make_simproc</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="inner_quoted">"map_apply"</span>
   <span class="main">{</span>lhss <span class="main">=</span> <span class="main">[</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">f</span> <span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span> option"</span><span class="antiquote">}</span></span><span class="main">]</span><span class="main">,</span>
    proc <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ct</span> <span class="main">=&gt;</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ct</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> map_apply<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> NONE
      <span class="main">|</span> <span class="entity">f</span> $ <span class="entity">x</span> <span class="main">=&gt;</span> 
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cTr</span> <span class="main">=</span> 
              Thm.typ_of_cterm <span class="entity">ct</span>
              |&gt; dest_Type
              |&gt; snd |&gt; hd
              |&gt; Thm.ctyp_of <span class="entity">ctxt</span><span class="main">;</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cTx</span> <span class="main">=</span> Thm.ctyp_of <span class="entity">ctxt</span> <span class="main">(</span>fastype_of <span class="entity">x</span><span class="main">)</span><span class="main">;</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cts</span> <span class="main">=</span> map <span class="main">(</span>SOME o Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="main">[</span><span class="entity">f</span><span class="main">,</span> <span class="entity">x</span><span class="main">]</span><span class="main">;</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            SOME <span class="main">(</span>Thm.instantiate' <span class="main">[</span>SOME <span class="entity">cTr</span><span class="main">,</span> SOME <span class="entity">cTx</span><span class="main">]</span> <span class="entity">cts</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eq_map_apply<span class="antiquote">}</span></span></span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span><span class="main">}</span>
›</span>

<span class="keyword1"><span class="command">lemma</span></span> map_apply_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> map_apply map_apply"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> map_apply_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer_prover</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_apply_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_mapping <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> rel_option <span class="free">B</span><span class="main">)</span> map_apply Mapping.lookup"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pcr_mapping_def cr_mapping_def Mapping.lookup_def map_apply_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_funD<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> option <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> option<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> option<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">map_update</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_update_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> rel_option <span class="free">B</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> rel_option <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> rel_option <span class="free">B</span><span class="main">)</span><span class="main">)</span> map_update map_update"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> map_update_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹Local_Theory.map_background_naming <span class="main">(</span>Name_Space.mandatory_path <span class="inner_quoted">"Mapping"</span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">lift_definition</span></span> update' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> option <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">map_update</span> <span class="keyword2"><span class="keyword">parametric</span></span> map_update_parametric <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> update'_code <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">,</span> <span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"update' <span class="free">x</span> None <span class="main">=</span> Mapping.delete <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"update' <span class="free">x</span> <span class="main">(</span>Some <span class="free">y</span><span class="main">)</span> <span class="main">=</span> Mapping.update <span class="free">x</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_update_def fun_eq_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span> map_update_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">,</span> <span class="operator">containers_post</span><span class="main">]</span> map_update_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">containers_pre</span><span class="main">]</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_is_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> option<span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">map_is_empty</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> Map.empty"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_is_empty_folds<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> map_empty <span class="main">⟷</span> map_is_empty <span class="free">m</span>"</span></span>
  <span class="quoted"><span class="quoted">"map_empty <span class="main">=</span> <span class="free">m</span> <span class="main">⟷</span> map_is_empty <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_is_empty_def map_empty_def<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> map_is_empty_folds<span class="main">[</span><span class="operator">containers_pre</span><span class="main">]</span>
  map_is_empty_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">,</span> <span class="operator">containers_post</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> map_is_empty_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"bi_total <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pcr_mapping <span class="free">A</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> map_is_empty Mapping.is_empty"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> map_is_empty_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> Mapping.is_empty_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> dom_eq_empty_conv<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> dom_eq_empty_conv <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_setD2 rel_setD1 Mapping.keys.transfer<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CONTAINERS</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> identify <span class="main">:</span> Context.generic <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> identify_attribute <span class="main">:</span> attribute<span class="main">;</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Containers</span><span class="main">:</span> <span class="entity">CONTAINERS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">identify</span> <span class="entity">context</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> Context.proof_of <span class="entity">context</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss</span> <span class="main">=</span> put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt1</span> <span class="main">=</span> <span class="entity">ss</span> addsimps <span class="entity">Containers_Pre.get</span> <span class="entity">ctxt'</span> addsimprocs <span class="main">[</span><span class="entity">map_apply_simproc</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt2</span> <span class="main">=</span> <span class="entity">ss</span> addsimps <span class="entity">Containers_Post.get</span> <span class="entity">ctxt'</span>

    <span class="comment1">(* Hack to recover Transfer.transferred function from attribute *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transfer_transferred</span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">Transfer.transferred_attribute</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">context</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> |&gt; snd |&gt; the
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">thm</span>
    |&gt; <span class="entity">full_simplify</span> <span class="entity">ctxt1</span>
    |&gt; <span class="entity">transfer_transferred</span>
    |&gt; <span class="entity">full_simplify</span> <span class="entity">ctxt2</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">identify_attribute</span> <span class="main">=</span> Thm.rule_attribute <span class="main">[</span><span class="main">]</span> <span class="entity">identify</span>

<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">attribute_setup</span></span> <span class="quoted">"containers_identify"</span> <span class="main">=</span>
  <span class="quoted">‹Scan.succeed <span class="entity">Containers.identify_attribute</span>›</span>
  <span class="quoted">"Transfer theorems for operator identification in Containers"</span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> map_apply map_empty map_is_empty map_update
<span class="keyword1"><span class="command">hide_fact</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> map_apply_def map_empty_def eq_map_apply

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Containers">
<div class="head">
<h1>Theory Containers</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Containers.thy
    Author:     Andreas Lochbihler, KIT *)</span>

<span class="keyword1"><span class="command">theory</span></span> Containers <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Set_Linorder.html">Set_Linorder</a>
  <a href="Collection_Order.html">Collection_Order</a>
  <a href="Collection_Eq.html">Collection_Eq</a>
  <a href="Collection_Enum.html">Collection_Enum</a>
  <a href="Equal.html">Equal</a>
  <a href="Mapping_Impl.html">Mapping_Impl</a>
  <a href="Map_To_Mapping.html">Map_To_Mapping</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Compatibility_Containers_Regular_Sets">
<div class="head">
<h1>Theory Compatibility_Containers_Regular_Sets</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Compatibility_Containers_Regular_Sets.thy
    Author:     Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Compatibility with Regular-Sets›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Compatibility_Containers_Regular_Sets <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Containers.html">Containers</a>
  <span class="quoted">"<a href="../Regular-Sets/Regexp_Method.html">Regular-Sets.Regexp_Method</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Adaptation theory to make <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>regexp›</span></span></span></span> work when <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Containers.html"></a><a href="Containers.html">Containers.Containers</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> are loaded.

  Warning: Each invocation of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>regexp›</span></span></span></span> takes longer than without <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Containers.html"></a><a href="Containers.html">Containers.Containers</a><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  because the code generator takes longer to generate the evaluation code for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>regexp›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">datatype_compat</span></span> rexp
<span class="keyword1"><span class="command">derive</span></span> ceq <span class="quoted">rexp</span>
<span class="keyword1"><span class="command">derive</span></span> ccompare <span class="quoted">rexp</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>choose<span class="main">)</span> set_impl <span class="quoted">rexp</span>

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span> <span class="skolem">s</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">r</span> <span class="main">∪</span> <span class="skolem">s</span><span class="main">^+</span><span class="main">)</span><span class="main">^*</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">r</span> <span class="main">∪</span> <span class="skolem">s</span><span class="main">)</span><span class="main">^*</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">regexp</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Containers_Userguide">
<div class="head">
<h1>Theory Containers_Userguide</h1>
</div>
<pre class="source"><span class="comment1">(* Title:      Containers/Containers_Userguide.thy
   Author:     Andreas Lochbihler, ETH Zurich *)</span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Containers_Userguide <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Card_Datatype.html">Card_Datatype</a>
  <a href="List_Proper_Interval.html">List_Proper_Interval</a>
  <a href="Containers.html">Containers</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹User guide›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{chapter:Userguide}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This user guide shows how to use and extend the lightweight containers framework (LC).
  For a more theoretical discussion, see \cite{Lochbihler2013ITP}.
  This user guide assumes that you are familiar with refinement in the code generator \cite{HaftmannBulwahn2013codetut,HaftmannKrausKuncarNipkow2013ITP}.
  The theory <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Containers_Userguide›</span></span></span></span> generates it; so if you want to experiment with the examples, you can find their source code there.
  Further examples can be found in the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">dir</span></span> ‹Examples›<span class="antiquote"><span class="antiquote">}</span></span></span></span> folder.
›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Characteristics›</span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
  \isastyletext
  \begin{itemize}
›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
  \isastyletext
  \item \textbf{Separate type classes for code generation}
    \\
    LC follows the ideal that type classes for code generation should be separate from the standard type classes in Isabelle.
    LC's type classes are designed such that every type can become an instance, so well-sortedness errors during code generation can always be remedied.
›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
  \isastyletext
  \item \textbf{Multiple implementations}
    \\
    LC supports multiple simultaneous implementations of the same container type.
    For example, the following implements at the same time
    (i)~the set of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">bool</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as a distinct list of the elements,
    (ii)~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"int set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as a RBT of the elements or as the RBT of the complement, and
    (iii)~sets of functions as monad-style lists:
    \par
›</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">{</span>True<span class="main">}</span><span class="main">,</span> <span class="main">{</span><span class="main">1</span> <span class="main">::</span> int<span class="main">}</span><span class="main">,</span> <span class="main">-</span> <span class="main">{</span><span class="numeral">2</span> <span class="main">::</span> int<span class="main">,</span> <span class="numeral">3</span><span class="main">}</span><span class="main">,</span> <span class="main">{</span><span class="main">λ</span><span class="bound">x</span> <span class="main">::</span> int<span class="main">.</span> <span class="bound">x</span> <span class="main">*</span> <span class="bound">x</span><span class="main">,</span> <span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">+</span> <span class="main">1</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
    \isastyletext
    \par
    The LC type classes are the key to simultaneously supporting different implementations.

  \item \textbf{Extensibility}
    \\
    The LC framework is designed for being extensible.
    You can add new containers, implementations and element types any time.
  \end{itemize}
›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Getting started›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{section:getting:started}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Add the entry theory <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Containers.html"></a><a href="Containers.html">Containers.Containers</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> for LC to the end of your imports.
  This will reconfigure the code generator such that it implements the types <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for sets and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for maps with one of the data structures supported.
  As with all the theories that adapt the code generator setup, it is important that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Containers.html"></a><a href="Containers.html">Containers.Containers</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> comes at the end of the imports.

  Run the following command, e.g., to check that LC works correctly and implements sets of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">int</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>s as red-black trees (RBT):
›</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">1</span> <span class="main">::</span> int<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This should produce <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">value</span></span> [names_short] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{</span></span><span class="main"><span class="main">1</span></span> <span class="main"><span class="main">::</span></span> int<span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Without LC, sets are represented as (complements of) a list of elements, i.e., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"set <span class="main"><span class="main">[</span></span><span class="main"><span class="main">1</span></span> <span class="main"><span class="main">::</span></span> int<span class="main"><span class="main">]</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the example.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  If your exported code does not use your own types as elements of sets or maps and you have not declared any code equation for these containers, then your \isacommand{export{\isacharunderscore}code} command will use LC to implement <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  
  Our running example will be arithmetic expressions.
  The function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">vars</span></span> <span class="free"><span class="free">e</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> computes the variables that occur in the expression <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">e</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> vname <span class="main">=</span> <span class="quoted">string</span>
<span class="keyword1"><span class="command">datatype</span></span> expr <span class="main">=</span> Var <span class="quoted">vname</span> <span class="main">|</span> Lit <span class="quoted">int</span> <span class="main">|</span> Add <span class="quoted">expr</span> <span class="quoted">expr</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">vars</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr <span class="main">⇒</span> vname set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">vars</span> <span class="main">(</span>Var <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">vars</span> <span class="main">(</span>Lit <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">vars</span> <span class="main">(</span>Add <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">vars</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∪</span> <span class="free">vars</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"vars <span class="main">(</span>Var <span class="inner_quoted">''x''</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  To illustrate how to deal with type variables, we will use the following variant where variable names are polymorphic:
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> expr' <span class="main">=</span> Var' <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">|</span> Lit' <span class="quoted">int</span> <span class="main">|</span> Add' <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> expr'"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> expr'"</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">vars'</span> <span class="main">::</span>  <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> expr' <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">vars'</span> <span class="main">(</span>Var' <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">vars'</span> <span class="main">(</span>Lit' <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">vars'</span> <span class="main">(</span>Add' <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">vars'</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∪</span> <span class="free">vars'</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"vars' <span class="main">(</span>Var' <span class="main">(</span><span class="main">1</span> <span class="main">::</span> int<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹New types as elements›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This section explains LC's type classes and shows how to instantiate them.
  If you want to use your own types as the elements of sets or the keys of maps, you must instantiate up to eight type classes: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:ceq}), <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccompare<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:ccompare}), <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> set_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:set_impl}), <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> mapping_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:mapping_impl}), <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cenum<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:cenum}), <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> finite_UNIV<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:finite_UNIV}), <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> card_UNIV<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:card_UNIV}), and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cproper_interval<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:cproper_interval}).
  Otherwise, well-sortedness errors like the following will occur:
\begin{verbatim}
*** Wellsortedness error:
*** Type expr not of sort {ceq,ccompare}
*** No type arity expr :: ceq
*** At command "value"
\end{verbatim}

  In detail, the sort requirements on the element type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are:
  \begin{itemize}
  \item <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:ceq}), <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccompare<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:ccompare}), and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> set_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:set_impl}) for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in general
  \item <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cenum<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:cenum}) for set comprehensions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="free"><span class="free">P</span></span> <span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  \item <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> card_UNIV<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cproper_interval<span class="antiquote"><span class="antiquote">}</span></span></span></span> for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> set set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and any deeper nesting of sets (\S\ref{subsection:card_UNIV}),%
   \footnote{%
     These type classes are only required for set complements (see \S\ref{subsection:well:sortedness}).
   }
    and
  \item <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> equal<span class="antiquote"><span class="antiquote">}</span></span></span></span>,%
    \footnote{%
      We deviate here from the strict separation of type classes, because it does not make sense to store types in a map on which we do not have equality, because the most basic operation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Mapping.lookup"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> inherently requires equality.
    }
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccompare<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:ccompare}) and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> mapping_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:mapping_impl}) for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  \end{itemize}
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Equality testing›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{subsection:ceq}›</span></span>

<span class="comment1">(*&lt;*)</span><span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dummy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>cenum<span class="main">,</span> ceq<span class="main">,</span> ccompare<span class="main">,</span> set_impl<span class="main">,</span> mapping_impl<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span><span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The type class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span> defines the operation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> bool<span class="main"><span class="main">)</span></span> option"</span></span> <span class="antiquote"><span class="antiquote">}</span></span></span></span> for testing whether two elements are equal.%
  \footnote{%
    Technically, the type class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span> defines the operation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">ceq</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
    As usage often does not fully determine <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">ceq</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>'s type, we use the notation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> that explicitly mentions the type.
    In detail, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is translated to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> bool<span class="main"><span class="main">)</span></span> option"</span></span> <span class="antiquote"><span class="antiquote">}</span></span></span></span> including the type constraint.
    We do the same for the other type class operators:
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CCOMPARE</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> constrains the operation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">ccompare</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (\S\ref{subsection:ccompare}), 
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">SET_IMPL</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> constrains the operation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">set_impl</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, (\S\ref{subsection:set_impl}),
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">MAPPING_IMPL</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (constrains the operation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">mapping_impl</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, (\S\ref{subsection:mapping_impl}), and
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CENUM</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> constrains the operation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">cenum</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, \S\ref{subsection:cenum}.
  }
  The test is embedded in an <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>option›</span></span></span></span> value to allow for types that do not support executable equality test such as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Whenever possible, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> should provide an executable equality operator.
  Otherwise, membership tests on such sets will raise an exception at run-time.

  For data types, the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive›</span></span></span></span> command can automatically instantiates of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  we only have to tell it whether an equality operation should be provided or not (parameter <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>no›</span></span></span></span>).
›</span></span>
<span class="comment1">(*&lt;*)</span><span class="keyword2"><span class="keyword">end</span></span><span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>eq<span class="main">)</span> ceq <span class="quoted">expr</span>

<span class="keyword1"><span class="command">datatype</span></span> example <span class="main">=</span> Example
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>no<span class="main">)</span> ceq <span class="quoted">example</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In the remainder of this subsection, we look at how to manually instantiate a type for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  First, the simple case of a type constructor <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>simple_tycon›</span></span></span></span> without parameters that already is an instance of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> equal<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
›</span></span>
<span class="keyword1"><span class="command">typedecl</span></span> simple_tycon
<span class="keyword1"><span class="command">axiomatization</span></span> <span class="keyword2"><span class="keyword">where</span></span> simple_tycon_equal<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">OFCLASS</span><span class="main">(</span>simple_tycon<span class="main">,</span> equal_class<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> simple_tycon <span class="main">::</span> <span class="quoted">equal</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> simple_tycon_equal<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> simple_tycon <span class="main">::</span> <span class="quoted">ceq</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CEQ</span><span class="main">(</span>simple_tycon<span class="main">)</span> <span class="main">=</span> Some <span class="main">(=)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ceq_simple_tycon_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  For polymorphic types, this is a bit more involved, as the next example with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> expr'"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> illustrates (note that we could have delegated all this to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive›</span></span></span></span>). 
  First, we need an operation that implements equality tests with respect to a given equality operation on the polymorphic type.
  For data types, we can use the relator which the transfer package (method <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>transfer›</span></span></span></span>) requires and the BNF package generates automatically.
  As we have used the old datatype package for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> expr'"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, we must define it manually:
›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">expr'_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> expr' <span class="main">⇒</span> <span class="tfree">'b</span> expr' <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">expr'_rel</span> <span class="main">(</span>Var' <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>      <span class="main">(</span>Var' <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span>        <span class="main">⟷</span> <span class="free">R</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">expr'_rel</span> <span class="main">(</span>Lit' <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>        <span class="main">(</span>Lit' <span class="free"><span class="bound"><span class="entity">i'</span></span></span><span class="main">)</span>         <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i'</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">expr'_rel</span> <span class="main">(</span>Add' <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">(</span>Add' <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub>'</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub>'</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">expr'_rel</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub>'</span></span></span> <span class="main">∧</span> <span class="free">expr'_rel</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub>'</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">expr'_rel</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span>                 <span class="main"><span class="bound"><span class="entity">_</span></span></span>                <span class="main">⟷</span> False"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If we give HOL equality as parameter, the relator is equality:›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> expr'_rel_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"expr'_rel <span class="main">(=)</span> <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⟷</span> <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="quoted"><span class="free">e<span class="hidden">⇩</span><sub>2</sub></span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> expr'_rel.induct<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Then, the instantiation is again canonical:
›</span></span>
<span class="keyword1"><span class="command">instantiation</span></span> expr' <span class="main">::</span> <span class="main">(</span><span class="quoted">ceq</span><span class="main">)</span> <span class="quoted">ceq</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span> expr'<span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="bound">eq</span> <span class="main">⇒</span> Some <span class="main">(</span>expr'_rel <span class="bound">eq</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span>
    <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ceq_expr'_def expr'_rel_eq<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> 
          <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Collection_Eq.ID_ceq 
          <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&lt;*)</span><span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dummy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq"</span></span> <span class="keyword2"><span class="keyword">begin</span></span><span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Note the following two points:
  First, the instantiation should avoid to use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(=)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> on terms of the polymorphic type.
  This keeps the LC framework separate from the type class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> equal<span class="antiquote"><span class="antiquote">}</span></span></span></span>, i.e., every choice of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> expr'"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> can be of sort <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> "ceq"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  The easiest way to achieve this is to obtain the equality test from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Second, we use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ID <span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  In proofs, we want that the simplifier uses assumptions like <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>CEQ('a) = Some …›</span></span></span></span> for rewriting.
  However, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a nullary constant, so the simplifier reverses such an equation, i.e., it only rewrites <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Some …›</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">::</span></span> ceq<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Applying the identity function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ID"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">::</span></span> ceq<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> avoids this, and the code generator eliminates all occurrences of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ID"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Although <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> ID_def<span class="antiquote"><span class="antiquote">}</span></span></span></span> by definition, do not use the conventional <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"id"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">ID</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"id <span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">::</span></span> ceq<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> immediately simplifies to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">::</span></span> ceq<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="comment1">(*&lt;*)</span><span class="keyword2"><span class="keyword">end</span></span><span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Ordering›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{subsection:ccompare}›</span></span>

<span class="comment1">(*&lt;*)</span><span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dummy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>ccompare<span class="main">,</span> ceq<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span><span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  LC takes the order for storing elements in search trees from the type class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccompare<span class="antiquote"><span class="antiquote">}</span></span></span></span> rather than <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>, because we cannot instantiate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span> for some types (e.g., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(⊆)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not linear).
  Similar to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">ceq</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccompare<span class="antiquote"><span class="antiquote">}</span></span></span></span> specifies an optional comparator <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CCOMPARE</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> order<span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> option"</span></span> <span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  If you cannot or do not want to implement a comparator on your type, you can default to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"None"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  In that case, you will not be able to use your type as elements of sets or as keys in maps implemented by search trees.

  If the type is a data type or instantiates <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span> and we wish to use that comparator also for the search tree, instantiation is again canonical:
  For our data type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">expr</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, derive does everything!
›</span></span>
<span class="comment1">(*&lt;*)</span><span class="keyword2"><span class="keyword">end</span></span><span class="comment1">(*&gt;*)</span>
<span class="comment1">(*&lt;*)</span><span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">derive</span></span> ccompare <span class="quoted">expr</span>
<span class="comment1">(*&lt;*)</span><span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In general, the pattern for type constructors without parameters looks as follows:
›</span></span>
<span class="keyword1"><span class="command">axiomatization</span></span> <span class="keyword2"><span class="keyword">where</span></span> simple_tycon_compare<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">OFCLASS</span><span class="main">(</span>simple_tycon<span class="main">,</span> compare_class<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> simple_tycon <span class="main">::</span> <span class="quoted">compare</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> simple_tycon_compare<span class="main">)</span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>compare<span class="main">)</span> ccompare <span class="quoted">simple_tycon</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  For polymorphic types like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> expr'"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, we should not do everything manually:
  First, we must define a comparator that takes the comparator on the type variable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as a parameter.
  This is necessary to maintain the separation between Isabelle/HOL's type classes (like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>) and LC's.
  Such a comparator is again easily defined by derive.
›</span></span>

<span class="keyword1"><span class="command">derive</span></span> ccompare <span class="quoted">expr'</span>

<span class="keyword1"><span class="command">thm</span></span> ccompare_expr'_def comparator_expr'_simps

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Heuristics for picking an implementation›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{subsection:set_impl} \label{subsection:mapping_impl}›</span></span>
<span class="comment1">(*&lt;*)</span><span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dummy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>ceq<span class="main">,</span> ccompare<span class="main">,</span> set_impl<span class="main">,</span> mapping_impl<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span><span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Now, we have defined the necessary operations on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">expr</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> expr'"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to store them in a set 
  or use them as the keys in a map.
  But before we can actually do so, we also have to say which data structure to use.
  The type classes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> set_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> mapping_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> are used for this.

  They define the overloaded operations <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">SET_IMPL</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> set_impl<span class="main"><span class="main">)</span></span> phantom"</span></span> <span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">MAPPING_IMPL</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> mapping_impl<span class="main"><span class="main">)</span></span> phantom"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, respectively.
  The phantom type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> phantom"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from theory <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="../../HOL/HOL-Library/Phantom_Type.html"></a><a href="../../HOL/HOL-Library/Phantom_Type.html">HOL-Library.Phantom_Type</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is isomorphic to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, but formally depends on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  This way, the type class operations meet the requirement that their type contains exactly one type variable.
  The Haskell and ML compiler will get rid of the extra type constructor again.

  For sets, you can choose between <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">set_Collect</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (characteristic function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">P</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> like in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="free"><span class="free">P</span></span> <span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>), <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">set_DList</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (distinct list), <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">set_RBT</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (red-black tree), and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">set_Monad</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (list with duplicates).
  Additionally, you can define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"set_impl"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"set_Choose"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> which picks the implementation based on the available operations (RBT if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CCOMPARE</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> provides a linear order, else distinct lists if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> provides equality testing, and lists with duplicates otherwise).
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"set_Choose"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the safest choice because it picks only a data structure when the required operations are actually available.
  If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">set_impl</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> picks a specific implementation, Isabelle does not ensure that all required operations are indeed available.

  For maps, the choices are <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"mapping_Assoc_List"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (associative list without duplicates), <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"mapping_RBT"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (red-black tree), and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"mapping_Mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (closures with function update).
  Again, there is also the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"mapping_Choose"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> heuristics.
  
  For simple cases, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive›</span></span></span></span> can be used again (even if the type is not a data type).
  Consider, e.g., the following instantiations:
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"expr set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> uses RBTs, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span>expr<span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> expr' set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> use the heuristics, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> expr'<span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> uses the same implementation as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="comment1">(*&lt;*)</span><span class="keyword2"><span class="keyword">end</span></span><span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> set_impl <span class="quoted">expr</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>choose<span class="main">)</span> mapping_impl <span class="quoted">expr</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>choose<span class="main">)</span> set_impl <span class="quoted">expr'</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  More complex cases such as taking the implementation preference of a type parameter must be done manually.
›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> expr' <span class="main">::</span> <span class="main">(</span><span class="quoted">mapping_impl</span><span class="main">)</span> <span class="quoted">mapping_impl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="tfree">'a</span> expr'<span class="main">)</span> <span class="main">=</span> 
   <span class="keyword1">Phantom</span><span class="main">(</span><span class="tfree">'a</span> expr'<span class="main">)</span> <span class="main">(</span>of_phantom <span class="keyword1">MAPPING_IMPL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">locale</span></span> mynamespace <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">empty</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">empty</span> <span class="main">=</span> Mapping.empty"</span></span> 
<span class="keyword1"><span class="command">declare</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> mynamespace.empty_def <span class="main">[</span><span class="operator">code</span><span class="main">]</span>
<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  To see the effect of the different configurations, consider the following examples where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [names_short] <span class="quoted"><span class="quoted">"empty"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> refers to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Mapping.empty"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  For that, we must disable pretty printing for sets as follows:
›</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="comment1">(*&lt;*)</span><span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="comment1">(*&gt;*)</span>pretty_sets<span class="main">[</span><span class="operator">code_post</span> <span class="quasi_keyword">del</span><span class="main">]</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \begin{center}
    \small
    \begin{tabular}{ll}
      \toprule
      \isamarkuptrue\isacommand{value}\isamarkupfalse\ {\isacharbrackleft}code{\isacharbrackright}
      &amp;
      \textbf{result}
      \\
      \midrule
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{}</span></span> <span class="main"><span class="main">::</span></span> expr set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      &amp;
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">value</span></span> [names_short] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{}</span></span> <span class="main"><span class="main">::</span></span> expr set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"empty <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span>expr<span class="main"><span class="main">,</span></span> unit<span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      &amp;
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">value</span></span> [names_short] <span class="quoted"><span class="quoted">"empty <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span>expr<span class="main"><span class="main">,</span></span> unit<span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      \midrule
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{}</span></span> <span class="main"><span class="main">::</span></span> string expr' set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
     &amp;
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">value</span></span> [names_short] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{}</span></span> <span class="main"><span class="main">::</span></span> string expr' set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{}</span></span> <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span>nat <span class="main"><span class="main">⇒</span></span> nat<span class="main"><span class="main">)</span></span> expr' set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      &amp;
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">value</span></span> [names_short] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{}</span></span> <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span>nat <span class="main"><span class="main">⇒</span></span> nat<span class="main"><span class="main">)</span></span> expr' set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{}</span></span> <span class="main"><span class="main">::</span></span> bool expr' set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      &amp;
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">value</span></span> [names_short] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{}</span></span> <span class="main"><span class="main">::</span></span> bool expr' set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"empty <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span>bool expr'<span class="main"><span class="main">,</span></span> unit<span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      &amp;
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">value</span></span> [names_short] <span class="quoted"><span class="quoted">"empty <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span>bool expr'<span class="main"><span class="main">,</span></span> unit<span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      \bottomrule
    \end{tabular}
  \end{center}
  
  For <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">expr</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">mapping_Choose</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> picks RBTs, because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CCOMPARE</span></span><span class="main"><span class="main">(</span></span>expr<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> provides a comparison operation for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"expr"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  For <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> expr'"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the effect of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">set_Choose</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is more pronounced:
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CCOMPARE</span></span><span class="main"><span class="main">(</span></span>string<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"None"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, so neither is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CCOMPARE</span></span><span class="main"><span class="main">(</span></span>string expr'<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">set_Choose</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> picks RBTs.
  As <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"nat <span class="main"><span class="main">⇒</span></span> nat"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> neither provides equality tests (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span>) nor comparisons (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccompare<span class="antiquote"><span class="antiquote">}</span></span></span></span>), neither does <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span>nat <span class="main"><span class="main">⇒</span></span> nat<span class="main"><span class="main">)</span></span> expr'"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, so we use lists with duplicates.
  The last two examples show the difference between inheriting a choice and choosing freshly:
  By default, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">bool</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> prefers distinct (associative) lists over RBTs, because there are just two elements.
  As <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"bool expr'"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> enherits the choice for maps from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">bool</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, an associative list implements <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"empty <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span>bool expr'<span class="main"><span class="main">,</span></span> unit<span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  For sets, in contrast, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">SET_IMPL</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> expr'<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> discards <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>'s preferences and picks RBTs, because there is a comparison operation.

  Finally, let's enable pretty-printing for sets again:
›</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="comment1">(*&lt;*)</span><span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="comment1">(*&gt;*)</span>pretty_sets <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span>
<span class="comment1">(*&lt;*)</span>
  <span class="comment1">(* The following value commands ensure that the code generator executes @{value ...} above,
     I could not find a way to specify [code] to @{value}. *)</span>
  <span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">::</span> expr set"</span></span>
  <span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"empty <span class="main">::</span> <span class="main">(</span>expr<span class="main">,</span> unit<span class="main">)</span> mapping"</span></span>
  <span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">::</span> string expr' set"</span></span>
  <span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">::</span> <span class="main">(</span>nat <span class="main">⇒</span> nat<span class="main">)</span> expr' set"</span></span>
  <span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">::</span> bool expr' set"</span></span>
  <span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"empty <span class="main">::</span> <span class="main">(</span>bool expr'<span class="main">,</span> unit<span class="main">)</span> mapping"</span></span>
<span class="comment1">(*&gt;*)</span>   
<span class="comment1">(*&lt;*)</span><span class="keyword2"><span class="keyword">end</span></span><span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Set comprehensions›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{subsection:cenum}›</span></span>

<span class="comment1">(*&lt;*)</span><span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dummy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> cenum"</span></span> <span class="keyword2"><span class="keyword">begin</span></span><span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  If you use the default code generator setup that comes with Isabelle, set comprehensions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="free"><span class="free">P</span></span> <span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">}</span></span> <span class="main"><span class="main">::</span></span> <span class="tfree"><span class="tfree">'a</span></span> set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are only executable if the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> has sort <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> enum<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Internally, Isabelle's code generator transforms set comprehensions into an explicit list of elements which it obtains from the list <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">enum</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of all of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>'s elements.
  Thus, the type must be an instance of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> enum<span class="antiquote"><span class="antiquote">}</span></span></span></span>, i.e., finite in particular.
  For example, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{</span></span><span class="bound"><span class="bound">c</span></span><span class="main"><span class="main">.</span></span> <span class="keyword1"><span class="keyword1">CHR</span></span> <span class="inner_quoted"><span class="inner_quoted">''A''</span></span> <span class="main"><span class="main">≤</span></span> <span class="bound"><span class="bound">c</span></span> <span class="main"><span class="main">∧</span></span> <span class="bound"><span class="bound">c</span></span> <span class="main"><span class="main">≤</span></span> <span class="keyword1"><span class="keyword1">CHR</span></span> <span class="inner_quoted"><span class="inner_quoted">''D''</span></span><span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> evaluates to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"set <span class="inner_quoted"><span class="inner_quoted">''ABCD''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the set of the characters A, B, C, and D.

  For compatibility, LC also implements such an enumeration strategy, but avoids the finiteness restriction.
  The type class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cenum<span class="antiquote"><span class="antiquote">}</span></span></span></span> mimicks <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> enum<span class="antiquote"><span class="antiquote">}</span></span></span></span>, but its single parameter <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"cEnum <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> list <span class="main"><span class="main">×</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">⇒</span></span> bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">×</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> bool<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">⇒</span></span> bool<span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> option"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> combines all of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> enum<span class="antiquote"><span class="antiquote">}</span></span></span></span>'s parameters, namely a list of all elements, a universal and an existential quantifier.
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>option›</span></span></span></span> ensures that every type can be an instance as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CENUM</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> can always default to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">None</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  
  For types that define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CENUM</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, set comprehensions evaluate to a list of their elements.
  Otherwise, set comprehensions are represented as a closure.
  This means that if the generated code contains at least one set comprehension, all element types of a set must instantiate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cenum<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Infinite types default to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">None</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and enumerations for finite types are canoncial, see <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Collection_Enum.html"></a><a href="Collection_Enum.html">Containers.Collection_Enum</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> for examples.
›</span></span>
<span class="comment1">(*&lt;*)</span><span class="keyword2"><span class="keyword">end</span></span><span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">instantiation</span></span> expr <span class="main">::</span> <span class="quoted">cenum</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CENUM</span><span class="main">(</span>expr<span class="main">)</span> <span class="main">=</span> None"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cEnum_expr_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>no<span class="main">)</span> cenum <span class="quoted">expr'</span>
<span class="keyword1"><span class="command">derive</span></span> compare_order <span class="quoted">expr</span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\par\medskip \isastyletext For example,›</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="bound">b</span> <span class="main">=</span> True<span class="main">}</span><span class="main">,</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> compare <span class="bound">x</span> <span class="main">(</span>Lit <span class="main">0</span><span class="main">)</span> <span class="main">=</span> Lt<span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
  \isastyletext{}
  yields <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">value</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">{</span></span><span class="bound"><span class="bound">b</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">b</span></span> <span class="main"><span class="main">=</span></span> True<span class="main"><span class="main">}</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">{</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> compare <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">(</span></span>Lit <span class="main"><span class="main">0</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> Lt<span class="main"><span class="main">}</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  LC keeps complements of such enumerated set comprehensions, i.e., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">-</span></span> <span class="main"><span class="main">{</span></span><span class="bound"><span class="bound">b</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">b</span></span> <span class="main"><span class="main">=</span></span> True<span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> evaluates to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">value</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">-</span></span> <span class="main"><span class="main">{</span></span><span class="bound"><span class="bound">b</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">b</span></span> <span class="main"><span class="main">=</span></span> True<span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  If you want that the complement operation actually computes the elements of the complements, you have to replace the code equations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">uminus</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as follows:
›</span></span>
<span class="keyword1"><span class="command">declare</span></span> Set_uminus_code<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span> Set_uminus_cenum<span class="main">[</span><span class="operator">code</span><span class="main">]</span>
<span class="comment1">(*&lt;*)</span><span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="bound">b</span> <span class="main">=</span> True<span class="main">}</span>"</span></span><span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Then, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">-</span></span> <span class="main"><span class="main">{</span></span><span class="bound"><span class="bound">b</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">b</span></span> <span class="main"><span class="main">=</span></span> True<span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> becomes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">value</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">-</span></span> <span class="main"><span class="main">{</span></span><span class="bound"><span class="bound">b</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">b</span></span> <span class="main"><span class="main">=</span></span> True<span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, but this applies to all complement invocations.
  For example, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"UNIV <span class="main"><span class="main">::</span></span> bool set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> becomes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">value</span></span> <span class="quoted"><span class="quoted">"UNIV <span class="main"><span class="main">::</span></span> bool set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="comment1">(*&lt;*)</span><span class="keyword1"><span class="command">declare</span></span> Set_uminus_cenum<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword">del</span></span><span class="main">]</span> Set_uminus_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Nested sets›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{subsection:finite_UNIV} \label{subsection:card_UNIV} \label{subsection:cproper_interval}›</span></span>

<span class="comment1">(*&lt;*)</span><span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">dummy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>card_UNIV<span class="main">,</span> cproper_interval<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span><span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  To deal with nested sets such as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"expr set set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the element type must provide three operations from three type classes:
  \begin{itemize}
  \item <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> finite_UNIV<span class="antiquote"><span class="antiquote">}</span></span></span></span> from theory <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="../../HOL/HOL-Library/Cardinality.html"></a><a href="../../HOL/HOL-Library/Cardinality.html">HOL-Library.Cardinality</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span> defines the constant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"finite_UNIV <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> bool<span class="main"><span class="main">)</span></span> phantom"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> which designates whether the type is finite.
  \item <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> card_UNIV<span class="antiquote"><span class="antiquote">}</span></span></span></span> from theory <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="../../HOL/HOL-Library/Cardinality.html"></a><a href="../../HOL/HOL-Library/Cardinality.html">HOL-Library.Cardinality</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span> defines the constant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"card_UNIV <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> nat<span class="main"><span class="main">)</span></span> phantom"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> which returns <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CARD</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, i.e., the number of values in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
    If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is infinite, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CARD</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">0</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  \item <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cproper_interval<span class="antiquote"><span class="antiquote">}</span></span></span></span> from theory <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Collection_Order.html"></a><a href="Collection_Order.html">Containers.Collection_Order</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> defines the function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"cproper_interval <span class="main"><span class="main">::</span></span> <span class="tfree"><span class="tfree">'a</span></span> option <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span> option <span class="main"><span class="main">⇒</span></span> bool"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
    If the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is finite and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CCOMPARE</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> yields a linear order on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, then <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"cproper_interval <span class="free"><span class="free">x</span></span> <span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> returns whether the open interval between <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is non-empty.
    The bound <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"None"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> denotes unboundedness.
  \end{itemize}

  Note that the type class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> finite_UNIV<span class="antiquote"><span class="antiquote">}</span></span></span></span> must not be confused with the type class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> finite<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> finite_UNIV<span class="antiquote"><span class="antiquote">}</span></span></span></span> allows the generated code to examine whether a type is finite whereas <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> finite<span class="antiquote"><span class="antiquote">}</span></span></span></span> requires that the type in fact is finite.
›</span></span>
<span class="comment1">(*&lt;*)</span><span class="keyword2"><span class="keyword">end</span></span><span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  For datatypes, the theory <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Card_Datatype.html"></a><a href="Card_Datatype.html">Containers.Card_Datatype</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> defines some machinery to assist in proving that the type is (in)finite and has a given number of elements -- see <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">file</span></span> ‹Examples/Card_Datatype_Ex.thy›<span class="antiquote"><span class="antiquote">}</span></span></span></span> for examples.
  With this, it is easy to instantiate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> card_UNIV<span class="antiquote"><span class="antiquote">}</span></span></span></span> for our running examples:
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> inj_expr <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inj Lit"</span></span> <span class="quoted"><span class="quoted">"inj Var"</span></span> <span class="quoted"><span class="quoted">"inj Add"</span></span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>Add <span class="free">e</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff inj_on_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> infinite_UNIV_expr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> finite <span class="main">(</span>UNIV <span class="main">::</span> expr set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> card_datatype
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rangeIt <span class="main">(</span>Lit <span class="main">0</span><span class="main">)</span> <span class="main">(</span>Add <span class="main">(</span>Lit <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> UNIV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> expr <span class="main">::</span> <span class="quoted">card_UNIV</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"finite_UNIV <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span>expr<span class="main">)</span> False"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"card_UNIV <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span>expr<span class="main">)</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_UNIV_expr_def card_UNIV_expr_def infinite_UNIV_expr<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> inj_expr' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inj Lit'"</span></span> <span class="quoted"><span class="quoted">"inj Var'"</span></span> <span class="quoted"><span class="quoted">"inj Add'"</span></span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>Add' <span class="free">e</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff inj_on_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> infinite_UNIV_expr'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> expr' set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> card_datatype
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rangeIt <span class="main">(</span>Lit' <span class="main">0</span><span class="main">)</span> <span class="main">(</span>Add' <span class="main">(</span>Lit' <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> UNIV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> expr' <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span> <span class="quoted">card_UNIV</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"finite_UNIV <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span><span class="tfree">'a</span> expr'<span class="main">)</span> False"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"card_UNIV <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span><span class="tfree">'a</span> expr'<span class="main">)</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_UNIV_expr'_def card_UNIV_expr'_def infinite_UNIV_expr'<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  As <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">expr</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> expr'"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are infinite, instantiating <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cproper_interval<span class="antiquote"><span class="antiquote">}</span></span></span></span> is trivial,
  because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cproper_interval<span class="antiquote"><span class="antiquote">}</span></span></span></span> only makes assumptions about its parameters for finite types.
  Nevertheless, it is important to actually define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">cproper_interval</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, because the
  code generator requires a code equation.
›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> expr <span class="main">::</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">cproper_interval_expr</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr proper_interval"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_expr</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> infinite_UNIV_expr<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> expr' <span class="main">::</span> <span class="main">(</span><span class="quoted">ccompare</span><span class="main">)</span> <span class="quoted">cproper_interval</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">cproper_interval_expr'</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> expr' proper_interval"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cproper_interval_expr'</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> undefined"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> infinite_UNIV_expr'<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Instantiation of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> proper_interval<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  To illustrate what to do with finite types, we instantiate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> proper_interval<span class="antiquote"><span class="antiquote">}</span></span></span></span> for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">expr</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccompare<span class="antiquote"><span class="antiquote">}</span></span></span></span> relates to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> compare<span class="antiquote"><span class="antiquote">}</span></span></span></span>, the class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cproper_interval<span class="antiquote"><span class="antiquote">}</span></span></span></span> has a counterpart <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> proper_interval<span class="antiquote"><span class="antiquote">}</span></span></span></span> without the finiteness assumption.
  Here, we first have to gather the simplification rules of the comparator from the derive
  invocation, especially, how the strict order of the comparator, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">lt_of_comp</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, can be defined.
  
  Since the order on lists is not yet shown to be consistent with the comparators that are used
  for lists, this part of the userguide is currently not available.
  
›</span></span>
<span class="comment1">(*
instantiation expr :: proper_interval begin

lemma less_expr_conv: "(&lt;) = lt_of_comp comparator_expr" "(≤) = le_of_comp comparator_expr"
  using less_expr_def less_eq_expr_def unfolding compare_expr_def by auto

lemma lt_of_comp_expr: "lt_of_comp comparator_expr e1 e2 = (
  case e1 of 
    Var x1 ⇒ 
      (case e2 of 
        Var x2 ⇒ lt_of_comp (comparator_list comparator_of) x1 x2  
      | Lit _ ⇒ True
      | Add _ _ ⇒ True)
  | Lit i1 ⇒
      (case e2 of
        Var _ ⇒ False
      | Lit i2 ⇒ lt_of_comp comparator_of i1 i2
      | Add _ _ ⇒ True)
  | Add a1 b1 ⇒
      (case e2 of
        Var _ ⇒ False
      | Lit _ ⇒ False
      | Add a2 b2 ⇒ lt_of_comp comparator_expr a1 a2 
          ∨ le_of_comp comparator_expr a1 a2 ∧ lt_of_comp comparator_expr b1 b2) 
    )"
  by (simp add: lt_of_comp_def le_of_comp_def comp_lex_code split: expr.split order.split)
    
fun proper_interval_expr :: "expr option ⇒ expr option ⇒ bool"
where
  "proper_interval_expr None (Some (Var x)) ⟷ proper_interval None (Some x)"
| "proper_interval_expr (Some (Var x)) (Some (Var y)) ⟷ proper_interval (Some x) (Some y)"
| "proper_interval_expr (Some (Lit i)) (Some (Lit j)) ⟷ proper_interval (Some i) (Some j)"
| "proper_interval_expr (Some (Lit i)) (Some (Var x)) ⟷ False"
| "proper_interval_expr (Some (Add e1 e2)) (Some (Lit i)) ⟷ False"
| "proper_interval_expr (Some (Add e1 e2)) (Some (Var x)) ⟷ False"
| "proper_interval_expr (Some (Add e1 e2)) (Some (Add e1' e2')) ⟷ 
    (case compare e1 e1' of Lt ⇒ True | Eq ⇒ proper_interval_expr (Some e2) (Some e2') | Gt ⇒ False)"
| "proper_interval_expr _ _ ⟷ True"

instance
proof(intro_classes)
  fix x y :: expr
  show "proper_interval None (Some y) = (∃z. z &lt; y)"
    unfolding less_expr_conv
    by (cases y)(auto simp add: lt_of_comp_expr  intro: exI[where x="''''"])

  { fix x y have "x &lt; Add x y" unfolding less_expr_conv 
      by(induct x arbitrary: y)(simp_all add: lt_of_comp_expr) }
  note le_Add = this
  thus "proper_interval (Some x) None = (∃z. x &lt; z)"
    by(simp add: less_expr_def exI[where x="Add x y"])

  note [simp] = less_expr_conv lt_of_comp_expr

  show "proper_interval (Some x) (Some y) = (∃z. x &lt; z ∧ z &lt; y)"
  proof(induct "Some x" "Some y" arbitrary: x y rule: proper_interval_expr.induct)
    case 2
    show ?case by(auto simp add: proper_interval_list_aux_correct)
  next
    case (3 i j)
    show ?case by(auto intro: exI[where x="Lit (i + 1)"])
  next
    case (7 e1 e2 e1' e2')
    thus ?case by(auto intro: le_Add simp add: le_less)
  next
    case ("8_2" i e1 e2)
    show ?case by(auto intro: exI[where x="Lit (i + 1)"])
  next
    case ("8_5" x i) show ?case
      by(auto intro: exI[where x="Var (x @ [undefined])"] simp add: less_append_same_iff)
  next
    case ("8_6" x e1 e2) show ?case
      by(auto intro: exI[where x="Lit 0"])
  next
    case ("8_7" i e1 e2) show ?case
      by(auto intro: exI[where x="Lit (i + 1)"])
  next
    case ("8_10" x i) show ?case
      by(auto intro: exI[where x="Lit (i - 1)"])
  next
    case ("8_12" x e1 e2) show ?case
      by(auto intro: exI[where x="Lit 0"])
  next
    case ("8_13" i e1 e2) show ?case
      by(auto intro: exI[where x="Lit (i + 1)"])
  qed auto
qed simp
end
*)</span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">{</span>Lit <span class="main">1</span><span class="main">}</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">{</span><span class="main">{</span>Lit <span class="main">1</span><span class="main">}</span><span class="main">}</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">{</span><span class="main">{</span><span class="main">{</span>Lit <span class="main">1</span><span class="main">}</span><span class="main">}</span><span class="main">}</span><span class="main">}</span>"</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹New implementations for containers›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{section:new:implementation}›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">typedecl</span></span> <span class="tfree">'v</span> trie_raw
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This section explains how to add a new implementation for a container type.
  If you do so, please consider to add your implementation to this AFP entry.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Model and verify the data structure›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{subsection:implement:data:structure}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  First, you of course have to define the data structure and verify that it has the required properties.
  As our running example, we use a trie to implement <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  A trie is a binary tree whose the nodes store the values, the keys are the paths from the root to the given node.
  We use lists of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">bool</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>ans for the keys where the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">bool</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>ean indicates whether we should go to the left or right child.

  For brevity, we skip this step and rather assume that the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'v</span></span> trie_raw"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of tries has following operations and properties:
›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> trie_key <span class="main">=</span> <span class="quoted"><span class="quoted">"bool list"</span></span>
<span class="keyword1"><span class="command">axiomatization</span></span>
  <span class="free">trie_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> trie_raw"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="free">trie_update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"trie_key <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> trie_raw <span class="main">⇒</span> <span class="tfree">'v</span> trie_raw"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="free">trie_lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> trie_raw <span class="main">⇒</span> trie_key <span class="main">⇒</span> <span class="tfree">'v</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="free">trie_keys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> trie_raw <span class="main">⇒</span> trie_key set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> trie_lookup_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">trie_lookup</span> <span class="free">trie_empty</span> <span class="main">=</span> Map.empty"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> trie_lookup_update<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="free">trie_lookup</span> <span class="main">(</span><span class="free">trie_update</span> <span class="free">k</span> <span class="free">v</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">trie_lookup</span> <span class="free">t</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> trie_keys_dom_lookup<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">trie_keys</span> <span class="free">t</span> <span class="main">=</span> dom <span class="main">(</span><span class="free">trie_lookup</span> <span class="free">t</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This is only a minimal example.
  A full-fledged implementation has to provide more operations and -- for efficiency -- should use more than just <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">bool</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>eans for the keys.
›</span></span>

<span class="comment1">(*&lt;*)</span> <span class="comment1">(* Implement trie by free term algebra *)</span>
<span class="keyword1"><span class="command">code_datatype</span></span> <span class="quoted">trie_empty</span> <span class="quoted">trie_update</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> trie_lookup_empty trie_lookup_update

<span class="keyword1"><span class="command">lemma</span></span> trie_keys_empty <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"trie_keys trie_empty <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> trie_keys_dom_lookup trie_lookup_empty<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> trie_keys_update <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"trie_keys <span class="main">(</span>trie_update <span class="free">k</span> <span class="free">v</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">k</span> <span class="main">(</span>trie_keys <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> trie_keys_dom_lookup trie_lookup_update<span class="main">)</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generalise the data structure›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{subsection:introduce:type:class}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  As <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'k</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'v</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> store keys of arbitrary type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'k</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, not just <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"trie_key"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, we cannot use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'v</span></span> trie_raw"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> directly.
  Instead, we must first convert arbitrary types <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'k</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"trie_key"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Of course, this is not always possbile, but we only have to make sure that we pick tries as implementation only if the types do.
  This is similar to red-black trees which require an order.
  Hence, we introduce a type class to convert arbitrary keys into trie keys.
  We make the conversions optional such that every type can instantiate the type class, just as LC does for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccompare<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> cbl <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool list<span class="main">)</span> <span class="main">×</span> <span class="main">(</span>bool list <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span><span class="main">)</span> option"</span></span>
<span class="keyword1"><span class="command">class</span></span> cbl <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">cbl</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cbl"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> inj_to_bl<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="free">cbl</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">to_bl</span><span class="main">,</span> <span class="free">from_bl</span><span class="main">)</span> <span class="main">⟹</span> inj <span class="free">to_bl</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> to_bl_inverse<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="free">cbl</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">to_bl</span><span class="main">,</span> <span class="free">from_bl</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">from_bl</span> <span class="main">(</span><span class="free">to_bl</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">from_bl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">from_bl</span> <span class="main">≡</span> snd <span class="main">(</span>the <span class="main">(</span>ID cbl<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">to_bl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">to_bl</span> <span class="main">≡</span> fst <span class="main">(</span>the <span class="main">(</span>ID cbl<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  It is best to immediately provide the instances for as many types as possible.
  Here, we only present two examples: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">unit</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> provides conversion functions, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> does not.
›</span></span>
<span class="keyword1"><span class="command">instantiation</span></span> unit <span class="main">::</span> <span class="quoted">cbl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cbl <span class="main">=</span> Some <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">[]</span><span class="main">,</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">()</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cbl_unit_def ID_Some <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> injI<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> <span class="quoted">"fun"</span> <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">,</span> <span class="quoted">type</span><span class="main">)</span> <span class="quoted">cbl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"cbl <span class="main">=</span> <span class="main">(</span>None <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> cbl<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cbl_fun_def ID_None<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Hide the invariants of the data structure›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{subsection:hide:invariants}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Many data structures have invariants on which the operations rely.
  You must hide such invariants in a \isamarkuptrue\isacommand{typedef}\isamarkupfalse{} before connecting to the container, because the code generator cannot handle explicit invariants.
  The type must be inhabited even if the types of the elements do not provide the required operations.
  The easiest way is often to ignore all invariants in that case.

  In our example, we require that all keys in the trie represent encoded values.
›</span></span>
<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">::</span> <span class="quoted">cbl</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> trie <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">t</span> <span class="main">::</span> <span class="tfree">'v</span> trie_raw<span class="main">.</span> 
    trie_keys <span class="bound">t</span> <span class="main">⊆</span> range <span class="main">(</span>to_bl <span class="main">::</span> <span class="tfree">'k</span> <span class="main">⇒</span> trie_key<span class="main">)</span> <span class="main">∨</span> ID <span class="main">(</span>cbl <span class="main">::</span> <span class="tfree">'k</span> cbl<span class="main">)</span> <span class="main">=</span> None<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"trie_empty <span class="main">∈</span> <span class="var">?trie</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> trie_keys_dom_lookup trie_lookup_empty<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Next, transfer the operations to the new type.
  The transfer package does a good job here.
›</span></span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_trie <span class="comment1">― ‹also sets up code generation›</span>

<span class="keyword1"><span class="command">lift_definition</span></span> empty <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">::</span> cbl<span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> trie"</span></span> 
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">trie_empty</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> trie_keys_empty<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> lookup <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">::</span> cbl<span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> trie <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> option"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">t</span><span class="main">.</span> trie_lookup <span class="bound">t</span> <span class="main">∘</span> to_bl"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> update <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span> <span class="main">::</span> cbl<span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> trie <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> trie"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"trie_update <span class="main">∘</span> to_bl"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> trie_keys_dom_lookup trie_lookup_update<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> keys <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">::</span> cbl<span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> trie <span class="main">⇒</span> <span class="tfree">'k</span> set"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">t</span><span class="main">.</span> from_bl <span class="main">`</span> trie_keys <span class="bound">t</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  And now we go for the properties.
  Note that some properties hold only if the type class operations are actually provided, i.e., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"cbl <span class="main"><span class="main">≠</span></span> None"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in our example.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"lookup empty <span class="main">=</span> Map.empty"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> trie_lookup_empty fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">::</span> cbl<span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> trie"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ID_cbl<span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="main">(</span>cbl <span class="main">::</span> <span class="tfree">'k</span> cbl<span class="main">)</span> <span class="main">≠</span> None"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_update<span class="main">:</span> <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>update <span class="free">k</span> <span class="free">v</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lookup <span class="free">t</span><span class="main">)</span><span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> ID_cbl
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> trie_lookup_update fun_eq_iff <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_to_bl<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> injD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keys_conv_dom_lookup<span class="main">:</span> <span class="quoted"><span class="quoted">"keys <span class="free">t</span> <span class="main">=</span> dom <span class="main">(</span>lookup <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> ID_cbl
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> trie_keys_dom_lookup to_bl_inverse <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Connecting to the container›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{subsection:connect:container}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Connecting to the container (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in our example) takes three steps:
  \begin{enumerate}
  \item Define a new pseudo-constructor
  \item Implement the container operations for the new type
  \item Configure the heuristics to automatically pick an implementation
  \item Test thoroughly
  \end{enumerate}
  Thorough testing is particularly important, because Isabelle does not check whether you have implemented all your operations, whether you have configured your heuristics sensibly, nor whether your implementation always terminates.
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Define a new pseudo-constructor›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Define a function that returns the abstract container view for a data structure value, and declare it as a datatype constructor for code generation with \isamarkuptrue\isacommand{code{\isacharunderscore}datatype}\isamarkupfalse.
  Unfortunately, you have to repeat all existing pseudo-constructors, because there is no way to extract the current set of pseudo-constructors from the code generator.
  We call them pseudo-constructors, because they do not behave like datatype constructors in the logic.
  For example, ours are neither injective nor disjoint.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Trie_Mapping</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">::</span> cbl<span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> trie <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> mapping"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Trie_Mapping</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> Mapping.Mapping <span class="main">(</span>lookup <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">code_datatype</span></span> <span class="quoted">Assoc_List_Mapping</span> <span class="quoted">RBT_Mapping</span> <span class="quoted">Mapping</span> <span class="quoted">Trie_Mapping</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implement the operations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Next, you have to prove and declare code equations that implement the container operations for the new implementation.
  Typically, these just dispatch to the operations on the type from \S\ref{subsection:hide:invariants}.
  Some operations depend on the type class operations from \S\ref{subsection:introduce:type:class} being defined; then, the code equation must check that the operations are indeed defined.
  If not, there is usually no way to implement the operation, so the code should raise an exception.
  Logically, we use the function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Code.abort"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"String.literal <span class="main"><span class="main">⇒</span></span> <span class="main"><span class="main">(</span></span>unit <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with definition <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span> <span class="bound"><span class="bound">f</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">f</span></span> <span class="main"><span class="main">()</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, but the generated code raises an exception \texttt{Fail} with the given message (the unit closure avoids non-termination in strict languages).
  This function gets the exception message and the unit-closure of the equation's left-hand side as argument, because it is then trivial to prove equality.

  Again, we only show a small set of operations; a realistic implementation should cover as many as possible.
›</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">::</span> cbl<span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> trie"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lookup_Trie_Mapping <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Mapping.lookup <span class="main">(</span>Trie_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">=</span> lookup <span class="free">t</span>"</span></span>
  <span class="comment1">― ‹Lookup does not need the check on <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">cbl</span><span class="antiquote">}</span></span>,
        because we have defined the pseudo-constructor <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Trie_Mapping</span><span class="antiquote">}</span></span> in terms of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"lookup"</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> update_Trie_Mapping <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Mapping.update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span>Trie_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID cbl <span class="main">::</span> <span class="tfree">'k</span> cbl <span class="keyword1">of</span>
     None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''update Trie_Mapping: cbl = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Mapping.update <span class="free">k</span> <span class="free">v</span> <span class="main">(</span>Trie_Mapping <span class="free">t</span><span class="main">)</span><span class="main">)</span>
   <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> Trie_Mapping <span class="main">(</span>update <span class="free">k</span> <span class="free">v</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lookup_update Mapping.update.abs_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keys_Trie_Mapping <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Mapping.keys <span class="main">(</span>Trie_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID cbl <span class="main">::</span> <span class="tfree">'k</span> cbl <span class="keyword1">of</span>
     None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''keys Trie_Mapping: cbl = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Mapping.keys <span class="main">(</span>Trie_Mapping <span class="free">t</span><span class="main">)</span><span class="main">)</span>
   <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> keys <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping.keys.abs_eq keys_conv_dom_lookup <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  These equations do not replace the existing equations for the other constructors, but they do take precedence over them.
  If there is already a generic implementation for an operation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">foo</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, say <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">foo</span></span> <span class="free"><span class="free">A</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">gen_foo</span></span> <span class="free"><span class="free">A</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and you prove a specialised equation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">foo</span></span> <span class="main"><span class="main">(</span></span>Trie_Mapping <span class="free"><span class="free">t</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">trie_foo</span></span> <span class="free"><span class="free">t</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, then when you call <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">foo</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> on some <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Trie_Mapping <span class="free"><span class="free">t</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, your equation will kick in.
  LC exploits this sequentiality especially for binary operators on sets like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(∩)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, where there are generic implementations and faster specialised ones.
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Configure the heuristics›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Finally, you should setup the heuristics that automatically picks a container implementation based on the types of the elements (\S\ref{subsection:set_impl}).

  The heuristics uses a type with a single value, e.g., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">mapping_impl</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with value <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Mapping_IMPL</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, but there is one pseudo-constructor for each container implementation in the generated code.
  All these pseudo-constructors are the same in the logic, but they are different in the generated code.
  Hence, the generated code can distinguish them, but we do not have to commit to anything in the logic.
  This allows to reconfigure and extend the heuristic at any time.

  First, define and declare a new pseudo-constructor for the heuristics.
  Again, be sure to redeclare all previous pseudo-constructors.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mapping_Trie</span> <span class="main">::</span> <span class="quoted">mapping_impl</span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mapping_Trie</span> <span class="main">=</span> Mapping_IMPL"</span></span>

<span class="keyword1"><span class="command">code_datatype</span></span> 
  <span class="quoted">mapping_Choose</span> <span class="quoted">mapping_Assoc_List</span> <span class="quoted">mapping_RBT</span> <span class="quoted">mapping_Mapping</span> <span class="quoted">mapping_Trie</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Then, adjust the implementation of the automatic choice.
  For every initial value of the container (such as the empty map or the empty set), there is one new constant (e.g., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">mapping_empty_choose</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">set_empty_choose</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) equivalent to it.
  Its code equation, however, checks the available operations from the type classes and picks an appropriate implementation.
  
  For example, the following prefers red-black trees over tries, but tries over associative lists:
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mapping_empty_choose_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>mapping_empty_choose <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>ccompare<span class="main">,</span> cbl<span class="main">}</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping<span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> Some <span class="main"><span class="bound">_</span></span>  <span class="main">⇒</span> RBT_Mapping RBT_Mapping2.empty
    <span class="main">|</span> None <span class="main">⇒</span>
      <span class="keyword1">case</span> ID <span class="main">(</span>cbl <span class="main">::</span> <span class="tfree">'a</span> cbl<span class="main">)</span> <span class="keyword1">of</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> Trie_Mapping empty 
      <span class="main">|</span> None <span class="main">⇒</span> Assoc_List_Mapping DAList.empty<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DAList.lookup_empty<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> Mapping.empty_def lookup_empty<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  There is also a second function for every such initial value that dispatches on the pseudo-constructors for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">mapping_impl</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  This function is used to pick the right implementation for types that specify a preference.
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> mapping_empty_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mapping_empty mapping_Trie <span class="main">=</span> Trie_Mapping empty"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lookup_empty Mapping.empty_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  For <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'k</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'v</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, LC also has a function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"mapping_impl_choose2"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> which is given two preferences and returns one (for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, it is called <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"set_impl_choose2"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>).
  Polymorphic type constructors like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">+</span></span> <span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> use it to pick an implementation based on the preferences of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  By default, it returns <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">mapping_Choose</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, i.e., ignore the preferences.
  You should add a code equation like the following that overrides this choice if both preferences are your new data structure:
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mapping_impl_choose2_Trie <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mapping_impl_choose2 mapping_Trie mapping_Trie <span class="main">=</span> mapping_Trie"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mapping_Trie_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  If your new data structure is better than the existing ones for some element type, you should reconfigure the type's preferene.
  As all preferences are logically equal, you can prove (and declare) the appropriate code equation.
  For example, the following prefers tries for keys of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"unit"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>:
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mapping_impl_unit_Trie <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">MAPPING_IMPL</span><span class="main">(</span>unit<span class="main">)</span> <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span>unit<span class="main">)</span> mapping_Trie"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mapping_impl_unit_def<span class="main">)</span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"Mapping.empty <span class="main">::</span> <span class="main">(</span>unit<span class="main">,</span> int<span class="main">)</span> mapping"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  You can also use your new pseudo-constructor with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>derive›</span></span></span></span> in instantiations, just give its name as option:
›</span></span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>mapping_Trie<span class="main">)</span> mapping_impl <span class="quoted">simple_tycon</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Changing the configuration›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  As containers are connected to data structures only by refinement in the code generator, this can always be adapted later on.
  You can add new data structures as explained in \S\ref{section:new:implementation}.
  If you want to drop one, you redeclare the remaining pseudo-constructors with \isamarkuptrue\isacommand{code{\isacharunderscore}datatype}\isamarkupfalse{} and delete all code equations that pattern-match on the obsolete pseudo-constructors.
  The command \isamarkuptrue\isacommand{code{\isacharunderscore}thms}\isamarkupfalse{} will tell you which constants have such code equations.
  You can also freely adapt the heuristics for picking implementations as described in \S\ref{subsection:connect:container}.

  One thing, however, you cannot change afterwards, namely the decision whether an element type supports an operation and if so how it does, because this decision is visible in the logic.
›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹New containers types›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We hope that the above explanations and the examples with sets and maps suffice to show what you need to do if you add a new container type, e.g., priority queues.
  There are three steps:
  \begin{enumerate}
  \item \textbf{Introduce a type constructor for the container.}
    \\
    Your new container type must not be a composite type, like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'b</span></span> option"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for maps, because refinement for code generation only works with a single type constructor.
    Neither should you reuse a type constructor that is used already in other contexts, e.g., do not use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> list"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to model queues.

    Introduce a new type constructor if necessary (e.g., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for maps) -- if your container type already has its own type constructor, everything is fine.

  \item \textbf{Implement the data structures} 
    \\
    and connect them to the container type as described in \S\ref{section:new:implementation}.

  \item \textbf{Define a heuristics for picking an implementation.}
    \\
    See \cite{Lochbihler2013ITP} for an explanation.
  \end{enumerate}
›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Troubleshooting›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This section describes some difficulties in using LC that we have come across, provides some background for them, and discusses how to overcome them.
  If you experience other difficulties, please contact the author.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Nesting of mappings›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Mappings can be arbitrarily nested on the value side, e.g., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">)</span></span> mapping<span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  However, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> cannot currently be the key of a mapping, i.e., code generation fails for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> mapping<span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'c</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Simiarly, you cannot have a set of mappings like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> mapping set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> at the moment.
  There are no issues to make this work, we have just not seen the need for it.
  If you need to generate code for such types, please get in touch with the author.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Wellsortedness errors›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{subsection:well:sortedness}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  LC uses its own hierarchy of type classes which is distinct from Isabelle/HOL's.
  This ensures that every type can be made an instance of LC's type classes.
  Consequently, you must instantiate these classes for your own types.
  The following lists where you can find information about the classes and examples how to instantiate them:
  \begin{center}
    \begin{tabular}{lll}
      \textbf{type class} &amp; \textbf{user guide} &amp; \textbf{theory}
      \\
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> card_UNIV<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; \S\ref{subsection:card_UNIV} &amp; <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="../../HOL/HOL-Library/Cardinality.html"></a><a href="../../HOL/HOL-Library/Cardinality.html">HOL-Library.Cardinality</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span> 
      %<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Cardinality.card_UNIV_class"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cenum<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; \S\ref{subsection:cenum} &amp; <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Collection_Enum.html"></a><a href="Collection_Enum.html">Containers.Collection_Enum</a><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      %<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Collection_Enum.cenum_class"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; \S\ref{subsection:ceq} &amp; <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Collection_Eq.html"></a><a href="Collection_Eq.html">Containers.Collection_Eq</a><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      %<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Collection_Eq.ceq_class"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ccompare<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; \S\ref{subsection:ccompare} &amp; <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Collection_Order.html"></a><a href="Collection_Order.html">Containers.Collection_Order</a><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      %<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Collection_Order.ccompare_class"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cproper_interval<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; \S\ref{subsection:cproper_interval} &amp; <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Collection_Order.html"></a><a href="Collection_Order.html">Containers.Collection_Order</a><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      %<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Collection_Order.cproper_interval_class"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> finite_UNIV<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; \S\ref{subsection:finite_UNIV} &amp; <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="../../HOL/HOL-Library/Cardinality.html"></a><a href="../../HOL/HOL-Library/Cardinality.html">HOL-Library.Cardinality</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
      %<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Cardinality.finite_UNIV_class"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> mapping_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; \S\ref{subsection:mapping_impl} &amp; <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Mapping_Impl.html"></a><a href="Mapping_Impl.html">Containers.Mapping_Impl</a><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      %<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Mapping_Impl.mapping_impl_class"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> set_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> &amp; \S\ref{subsection:set_impl} &amp; <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Set_Impl.html"></a><a href="Set_Impl.html">Containers.Set_Impl</a><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      %<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Set_Impl.set_impl_class"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
      \\
    \end{tabular}
  \end{center}

  The type classes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> card_UNIV<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cproper_interval<span class="antiquote"><span class="antiquote">}</span></span></span></span> are only required to implement the operations on set complements.
  If your code does not need complements, you can manually delete the code equations involving <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Complement"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, the theorem list <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] <span class="dynamic"><span class="dynamic"><span class="dynamic"><span class="dynamic">set_complement_code</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> collects them.
  It is also recommended that you remove the pseudo-constructor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Complement<span class="antiquote"><span class="antiquote">}</span></span></span></span> from the code generator.
  Note that some set operations like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span> <span class="main"><span class="main">-</span></span> <span class="free"><span class="free">B</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> UNIV<span class="antiquote"><span class="antiquote">}</span></span></span></span> have no code equations any more.
›</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="dynamic"><span class="dynamic">set_complement_code</span></span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main">]</span>
<span class="keyword1"><span class="command">code_datatype</span></span> <span class="quoted">Collect_set</span> <span class="quoted">DList_set</span> <span class="quoted">RBT_set</span> <span class="quoted">Set_Monad</span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">datatype</span></span> minimal_sorts <span class="main">=</span> Minimal_Sorts <span class="quoted">bool</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>eq<span class="main">)</span> ceq <span class="quoted">minimal_sorts</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>no<span class="main">)</span> ccompare <span class="quoted">minimal_sorts</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>monad<span class="main">)</span> set_impl <span class="quoted">minimal_sorts</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>no<span class="main">)</span> cenum <span class="quoted">minimal_sorts</span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>Minimal_Sorts True<span class="main">}</span> <span class="main">∪</span> <span class="main">{}</span> <span class="main">∩</span> Minimal_Sorts <span class="main">`</span> <span class="main">{</span>True<span class="main">,</span> False<span class="main">}</span>"</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Exception raised at run-time›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{subsection:set_impl_unsupported_operation}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Not all combinations of data and container implementation are possible.
  For example, you cannot implement a set of functions with a RBT, because there is no order on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  If you try, the code will raise an exception \texttt{Fail} (with an exception message) or \texttt{Match}.
  They can occur in three cases:

  \begin{enumerate}
  \item
    You have misconfigured the heuristics that picks implementations (\S\ref{subsection:set_impl}), or you have manually picked an implementation that requires an operation that the element type does not provide.
    Printing a stack trace for the exception may help you in locating the error.

  \item You are trying to invoke an operation on a set complement which cannot be implemented on a complement representation, e.g., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(`)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
    If the element type is enumerable, provide an instance of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> cenum<span class="antiquote"><span class="antiquote">}</span></span></span></span> and choose to represent complements of sets of enumerable types by the elements rather than the elements of the complement (see \S\ref{subsection:cenum} for how to do this).

  \item You use set comprehensions on types which do not provide an enumeration (i.e., they are represented as closures) or you chose to represent a map as a closure.

    A lot of operations are not implementable for closures, in particular those that return some element of the container

    Inspect the code equations with \isacommand{code{\isacharunderscore}thms} and look for calls to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Collect_set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> which are LC's constructor for sets and maps as closures.

    Note that the code generator preprocesses set comprehensions like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{</span></span><span class="bound"><span class="bound">i</span></span> <span class="main"><span class="main">&lt;</span></span> <span class="numeral"><span class="numeral">4</span></span><span class="main"><span class="main">|</span></span><span class="bound"><span class="bound">i</span></span> <span class="main"><span class="main">::</span></span> int<span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">i</span></span> <span class="main"><span class="main">&gt;</span></span> <span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">i</span></span> <span class="main"><span class="main">::</span></span> int<span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">i</span></span> <span class="main"><span class="main">&lt;</span></span> <span class="numeral"><span class="numeral">4</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">`</span></span> <span class="main"><span class="main">{</span></span><span class="bound"><span class="bound">i</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">i</span></span> <span class="main"><span class="main">&gt;</span></span> <span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, so this is a set comprehension over <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">int</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> rather than <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">bool</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  \end{enumerate}
›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_set_impl_unsupported_operation1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> <span class="main">(</span>int <span class="main">⇒</span> int<span class="main">)</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_set_impl_unsupported_operation1</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> RBT_set RBT_Set2.empty <span class="main">∪</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_set_impl_unsupported_operation2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> bool set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_set_impl_unsupported_operation2</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">i</span> <span class="main">&lt;</span> <span class="numeral">4</span> <span class="main">|</span> <span class="bound">i</span> <span class="main">::</span> int<span class="main">.</span> <span class="bound">i</span> <span class="main">&gt;</span> <span class="numeral">2</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_mapping_impl_unsupported_operation</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">test_mapping_impl_unsupported_operation</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> 
   Mapping.is_empty <span class="main">(</span>RBT_Mapping <span class="main">(</span>RBT_Mapping2.empty<span class="main">)</span> <span class="main">::</span> <span class="main">(</span>Enum.finite_4<span class="main">,</span> unit<span class="main">)</span> mapping<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_fail</span> <span class="entity">s</span> <span class="entity">f</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">error</span> <span class="entity">s'</span> <span class="main">=</span> Fail <span class="main">(</span><span class="inner_quoted">"exception Fail \""</span> ^ <span class="entity">s</span> ^ <span class="inner_quoted">"\" expected, but got "</span> ^ <span class="entity">s'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">f</span> <span class="main">(</span><span class="main">)</span><span class="main">;</span> <span class="keyword3"><span class="keyword">raise</span></span> <span class="main">(</span><span class="entity">error</span> <span class="inner_quoted">"no exception"</span><span class="main">)</span> <span class="main">)</span>
    <span class="keyword3"><span class="keyword">handle</span></span>
      Fail <span class="entity">s'</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">s</span> <span class="main">=</span> <span class="entity">s'</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> <span class="main">(</span><span class="entity">error</span> <span class="entity">s'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="entity">test_fail</span> <span class="inner_quoted">"union RBT_set Set_Monad: ccompare = None"</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_set_impl_unsupported_operation1</span><span class="antiquote">}</span></span></span><span class="main">;</span>
<span class="entity">test_fail</span> <span class="inner_quoted">"image Collect_set"</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_set_impl_unsupported_operation2</span><span class="antiquote">}</span></span></span><span class="main">;</span>
<span class="entity">test_fail</span> <span class="inner_quoted">"is_empty RBT_Mapping: ccompare = None"</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_mapping_impl_unsupported_operation</span><span class="antiquote">}</span></span></span><span class="main">;</span>
›</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹LC slows down my code›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Normally, this will not happen, because LC's data structures are more efficient than Isabelle's list-based implementations.
  However, in some rare cases, you can experience a slowdown:
›</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tiny_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> tiny_set_code<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tiny_set</span> <span class="main">=</span> <span class="main">{</span><span class="main">1</span><span class="main">,</span> <span class="numeral">2</span><span class="main">}</span>"</span></span>
<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
  \isastyletext
  \begin{enumerate}
  \item \textbf{Your containers contain just a few elements.}
    \\
    In that case, the overhead of the heuristics to pick an implementation outweighs the benefits of efficient implementations.
    You should identify the tiny containers and disable the heuristics locally.
    You do so by replacing the initial value like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">{}</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Mapping.empty"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with low-overhead constructors like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Set_Monad"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
    For example, if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] tiny_set_code<span class="antiquote"><span class="antiquote">}</span></span></span></span>: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> tiny_set_code<span class="antiquote"><span class="antiquote">}</span></span></span></span> is your code equation with a tiny set,
    the following changes the code equation to directly use the list-based representation, i.e., disables the heuristics:
    \par
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> empty_Set_Monad<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">=</span> Set_Monad <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">declare</span></span> tiny_set_code<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">,</span> <span class="operator">unfolded</span> empty_Set_Monad<span class="main">,</span> <span class="operator">code</span><span class="main">]</span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
    \isastyletext
    \par
     If you want to globally disable the heuristics, you can also declare an equation like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] empty_Set_Monad<span class="antiquote"><span class="antiquote">}</span></span></span></span> as [code].

  \item \textbf{The element type contains many type constructors and some type variables.}
    \\
    LC heavily relies on type classes, and type classes are implemented as dictionaries if the compiler cannot statically resolve them, i.e., if there are type variables.
    For type constructors with type variables (like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">*</span></span> <span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>), LC's definitions of the type class parameters recursively calls itself on the type variables, i.e., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
    If the element type is polymorphic, the compiler cannot precompute these recursive calls and therefore they have to be constructed repeatedly at run time.
    If you wrap your complicated type in a new type constructor, you can define optimised equations for the type class parameters.
  \end{enumerate}
›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Card_Datatype_Ex">
<div class="head">
<h1>Theory Card_Datatype_Ex</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Card_Datatype_Ex.thy
    Author:     Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Card_Datatype_Ex <span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="Card_Datatype.html">../Card_Datatype</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Examples›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Finite types›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> foo <span class="main">=</span> Foo <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">|</span> Bar <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span> <span class="main">|</span> FooBar <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span>"</span></span> <span class="main">|</span> Stop

<span class="keyword1"><span class="command">lemma</span></span> inj_foo <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"inj Foo"</span></span> 
  <span class="quoted"><span class="quoted">"inj Bar"</span></span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>Bar <span class="free">x</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"inj FooBar"</span></span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>FooBar <span class="free">x</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>FooBar <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> card_datatype <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> UNIV_foo<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>UNIV <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> foo set<span class="main">)</span> <span class="main">=</span> 
  rangeC <span class="main">{</span>Foo<span class="main">}</span> <span class="main">∪</span> 
  rangeC <span class="main">(</span>rangeC <span class="main">{</span>Bar<span class="main">}</span><span class="main">)</span> <span class="main">∪</span> 
  rangeC <span class="main">(</span>rangeC <span class="main">(</span>rangeC <span class="main">{</span>FooBar<span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> 
  rangeC <span class="main">{</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">.</span> Stop<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> UNIV_eq_I<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_UNIV_foo<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> foo set<span class="main">)</span> <span class="main">⟷</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∧</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> UNIV_foo<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">card_foo</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">card_foo</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">*</span> card_sum <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> CARD_foo <span class="main">[</span><span class="operator">card_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> foo<span class="main">)</span> <span class="main">=</span> card_foo <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_foo_def UNIV_foo Let_def <span class="dynamic"><span class="dynamic">card_simps</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> bar 
  <span class="main">=</span> Bar1 
  <span class="main">|</span> Bar2 <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
  <span class="main">|</span> Bar3 <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> foo"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> char <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> option"</span></span> 
  <span class="main">|</span> Bar4 <span class="quoted">char</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted">bool</span>

<span class="keyword1"><span class="command">lemma</span></span> inj_bar <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"inj Bar2"</span></span>
  <span class="quoted"><span class="quoted">"inj Bar3"</span></span>
  <span class="quoted"><span class="quoted">"inj <span class="main">(</span>Bar3 <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inj <span class="main">(</span>Bar3 <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inj Bar4"</span></span>
  <span class="quoted"><span class="quoted">"inj <span class="main">(</span>Bar4 <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inj <span class="main">(</span>Bar4 <span class="free">z</span> <span class="free">u</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> card_datatype <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> UNIV_bar<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>UNIV <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> bar set<span class="main">)</span> <span class="main">=</span>
  rangeC <span class="main">{</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">::</span>unit<span class="main">.</span> Bar1<span class="main">}</span> <span class="main">∪</span>
  rangeC <span class="main">{</span>Bar2<span class="main">}</span> <span class="main">∪</span>
  rangeC <span class="main">(</span>rangeC <span class="main">(</span>rangeC <span class="main">{</span>Bar3<span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span>
  rangeC <span class="main">(</span>rangeC <span class="main">(</span>rangeC <span class="main">{</span>Bar4<span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> UNIV_eq_I<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_UNIV_bar<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> bar set<span class="main">)</span> <span class="main">⟷</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∧</span> finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> UNIV_bar finite_UNIV_fun finite_prod finite_UNIV_foo<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">card_bar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">card_bar</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span>
   <span class="keyword1">else</span> <span class="main">1</span> <span class="main">+</span> card_fun <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">+</span> card_foo <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">*</span> card_fun <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">(</span>card_fun <span class="keyword1">CARD</span><span class="main">(</span>char<span class="main">)</span> <span class="main">(</span>card_fun <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> card_option <span class="main">(</span>card_prod <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="keyword1">CARD</span><span class="main">(</span>char<span class="main">)</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">*</span> <span class="keyword1">CARD</span><span class="main">(</span>bool<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> CARD_bar <span class="main">[</span><span class="operator">card_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> bar<span class="main">)</span> <span class="main">=</span> card_bar <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> UNIV_bar card_bar_def finite_UNIV_bar finite_UNIV_foo finite_prod finite_UNIV_fun <span class="dynamic"><span class="dynamic">card_simps</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> card_prod<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Infinite types›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> tree <span class="main">=</span> Leaf <span class="main">|</span> Node <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> inj_expr <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"inj Node"</span></span>
  <span class="quoted"><span class="quoted">"inj <span class="main">(</span>Node <span class="free">a</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inj <span class="main">(</span>Node <span class="free">a</span> <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> card_datatype <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_UNIV_tree<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> <span class="tfree">'a</span> tree set<span class="main">)</span> <span class="main">⟷</span> False"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rangeIt Leaf <span class="main">(</span>Node <span class="main">(</span>undefined <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span> Leaf<span class="main">)</span> <span class="main">⊆</span> UNIV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">card_tree</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">card_tree</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> CARD_tree <span class="main">[</span><span class="operator">card_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span> tree<span class="main">)</span> <span class="main">=</span> card_tree <span class="keyword1">CARD</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_tree_def finite_UNIV_tree<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Map_To_Mapping_Ex">
<div class="head">
<h1>Theory Map_To_Mapping_Ex</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Containers/Map_To_Mapping_Ex.thy
    Author:     Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Map_To_Mapping_Ex <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="Map_To_Mapping.html">../Map_To_Mapping</a>"</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Test cases for replacing <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇀</span></span> <span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> mapping"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> mapping_filter <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'b</span> list"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"List.map_filter"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> mapping_filter_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> map_filter_simps<span class="main">[</span><span class="operator">containers_identify</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> int option<span class="main">)</span> <span class="main">⇒</span> nat list <span class="main">⇒</span> int list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">test</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> Map.empty <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span> List.map_filter <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">(</span><span class="numeral">2</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">(</span><span class="main">1</span> <span class="main">↦</span> <span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> test' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span> int<span class="main">)</span> mapping <span class="main">⇒</span> nat list <span class="main">⇒</span> int list"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">test</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> test_def<span class="main">[</span><span class="operator">containers_identify</span><span class="main">]</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test'</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML


<span class="keyword1"><span class="command">fun</span></span> <span class="entity">iter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> option<span class="main">)</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">iter</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">iter</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> Option.bind <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">iter</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> iter' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> mapping <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">iter</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> iter.simps<span class="main">[</span><span class="operator">containers_identify</span><span class="main">]</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">iter'</span></span> <span class="keyword2"><span class="keyword">in</span></span> SML


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dom_test</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">dom_test</span> <span class="main">⟷</span> <span class="main">(</span>dom <span class="main">[</span><span class="main">(</span><span class="main">1</span> <span class="main">::</span> int<span class="main">)</span> <span class="main">↦</span> <span class="main">(</span><span class="main">[</span><span class="main">()</span><span class="main">]</span> <span class="main">::</span> unit list<span class="main">)</span><span class="main">]</span> <span class="main">=</span> <span class="main">{</span><span class="main">1</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> dom_test_def<span class="main">[</span><span class="operator">containers_identify</span><span class="main">]</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹<span class="keyword1"><span class="keyword">val</span></span> true <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">dom_test</span><span class="antiquote">}</span></span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="TwoSat_Ex">
<div class="head">
<h1>Theory TwoSat_Ex</h1>
</div>
<pre class="source"><span class="comment1">(* Title:      Containers/Examples/TwoSat_Ex.thy
   Author:     Andreas Lochbihler, ETH Zurich
   Author:     Peter Lammich, TU Munich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Formalisation of 2SAT independent of an implementation›</span></span>

<span class="keyword1"><span class="command">theory</span></span> TwoSat_Ex <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOL/Main.html">Main</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Uprod.html">HOL-Library.Uprod</a>"</span>
  <span class="quoted">"<a href="../Deriving/Compare_Instances.html">Deriving.Compare_Instances</a>"</span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> var <span class="main">=</span> <span class="quoted">nat</span>
<span class="keyword1"><span class="command">datatype</span></span> lit <span class="main">=</span> Lit <span class="main">(</span><span class="free"><span class="entity">pos</span></span><span class="main">:</span> <span class="quoted">bool</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">var</span></span><span class="main">:</span> <span class="quoted">var</span><span class="main">)</span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Pos</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"var <span class="main">⇒</span> lit"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Pos</span> <span class="main">≡</span> Lit True"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Neg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"var <span class="main">⇒</span> lit"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Neg</span> <span class="main">≡</span> Lit False"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> clause <span class="main">=</span> <span class="quoted"><span class="quoted">"lit uprod"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> cnf <span class="main">=</span> <span class="quoted"><span class="quoted">"clause set"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">negate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"lit <span class="main">⇒</span> lit"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">negate</span> <span class="main">(</span>Lit <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> Lit <span class="main">(</span><span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> negate_inject <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"negate <span class="free">x</span> <span class="main">=</span> negate <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> double_negate<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"negate <span class="main">(</span>negate <span class="free">l</span><span class="main">)</span> <span class="main">=</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> var_negate<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"var <span class="main">(</span>negate <span class="free">l</span><span class="main">)</span> <span class="main">=</span> var <span class="free">l</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">type_synonym</span></span> valuation <span class="main">=</span> <span class="quoted"><span class="quoted">"var <span class="main">⇒</span> bool"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sat_lit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"valuation <span class="main">⇒</span> lit <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat_lit</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">(</span>var <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">⟷</span> pos <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sat_lit_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"sat_lit <span class="free">σ</span> <span class="main">(</span>Lit <span class="free">p</span> <span class="free">v</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">σ</span> <span class="free">v</span> <span class="main">=</span> <span class="free">p</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sat_lit_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">function</span></span> <span class="entity">sat_clause</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sat_clause</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">(</span>Upair <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">)</span> <span class="main">⟷</span> sat_lit <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="main">∨</span> sat_lit <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span>"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> surj_pair uprod_exhaust<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>
      
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sat_cnf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"valuation <span class="main">⇒</span> cnf <span class="main">⇒</span> bool"</span></span>  
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat_cnf</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">cnf</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">cl</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">cnf</span></span></span><span class="main">.</span> sat_clause <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="bound">cl</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">satisfiable</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"cnf <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">satisfiable</span> <span class="free"><span class="bound"><span class="entity">cnf</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">σ</span><span class="main">.</span> sat_cnf <span class="bound">σ</span> <span class="free"><span class="bound"><span class="entity">cnf</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_2sat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"cnf <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_2sat</span> <span class="free"><span class="bound"><span class="entity">cnf</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">cl</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">cnf</span></span></span><span class="main">.</span> proper_uprod <span class="bound">cl</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_2sat_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_2sat <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"is_2sat <span class="main">(</span>insert <span class="free">cl</span> <span class="free">cnf</span><span class="main">)</span> <span class="main">⟷</span> proper_uprod <span class="free">cl</span> <span class="main">∧</span> is_2sat <span class="free">cnf</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_2sat_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> negate_sat<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sat_lit <span class="free">σ</span> <span class="main">(</span>negate <span class="free">l</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span> sat_lit <span class="free">σ</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sat_lit_def<span class="main">)</span>
    
<span class="keyword1"><span class="command">function</span></span> <span class="entity">edges_of_clause</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">edges_of_clause</span> <span class="main">(</span>Upair <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>negate <span class="free"><span class="bound"><span class="entity">l1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>negate <span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> uprod_exhaust<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">imp_graph</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"cnf <span class="main">⇒</span> <span class="main">(</span>lit <span class="main">×</span> lit<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">imp_graph</span> <span class="free"><span class="bound"><span class="entity">cnf</span></span></span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>edges_of_clause <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">cnf</span></span></span><span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> imp_graph_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_graph <span class="free">cnf</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>negate <span class="bound">l1</span><span class="main">,</span><span class="bound">l2</span><span class="main">)</span> <span class="main">|</span> <span class="bound">l1</span> <span class="bound">l2</span><span class="main">.</span> Upair <span class="bound">l1</span> <span class="bound">l2</span> <span class="main">∈</span> <span class="free">cnf</span><span class="main">}</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> imp_graph_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> l1 l2 cl <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">cl</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> Upair_inject<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> edges_of_clause.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  
<span class="keyword1"><span class="command">lemma</span></span> imp_graph_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"imp_graph <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> imp_graph_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> imp_graph_insert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"imp_graph <span class="main">(</span>insert <span class="free">cl</span> <span class="free">cls</span><span class="main">)</span> <span class="main">=</span> edges_of_clause <span class="free">cl</span> <span class="main">∪</span> imp_graph <span class="free">cls</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> imp_graph_def<span class="main">)</span>
    
<span class="keyword1"><span class="command">lemma</span></span> imp_graph_skew_sym<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span><span class="free">l<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">∈</span> imp_graph <span class="free">cnf</span> <span class="main">⟹</span> <span class="main">(</span>negate <span class="free">l<span class="hidden">⇩</span><sub>2</sub></span><span class="main">,</span> negate <span class="free">l<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">∈</span> imp_graph <span class="free">cnf</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> imp_graph_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> cl <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">cl</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_bexI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> imp_graph_rtrancl_skew_sym<span class="main">:</span>    
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> <span class="free">l<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⟹</span> <span class="main">(</span>negate <span class="free">l<span class="hidden">⇩</span><sub>2</sub></span><span class="main">,</span> negate <span class="free">l<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtrancl.induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> imp_graph_skew_sym<span class="main">)</span>  
      
<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">σ</span> <span class="free">cnf</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sat<span class="main">:</span> <span class="quoted"><span class="quoted">"sat_cnf <span class="free">σ</span> <span class="free">cnf</span>"</span></span>  
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">lemma</span></span> imp_step<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"sat_lit <span class="free">σ</span> <span class="free">l<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>  
    <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> <span class="free">l<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">∈</span> imp_graph <span class="free">cnf</span>"</span></span> 
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sat_lit <span class="free">σ</span> <span class="free">l<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> I sat <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> sat_lit <span class="free">σ</span> <span class="free">l<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∨</span> sat_lit <span class="free">σ</span> <span class="free">l<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> sat_cnf_def imp_graph_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">with</span></span> S <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> 
  
  <span class="keyword1"><span class="command">lemma</span></span> imp_steps<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"sat_lit <span class="free">σ</span> <span class="free">l<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>  
    <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> <span class="free">l<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sat_lit <span class="free">σ</span> <span class="free">l<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>1<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> imp_step<span class="main">)</span>  

  <span class="keyword1"><span class="command">lemma</span></span> ln_loop<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l</span><span class="main">,</span> negate <span class="free">l</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> sat_lit <span class="free">σ</span> <span class="free">l</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> imp_steps<span class="main">[</span><span class="operator">OF</span> _ assms<span class="main">]</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"sat_lit <span class="free">σ</span> <span class="free">l</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>  
  
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> loop_imp_unsat<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Pos <span class="free">x</span><span class="main">,</span> Neg <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Neg <span class="free">x</span><span class="main">,</span> Pos <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> satisfiable <span class="free">cnf</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms ln_loop<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="free">cnf</span></span> <span class="quoted"><span class="quoted">"Pos <span class="free">x</span>"</span></span><span class="main">]</span> ln_loop<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="free">cnf</span></span> <span class="quoted"><span class="quoted">"Neg <span class="free">x</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> satisfiable_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sat_lit_def<span class="main">)</span>
    
    
<span class="comment1">(*
  Informal argument why we can find satisfying valuation if
  there are no cycles Pos x →<span class="hidden">⇧</span><sup>*</sup> Neg x →<span class="hidden">⇧</span><sup>*</sup> Pos x.

  Assign all variables as follows:
    Let current assignment be A. By assumption, closed and consistent.
    Choose unassigned variable x
    Try to assign Pos x, form transitive closure.
    If this yields a conflict, assign Neg x

    Assume both Pos x and Neg x would yield conflict:
      As current assignment is always closed, we have 
        G<span class="hidden">⇧</span><sup>*</sup>``Pos x ∩ negate``A = {} and G<span class="hidden">⇧</span><sup>*</sup>``Neg x ∩ negate``A = {}
        (Otherwise:
          Pos x →<span class="hidden">⇧</span><sup>*</sup> negate l, l∈A
          ⟹ l →<span class="hidden">⇧</span><sup>*</sup> Neg x (skew sym)
          ⟹ Neg x ∈ A (A closed, l∈A)
          ⟹ x not unassigned, contr!
        )
      Thus, conflict must be of form:
        Pos x →<span class="hidden">⇧</span><sup>*</sup> Pos y, Pos x →<span class="hidden">⇧</span><sup>*</sup> Neg y
        Neg x →<span class="hidden">⇧</span><sup>*</sup> Pos z, Neg x →<span class="hidden">⇧</span><sup>*</sup> Neg z
        
        ⟹ (skew sym)
          Pos y →<span class="hidden">⇧</span><sup>*</sup> Neg x ⟹ Pos x →<span class="hidden">⇧</span><sup>*</sup> Neg x
          Pos z →<span class="hidden">⇧</span><sup>*</sup> Pos x ⟹ Neg x →<span class="hidden">⇧</span><sup>*</sup> Pos x
          contr to no-cycle assm
*)</span>    
    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">consistent</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"lit set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">consistent</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∄</span><span class="bound">x</span><span class="main">.</span> Pos <span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="main">∧</span> Neg <span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"consistent <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> consistent_def<span class="main">)</span>  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">vars_of_cnf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"cnf <span class="main">⇒</span> var set"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">vars_of_cnf</span> <span class="free"><span class="bound"><span class="entity">cnf</span></span></span> <span class="main">≡</span> <span class="main">⋃</span><span class="bound">cl</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">cnf</span></span></span><span class="main">.</span> var <span class="main">`</span> set_uprod <span class="bound">cl</span>"</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> eq_SomeD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> Eps <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> someI<span class="main">)</span>  
  
<span class="keyword1"><span class="command">locale</span></span> construct_sa <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">cnf</span> <span class="main">::</span> <span class="quoted">cnf</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FIN<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>vars_of_cnf <span class="free">cnf</span><span class="main">)</span>"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> NO_CYC<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">∄</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span>Pos <span class="bound">x</span><span class="main">,</span> Neg <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="main">(</span>Neg <span class="bound">x</span><span class="main">,</span> Pos <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TSAT<span class="main">:</span> <span class="quoted"><span class="quoted">"is_2sat <span class="free">cnf</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">≡</span> imp_graph <span class="free">cnf</span>"</span></span>

  <span class="keyword1"><span class="command">function</span></span> <span class="entity">extend</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"lit set <span class="main">⇒</span> lit set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">extend</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">if</span> vars_of_cnf <span class="free">cnf</span> <span class="main">⊆</span> var <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> 
      <span class="keyword1">else</span> <span class="keyword1">let</span>
        <span class="bound">x</span> <span class="main">=</span> <span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vars_of_cnf <span class="free">cnf</span> <span class="main">-</span> var <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span>
      <span class="keyword1">in</span>
        <span class="keyword1">if</span> consistent <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="main">∪</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span>Pos <span class="bound">x</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">then</span>
          <span class="free">extend</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="main">∪</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span>Pos <span class="bound">x</span><span class="main">}</span><span class="main">)</span>
        <span class="keyword1">else</span>
          <span class="free">extend</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="main">∪</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span>Neg <span class="bound">x</span><span class="main">}</span><span class="main">)</span>
    <span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">termination</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"inv_image finite_psubset <span class="main">(</span><span class="main">λ</span><span class="bound">ls</span><span class="main">.</span> vars_of_cnf <span class="free">cnf</span> <span class="main">-</span> var<span class="main">`</span><span class="bound">ls</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> eq_SomeD<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> FIN<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> eq_SomeD<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> FIN<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">declare</span></span> extend.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>    
      
  <span class="keyword1"><span class="command">lemma</span></span> extend_vars<span class="main">:</span> <span class="quoted"><span class="quoted">"vars_of_cnf <span class="free">cnf</span> <span class="main">⊆</span> var <span class="main">`</span> extend <span class="free">ls</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ls</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> extend.induct<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> extend.simps<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      
  <span class="keyword1"><span class="command">lemma</span></span> extend_cons_closed_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"consistent <span class="free">ls</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"G <span class="main">``</span> <span class="free">ls</span> <span class="main">⊆</span> <span class="free">ls</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"consistent <span class="main">(</span>extend <span class="free">ls</span><span class="main">)</span> <span class="main">∧</span> G <span class="main">``</span> extend <span class="free">ls</span> <span class="main">⊆</span> extend <span class="free">ls</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ls</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> extend.induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">ls</span><span class="main">)</span>
      
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"vars_of_cnf <span class="free">cnf</span> <span class="main">⊆</span> var<span class="main">`</span><span class="skolem">ls</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"1.prems"</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2 3<span class="main"><span class="main">)</span></span> extend.simps<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> False
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vars_of_cnf <span class="free">cnf</span> <span class="main">-</span> var <span class="main">`</span> <span class="skolem">ls</span><span class="main">)</span>"</span></span>  
      <span class="keyword1"><span class="command">with</span></span> False <span class="keyword1"><span class="command">have</span></span> XI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vars_of_cnf <span class="free">cnf</span> <span class="main">-</span> var <span class="main">`</span> <span class="skolem">ls</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> DiffI someI_ex subsetI<span class="main">)</span>

      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"consistent <span class="main">(</span><span class="skolem">ls</span> <span class="main">∪</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span>Pos <span class="skolem">x</span><span class="main">}</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> CPOS <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> True
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted">"1.prems"</span> <span class="keyword1"><span class="command">have</span></span> CL<span class="main">:</span> <span class="quoted"><span class="quoted">"G <span class="main">``</span> <span class="main">(</span><span class="skolem">ls</span> <span class="main">∪</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span>Pos <span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">ls</span> <span class="main">∪</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span>Pos <span class="skolem">x</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
          <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"1.IH"</span><span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> False x_def CPOS CPOS CL<span class="main">]</span>
          <span class="keyword1"><span class="command">unfolding</span></span> extend.simps<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">ls</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">unfolding</span></span> x_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> NCPOS<span class="main">:</span> False
          
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted">"1.prems"</span> <span class="keyword1"><span class="command">have</span></span> CL<span class="main">:</span> <span class="quoted"><span class="quoted">"G <span class="main">``</span> <span class="main">(</span><span class="skolem">ls</span> <span class="main">∪</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span>Neg <span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">ls</span> <span class="main">∪</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span>Neg <span class="skolem">x</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"consistent <span class="main">(</span><span class="skolem">ls</span> <span class="main">∪</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span>Neg <span class="skolem">x</span><span class="main">}</span><span class="main">)</span>"</span></span><span class="main">)</span>  
          <span class="keyword3"><span class="command">case</span></span> CNEG<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> True
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
            <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"1.IH"</span><span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> False x_def NCPOS CNEG CL<span class="main">]</span> NCPOS
            <span class="keyword1"><span class="command">unfolding</span></span> extend.simps<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">ls</span></span><span class="main">]</span> x_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> NCNEG<span class="main">:</span> False
            
          <span class="keyword1"><span class="command">have</span></span> X1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> negate <span class="skolem">l</span><span class="main">)</span><span class="main">∈</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> UNASS<span class="main">:</span> <span class="quoted"><span class="quoted">"var <span class="skolem">l</span> <span class="main">∉</span> var <span class="main">`</span> <span class="skolem">ls</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> consistent <span class="main">(</span><span class="skolem">ls</span> <span class="main">∪</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="skolem">l</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">l</span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
            <span class="keyword1"><span class="command">from</span></span> that<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> X1<span class="main">:</span> <span class="quoted"><span class="quoted">"Pos <span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">ls</span> <span class="main">∪</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="skolem">l</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"Neg <span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">ls</span> <span class="main">∪</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="skolem">l</span><span class="main">}</span>"</span></span>
              <span class="keyword1"><span class="command">unfolding</span></span> consistent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> <span class="quoted">"1.prems"</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> Pos <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∨</span> <span class="main">(</span><span class="skolem">l</span><span class="main">,</span> Neg <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>   
              <span class="keyword1"><span class="command">unfolding</span></span> consistent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> X2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> Pos <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">l</span><span class="main">,</span> Neg <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule_tac</span> ccontr<span class="main">)</span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> Pos <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> Neg <span class="skolem">y</span><span class="main">)</span><span class="main">∉</span>G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
              <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Neg <span class="skolem">y</span><span class="main">,</span>negate <span class="skolem">l</span><span class="main">)</span><span class="main">∈</span>G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"Neg <span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">ls</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> X1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> imp_graph_rtrancl_skew_sym<span class="main">)</span>
              <span class="keyword1"><span class="command">with</span></span> CL <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"negate <span class="skolem">l</span> <span class="main">∈</span> <span class="skolem">ls</span>"</span></span>
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="quoted">"1.prems"</span><span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> ImageI Image_closed_trancl<span class="main">)</span>    
              <span class="keyword1"><span class="command">with</span></span> UNASS <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l</span></span><span class="main">)</span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>  
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> Neg <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> Pos <span class="skolem">y</span><span class="main">)</span> <span class="main">∉</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
              <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Pos <span class="skolem">y</span><span class="main">,</span> negate <span class="skolem">l</span><span class="main">)</span> <span class="main">∈</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"Pos <span class="skolem">y</span> <span class="main">∈</span> <span class="skolem">ls</span>"</span></span> 
                <span class="keyword1"><span class="command">using</span></span> X1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> imp_graph_rtrancl_skew_sym<span class="main">)</span>
              <span class="keyword1"><span class="command">with</span></span> CL <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"negate <span class="skolem">l</span> <span class="main">∈</span> <span class="skolem">ls</span>"</span></span>
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="quoted">"1.prems"</span><span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> ImageI Image_closed_trancl<span class="main">)</span>    
              <span class="keyword1"><span class="command">with</span></span> UNASS <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l</span></span><span class="main">)</span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>  
            <span class="keyword1"><span class="command">qed</span></span>
            <span class="keyword1"><span class="command">from</span></span> X2 imp_graph_rtrancl_skew_sym<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="free">cnf</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Neg <span class="skolem">y</span><span class="main">,</span> negate <span class="skolem">l</span><span class="main">)</span> <span class="main">∈</span> G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
            <span class="keyword1"><span class="command">with</span></span> X2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
          <span class="keyword1"><span class="command">qed</span></span>
            
          <span class="keyword1"><span class="command">from</span></span> X1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Pos <span class="skolem">x</span>"</span></span><span class="main">,</span> <span class="operator">OF</span> _ NCPOS<span class="main">]</span> XI <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Pos <span class="skolem">x</span><span class="main">,</span> Neg <span class="skolem">x</span><span class="main">)</span><span class="main">∈</span>G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> X1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Neg <span class="skolem">x</span>"</span></span><span class="main">,</span> <span class="operator">OF</span> _ NCNEG<span class="main">]</span> XI <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Neg <span class="skolem">x</span><span class="main">,</span> Pos <span class="skolem">x</span><span class="main">)</span><span class="main">∈</span>G<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> NO_CYC <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>   
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span> 
    
  <span class="keyword1"><span class="command">lemma</span></span> extend_cons_closed<span class="main">:</span>
    <span class="quoted"><span class="quoted">"consistent <span class="main">(</span>extend <span class="main">{}</span><span class="main">)</span>"</span></span> 
    <span class="quoted"><span class="quoted">"G <span class="main">``</span> extend <span class="main">{}</span> <span class="main">⊆</span> extend <span class="main">{}</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> extend_cons_closed_aux<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span><span class="main">]</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      
  <span class="keyword1"><span class="command">lemma</span></span> CCV_sat<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> CONS<span class="main">:</span> <span class="quoted"><span class="quoted">"consistent <span class="free">ls</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> CLOSED<span class="main">:</span> <span class="quoted"><span class="quoted">"G<span class="main">``</span><span class="free">ls</span> <span class="main">⊆</span> <span class="free">ls</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> VARS<span class="main">:</span> <span class="quoted"><span class="quoted">"vars_of_cnf <span class="free">cnf</span> <span class="main">⊆</span> var<span class="main">`</span><span class="free">ls</span>"</span></span>  
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sat_cnf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> Pos <span class="bound">x</span> <span class="main">∈</span> <span class="free">ls</span><span class="main">)</span> <span class="free">cnf</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> sat_cnf_def
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">cl</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cl</span><span class="main">∈</span><span class="free">cnf</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> TSAT <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">l1</span></span> <span class="skolem"><span class="skolem">l2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cl</span> <span class="main">=</span> Upair <span class="skolem">l1</span> <span class="skolem">l2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l1</span> <span class="main">≠</span> <span class="skolem">l2</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_2sat_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proper_uprod_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bspec <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> uprod_split_asm<span class="main">)</span>
      
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> sat_clause <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> Pos <span class="bound">x</span> <span class="main">∈</span> <span class="free">ls</span><span class="main">)</span> <span class="skolem">cl</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l1</span> <span class="main">∉</span> <span class="free">ls</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l2</span> <span class="main">∉</span> <span class="free">ls</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹consistent <span class="free">ls</span>›</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sat_lit_def consistent_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l1</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">l2</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
    
    <span class="keyword1"><span class="command">from</span></span> VARS <span class="quoted"><span class="quoted">‹<span class="skolem">cl</span> <span class="main">∈</span> <span class="free">cnf</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"var <span class="skolem">l1</span> <span class="main">∈</span> var <span class="main">`</span> <span class="free">ls</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> vars_of_cnf_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">l1</span> <span class="main">∉</span> <span class="free">ls</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"negate <span class="skolem">l1</span> <span class="main">∈</span> <span class="free">ls</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">L</span> <span class="bound">n</span> <span class="bound">f</span><span class="main">.</span> <span class="main">∃</span><span class="bound">l</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">∉</span> <span class="bound">f</span> <span class="main">`</span> <span class="bound">L</span> <span class="main">∨</span> <span class="main">(</span><span class="bound">l</span><span class="main">::</span>lit<span class="main">)</span> <span class="main">∈</span> <span class="bound">L</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">n</span> <span class="main">∉</span> <span class="bound">f</span> <span class="main">`</span> <span class="bound">L</span> <span class="main">∨</span> <span class="bound">f</span> <span class="bound">l</span> <span class="main">=</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">l1</span> <span class="main">∉</span> <span class="free">ls</span>›</span></span> <span class="quoted"><span class="quoted">‹var <span class="skolem">l1</span> <span class="main">∈</span> var <span class="main">`</span> <span class="free">ls</span>›</span></span> lit.expand negate_sat var_negate<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">cl</span> <span class="main">∈</span> <span class="free">cnf</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>negate <span class="skolem">l1</span><span class="main">,</span> <span class="skolem">l2</span><span class="main">)</span> <span class="main">∈</span> G"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> imp_graph_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_bexI<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l2</span> <span class="main">∈</span> <span class="free">ls</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> CLOSED <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">l2</span> <span class="main">∉</span> <span class="free">ls</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> sat<span class="main">:</span> <span class="quoted"><span class="quoted">"satisfiable <span class="free">cnf</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> CCV_sat<span class="main">[</span><span class="operator">OF</span> extend_cons_closed extend_vars<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span>   <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> satisfiable_def<span class="main">)</span>
      
<span class="keyword2"><span class="keyword">end</span></span>

  
<span class="keyword1"><span class="command">lemma</span></span> imp_graph_vars<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l</span><span class="main">,</span> <span class="free">l'</span><span class="main">)</span> <span class="main">∈</span> imp_graph <span class="free">cnf</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"var <span class="free">l</span> <span class="main">∈</span> vars_of_cnf <span class="free">cnf</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> imp_graph_def vars_of_cnf_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rev_bexI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> uprod_split_asm if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">theorem</span></span> finite_2sat_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FIN<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>vars_of_cnf <span class="free">cnf</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TSAT<span class="main">:</span> <span class="quoted"><span class="quoted">"is_2sat <span class="free">cnf</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"satisfiable <span class="free">cnf</span> 
    <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>vars_of_cnf <span class="free">cnf</span><span class="main">.</span> 
          <span class="main">¬</span> <span class="main">(</span><span class="main">(</span>Pos <span class="bound">x</span><span class="main">,</span> Neg <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="main">(</span>Neg <span class="bound">x</span><span class="main">,</span> Pos <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">;</span></span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> loop_imp_unsat<span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">" <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>vars_of_cnf <span class="free">cnf</span><span class="main">.</span>
     <span class="main">(</span>Pos <span class="bound">x</span><span class="main">,</span> Neg <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⟶</span> <span class="main">(</span>Neg <span class="bound">x</span><span class="main">,</span> Pos <span class="bound">x</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> construct_sa <span class="quoted"><span class="free">cnf</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> FIN TSAT <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> converse_rtranclE imp_graph_vars lit.inject lit.sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  
  <span class="keyword1"><span class="command">from</span></span> sat <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"satisfiable <span class="free">cnf</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">derive</span></span> linorder <span class="quoted">lit</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Finiteness›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lits_of_cnf</span> <span class="free"><span class="bound"><span class="entity">cnf</span></span></span> <span class="main">=</span> Pos<span class="main">`</span>vars_of_cnf <span class="free"><span class="bound"><span class="entity">cnf</span></span></span> <span class="main">∪</span> Neg<span class="main">`</span>vars_of_cnf <span class="free"><span class="bound"><span class="entity">cnf</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> inj_on_Pos <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on Pos <span class="free">A</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> inj_on_Neg <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on Neg <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lits_of_cnf_finite<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>lits_of_cnf <span class="free">cnf</span><span class="main">)</span> <span class="main">⟷</span> finite <span class="main">(</span>vars_of_cnf <span class="free">cnf</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lits_of_cnf_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> finite_image_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> vars_of_cnf_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="free">cnf</span> <span class="main">⟹</span> finite <span class="main">(</span>vars_of_cnf <span class="free">cnf</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> vars_of_cnf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> lit_eq_negate_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Lit <span class="free">p</span> <span class="free">v</span> <span class="main">=</span> negate <span class="free">l</span> <span class="main">⟷</span> <span class="free">l</span> <span class="main">=</span> Lit <span class="main">(</span><span class="main">¬</span><span class="free">p</span><span class="main">)</span> <span class="free">v</span>"</span></span>
  <span class="quoted"><span class="quoted">"negate <span class="free">l</span> <span class="main">=</span> Lit <span class="free">p</span> <span class="free">v</span> <span class="main">⟷</span> <span class="free">l</span> <span class="main">=</span> Lit <span class="main">(</span><span class="main">¬</span><span class="free">p</span><span class="main">)</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> imp_graph_nodes<span class="main">:</span> <span class="quoted"><span class="quoted">"imp_graph <span class="free">cnf</span> <span class="main">⊆</span> lits_of_cnf <span class="free">cnf</span> <span class="main">×</span> lits_of_cnf <span class="free">cnf</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> imp_graph_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> l1 l2 cl 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">cl</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">l1</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">l2</span></span><span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lits_of_cnf_def vars_of_cnf_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
<span class="keyword1"><span class="command">lemma</span></span> imp_graph_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>vars_of_cnf <span class="free">cnf</span><span class="main">)</span> <span class="main">⟹</span> finite <span class="main">(</span>imp_graph <span class="free">cnf</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> imp_graph_nodes<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Containers_DFS_Ex">
<div class="head">
<h1>Theory Containers_DFS_Ex</h1>
</div>
<pre class="source"><span class="comment1">(* Title:      Containers/Examples/Containers_DFS_Ex.thy
   Author:     Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Formalisation of depth-first search using Containers›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Containers_DFS_Ex <span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="Containers.html">../Containers</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Transitive_Closure_Table.html">HOL-Library.Transitive_Closure_Table</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary stuff›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">restrict</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">↿</span>"</span> 60<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main"><span class="free">↿</span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound"><span class="bound">a</span></span><span class="main">,</span> <span class="bound"><span class="bound">b</span></span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">.</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> in_restrict <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">↿</span> <span class="free">A</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> restrict_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> restrict_UNIV <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">↿</span> UNIV <span class="main">=</span> <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> restrict_restrict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">↿</span> <span class="free">A</span> <span class="main">↿</span> <span class="free">B</span> <span class="main">=</span> <span class="free">R</span> <span class="main">↿</span> <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> rtrancl_restrict_reachable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">z</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∉</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">R</span> <span class="main">↿</span> <span class="main">-</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">z</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> x
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> converse_rtrancl_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x</span> <span class="skolem">x'</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>›</span></span> z <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x'</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">↿</span> <span class="main">-</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">z</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl_trans converse_rtrancl_into_rtrancl<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> step.IH <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> converse_rtrancl_into_rtrancl<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> rtrancl_restrict_start<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">R</span> <span class="main">↿</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≡</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"rtrancl_path <span class="var">?R</span> <span class="free">x</span> <span class="skolem">xs</span> <span class="free">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> set <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtrancl_def rtranclp_eq_rtrancl_path <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtrancl_path_distinct<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">R</span> <span class="main">↿</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> converse_rtrancl_into_rtrancl<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> comp_fun_commute<span class="main">)</span> fold_set_union_disj<span class="main">:</span> <span class="comment1">(* Move to distribution *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∩</span> <span class="free">B</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">f</span> <span class="free">z</span> <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> Finite_Set.fold <span class="free">f</span> <span class="main">(</span>Finite_Set.fold <span class="free">f</span> <span class="free">z</span> <span class="free">A</span><span class="main">)</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>1<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> Image_insert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"NO_MATCH <span class="main">(</span><span class="main">{}</span> <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">``</span> insert <span class="free">x</span> <span class="free">A</span> <span class="main">=</span> <span class="free">R</span> <span class="main">``</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span><span class="free">R</span> <span class="main">``</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Declarative definition›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> dfs_result <span class="main">=</span> <span class="entity">is_Reachable</span><span class="main">:</span> Reachable <span class="main">|</span> Visited <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">E</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">reachable</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">=&gt;</span> <span class="tfree">'a</span> <span class="main">=&gt;</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">reachable</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">tgt</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">tgt</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We avoid the non-determinism of visited nodes in depth-first search by only returning
  the set of visited nodes when the search fails, because in that case it contains all reachable
  nodes and therefore is deterministic again.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dfs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> dfs_result"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">dfs</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">tgt</span></span></span> <span class="free"><span class="bound"><span class="entity">visited</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">tgt</span></span></span> <span class="main">∈</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">visited</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">}</span> <span class="keyword1">then</span> Reachable <span class="keyword1">else</span> Visited <span class="main">(</span><span class="free"><span class="bound"><span class="entity">visited</span></span></span> <span class="main">∪</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">visited</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Derivation of the recursion equation›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">tgt</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">loop</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">loop</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">x</span> <span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> Reachable <span class="main">⇒</span> Reachable <span class="main">|</span> Visited <span class="bound">𝒱</span> <span class="main">⇒</span> 
    <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="bound">𝒱</span> <span class="keyword1">then</span> Visited <span class="bound">𝒱</span> <span class="keyword1">else</span> dfs <span class="bound">x</span> <span class="free">tgt</span> <span class="bound">𝒱</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> loop_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">loop</span> <span class="free">x</span> Reachable <span class="main">=</span> Reachable"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">loop</span> <span class="free">x</span> <span class="main">(</span>Visited <span class="free">𝒱</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">𝒱</span> <span class="keyword1">then</span> Visited <span class="free">𝒱</span> <span class="keyword1">else</span> dfs <span class="free">x</span> <span class="free">tgt</span> <span class="free">𝒱</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> loop_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> loop_simps <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> comp_fun_commute_dfs_body<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_fun_commute <span class="free">loop</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> loop_def dfs_def fun_eq_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl_mono<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span> rtrancl_trans <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rtrancl_restrict_reachable <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> dfs_result.split<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> f<span class="main">:</span> comp_fun_commute <span class="quoted"><span class="free">loop</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> comp_fun_commute_dfs_body<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fold_dfs_Reachable <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span> Reachable <span class="free">A</span> <span class="main">=</span> Reachable"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> dfs_blocked<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">E</span> <span class="main">``</span> <span class="free">A</span> <span class="main">⊆</span> <span class="free">visited</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">tgt</span> <span class="main">∉</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="free">visited</span><span class="main">)</span> <span class="free">A</span> <span class="main">=</span> Visited <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">visited</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> converse_rtranclE <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfs_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dfs_visited<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> <span class="free">visited</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="free">visited</span><span class="main">)</span> <span class="free">A</span> <span class="main">=</span> Visited <span class="free">visited</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dfs_rec<span class="main">:</span>
  <span class="quoted"><span class="quoted">"dfs <span class="free">src</span> <span class="free">tgt</span> <span class="free">visited</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">src</span> <span class="main">=</span> <span class="free">tgt</span> <span class="keyword1">then</span> Reachable
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">succs</span> <span class="main">=</span> <span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="keyword1">in</span> <span class="keyword1">if</span> finite <span class="bound">succs</span> <span class="keyword1">then</span> Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span> <span class="bound">succs</span>
   <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''infinite successor relation''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> dfs <span class="free">src</span> <span class="free">tgt</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">src</span> <span class="main">≠</span> <span class="free">tgt</span> <span class="main">∧</span> finite <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfs_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">src</span> <span class="main">≠</span> <span class="free">tgt</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">tgt</span> <span class="main">≠</span> <span class="free">src</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">src</span><span class="main">,</span> <span class="free">tgt</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="free">visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?g</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="free">visited</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> 
      Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">∩</span> insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> fin <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> f.fold_set_union_disj<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> True <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"rtrancl_path <span class="var">?g</span> <span class="free">src</span> <span class="skolem">xs</span> <span class="free">tgt</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span><span class="free">src</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtrancl_def rtranclp_eq_rtrancl_path <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtrancl_path_distinct<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span> <span class="main">=</span> Reachable"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">src</span> <span class="main">≠</span> <span class="free">tgt</span>›</span></span> fin
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">src</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="skolem">z</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="free">tgt</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">xs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?succs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">-</span> <span class="free">visited</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">x</span><span class="main">}</span>"</span></span>
    
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="skolem">x</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>insert <span class="skolem">y</span> <span class="var">?succs</span><span class="main">)</span> <span class="main">=</span>
            Finite_Set.fold <span class="free">loop</span> <span class="main">(</span><span class="free">loop</span> <span class="skolem">y</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="skolem">x</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="var">?succs</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> f.fold_insert2<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹finite <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span>›</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">y</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹rtrancl_path <span class="var">?g</span> <span class="skolem">y</span> <span class="skolem">xs</span> <span class="free">tgt</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="free">tgt</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> insert <span class="skolem">x</span> <span class="free">visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> converse_rtrancl_into_rtrancl<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="free">visited</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">loop</span> <span class="skolem">y</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="skolem">x</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Reachable"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∉</span> set <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfs_def<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="free">visited</span>›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert <span class="skolem">y</span> <span class="var">?succs</span> <span class="main">=</span> <span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">-</span> insert <span class="skolem">x</span> <span class="free">visited</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹distinct <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">y</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfs_def Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> 
      Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">∩</span> insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> fin <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> f.fold_set_union_disj<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> fin <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> <span class="free">visited</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span> <span class="main">=</span> Visited <span class="main">(</span><span class="free">visited</span> <span class="main">∪</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="free">visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> False
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="skolem">A</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"<span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> <span class="free">visited</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">visited</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_psubset_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> psubset
      <span class="keyword1"><span class="command">note</span></span> fin <span class="main">=</span> <span class="quoted"><span class="quoted">‹finite <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">note</span></span> src_tgt <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">src</span><span class="main">,</span> <span class="free">tgt</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="skolem">visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> insert <span class="free">src</span> <span class="skolem">visited</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?g</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="skolem">visited</span>"</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">src</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="skolem">visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"rtrancl_path <span class="var">?g</span> <span class="free">src</span> <span class="skolem">xs</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span><span class="free">src</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtrancl_def rtranclp_eq_rtrancl_path <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtrancl_path_distinct<span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">src</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span> <span class="operator">auto</span> <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> True <span class="keyword1"><span class="command">using</span></span> True
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> converse_rtranclE<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> <span class="skolem">visited</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≠</span> <span class="free">src</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?succs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> insert <span class="free">src</span> <span class="skolem">visited</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?visited</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insert <span class="free">src</span> <span class="skolem">visited</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?visited'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?visited</span> <span class="main">∪</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> insert <span class="free">src</span> <span class="skolem">visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="var">?visited</span><span class="main">)</span> <span class="main">(</span>insert <span class="skolem">y</span> <span class="var">?succs</span><span class="main">)</span> <span class="main">=</span>
              Finite_Set.fold <span class="free">loop</span> <span class="main">(</span><span class="free">loop</span> <span class="skolem">y</span> <span class="main">(</span>Visited <span class="var">?visited</span><span class="main">)</span><span class="main">)</span> <span class="var">?succs</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> f.fold_insert2<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fin<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> y_tgt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="free">tgt</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="var">?visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y src_tgt
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> converse_rtrancl_into_rtrancl rtrancl_mono<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">loop</span> <span class="skolem">y</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="free">src</span> <span class="skolem">visited</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Visited <span class="var">?visited'</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> y <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfs_def<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">≡</span> <span class="var">?succs</span> <span class="main">∩</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> insert <span class="free">src</span> <span class="skolem">visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?succs</span> <span class="main">=</span> <span class="skolem">A</span> <span class="main">∪</span> <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> insert <span class="free">src</span> <span class="var">?visited'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> A_def <span class="keyword1"><span class="command">using</span></span> y <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="var">?visited'</span><span class="main">)</span> <span class="var">?succs</span> <span class="main">=</span>
               Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="var">?visited'</span><span class="main">)</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="var">?visited'</span><span class="main">)</span> <span class="skolem">A</span><span class="main">)</span> <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> insert <span class="free">src</span> <span class="var">?visited'</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> f.fold_set_union_disj<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ fin<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword1"><span class="command">from</span></span> fin <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> A_def
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">E</span> <span class="main">``</span> <span class="skolem">A</span> <span class="main">⊆</span> <span class="var">?visited'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y <span class="keyword1"><span class="command">unfolding</span></span> A_def
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl_into_rtrancl<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">tgt</span> <span class="main">∉</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> A_def <span class="keyword1"><span class="command">using</span></span> y_tgt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="var">?visited'</span><span class="main">)</span> <span class="skolem">A</span> <span class="main">=</span> <span class="main">(</span>Visited <span class="main">(</span><span class="skolem">A</span> <span class="main">∪</span> <span class="var">?visited'</span><span class="main">)</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> dfs_blocked<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">∪</span> <span class="var">?visited'</span> <span class="main">=</span> insert <span class="free">src</span> <span class="var">?visited'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> A_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">{</span></span> 
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> <span class="var">?visited'</span> <span class="main">⊂</span> <span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> <span class="skolem">visited</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">src</span><span class="main">,</span> <span class="free">tgt</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="var">?visited'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">src</span><span class="main">,</span> <span class="free">tgt</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="skolem">visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl_mono<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">ultimately</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Finite_Set.fold <span class="free">loop</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="free">src</span> <span class="var">?visited'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> insert <span class="free">src</span> <span class="var">?visited'</span><span class="main">)</span> <span class="main">=</span>
                Visited <span class="main">(</span><span class="var">?visited'</span> <span class="main">∪</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="var">?visited'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> psubset.hyps<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
          <span class="keyword3"><span class="command">assume</span></span> src_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">src</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="skolem">visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
            <span class="keyword2"><span class="keyword">and</span></span> y_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∉</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> insert <span class="free">src</span> <span class="skolem">visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
          <span class="keyword1"><span class="command">from</span></span> src_x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">src</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="var">?visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rtrancl_restrict_start Compl_insert Containers_DFS_Ex.restrict_restrict Diff_Compl double_complement<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> rtrancl_restrict_reachable<span class="main">[</span><span class="operator">OF</span> this y_x<span class="main">]</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">src</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="var">?visited'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> Un_insert_left compl_sup<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?visited'</span> <span class="main">∪</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="var">?visited'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">visited</span> <span class="main">∪</span> <span class="main">(</span><span class="free">E</span> <span class="main">↿</span> <span class="main">-</span> <span class="skolem">visited</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> y <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> converse_rtrancl_into_rtrancl rtrancl_mono<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert <span class="skolem">y</span> <span class="var">?succs</span> <span class="main">=</span> <span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="main">-</span> insert <span class="free">src</span> <span class="skolem">visited</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">finally</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False fin
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfs_def Let_def<span class="main">)</span><span class="main">(</span><span class="operator">subst</span> dfs_visited<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> dfs_body <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> dfs_result<span class="main">)</span> comp_fun_commute"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">tgt</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> Reachable <span class="main">⇒</span> Reachable <span class="main">|</span> Visited <span class="bound">𝒱</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="bound">𝒱</span> <span class="keyword1">then</span> Visited <span class="bound">𝒱</span> <span class="keyword1">else</span> dfs <span class="bound">x</span> <span class="bound">tgt</span> <span class="bound">𝒱</span>"</span></span>
 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> comp_fun_commute_dfs_body<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dfs_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dfs <span class="free">src</span> <span class="free">tgt</span> <span class="free">visited</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">src</span> <span class="main">=</span> <span class="free">tgt</span> <span class="keyword1">then</span> Reachable
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">S</span> <span class="main">=</span> <span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="free">src</span><span class="main">}</span> <span class="keyword1">in</span> 
   <span class="keyword1">if</span> finite <span class="bound">S</span> <span class="keyword1">then</span> set_fold_cfc <span class="main">(</span>dfs_body <span class="free">tgt</span><span class="main">)</span> <span class="main">(</span>Visited <span class="main">(</span>insert <span class="free">src</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span> <span class="bound">S</span>
   <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''infinite successor relation''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> dfs <span class="free">src</span> <span class="free">tgt</span> <span class="free">visited</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">subst</span> dfs_rec<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> reachable_dfs <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"reachable <span class="free">src</span> <span class="free">tgt</span> <span class="main">=</span> is_Reachable <span class="main">(</span>dfs <span class="free">src</span> <span class="free">tgt</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfs_def reachable_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement to executable code›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'a</span> graph <span class="main">=</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set set"</span></span> <span class="keyword2"><span class="keyword">morphisms</span></span> edges Graph <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_graph

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Implement graphs with successor function›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">graph_of_succs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">graph_of_succs</span> <span class="free"><span class="bound"><span class="entity">succs</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span><span class="main">.</span> <span class="bound">w</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">succs</span></span></span> <span class="bound">v</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> graph_of_succs_def<span class="main">[</span><span class="operator">containers_post</span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">,</span> <span class="operator">containers_pre</span><span class="main">]</span>

<span class="keyword1"><span class="command">lift_definition</span></span> Succ <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> graph"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"graph_of_succs"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">code_datatype</span></span> <span class="quoted">Succ</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Identify operations on graph›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">successors</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">successors</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="main">``</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> successors_def<span class="main">[</span><span class="operator">containers_post</span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">,</span> <span class="operator">containers_pre</span><span class="main">]</span>

<span class="keyword1"><span class="command">lift_definition</span></span> succs <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> graph <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">successors</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> succs_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"succs <span class="main">(</span>Succ <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> successors_def fun_eq_iff graph_of_succs_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Transfer algorithms to abstract graph type›</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> reachable_impl <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> graph <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">reachable</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> dfs_impl <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> graph <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> dfs_result"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">dfs</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> dfs_body_impl <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> graph <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> dfs_result<span class="main">)</span> comp_fun_commute"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">dfs_body</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">containers_identify</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span> <span class="main">=</span> reachable_dfs dfs_code dfs_body.rep_eq

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Tests›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_graph</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat graph"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_graph</span> <span class="main">=</span> Succ <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">{}</span><span class="main">)</span><span class="main">(</span><span class="main">0</span> <span class="main">:=</span> <span class="main">{</span><span class="main">1</span><span class="main">,</span><span class="numeral">3</span><span class="main">}</span><span class="main">,</span> <span class="main">1</span> <span class="main">:=</span> <span class="main">{</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">4</span><span class="main">}</span><span class="main">,</span> <span class="numeral">2</span> <span class="main">:=</span> <span class="main">{</span><span class="main">1</span><span class="main">}</span><span class="main">,</span> <span class="numeral">3</span> <span class="main">:=</span> <span class="main">{</span><span class="main">1</span><span class="main">,</span> <span class="numeral">5</span><span class="main">}</span><span class="main">,</span> <span class="numeral">4</span> <span class="main">:=</span> <span class="main">{</span><span class="numeral">5</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_dfs</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_dfs</span> <span class="main">=</span> map <span class="main">(</span>reachable_impl test_graph <span class="main">0</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="numeral">7</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">[</span>true<span class="main">,</span> true<span class="main">,</span> true<span class="main">,</span> true<span class="main">,</span> true<span class="main">,</span> true<span class="main">,</span> false<span class="main">]</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_dfs</span><span class="antiquote">}</span></span></span><span class="main">;</span>
›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Containers_TwoSat_Ex">
<div class="head">
<h1>Theory Containers_TwoSat_Ex</h1>
</div>
<pre class="source"><span class="comment1">(* Title:      Containers/Examples/Containers_TwoSat_Ex.thy
   Author:     Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementation of 2SAT using Containers›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Containers_TwoSat_Ex <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="TwoSat_Ex.html">TwoSat_Ex</a>
  <a href="Containers_DFS_Ex.html">Containers_DFS_Ex</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> abort_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">shows</span></span> <span class="comment1">(* Move to Isabelle distribution *)</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> Code.abort Code.abort"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Code.abort_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>


<span class="keyword1"><span class="command">instantiation</span></span> uprod <span class="main">::</span> <span class="main">(</span><span class="quoted">finite_UNIV</span><span class="main">)</span> <span class="quoted">finite_UNIV</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">finite_UNIV_uprod</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> uprod<span class="main">,</span> bool<span class="main">)</span> phantom"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">finite_UNIV_uprod</span> <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span><span class="tfree">'a</span> uprod<span class="main">)</span> <span class="main">(</span>of_phantom <span class="main">(</span>finite_UNIV <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> bool<span class="main">)</span> phantom<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_UNIV_uprod_def finite_UNIV<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uprod <span class="main">::</span> <span class="main">(</span><span class="quoted">card_UNIV</span><span class="main">)</span> <span class="quoted">card_UNIV</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">card_UNIV_uprod</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> uprod<span class="main">,</span> nat<span class="main">)</span> phantom"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">card_UNIV_uprod</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">n</span> <span class="main">=</span> of_phantom <span class="main">(</span>card_UNIV <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> nat<span class="main">)</span> phantom<span class="main">)</span> <span class="keyword1">in</span> <span class="keyword1">Phantom</span><span class="main">(</span><span class="tfree">'a</span> uprod<span class="main">)</span> <span class="main">(</span><span class="bound">n</span> <span class="main">*</span> <span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_UNIV_uprod_def card_UNIV Let_def card_UNIV_uprod<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  To instantiate the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span> type class for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> uprod"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, we must make a small detour.
  As <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> uprod"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>'s type definition uses HOL equality, we cannot implement a new notion of 
  equality that is parametrised by the equality relation. Instead, we define the subtype of all binary
  relations that contains only <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(=)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and define the parametrised equality relation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">uprod_ceq</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  on the subtype. Then, the instantiation can pass the equality relation from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">CEQ</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">::</span></span> ceq<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">uprod_ceq</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because the type class axioms ensure that the obtained relation is equivalent
  to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(=)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'a</span> equal <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(=)</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_equal

<span class="keyword1"><span class="command">lift_definition</span></span> uprod_eq <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> equal <span class="main">⇒</span> <span class="tfree">'a</span> uprod <span class="main">⇒</span> <span class="tfree">'a</span> uprod <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">eq</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="bound">eq</span> <span class="bound">a</span> <span class="bound">c</span> <span class="main">∧</span> <span class="bound">eq</span> <span class="bound">b</span> <span class="bound">d</span> <span class="main">∨</span> <span class="bound">eq</span> <span class="bound">b</span> <span class="bound">c</span> <span class="main">∧</span> <span class="bound">eq</span> <span class="bound">a</span> <span class="bound">d</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> uprod_eq_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uprod_eq <span class="free">eq</span> <span class="main">(</span>Upair <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span>Upair <span class="free">c</span> <span class="free">d</span><span class="main">)</span> <span class="main">⟷</span> 
   Rep_equal <span class="free">eq</span> <span class="free">a</span> <span class="free">c</span> <span class="main">∧</span> Rep_equal <span class="free">eq</span> <span class="free">b</span> <span class="free">d</span> <span class="main">∨</span> Rep_equal <span class="free">eq</span> <span class="free">b</span> <span class="free">c</span> <span class="main">∧</span> Rep_equal <span class="free">eq</span> <span class="free">a</span> <span class="free">d</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> Upair.transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">lift_definition</span></span> <span class="main">(</span>code_dt<span class="main">)</span> ceq_equal <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ceq equal option"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">CEQ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> forw_subst<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"pred_option <span class="main"><span class="main"><span class="main">_</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_use</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ceq<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uprod <span class="main">::</span> <span class="main">(</span><span class="quoted">ceq</span><span class="main">)</span> <span class="quoted">ceq</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">ceq_uprod</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ceq_uprod</span> <span class="main">=</span> map_option uprod_eq ceq_equal"</span></span>
<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">standard</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ceq_uprod_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  For comparison, we do a similar trick as for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ceq<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'a</span> compare <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">f</span> <span class="main">::</span> <span class="tfree">'a</span> comparator<span class="main">.</span> comparator <span class="bound">f</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"partial_order_on UNIV <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> partial_order_on_def preorder_on_def refl_on_def trans_def antisym_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ord</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> lin<span class="main">:</span> <span class="quoted"><span class="quoted">"linear_order <span class="skolem">ord</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> porder_extend_to_linorder<span class="main">)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> comparator"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">ord</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">ord</span> <span class="keyword1">then</span> Eq <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">ord</span> <span class="keyword1">then</span> Lt <span class="keyword1">else</span> Gt<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"comparator <span class="skolem">f</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"invert_order <span class="main">(</span><span class="skolem">f</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">y</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword1"><span class="command">using</span></span> lin
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_def linear_order_on_def partial_order_on_def preorder_on_def refl_on_def total_on_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> Eq"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword1"><span class="command">using</span></span> that lin
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_def linear_order_on_def partial_order_on_def antisym_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">x</span> <span class="skolem">z</span> <span class="main">=</span> Lt"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> Lt"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">=</span> Lt"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="keyword1"><span class="command">using</span></span> that lin
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_def linear_order_on_def partial_order_on_def preorder_on_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> transD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_compare

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="main">(</span>code_dt<span class="main">)</span> ccompare_comparator <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> ccompare compare option"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> forw_subst<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"pred_option <span class="main"><span class="main"><span class="main">_</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_use</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ccompare<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> uprod_compare <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> compare <span class="main">⇒</span> <span class="tfree">'a</span> uprod comparator"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">compare</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span>
  <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">case</span> <span class="bound">compare</span> <span class="bound">a</span> <span class="bound">b</span> <span class="keyword1">of</span> Lt <span class="main">⇒</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">x'</span><span class="main">,</span> <span class="bound">y'</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">case</span> <span class="bound">compare</span> <span class="bound">c</span> <span class="bound">d</span> <span class="keyword1">of</span> Lt <span class="main">⇒</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">d</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span>
  <span class="keyword1">in</span> <span class="keyword1">case</span> <span class="bound">compare</span> <span class="bound">x</span> <span class="bound">x'</span> <span class="keyword1">of</span> Lt <span class="main">⇒</span> Lt <span class="main">|</span> Gt <span class="main">⇒</span> Gt <span class="main">|</span> Eq <span class="main">⇒</span> <span class="bound">compare</span> <span class="bound">y</span> <span class="bound">y'</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> compare ab ab' cd cd'
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ab</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">ab'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">cd</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">cd'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">hypsubst</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> disjE conjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span> <span class="skolem">d</span>
    <span class="keyword3"><span class="command">assume</span></span> compare<span class="main">:</span> <span class="quoted"><span class="quoted">"comparator <span class="skolem">compare</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> comparator <span class="quoted"><span class="skolem">compare</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xy</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="skolem">compare</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword1">of</span> Lt <span class="main">⇒</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xy'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="skolem">compare</span> <span class="skolem">c</span> <span class="skolem">d</span> <span class="keyword1">of</span> Lt <span class="main">⇒</span> <span class="main">(</span><span class="skolem">c</span><span class="main">,</span> <span class="skolem">d</span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="skolem">d</span><span class="main">,</span> <span class="skolem">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?yx</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="skolem">compare</span> <span class="skolem">b</span> <span class="skolem">a</span> <span class="keyword1">of</span> Lt <span class="main">⇒</span> <span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?yx'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="skolem">compare</span> <span class="skolem">d</span> <span class="skolem">c</span> <span class="keyword1">of</span> Lt <span class="main">⇒</span> <span class="main">(</span><span class="skolem">d</span><span class="main">,</span> <span class="skolem">c</span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="skolem">c</span><span class="main">,</span> <span class="skolem">d</span><span class="main">)</span>"</span></span>
  
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?xy</span> <span class="main">=</span> <span class="var">?yx</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?xy'</span> <span class="main">=</span> <span class="var">?yx'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq Gt_lt_conv Lt_lt_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?side</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">xy</span> <span class="bound">xy'</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xy</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">case</span> <span class="bound">xy'</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">x'</span><span class="main">,</span> <span class="bound">y'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="skolem">compare</span> <span class="bound">x</span> <span class="bound">x'</span> <span class="keyword1">of</span> Eq <span class="main">⇒</span> <span class="skolem">compare</span> <span class="bound">y</span> <span class="bound">y'</span> <span class="main">|</span> Lt <span class="main">⇒</span> Lt <span class="main">|</span> Gt <span class="main">⇒</span> Gt<span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?side</span> <span class="var">?xy</span> <span class="var">?xy'</span> <span class="main">=</span> <span class="var">?side</span> <span class="var">?xy</span> <span class="var">?yx'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?side</span> <span class="var">?yx</span> <span class="var">?xy'</span> <span class="main">=</span> <span class="var">?side</span> <span class="var">?xy</span> <span class="var">?xy'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?side</span> <span class="var">?yx</span> <span class="var">?yx'</span> <span class="main">=</span> <span class="var">?side</span> <span class="var">?xy</span> <span class="var">?xy'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> uprod_compare_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uprod_compare <span class="free">compare</span> <span class="main">(</span>Upair <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span>Upair <span class="free">c</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">case</span> Rep_compare <span class="free">compare</span> <span class="free">a</span> <span class="free">b</span> <span class="keyword1">of</span> Lt <span class="main">⇒</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="free">b</span><span class="main">,</span> <span class="free">a</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">x'</span><span class="main">,</span> <span class="bound">y'</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">case</span> Rep_compare <span class="free">compare</span> <span class="free">c</span> <span class="free">d</span> <span class="keyword1">of</span> Lt <span class="main">⇒</span> <span class="main">(</span><span class="free">c</span><span class="main">,</span> <span class="free">d</span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span><span class="free">d</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span>
    <span class="keyword1">in</span> <span class="keyword1">case</span> Rep_compare <span class="free">compare</span> <span class="bound">x</span> <span class="bound">x'</span> <span class="keyword1">of</span> Eq <span class="main">⇒</span> Rep_compare <span class="free">compare</span> <span class="bound">y</span> <span class="bound">y'</span> <span class="main">|</span> Lt <span class="main">⇒</span> Lt <span class="main">|</span> Gt <span class="main">⇒</span> Gt<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">compare</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> Upair.transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> comparator_uprod_compare<span class="main">:</span> <span class="quoted"><span class="quoted">"comparator <span class="main">(</span>uprod_compare <span class="free">compare</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">compare</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"invert_order <span class="main">(</span>uprod_compare <span class="free">compare</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> uprod_compare <span class="free">compare</span> <span class="skolem">y</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">compare</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> comparator <span class="quoted"><span class="skolem">compare</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> order.split prod.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq Gt_lt_conv Lt_lt_conv sym <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> order.asym<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"uprod_compare <span class="free">compare</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> Eq"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">compare</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> 1<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">interpret</span></span> comparator <span class="quoted"><span class="skolem">compare</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> order.split_asm prod.split_asm <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"uprod_compare <span class="free">compare</span> <span class="skolem">x</span> <span class="skolem">z</span> <span class="main">=</span> Lt"</span></span> 
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"uprod_compare <span class="free">compare</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> Lt"</span></span> <span class="quoted"><span class="quoted">"uprod_compare <span class="free">compare</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="main">=</span> Lt"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">compare</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> 1<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">interpret</span></span> comparator <span class="quoted"><span class="skolem">compare</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1<span class="main">(</span>2-<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> order.splits prod.split_asm <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq Gt_lt_conv Lt_lt_conv <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> trans<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uprod <span class="main">::</span> <span class="main">(</span><span class="quoted">ccompare</span><span class="main">)</span> <span class="quoted">ccompare</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">ccompare_uprod</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ccompare_uprod</span> <span class="main">=</span> map_option uprod_compare <span class="main">(</span>ccompare_comparator <span class="main">::</span> <span class="tfree">'a</span> compare option<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ccompare_uprod_def comparator_uprod_compare<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uprod <span class="main">::</span> <span class="main">(</span><span class="quoted">set_impl</span><span class="main">)</span> <span class="quoted">set_impl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'a</span> uprod<span class="main">)</span> <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span><span class="tfree">'a</span> uprod<span class="main">)</span> <span class="main">(</span>of_phantom <span class="keyword1">SET_IMPL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>




<span class="comment1">(* Graph uses successor representation with function 
  -&gt; let's write a code equation for imp_graph
  -&gt; let's first define the successor operation for an individual vertex.
*)</span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">succs_of_clause</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"lit <span class="main">⇒</span> lit uprod <span class="main">⇒</span> lit set <span class="main">⇒</span> lit set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">succs_of_clause</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span>Upair <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> negate <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="keyword1">then</span> insert <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> negate <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="keyword1">then</span> insert <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="keyword1">else</span> id<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> surj_pair uprod_exhaust<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1"><span class="command">lemma</span></span> succs_of_clause_split<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>succs_of_clause <span class="free">l</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">l1</span> <span class="bound">l2</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> Upair <span class="bound">l1</span> <span class="bound">l2</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">(</span>succs_of_clause <span class="free">l</span> <span class="main">(</span>Upair <span class="bound">l1</span> <span class="bound">l2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> commute_succs_of_clause<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_fun_commute <span class="main">(</span>succs_of_clause <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> succs_of_clause_split<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> comp_fun_commute <span class="quoted"><span class="quoted">"succs_of_clause <span class="free">l</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">l</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> commute_succs_of_clause<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> idem_succs_of_clause<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_fun_idem <span class="main">(</span>succs_of_clause <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> succs_of_clause_split<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> comp_fun_idem <span class="quoted"><span class="quoted">"succs_of_clause <span class="free">l</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">l</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> idem_succs_of_clause<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> succs_loop_body <span class="main">::</span> <span class="quoted"><span class="quoted">"lit <span class="main">⇒</span> <span class="main">(</span>lit uprod<span class="main">,</span> lit set<span class="main">)</span> comp_fun_idem"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"succs_of_clause"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> idem_succs_of_clause<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">succ_imp_graph</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"cnf <span class="main">⇒</span> lit <span class="main">⇒</span> lit set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">succ_imp_graph</span> <span class="free"><span class="bound"><span class="entity">cnf</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> set_fold_cfi <span class="main">(</span>succs_loop_body <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">{}</span> <span class="free"><span class="bound"><span class="entity">cnf</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> succ_imp_graph_alt_def<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"succ_imp_graph <span class="free">cnf</span> <span class="free">l</span> <span class="main">=</span> Finite_Set.fold <span class="main">(</span>succs_of_clause <span class="free">l</span><span class="main">)</span> <span class="main">{}</span> <span class="free">cnf</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> succ_imp_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> succ_imp_graph_correct<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"finite <span class="free">cnf</span> <span class="main">⟹</span> succ_imp_graph <span class="free">cnf</span> <span class="free">l</span> <span class="main">=</span> <span class="main">{</span><span class="bound">l'</span><span class="main">.</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span> <span class="bound">l'</span><span class="main">)</span> <span class="main">∈</span> imp_graph <span class="free">cnf</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> succs_of_clause_split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> succ_imp_graph_alt_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> imp_graph_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"imp_graph <span class="free">cnf</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">cnf</span> <span class="keyword1">then</span> <span class="main">{</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="bound">l'</span><span class="main">)</span><span class="main">.</span> <span class="bound">l'</span> <span class="main">∈</span> succ_imp_graph <span class="free">cnf</span> <span class="bound">l</span><span class="main">}</span> 
   <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Infinite or invalid 2CNF formula''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> succ_imp_graph_correct<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> imp_graph_impl <span class="main">::</span> <span class="quoted"><span class="quoted">"cnf <span class="main">⇒</span> lit graph"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">imp_graph</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> imp_graph_code<span class="main">[</span><span class="operator">containers_identify</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> UNIV_lit<span class="main">:</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">=</span> range <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">pos</span><span class="main">)</span><span class="main">.</span> Lit <span class="bound">x</span> <span class="bound">pos</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">instantiation</span></span> lit <span class="main">::</span> <span class="quoted">finite_UNIV</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">finite_UNIV_lit</span></span> <span class="main">=</span> <span class="keyword1">Phantom</span><span class="main">(</span>lit<span class="main">)</span> False"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">standard</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_UNIV_lit_def UNIV_lit inj_on_def UNIV_Times_UNIV<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> finite_cartesian_product_iff <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> UNIV_Times_UNIV <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> finite_imageD<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>eq<span class="main">)</span> ceq <span class="quoted">lit</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> set_impl <span class="quoted">lit</span>
<span class="keyword1"><span class="command">derive</span></span> ccompare <span class="quoted">lit</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">imp_graph_impl</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">lemma</span></span> finite_vars_of_cnf<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">cnf</span> <span class="main">⟹</span> finite <span class="main">(</span>vars_of_cnf <span class="free">cnf</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> vars_of_cnf_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> satisfiable_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"satisfiable <span class="free">cnf</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">cnf</span> <span class="main">∧</span> is_2sat <span class="free">cnf</span> <span class="keyword1">then</span> 
   <span class="keyword1">let</span> <span class="bound">G</span> <span class="main">=</span> imp_graph <span class="free">cnf</span> <span class="keyword1">in</span> <span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>vars_of_cnf <span class="free">cnf</span><span class="main">.</span> <span class="main">¬</span> <span class="main">(</span>reachable <span class="bound">G</span> <span class="main">(</span>Pos <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>Neg <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> reachable <span class="bound">G</span> <span class="main">(</span>Neg <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>Pos <span class="bound">x</span><span class="main">)</span><span class="main">)</span>
   <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Infinite or invalid 2CNF formula''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> satisfiable <span class="free">cnf</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> reachable_def finite_2sat_iff finite_vars_of_cnf Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> satisfiable_code<span class="main">[</span><span class="operator">containers_identify</span><span class="main">]</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">satisfiable</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Memoize the implication graph's successor function›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> succ_imp_graph_outside<span class="main">:</span> <span class="quoted"><span class="quoted">"succ_imp_graph <span class="free">cnf</span> <span class="free">l</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"var <span class="free">l</span> <span class="main">∉</span> vars_of_cnf <span class="free">cnf</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="free">cnf</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">interpret</span></span> comp_fun_idem <span class="quoted"><span class="quoted">"succs_of_clause <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> idem_succs_of_clause<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True that
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> succ_imp_graph_alt_def vars_of_cnf_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm succs_of_clause_split<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> succ_imp_graph_alt_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> tabulate_graph <span class="main">::</span> <span class="quoted"><span class="quoted">"cnf <span class="main">⇒</span> <span class="main">(</span>lit<span class="main">,</span> lit set<span class="main">)</span> mapping"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">cnf</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∉</span> Domain <span class="main">(</span>imp_graph <span class="bound">cnf</span><span class="main">)</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span>imp_graph <span class="bound">cnf</span> <span class="main">``</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">insert_mapping</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'k</span> <span class="main">×</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span> set<span class="main">)</span> mapping <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'v</span> set<span class="main">)</span> mapping"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">insert_mapping</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> Mapping.lookup <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> Mapping.update <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">|</span> Some <span class="bound">V</span> <span class="main">⇒</span> Mapping.update <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">(</span>insert <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">V</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> comp_fun_idem_insert_mapping<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_fun_idem insert_mapping"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> insert_mapping_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Map_To_Mapping.map_apply_def fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">interpretation</span></span> comp_fun_idem <span class="quoted">insert_mapping</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> comp_fun_idem_insert_mapping<span class="main">)</span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">insert_clause</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"clause <span class="main">⇒</span> <span class="main">(</span>lit<span class="main">,</span> lit set<span class="main">)</span> mapping <span class="main">⇒</span> <span class="main">(</span>lit<span class="main">,</span> lit set<span class="main">)</span> mapping"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">insert_clause</span> <span class="main">(</span>Upair <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">)</span> <span class="main">=</span> insert_mapping <span class="main">(</span>negate <span class="free"><span class="bound"><span class="entity">l1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">)</span> <span class="main">∘</span> insert_mapping <span class="main">(</span>negate <span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> uprod_exhaust<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_fun_commute<span class="main">)</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1"><span class="command">lemma</span></span> comp_fun_idem_insert_clause<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_fun_idem insert_clause"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x y <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> commute_left_comp comp_fun_commute rewriteL_comp_comp<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> commute_left_comp comp_assoc comp_fun_idem<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> insert_clause' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>clause<span class="main">,</span> <span class="main">(</span>lit<span class="main">,</span> lit set<span class="main">)</span> mapping<span class="main">)</span> comp_fun_idem"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"insert_clause"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> comp_fun_idem_insert_clause<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> tabulate_graph_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"tabulate_graph <span class="free">cnf</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">cnf</span> <span class="keyword1">then</span> set_fold_cfi insert_clause' Mapping.empty <span class="free">cnf</span> 
   <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Infinite clause set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> tabulate_graph <span class="free">cnf</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> comp_fun_idem <span class="quoted">insert_clause</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> comp_fun_idem_insert_clause<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> * <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Finite_Set.fold insert_clause Mapping.empty <span class="free">cnf</span> <span class="main">=</span> tabulate_graph <span class="free">cnf</span>"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">cnf</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> empty
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff Map_To_Mapping.map_empty_def vars_of_cnf_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">C</span> <span class="skolem">cnf</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">C</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert<span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff Map_To_Mapping.map_apply_def <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span><span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">cnf</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> *<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> succ_imp_graph_impl_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"succ_imp_graph <span class="free">cnf</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">cnf</span> <span class="keyword1">then</span> <span class="keyword1">let</span> <span class="bound">m</span> <span class="main">=</span> tabulate_graph <span class="free">cnf</span>
   <span class="keyword1">in</span> <span class="main">(</span><span class="main">λ</span><span class="bound">l</span><span class="main">.</span> <span class="keyword1">case</span> Mapping.lookup <span class="bound">m</span> <span class="bound">l</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">{}</span> <span class="main">|</span> Some <span class="bound">succs'</span> <span class="main">⇒</span> <span class="bound">succs'</span><span class="main">)</span>
   <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Infinite clause set''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> succ_imp_graph <span class="free">cnf</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> succ_imp_graph_correct fun_eq_iff Map_To_Mapping.map_apply_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> succ_imp_graph_outside<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> mapping_impl <span class="quoted">lit</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">satisfiable</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML Scala Haskell<span class="main">?</span> OCaml<span class="main">?</span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>