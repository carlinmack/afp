<div id="MissingRelation">
<div class="head">
<h1>Theory MissingRelation</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> MissingRelation
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="MissingRelation-range_dom"><span class="command">lemma</span></span> range_dom<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> Domain <span class="free">f</span> <span class="main">=</span> Range <span class="free">f</span>"</span></span>
  <span class="quoted"><span class="quoted">"converse <span class="free">f</span> <span class="main">``</span> Range <span class="free">f</span> <span class="main">=</span> Domain <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-Gr_Image_image"><span class="command">lemma</span></span> Gr_Image_image<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"BNF_Def.Gr <span class="free">A</span> <span class="free">f</span> <span class="main">``</span> <span class="free">B</span> <span class="main">=</span> <span class="free">f</span> <span class="main">`</span> <span class="main">(</span><span class="free">A</span> <span class="main">∩</span> <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> BNF_Def.Gr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">univalent</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">univalent</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">⟶</span> <span class="bound">z</span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="MissingRelation-univalent_right_unique"><span class="command">lemma</span></span> univalent_right_unique<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"right_unique <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span> <span class="main">=</span> univalent <span class="free">R</span>"</span></span>
        <span class="quoted"><span class="quoted">"univalent <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span><span class="free">r</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">}</span> <span class="main">=</span> right_unique <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> univalent_def right_unique_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> univalent_right_unique<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">pred_set_conv</span><span class="main">]</span>

<span class="keyword1" id="MissingRelation-univalent_inter"><span class="command">lemma</span></span> univalent_inter<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">f_a</span> <span class="main">∨</span> univalent <span class="free">f_b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"univalent <span class="main">(</span><span class="free">f_a</span> <span class="main">∩</span> <span class="free">f_b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-univalent_union"><span class="command">lemma</span></span> univalent_union<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">f_a</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">f_b</span>"</span></span> <span class="quoted"><span class="quoted">"Domain <span class="free">f_a</span> <span class="main">∩</span> Domain <span class="free">f_b</span> <span class="main">=</span> Domain <span class="main">(</span><span class="free">f_a</span> <span class="main">∩</span> <span class="free">f_b</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"univalent <span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> univalent_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">clarify</span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> uni<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="main">(</span><span class="free">f_a</span> <span class="main">∩</span> <span class="free">f_b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span>
  <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f_a</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">hence</span></span> fb<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span><span class="main">∈</span><span class="free">f_b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a assms<span class="main">[</span><span class="operator">unfolded</span> univalent_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>Domain <span class="free">f_a</span> <span class="main">∩</span> Domain <span class="free">f_b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> assms uni fb True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DomainE IntD1 IntD2 univalent_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> a <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> fb<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span><span class="main">∈</span><span class="free">f_a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f_b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a assms<span class="main">[</span><span class="operator">unfolded</span> univalent_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>Domain <span class="free">f_a</span> <span class="main">∩</span> Domain <span class="free">f_b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> assms uni fb <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DomainE IntD1 IntD2 univalent_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> a <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MissingRelation-Gr_domain"><span class="command">lemma</span></span> Gr_domain<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Domain <span class="main">(</span>BNF_Def.Gr <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">A</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Domain <span class="main">(</span>BNF_Def.Gr <span class="free">A</span> id <span class="keyword1">O</span> <span class="free">R</span><span class="main">)</span> <span class="main">=</span> <span class="free">A</span> <span class="main">∩</span> Domain <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> BNF_Def.Gr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-in_Gr"><span class="command">lemma</span></span> in_Gr<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> BNF_Def.Gr <span class="free">A</span> <span class="free">f</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∧</span> <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> BNF_Def.Gr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-Id_on_domain"><span class="command">lemma</span></span> Id_on_domain<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Domain <span class="main">(</span>Id_on <span class="free">A</span> <span class="keyword1">O</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">A</span> <span class="main">∩</span> Domain <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-Domain_id_on"><span class="command">lemma</span></span> Domain_id_on<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Domain <span class="main">(</span><span class="free">R</span> <span class="keyword1">O</span> <span class="free">S</span><span class="main">)</span> <span class="main">=</span> Domain <span class="free">R</span> <span class="main">∩</span> <span class="free">R</span><span class="main">¯</span> <span class="main">``</span> Domain <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-Id_on_int"><span class="command">lemma</span></span> Id_on_int<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Id_on <span class="free">A</span> <span class="keyword1">O</span> <span class="free">f</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">∩</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-Domain_int_univ"><span class="command">lemma</span></span> Domain_int_univ<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Domain <span class="main">(</span><span class="free">A</span> <span class="main">×</span> UNIV <span class="main">∩</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">A</span> <span class="main">∩</span> Domain <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-Domain_O"><span class="command">lemma</span></span> Domain_O<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">⊆</span> Domain <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">``</span> <span class="free">a</span> <span class="main">⊆</span> Domain <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">⊆</span> Domain <span class="main">(</span><span class="free">x</span> <span class="keyword1">O</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xa</span> <span class="keyword3"><span class="command">assume</span></span> xa<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">∈</span> <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">∈</span> Domain <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> xaw<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xa</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> xa <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span> <span class="main">∈</span> Domain <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> xaw <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xa</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">x</span> <span class="keyword1">O</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">∈</span> Domain <span class="main">(</span><span class="free">x</span> <span class="keyword1">O</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MissingRelation-fst_UNIV"><span class="command">lemma</span></span> fst_UNIV<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> fst <span class="main">`</span> <span class="free">A</span> <span class="main">×</span> UNIV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1" id="MissingRelation-Gr_range"><span class="command">lemma</span></span> Gr_range<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Range <span class="main">(</span>BNF_Def.Gr <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">`</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> BNF_Def.Gr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-tuple_disj"><span class="command">lemma</span></span> tuple_disj<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">x</span> <span class="main">∨</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">z</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">,</span><span class="free">z</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-univalent_empty"><span class="command">lemma</span></span> univalent_empty <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"univalent <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-univalent_char"><span class="command">lemma</span></span> univalent_char <span class="main">:</span> <span class="quoted"><span class="quoted">"univalent <span class="free">R</span> <span class="main">⟷</span> converse <span class="free">R</span> <span class="keyword1">O</span> <span class="free">R</span> <span class="main">⊆</span> Id"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-univalentD"><span class="command">lemma</span></span> univalentD <span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"univalent <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">z</span><span class="main">)</span><span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="free">z</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-univalentI"><span class="command">lemma</span></span> univalentI<span class="main">:</span> <span class="quoted"><span class="quoted">"converse <span class="free">R</span> <span class="keyword1">O</span> <span class="free">R</span> <span class="main">⊆</span> Id <span class="main">⟹</span> univalent <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-univalent_composes"><span class="command">lemma</span></span> univalent_composes<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">R</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">S</span>"</span></span>
 <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"univalent <span class="main">(</span><span class="free">R</span> <span class="keyword1">O</span> <span class="free">S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> univalent_char <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-id_univalent"><span class="command">lemma</span></span> id_univalent<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="main">(</span>Id_on <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> univalent_char <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-univalent_insert"><span class="command">lemma</span></span> univalent_insert<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span> <span class="main">∉</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"univalent <span class="main">(</span>insert <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="free">R</span><span class="main">)</span> <span class="main">⟷</span> univalent <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-univalent_set_distinctI"><span class="command">lemma</span></span> univalent_set_distinctI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="comment1">(* not an iff: duplicates of A and B might align *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"univalent <span class="main">(</span>set <span class="main">(</span>zip <span class="free">A</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">B</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">A</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> univ<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="main">(</span>set <span class="main">(</span>zip <span class="skolem">A</span> <span class="main">(</span>tl <span class="skolem">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> Cons<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> set <span class="main">(</span>take <span class="skolem">x</span> <span class="skolem">A</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">using</span></span> in_set_takeD <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> Domain <span class="main">(</span>set <span class="main">(</span>zip <span class="skolem">A</span> <span class="main">(</span>tl <span class="skolem">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Domain_fst set_map<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> map_fst_zip_take <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span> <span class="main">∉</span> set <span class="main">(</span>zip <span class="skolem">A</span> <span class="main">(</span>tl <span class="skolem">B</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> univ univalent_insert<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">B</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-set_zip_conv"><span class="command">lemma</span></span> set_zip_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span>set <span class="main">(</span>zip <span class="free">A</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span><span class="main">¯</span> <span class="main">=</span> set <span class="main">(</span>zip <span class="free">B</span> <span class="free">A</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> set_zip <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-univalent_O_converse"><span class="command">lemma</span></span> univalent_O_converse<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"univalent <span class="main">(</span>converse <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="keyword1">O</span> converse <span class="free">R</span> <span class="main">=</span> Id_on <span class="main">(</span>Domain <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> univalent_char<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-Image_outside_Domain"><span class="command">lemma</span></span> Image_outside_Domain<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Domain <span class="free">R</span> <span class="main">∩</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">``</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-Image_Domain"><span class="command">lemma</span></span> Image_Domain<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Domain <span class="free">R</span> <span class="main">=</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">``</span> <span class="free">A</span> <span class="main">=</span> Range <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-Domain_set_zip"><span class="command">lemma</span></span> Domain_set_zip<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"length <span class="free">A</span> <span class="main">=</span> length <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Domain <span class="main">(</span>set <span class="main">(</span>zip <span class="free">A</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> set <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Domain_fst set_map<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> map_fst_zip<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span><span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="MissingRelation-Range_set_zip"><span class="command">lemma</span></span> Range_set_zip<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"length <span class="free">A</span> <span class="main">=</span> length <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Range <span class="main">(</span>set <span class="main">(</span>zip <span class="free">A</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> set <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Range_snd set_map<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> map_snd_zip<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span><span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="MissingRelation-Gr_univalent"><span class="command">lemma</span></span> Gr_univalent<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"univalent <span class="main">(</span>BNF_Def.Gr <span class="free">A</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> BNF_Def.Gr_def univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-univalent_fn"><span class="command">lemma</span></span> univalent_fn<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"BNF_Def.Gr <span class="main">(</span>Domain <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">SOME</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span> <span class="main">=</span> <span class="free">R</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> set_eq_iff
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">clarify</span><span class="main"><span class="keyword3">,</span></span><span class="operator">standard</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="keyword1">SOME</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> someI <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">with</span></span> assms a <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> Domain <span class="free">R</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> someI <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MissingRelation-Gr_not_in"><span class="command">lemma</span></span> Gr_not_in<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> <span class="free">F</span> <span class="main">∨</span> <span class="free">f</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">y</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∉</span> BNF_Def.Gr <span class="free">F</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-Gr_insert"><span class="command">lemma</span></span> Gr_insert<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"BNF_Def.Gr <span class="main">(</span>insert <span class="free">x</span> <span class="free">F</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> insert <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>BNF_Def.Gr <span class="free">F</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> BNF_Def.Gr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-Gr_empty"><span class="command">lemma</span></span> Gr_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"BNF_Def.Gr <span class="main">{}</span> <span class="free">f</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MissingRelation-Gr_card"><span class="command">lemma</span></span> Gr_card<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>BNF_Def.Gr <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> card <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>BNF_Def.Gr <span class="free">A</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">A</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">A</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>Domain <span class="main">(</span><span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> infinite <span class="main">(</span>Domain <span class="main">(</span><span class="skolem">A</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">using</span></span> Diff_infinite_finite Domain_Diff_subset finite.emptyI
              finite.insertI finite_Domain finite_subset Diff_subset Domain_mono
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>Domain <span class="skolem">A</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> fst <span class="main">`</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finite.simps <span class="keyword1"><span class="command">unfolding</span></span> Domain_fst <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"infinite <span class="main">(</span>Domain <span class="skolem">A</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Gr</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"BNF_Def.Gr <span class="free">A</span> <span class="free">f</span>"</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"infinite <span class="var">?Gr</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> infinite_coinduct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"infinite <span class="keyword1"><span class="keyword1"><span class="keyword1">o</span></span></span> Domain"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>BNF_Def.Gr_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MissingRelation-univalent_finite"><span class="command">lemma</span></span> univalent_finite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>Domain <span class="free">R</span><span class="main">)</span> <span class="main">=</span> card <span class="free">R</span>"</span></span>
        <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Domain <span class="free">R</span><span class="main">)</span> <span class="main">⟷</span> finite <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"BNF_Def.Gr <span class="main">(</span>Domain <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">SOME</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>Domain <span class="var">?R</span><span class="main">)</span> <span class="main">=</span> card <span class="var">?R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>Domain  <span class="free">R</span><span class="main">)</span> <span class="main">=</span> card  <span class="free">R</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> univalent_fn<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span><span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Domain <span class="free">R</span><span class="main">)</span> <span class="main">⟷</span> finite <span class="free">R</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Domain_empty_iff card_0_eq card.infinite finite.emptyI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MissingRelation-trancl_power_least"><span class="command">lemma</span></span> trancl_power_least<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∈</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">n</span><span class="main">.</span> <span class="free">p</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">^^</span> Suc <span class="bound">n</span> <span class="main">∧</span> <span class="main">(</span><span class="free">p</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">^^</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∈</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> trancl_power<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> p<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">n</span><span class="main">&gt;</span><span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">^^</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">n'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">=</span> <span class="skolem">n</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">n'</span> <span class="main">=</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> p <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">^^</span> Suc <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">n</span><span class="main">.</span> <span class="free">p</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">^^</span> Suc <span class="bound">n</span> <span class="main">∧</span> <span class="main">(</span><span class="free">p</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">^^</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">n'</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">^^</span> <span class="main">0</span> <span class="keyword1">O</span> <span class="free">R</span> <span class="main">∧</span> <span class="main">(</span><span class="free">p</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">^^</span> <span class="main">0</span> <span class="main">⟶</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">^^</span> Suc <span class="skolem">n</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> Suc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">n</span><span class="main">.</span> <span class="free">p</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">^^</span> Suc <span class="bound">n</span> <span class="main">∧</span> <span class="main">(</span><span class="free">p</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">^^</span> <span class="bound">n</span> <span class="main">⟶</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> zero_less_Suc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound"><span class="bound">n</span></span><span class="main">&gt;</span><span class="main">0</span><span class="main">.</span> <span class="free">p</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">^^</span> <span class="bound">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∈</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> trancl_power<span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MissingRelation-refl_on_tranclI"><span class="command">lemma</span></span> refl_on_tranclI <span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">A</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="free">A</span> <span class="main">(</span>trancl <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">×</span> <span class="free">A</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span> <span class="operator">rule</span> trancl_subset_Sigma
        <span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> refl_onD1<span class="main"><span class="main">]</span></span> assms<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> refl_onD2<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">THEN</span> refl_onD<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">idempotent</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">idempotent</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">O</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1" id="MissingRelation-trans_def"><span class="command">lemma</span></span> trans_def<span class="main">:</span> <span class="quoted"><span class="quoted">"trans <span class="free">r</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>Id <span class="main">∪</span> <span class="free">r</span><span class="main">)</span> <span class="keyword1">O</span> <span class="free">r</span> <span class="main">=</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"trans <span class="free">r</span> <span class="main">=</span> <span class="main">(</span><span class="free">r</span> <span class="keyword1">O</span> <span class="main">(</span>Id <span class="main">∪</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>trans_def<span class="main">)</span>

<span class="keyword1" id="MissingRelation-idempotent_impl_trans"><span class="command">lemma</span></span> idempotent_impl_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"idempotent <span class="free">r</span> <span class="main">⟹</span> trans <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>trans_def idempotent_def<span class="main">)</span>

<span class="keyword1" id="MissingRelation-refl_trans_impl_idempotent"><span class="command">lemma</span></span> refl_trans_impl_idempotent<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"refl_on <span class="free">A</span> <span class="free">r</span> <span class="main">⟹</span> trans <span class="free">r</span> <span class="main">⟹</span> idempotent <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>refl_on_def trans_def idempotent_def<span class="main">)</span>

<span class="keyword1" id="MissingRelation-idempotent_subset"><span class="command">lemma</span></span> idempotent_subset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"idempotent <span class="free">R</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">⊆</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="keyword1">O</span> <span class="free">R</span> <span class="main">⊆</span> <span class="free">R</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="keyword1">O</span> <span class="free">S</span> <span class="main">⊆</span> <span class="free">R</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="keyword1">O</span> <span class="free">R</span> <span class="keyword1">O</span> <span class="free">S</span> <span class="main">⊆</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>idempotent_def<span class="main">)</span>

<span class="comment1">(* not really about relations, but I need it in GraphRewriting.thy.
   Renaming the entire file to 'preliminaries' just because this is here would be too much. *)</span>
<span class="keyword1" id="MissingRelation-list_sorted_max"><span class="command">lemma</span></span> list_sorted_max<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted <span class="free">list</span> <span class="main">⟹</span> <span class="free">list</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> fold max <span class="free">xs</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span>last <span class="free">list</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">list</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">list</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span> <span class="main">⟹</span> fold max <span class="skolem">ys</span> <span class="skolem">y</span> <span class="main">=</span> last <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span><span class="skolem">x</span> <span class="main">#</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"sorted <span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="skolem">ys</span> 
    <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> fold max <span class="skolem">xs</span> <span class="skolem">x</span> <span class="main">=</span> last <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> fold_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> max.orderE sorted.elims<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> sorted2<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Cons <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="LabeledGraphs">
<div class="head">
<h1>Theory LabeledGraphs</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Labeled Graphs›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define graphs as in the paper. Graph homomorphisms and subgraphs are defined slightly
      differently.
      Their correspondence to the definitions in the paper is given by separate lemmas.
      After defining graphs, we only talk about the semantics until after defining homomorphisms.
      The reason is that graph rewriting can be done without knowing about semantics.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> LabeledGraphs
<span class="keyword2"><span class="keyword">imports</span></span> <a href="MissingRelation.html">MissingRelation</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> labeled_graph
  <span class="main">=</span> LG <span class="main">(</span><span class="free"><span class="entity">edges</span></span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span> <span class="main">×</span> <span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set"</span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">vertices</span></span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">restrict</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">restrict</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">=</span> LG <span class="main">{</span><span class="main">(</span><span class="bound"><span class="bound">l</span></span><span class="main">,</span><span class="bound"><span class="bound">v1</span></span><span class="main">,</span><span class="bound"><span class="bound">v2</span></span><span class="main">)</span> <span class="main">∈</span> edges <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">.</span> <span class="bound">v1</span> <span class="main">∈</span> vertices <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> <span class="bound">v2</span> <span class="main">∈</span> vertices <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">}</span> <span class="main">(</span>vertices <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 1. We define graphs and show that any graph with no edges (in particular
       the empty graph) is indeed a graph.›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">graph</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">graph</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> restrict <span class="free"><span class="bound"><span class="entity">X</span></span></span>"</span></span>

<span class="keyword1" id="LabeledGraphs-graph_empty_e"><span class="command">lemma</span></span> graph_empty_e<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>LG <span class="main">{}</span> <span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> restrict_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-graph_single"><span class="command">lemma</span></span> graph_single<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>LG <span class="main">{</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">,</span><span class="free">c</span><span class="main">)</span><span class="main">}</span> <span class="main">{</span><span class="free">b</span><span class="main">,</span><span class="free">c</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> restrict_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">finite_graph</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">finite_graph</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> graph <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∧</span> finite <span class="main">(</span>vertices <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span> <span class="main">∧</span> finite <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="LabeledGraphs-restrict_idemp"><span class="command">lemma</span></span> restrict_idemp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"restrict <span class="main">(</span>restrict <span class="free">x</span><span class="main">)</span> <span class="main">=</span> restrict <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>restrict_def<span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-vertices_restrict"><span class="command">lemma</span></span> vertices_restrict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"vertices <span class="main">(</span>restrict <span class="free">G</span><span class="main">)</span> <span class="main">=</span> vertices <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">G</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>restrict_def<span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-restrictI"><span class="command">lemma</span></span> restrictI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"edges <span class="free">G</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">v1</span><span class="main">,</span><span class="bound">v2</span><span class="main">)</span><span class="main">.</span> <span class="bound">v1</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">∧</span> <span class="bound">v2</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">=</span> restrict <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">G</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>restrict_def<span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-restrict_subsD"><span class="command">lemma</span></span> restrict_subsD<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"edges <span class="free">G</span> <span class="main">⊆</span> edges <span class="main">(</span>restrict <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">=</span> restrict <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">G</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>restrict_def<span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-restrictD"><span class="command">lemma</span></span> restrictD<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">=</span> restrict <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edges <span class="free">G</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">v1</span><span class="main">,</span><span class="bound">v2</span><span class="main">)</span><span class="main">.</span> <span class="bound">v1</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">∧</span> <span class="bound">v2</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>restrict <span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">v1</span><span class="main">,</span><span class="bound">v2</span><span class="main">)</span><span class="main">.</span> <span class="bound">v1</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">∧</span> <span class="bound">v2</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">G</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>restrict_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(* Given a relation on vertices, make one on edges *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">on_triple</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">on_triple</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="bound">l'</span><span class="main">,</span><span class="bound">s'</span><span class="main">,</span><span class="bound">t'</span><span class="main">)</span><span class="main">)</span> <span class="main">.</span> <span class="bound">l</span><span class="main">=</span><span class="bound">l'</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span><span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1" id="LabeledGraphs-on_triple"><span class="command">lemma</span></span> on_triple<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">l1</span><span class="main">,</span><span class="free">v1</span><span class="main">,</span><span class="free">v2</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">l2</span><span class="main">,</span><span class="free">v3</span><span class="main">,</span><span class="free">v4</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> on_triple <span class="free">R</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">v1</span><span class="main">,</span><span class="free">v3</span><span class="main">)</span><span class="main">∈</span> <span class="free">R</span> <span class="main">∧</span> <span class="main">(</span><span class="free">v2</span><span class="main">,</span><span class="free">v4</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">∧</span> <span class="free">l1</span> <span class="main">=</span> <span class="free">l2</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> on_triple_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-on_triple_univ"><span class="command">lemma</span></span> on_triple_univ<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"univalent <span class="free">f</span> <span class="main">⟹</span> univalent <span class="main">(</span>on_triple <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> on_triple_def univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-on_tripleD"><span class="command">lemma</span></span> on_tripleD<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">l1</span><span class="main">,</span><span class="free">v1</span><span class="main">,</span><span class="free">v2</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">l2</span><span class="main">,</span><span class="free">v3</span><span class="main">,</span><span class="free">v4</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> on_triple <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">l2</span> <span class="main">=</span> <span class="free">l1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v1</span><span class="main">,</span><span class="free">v3</span><span class="main">)</span><span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v2</span><span class="main">,</span><span class="free">v4</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
 <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> on_triple_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-on_triple_ID_restrict"><span class="command">lemma</span></span> on_triple_ID_restrict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"on_triple <span class="main">(</span>Id_on <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span><span class="main">)</span> <span class="main">``</span> edges <span class="free">G</span> <span class="main">=</span> edges <span class="main">(</span>restrict <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> on_triple_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">G</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>restrict_def<span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-relcomp_on_triple"><span class="command">lemma</span></span> relcomp_on_triple<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"on_triple <span class="main">(</span><span class="free">R</span> <span class="keyword1">O</span> <span class="free">S</span><span class="main">)</span> <span class="main">=</span> on_triple <span class="free">R</span> <span class="keyword1">O</span> on_triple <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> on_triple_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>

<span class="keyword1" id="LabeledGraphs-on_triple_preserves_finite"><span class="command">lemma</span></span> on_triple_preserves_finite<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"finite <span class="free">E</span>  <span class="main">⟹</span> finite <span class="main">(</span>on_triple <span class="main">(</span>BNF_Def.Gr <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">``</span> <span class="free">E</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>on_triple_def BNF_Def.Gr_def<span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-on_triple_fst"><span class="command">lemma</span></span> on_triple_fst<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">G</span> <span class="main">=</span> Domain <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> fst <span class="main">`</span> on_triple <span class="free">g</span> <span class="main">``</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> fst <span class="main">`</span> edges <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> fst <span class="main">`</span> on_triple <span class="free">g</span> <span class="main">``</span> edges <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> on_triple <span class="free">g</span> <span class="main">``</span> edges <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">c</span><span class="main">,</span><span class="skolem">d</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> on_triple_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> fst <span class="main">`</span> edges <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> fst <span class="main">`</span> edges <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> ab<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">c</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">b</span><span class="main">,</span><span class="skolem">d</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">c</span><span class="main">,</span><span class="skolem">d</span><span class="main">)</span> <span class="main">∈</span> on_triple <span class="free">g</span> <span class="main">``</span> edges <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ab <span class="keyword1"><span class="command">unfolding</span></span> on_triple_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> fst <span class="main">`</span> on_triple <span class="free">g</span> <span class="main">``</span> edges <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv image_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">edge_preserving</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">edge_preserving</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">e1</span></span></span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span> <span class="main">≡</span> 
     <span class="main">(</span><span class="main">∀</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v1</span><span class="main">,</span><span class="bound">v2</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">e1</span></span></span><span class="main">.</span> <span class="main">∀</span> <span class="bound">v1'</span> <span class="bound">v2'</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v1</span><span class="main">,</span> <span class="bound">v1'</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v2</span><span class="main">,</span><span class="bound">v2'</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">)</span>
                                    <span class="main">⟶</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v1'</span><span class="main">,</span><span class="bound">v2'</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="LabeledGraphs-edge_preserving_atomic"><span class="command">lemma</span></span> edge_preserving_atomic<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">h1</span> <span class="free">e1</span> <span class="free">e2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v1</span><span class="main">,</span> <span class="free">v1'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">h1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v2</span><span class="main">,</span> <span class="free">v2'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">h1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">v1</span><span class="main">,</span> <span class="free">v2</span><span class="main">)</span> <span class="main">∈</span> <span class="free">e1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">v1'</span><span class="main">,</span> <span class="free">v2'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">e2</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-edge_preservingI"><span class="command">lemma</span></span> edge_preservingI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"on_triple <span class="free">R</span> <span class="main">``</span> <span class="free">E</span> <span class="main">⊆</span> <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">R</span> <span class="free">E</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving_def <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">clarify</span><span class="main"><span class="keyword3">,</span></span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">a</span> <span class="skolem">s</span> <span class="skolem">t</span> <span class="skolem">v1'</span> <span class="skolem">v2'</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> assms<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>on_triple_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LabeledGraphs-on_triple_dest"><span class="command">lemma</span></span> on_triple_dest<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"on_triple <span class="free">R</span> <span class="main">``</span> <span class="free">E</span> <span class="main">⊆</span> <span class="free">G</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">E</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">xx</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">yy</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
        <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">xx</span><span class="main">,</span><span class="free">yy</span><span class="main">)</span> <span class="main">∈</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Image_def on_triple_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="LabeledGraphs-edge_preserving"><span class="command">lemma</span></span> edge_preserving<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">R</span> <span class="free">E</span> <span class="free">G</span> <span class="main">⟷</span> on_triple <span class="free">R</span> <span class="main">``</span> <span class="free">E</span> <span class="main">⊆</span> <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">R</span> <span class="free">E</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">k</span> <span class="bound">v1</span> <span class="bound">v2</span> <span class="bound">v1'</span> <span class="bound">v2'</span><span class="main">.</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v1</span><span class="main">,</span> <span class="bound">v2</span><span class="main">)</span><span class="main">∈</span><span class="free">E</span> <span class="main">⟹</span>
            <span class="main">(</span><span class="bound">v1</span><span class="main">,</span> <span class="bound">v1'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">v2</span><span class="main">,</span> <span class="bound">v2'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v1'</span><span class="main">,</span> <span class="bound">v2'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"on_triple <span class="free">R</span> <span class="main">``</span> <span class="free">E</span> <span class="main">⊆</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Image_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-edge_preserving_subset"><span class="command">lemma</span></span> edge_preserving_subset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">R<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> <span class="free">R<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">E<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> <span class="free">E<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">R<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">E<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">R<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">E<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="LabeledGraphs-edge_preserving_unionI"><span class="command">lemma</span></span> edge_preserving_unionI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">f</span> <span class="free">A</span> <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">f</span> <span class="free">B</span> <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">f</span> <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="LabeledGraphs-compose_preserves_edge_preserving"><span class="command">lemma</span></span> compose_preserves_edge_preserving<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">h1</span> <span class="free">e1</span> <span class="free">e2</span>"</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">h2</span> <span class="free">e2</span> <span class="free">e3</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="main">(</span><span class="free">h1</span> <span class="keyword1">O</span> <span class="free">h2</span><span class="main">)</span> <span class="free">e1</span> <span class="free">e3</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 _ <span class="skolem">k</span> _ <span class="skolem">v1</span> <span class="skolem">v2</span> <span class="skolem">v1''</span> <span class="skolem">v2''</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> 1<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">k</span><span class="main">,</span> <span class="skolem">v1</span><span class="main">,</span> <span class="skolem">v2</span><span class="main">)</span> <span class="main">∈</span> <span class="free">e1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">v1''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">h1</span> <span class="keyword1">O</span> <span class="free">h2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v2</span><span class="main">,</span> <span class="skolem">v2''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">h1</span> <span class="keyword1">O</span> <span class="free">h2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v1'</span></span> <span class="skolem"><span class="skolem">v2'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    v<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v1</span><span class="main">,</span><span class="skolem">v1'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">h1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v1'</span><span class="main">,</span><span class="skolem">v1''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">h2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v2</span><span class="main">,</span><span class="skolem">v2'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">h1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v2'</span><span class="main">,</span><span class="skolem">v2''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">h2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> edge_preserving_atomic<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> v<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> 1<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
       edge_preserving_atomic<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> v<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>4<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LabeledGraphs-edge_preserving_Id"><span class="command">lemma</span></span> edge_preserving_Id<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"edge_preserving <span class="main">(</span>Id_on <span class="free">y</span><span class="main">)</span> <span class="free">x</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> edge_preserving_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This is an alternate version of definition 10. We require @term{vertices s = Domain h}
   to ensure that graph homomorphisms are sufficiently unique:
   The partiality follows the definition in the paper, per the remark before Def. 7.
   but it means that we cannot use Isabelle's total functions for the homomorphisms.
   We show that graph homomorphisms and embeddings coincide in a separate lemma.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">graph_homomorphism</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">graph_homomorphism</span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> 
    <span class="main">=</span> <span class="main">(</span> vertices <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> Domain <span class="free"><span class="bound"><span class="entity">f</span></span></span>
      <span class="main">∧</span> graph <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∧</span> graph <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span>
      <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">``</span> vertices <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">⊆</span> vertices <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span>
      <span class="main">∧</span> univalent <span class="free"><span class="bound"><span class="entity">f</span></span></span>
      <span class="main">∧</span> edge_preserving <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span><span class="main">)</span> <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span>
      <span class="main">)</span>"</span></span>

<span class="keyword1" id="LabeledGraphs-graph_homomorphismI"><span class="command">lemma</span></span> graph_homomorphismI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">s</span> <span class="main">=</span> Domain <span class="free">h</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">``</span> vertices <span class="free">s</span> <span class="main">⊆</span> vertices <span class="free">t</span>"</span></span>
          <span class="quoted"><span class="quoted">"univalent <span class="free">h</span>"</span></span>
          <span class="quoted"><span class="quoted">"edge_preserving <span class="free">h</span> <span class="main">(</span>edges <span class="free">s</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">t</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">=</span> restrict <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">=</span> restrict <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">s</span> <span class="free">t</span> <span class="free">h</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-graph_homomorphism_composes"><span class="command">lemma</span></span> graph_homomorphism_composes<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">a</span> <span class="free">b</span> <span class="free">x</span>"</span></span>
          <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">b</span> <span class="free">c</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">a</span> <span class="free">c</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">O</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> graph_homomorphismI<span class="main"><span class="keyword3">,</span></span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">a</span> <span class="main">⊆</span> Domain <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">``</span> vertices <span class="free">a</span> <span class="main">⊆</span> Domain <span class="free">y</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">from</span></span> this Domain_O<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> assms<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>graph_homomorphism_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>compose_preserves_edge_preserving<span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-graph_homomorphism_empty"><span class="command">lemma</span></span> graph_homomorphism_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{}</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span> <span class="main">⟷</span> <span class="free">f</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∧</span> graph <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-graph_homomorphism_Id"><span class="command">lemma</span></span> graph_homomorphism_Id<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>restrict <span class="free">a</span><span class="main">)</span> <span class="main">(</span>restrict <span class="free">a</span><span class="main">)</span> <span class="main">(</span>Id_on <span class="main">(</span>vertices <span class="free">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> graph_homomorphismI<span class="main"><span class="keyword3">;</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>edge_preserving_def<span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-Id_on_vertices_identity"><span class="command">lemma</span></span> Id_on_vertices_identity<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">a</span> <span class="free">b</span> <span class="free">f</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">aa</span><span class="main">,</span> <span class="free">ba</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">aa</span><span class="main">,</span> <span class="free">ba</span><span class="main">)</span> <span class="main">∈</span> Id_on <span class="main">(</span>vertices <span class="free">a</span><span class="main">)</span> <span class="keyword1">O</span> <span class="free">f</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">aa</span><span class="main">,</span> <span class="free">ba</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f</span> <span class="keyword1">O</span> Id_on <span class="main">(</span>vertices <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Alternate version of definition 7.›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">subgraph</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">subgraph</span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span> 
  <span class="main">≡</span> graph_homomorphism <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">(</span>Id_on <span class="main">(</span>vertices <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="LabeledGraphs-subgraph_trans"><span class="command">lemma</span></span> subgraph_trans<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>3</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>3</sub></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Id_on <span class="main">(</span>vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="keyword1">O</span> Id_on <span class="main">(</span>vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">=</span> Id_on <span class="main">(</span>vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> graph_homomorphism_composes<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Just before Definition 7 in the paper, a notation is introduced for applying a function to
       a graph. We use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">map_graph</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for this, and the version <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">map_graph_fn</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in
       case that its first argument is a total function rather than a partial one. ›</span></span>
<span class="comment1">(* Introducing the map notation just above Def 7 in the paper *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_graph</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> labeled_graph"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_graph</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">=</span> LG <span class="main">(</span>on_triple <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">``</span> <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">``</span> <span class="main">(</span>vertices <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="LabeledGraphs-map_graph_selectors"><span class="command">lemma</span></span> map_graph_selectors<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"vertices <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">``</span> <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"edges <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span> <span class="main">=</span> on_triple <span class="free">f</span> <span class="main">``</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-map_graph_comp"><span class="command">lemma</span></span> map_graph_comp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Range <span class="free">g</span> <span class="main">⊆</span> Domain <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_graph <span class="main">(</span><span class="free">g</span> <span class="keyword1">O</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> map_graph <span class="free">f</span> <span class="keyword1">o</span> map_graph <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span><span class="operator">goal_cases</span><span class="main">)</span> <span class="comment1">(* need goal_cases to get the type of x right *)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_graph <span class="main">(</span><span class="free">g</span> <span class="keyword1">O</span> <span class="free">f</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span>map_graph <span class="free">f</span> <span class="keyword1">o</span> map_graph <span class="free">g</span><span class="main">)</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> map_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LabeledGraphs-map_graph_returns_restricted"><span class="command">lemma</span></span> map_graph_returns_restricted<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">G</span> <span class="main">=</span> Domain <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_graph <span class="free">f</span> <span class="free">G</span> <span class="main">=</span> restrict <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">G</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>map_graph_def restrict_def<span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-map_graph_preserves_restricted"><span class="command">lemma</span></span> map_graph_preserves_restricted<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> restrictI<span class="main"><span class="keyword3">,</span></span><span class="operator">standard</span><span class="main">)</span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> edges <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="bound">v1</span><span class="main">,</span> <span class="bound">v2</span><span class="main">)</span><span class="main">.</span> <span class="bound">v1</span><span class="main">∈</span>vertices <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">v2</span><span class="main">∈</span>vertices <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>map_graph_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LabeledGraphs-map_graph_edge_preserving"><span class="command">lemma</span></span> map_graph_edge_preserving<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">f</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span> <span class="main">(</span>edges <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-map_graph_homo"><span class="command">lemma</span></span> map_graph_homo<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">G</span> <span class="main">=</span> Domain <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">=</span> restrict <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">G</span> <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> graph_homomorphismI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> vertices <span class="free">G</span> <span class="main">⊆</span> vertices <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> map_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">f</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span> <span class="main">(</span>edges <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"map_graph <span class="free">f</span> <span class="free">G</span> <span class="main">=</span> restrict <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="LabeledGraphs-map_graph_homo_simp"><span class="command">lemma</span></span> map_graph_homo_simp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">G</span> <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span> <span class="free">f</span>
   <span class="main">⟷</span> univalent <span class="free">f</span> <span class="main">∧</span> vertices <span class="free">G</span> <span class="main">=</span> Domain <span class="free">f</span> <span class="main">∧</span> graph <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">G</span> <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span> <span class="free">f</span> <span class="main">⟹</span>
    univalent <span class="free">f</span> <span class="main">∧</span> vertices <span class="free">G</span> <span class="main">=</span> Domain <span class="free">f</span> <span class="main">∧</span> <span class="free">G</span> <span class="main">=</span> restrict <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">on_graph</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">on_graph</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> BNF_Def.Gr <span class="main">(</span>vertices <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">map_graph_fn</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">map_graph_fn</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> map_graph <span class="main">(</span>on_graph <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span>"</span></span>

<span class="keyword1" id="LabeledGraphs-map_graph_fn_graphI"><span class="command">lemma</span></span> map_graph_fn_graphI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"graph <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> map_graph_def restrict_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-on_graph_id"><span class="command">lemma</span></span> on_graph_id<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"on_graph <span class="free">B</span> id <span class="main">=</span> Id_on <span class="main">(</span>vertices <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> BNF_Def.Gr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-in_on_graph"><span class="command">lemma</span></span> in_on_graph<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> on_graph <span class="free">G</span> <span class="free">a</span> <span class="keyword1">O</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> BNF_Def.Gr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-on_graph_comp"><span class="command">lemma</span></span> on_graph_comp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"on_graph <span class="free">G</span> <span class="main">(</span><span class="free">f</span> <span class="keyword1">o</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> on_graph <span class="free">G</span> <span class="free">g</span> <span class="keyword1">O</span> on_graph <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">g</span><span class="main">)</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> BNF_Def.Gr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-map_graph_fn_eqI"><span class="command">lemma</span></span> map_graph_fn_eqI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_graph_fn <span class="free">G</span> <span class="free">f</span> <span class="main">=</span> map_graph_fn <span class="free">G</span> <span class="free">g</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">ac</span> <span class="skolem">ba</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">ac</span><span class="main">,</span> <span class="skolem">ba</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ac</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ba</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>edges <span class="free">G</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="skolem">a</span><span class="main">,</span> <span class="free">g</span> <span class="skolem">ac</span><span class="main">,</span> <span class="free">g</span> <span class="skolem">ba</span><span class="main">)</span> <span class="main">∈</span> on_triple <span class="main">(</span>on_graph <span class="free">G</span> <span class="free">f</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>edges <span class="free">G</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="skolem">a</span><span class="main">,</span> <span class="free">g</span> <span class="skolem">ac</span><span class="main">,</span> <span class="free">g</span> <span class="skolem">ba</span><span class="main">)</span> <span class="main">∈</span> on_triple <span class="main">(</span>on_graph <span class="free">G</span> <span class="free">g</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_Gr on_triple<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"edges <span class="var">?l</span> <span class="main">=</span> edges <span class="var">?r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Image_def<span class="main">)</span> 
  <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="var">?l</span> <span class="main">=</span> vertices <span class="var">?r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>image_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> e v <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="var"><span class="quoted"><span class="var">?l</span></span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">cases</span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LabeledGraphs-map_graph_fn_comp"><span class="command">lemma</span></span> map_graph_fn_comp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"map_graph_fn <span class="free">G</span> <span class="main">(</span><span class="free">f</span> <span class="keyword1">o</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> map_graph_fn <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">g</span><span class="main">)</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> on_graph_comp <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-map_graph_fn_id"><span class="command">lemma</span></span> map_graph_fn_id<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"map_graph_fn <span class="free">X</span> id <span class="main">=</span> restrict <span class="free">X</span>"</span></span>
<span class="quoted"><span class="quoted">"map_graph <span class="main">(</span>Id_on <span class="main">(</span>vertices <span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="free">X</span> <span class="main">=</span> restrict <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> BNF_Def.Gr_def map_graph_def on_triple_def restrict_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">X</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="LabeledGraphs-graph_homo"><span class="command">lemma</span></span> graph_homo<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">G</span> <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span>on_graph <span class="free">G</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> map_graph_homo_simp BNF_Def.Gr_def univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-graph_homo_inv"><span class="command">lemma</span></span> graph_homo_inv<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span> <span class="free">G</span> <span class="main">(</span>converse <span class="main">(</span>on_graph <span class="free">G</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> graph_homomorphismI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"univalent <span class="main">(</span><span class="main">(</span>on_graph <span class="free">G</span> <span class="free">f</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> univalent_def BNF_Def.Gr_def inj_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="main">(</span><span class="main">(</span>on_graph <span class="free">G</span> <span class="free">f</span><span class="main">)</span><span class="main">¯</span><span class="main">)</span> <span class="main">(</span>edges <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving inj_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-edge_preserving_on_graphI"><span class="command">lemma</span></span> edge_preserving_on_graphI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">l</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">X</span> <span class="main">⟹</span> <span class="bound">x</span><span class="main">∈</span>vertices <span class="free">X</span> <span class="main">⟹</span> <span class="bound">y</span> <span class="main">∈</span> vertices <span class="free">X</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="free">f</span> <span class="bound">x</span><span class="main">,</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="main">(</span>on_graph <span class="free">X</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">X</span><span class="main">)</span> <span class="free">Y</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving_def BNF_Def.Gr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-subgraph_subset"><span class="command">lemma</span></span> subgraph_subset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> vrt<span class="main">:</span><span class="quoted"><span class="quoted">"Id_on <span class="main">(</span>vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">``</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ep<span class="main">:</span><span class="quoted"><span class="quoted">"edge_preserving <span class="main">(</span>Id_on <span class="main">(</span>vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> vrt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Our definition of subgraph is equivalent to definition 7.›</span></span>
<span class="keyword1" id="LabeledGraphs-subgraph_def2"><span class="command">lemma</span></span> subgraph_def2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⟷</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> ep<span class="main">:</span><span class="quoted"><span class="quoted">"edge_preserving <span class="main">(</span>Id_on <span class="main">(</span>vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> v ep graph_homomorphism_Id<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>1</sub></span>"</span></span><span class="main">,</span><span class="operator">folded</span> assms<span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> sg<span class="main">:</span><span class="quoted"><span class="quoted">"subgraph <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> vrt<span class="main">:</span><span class="quoted"><span class="quoted">"Id_on <span class="main">(</span>vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">``</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ep<span class="main">:</span><span class="quoted"><span class="quoted">"edge_preserving <span class="main">(</span>Id_on <span class="main">(</span>vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> vrt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We also define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">graph_union</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. In contrast to the paper, our definition ignores the labels.
      The corresponding definition in the paper is written just above Definition 7.
      Adding labels to graphs would require a lot of unnecessary additional bookkeeping.
      Nowhere in the paper is the union actually used on different sets of labels,
      in which case these definitions coincide.›</span></span>

<span class="comment1">(* Since the set of labels is an implicit type, the notion of graph_union does not completely correspond to the one in the paper *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">graph_union</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">graph_union</span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> LG <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∪</span> edges <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">(</span>vertices <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∪</span> vertices <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="LabeledGraphs-graph_unionI"><span class="command">lemma</span></span> graph_unionI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
          <span class="quoted"><span class="quoted">"vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_union <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> graph_union_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-graph_union_iff"><span class="command">lemma</span></span> graph_union_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_union <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⟷</span> <span class="main">(</span>edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> graph_union_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-graph_union_idemp"><span class="command">lemma</span></span> graph_union_idemp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"graph_union <span class="free">A</span> <span class="free">A</span> <span class="main">=</span> <span class="free">A</span>"</span></span>
<span class="quoted"><span class="quoted">"graph_union <span class="free">A</span> <span class="main">(</span>graph_union <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>graph_union <span class="free">A</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="quoted"><span class="quoted">"graph_union <span class="free">A</span> <span class="main">(</span>graph_union <span class="free">B</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>graph_union <span class="free">B</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> graph_union_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-graph_union_vertices"><span class="command">lemma</span></span> graph_union_vertices<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"vertices <span class="main">(</span>graph_union <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">=</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∪</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> graph_union_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="LabeledGraphs-graph_union_edges"><span class="command">lemma</span></span> graph_union_edges<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"edges <span class="main">(</span>graph_union <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">=</span> edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∪</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> graph_union_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-graph_union_preserves_restrict"><span class="command">lemma</span></span> graph_union_preserves_restrict<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_union <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> restrict <span class="main">(</span>graph_union <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?e</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∪</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?v</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∪</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="bound">v1</span><span class="main">,</span> <span class="bound">v2</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="bound">v1</span><span class="main">,</span> <span class="bound">v2</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?e</span> <span class="main">∧</span> <span class="bound">v1</span> <span class="main">∈</span> <span class="var">?v</span> <span class="main">∧</span> <span class="bound">v2</span> <span class="main">∈</span> <span class="var">?v</span><span class="main">}</span>"</span></span> <span class="comment1">(* restricted edges *)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="skolem">v1</span> <span class="skolem">v2</span>
    <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">v1</span><span class="main">,</span><span class="skolem">v2</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?e</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">v1</span><span class="main">,</span><span class="skolem">v2</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?r</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">v1</span><span class="main">,</span><span class="skolem">v2</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span>restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">v1</span><span class="main">,</span><span class="skolem">v2</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v1</span> <span class="main">∈</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v2</span> <span class="main">∈</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
         <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>restrict_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">v1</span><span class="main">,</span><span class="skolem">v2</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span>restrict <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">v1</span><span class="main">,</span><span class="skolem">v2</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v1</span> <span class="main">∈</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v2</span> <span class="main">∈</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
         <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>restrict_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?e</span> <span class="main">=</span> <span class="var">?r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> graph_union_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LabeledGraphs-graph_map_union"><span class="command">lemma</span></span> graph_map_union<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span><span class="main">::</span>nat<span class="main">.</span> graph_union <span class="main">(</span>map_graph <span class="main">(</span><span class="free">g</span> <span class="bound">i</span><span class="main">)</span> <span class="free">X</span><span class="main">)</span> <span class="free">Y</span> <span class="main">=</span> <span class="free">Y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> <span class="bound">i</span> <span class="main">≤</span> <span class="bound">j</span> <span class="main">⟹</span> <span class="free">g</span> <span class="bound">i</span> <span class="main">⊆</span> <span class="free">g</span> <span class="bound">j</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_union <span class="main">(</span>map_graph <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> <span class="free">g</span> <span class="bound">i</span><span class="main">)</span> <span class="free">X</span><span class="main">)</span> <span class="free">Y</span> <span class="main">=</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"edges <span class="main">(</span>map_graph <span class="main">(</span><span class="free">g</span> <span class="skolem">i</span><span class="main">)</span> <span class="free">X</span><span class="main">)</span> <span class="main">⊆</span> edges <span class="free">Y</span>"</span></span>
              <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="main">(</span>map_graph <span class="main">(</span><span class="free">g</span> <span class="skolem">i</span><span class="main">)</span> <span class="free">X</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="free">Y</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>graph_union_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">ac</span> <span class="skolem">ba</span> <span class="skolem">aa</span> <span class="skolem">b</span> <span class="skolem">x</span> <span class="skolem">xa</span>
    <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">ac</span><span class="main">,</span> <span class="skolem">ba</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">X</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">ac</span><span class="main">,</span> <span class="skolem">aa</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">ba</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="skolem">xa</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">aa</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">Y</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">xa</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">ac</span><span class="main">,</span> <span class="skolem">ba</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">X</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">ac</span><span class="main">,</span> <span class="skolem">aa</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="skolem">xa</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">ba</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="skolem">xa</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> a assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">xa</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> e<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">xa</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">ac</span><span class="main">,</span> <span class="skolem">ba</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">X</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">ac</span><span class="main">,</span> <span class="skolem">aa</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">ba</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="skolem">x</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> a assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">xa</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> e<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>map_graph <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> <span class="free">g</span> <span class="bound">i</span><span class="main">)</span> <span class="free">X</span><span class="main">)</span> <span class="main">⊆</span> edges <span class="free">Y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"vertices <span class="main">(</span>map_graph <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> <span class="free">g</span> <span class="bound">i</span><span class="main">)</span> <span class="free">X</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="free">Y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We show that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">subgraph</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> indeed matches the definition in the paper (Definition 7).›</span></span>

<span class="keyword1" id="LabeledGraphs-subgraph_def"><span class="command">lemma</span></span> subgraph_def<span class="main">:</span>
<span class="quoted"><span class="quoted">"subgraph <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="main">(</span><span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> graph_union <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> assms<span class="main">:</span><span class="quoted"><span class="quoted">"subgraph <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> r<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> subgraph_subset<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> ss<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="main">(</span>restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> graph_union <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">G<span class="hidden">⇩</span><sub>2</sub></span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LG <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ss r
    <span class="keyword1"><span class="command">unfolding</span></span> graph_union_def LG <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> gu<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> graph_union <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> sub<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span>edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∪</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="quoted"><span class="quoted">"vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_union_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">G<span class="hidden">⇩</span><sub>2</sub></span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">have</span></span> r<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gu <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def2<span class="main">[</span><span class="operator">OF</span> r<span class="main">]</span> <span class="keyword1"><span class="command">using</span></span> sub <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LabeledGraphs-subgraph_refl"><span class="command">lemma</span></span> subgraph_refl<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
<span class="quoted"><span class="quoted">"subgraph <span class="free">G</span> <span class="free">G</span> <span class="main">=</span> <span class="main">(</span><span class="free">G</span> <span class="main">=</span> restrict <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def graph_union_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">G</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-subgraph_restrict"><span class="command">lemma</span></span> subgraph_restrict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"subgraph <span class="free">G</span> <span class="main">(</span>restrict <span class="free">G</span><span class="main">)</span> <span class="main">=</span> graph <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> subgraph_refl subgraph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 10. We write <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">graph_homomorphism</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead of embedding.›</span></span>
<span class="keyword1" id="LabeledGraphs-graph_homomorphism_def2"><span class="command">lemma</span></span> graph_homomorphism_def2<span class="main">:</span> <span class="comment1">(* Shows a graph homomorphism is an embedding as in the paper *)</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">f</span> <span class="main">=</span>
   <span class="main">(</span>vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> Domain <span class="free">f</span> <span class="main">∧</span> univalent <span class="free">f</span> <span class="main">∧</span> <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> graph_union <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?m</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_graph <span class="free">f</span> <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">hence</span></span> assms <span class="main">:</span> <span class="quoted"><span class="quoted">"vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> Domain <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> sg<span class="main">:</span> <span class="quoted"><span class="quoted">"subgraph <span class="var">?m</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> f_id<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="keyword1">O</span> Id_on <span class="main">(</span><span class="free">f</span> <span class="main">``</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="main">(</span>Id_on <span class="main">(</span>vertices <span class="var">?m</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="var">?m</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"on_triple <span class="main">(</span><span class="free">f</span> <span class="keyword1">O</span> Id_on <span class="main">(</span><span class="free">f</span> <span class="main">``</span> vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">``</span> edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>  <span class="comment1">(* rewriting peak *)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> relcomp_Image edge_preserving map_graph_selectors relcomp_on_triple<span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">f</span> <span class="main">(</span>edges <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving f_id<span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> sg assms <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> ih<span class="main">:</span><span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> Domain <span class="free">f</span> <span class="main">∧</span> univalent <span class="free">f</span> <span class="main">∧</span> <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> restrict <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span> subgraph <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def edge_preserving
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="LabeledGraphs-map_graph_preserves_subgraph"><span class="command">lemma</span></span> map_graph_preserves_subgraph<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">A</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">B</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>graph_union_iff<span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-graph_homomorphism_concr_graph"><span class="command">lemma</span></span> graph_homomorphism_concr_graph<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>LG <span class="free">e</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="free">e</span> <span class="free">v</span><span class="main">)</span> <span class="free">G</span> <span class="free">x</span> <span class="main">⟷</span>
         <span class="free">x</span> <span class="main">``</span> <span class="free">v</span> <span class="main">⊆</span> vertices <span class="free">G</span> <span class="main">∧</span> on_triple <span class="free">x</span> <span class="main">``</span> <span class="free">e</span> <span class="main">⊆</span> edges <span class="free">G</span> <span class="main">∧</span> univalent <span class="free">x</span> <span class="main">∧</span> Domain <span class="free">x</span> <span class="main">=</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def2 graph_union_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphs-subgraph_preserves_hom"><span class="command">lemma</span></span> subgraph_preserves_hom<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">A</span> <span class="free">B</span>"</span></span>
          <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">X</span> <span class="free">A</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">X</span> <span class="free">B</span> <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> graph_homomorphism_def2 map_graph_preserves_restricted subgraph_def subgraph_trans<span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-graph_homo_union_id"><span class="command">lemma</span></span> graph_homo_union_id<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>graph_union <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">A</span> <span class="main">⟹</span> graph_homomorphism <span class="free">A</span> <span class="free">G</span> <span class="main">(</span>Id_on <span class="main">(</span>vertices <span class="free">A</span><span class="main">)</span> <span class="keyword1">O</span> <span class="free">f</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"graph <span class="free">B</span> <span class="main">⟹</span> graph_homomorphism <span class="free">B</span> <span class="free">G</span> <span class="main">(</span>Id_on <span class="main">(</span>vertices <span class="free">B</span><span class="main">)</span> <span class="keyword1">O</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def edge_preserving
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span>edge_preserving_atomic<span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-graph_homo_union"><span class="command">lemma</span></span> graph_homo_union<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
   <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">A</span> <span class="free">G</span> <span class="free">f_a</span>"</span></span>
   <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">B</span> <span class="free">G</span> <span class="free">f_b</span>"</span></span>
   <span class="quoted"><span class="quoted">"Domain <span class="free">f_a</span> <span class="main">∩</span> Domain <span class="free">f_b</span> <span class="main">=</span> Domain <span class="main">(</span><span class="free">f_a</span> <span class="main">∩</span> <span class="free">f_b</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>graph_union <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="free">G</span> <span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> graph_homomorphismI<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> v0<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f_a</span> <span class="main">``</span> vertices <span class="free">A</span> <span class="main">⊆</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f_b</span> <span class="main">``</span> vertices <span class="free">B</span> <span class="main">⊆</span> vertices <span class="free">G</span>"</span></span>
          <span class="quoted"><span class="quoted">"vertices <span class="free">A</span> <span class="main">=</span> Domain <span class="free">f_a</span>"</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">B</span> <span class="main">=</span> Domain <span class="free">f_b</span>"</span></span>
          <span class="quoted"><span class="quoted">"graph <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">B</span>"</span></span>
          <span class="quoted"><span class="quoted">"univalent <span class="free">f_a</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">f_b</span>"</span></span>
          <span class="quoted"><span class="quoted">"edge_preserving <span class="free">f_a</span> <span class="main">(</span>edges <span class="free">A</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"edge_preserving <span class="free">f_b</span> <span class="main">(</span>edges <span class="free">B</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">hence</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f_a</span> <span class="main">``</span> vertices <span class="main">(</span>graph_union <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="free">G</span>"</span></span>
           <span class="quoted"><span class="quoted">"<span class="free">f_b</span> <span class="main">``</span> vertices <span class="main">(</span>graph_union <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> uni<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> v0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span> <span class="main">``</span> vertices <span class="main">(</span>graph_union <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> f_a<span class="main">:</span><span class="quoted"><span class="quoted">"Id_on <span class="main">(</span>vertices <span class="free">A</span><span class="main">)</span> <span class="keyword1">O</span> <span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span> <span class="main">=</span> <span class="free">f_a</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> uni v0<span class="main">(</span>3<span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">A</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>univalent_def on_triple_def Image_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> onA<span class="main">:</span><span class="quoted"><span class="quoted">"on_triple <span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span> <span class="main">``</span> edges <span class="free">A</span> <span class="main">=</span> on_triple <span class="main">(</span>Id_on <span class="main">(</span>vertices <span class="free">A</span><span class="main">)</span> <span class="keyword1">O</span> <span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span><span class="main">)</span> <span class="main">``</span> edges <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> relcomp_on_triple relcomp_Image on_triple_ID_restrict v0<span class="main">(</span>5<span class="main">)</span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">have</span></span> f_b<span class="main">:</span><span class="quoted"><span class="quoted">"Id_on <span class="main">(</span>vertices <span class="free">B</span><span class="main">)</span> <span class="keyword1">O</span> <span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span> <span class="main">=</span> <span class="free">f_b</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> uni v0<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> Un_commute<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">f_a</span></span> <span class="main">_</span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">B</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>univalent_def on_triple_def Image_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> onB<span class="main">:</span><span class="quoted"><span class="quoted">"on_triple <span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span> <span class="main">``</span> edges <span class="free">B</span> <span class="main">=</span> on_triple <span class="main">(</span>Id_on <span class="main">(</span>vertices <span class="free">B</span><span class="main">)</span> <span class="keyword1">O</span> <span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span><span class="main">)</span> <span class="main">``</span> edges <span class="free">B</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> relcomp_on_triple relcomp_Image on_triple_ID_restrict v0<span class="main">(</span>6<span class="main">)</span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">A</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
       <span class="quoted"><span class="quoted">"edge_preserving <span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">B</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> v0<span class="main">(</span>9<span class="main">,</span>10<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving onA<span class="main">[</span><span class="operator">unfolded</span> f_a<span class="main">]</span> onB<span class="main">[</span><span class="operator">unfolded</span> f_b<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="main">(</span><span class="free">f_a</span> <span class="main">∪</span> <span class="free">f_b</span><span class="main">)</span> <span class="main">(</span>edges <span class="main">(</span>graph_union <span class="free">A</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> assms<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="LabeledGraphs-graph_homomorphism_on_graph"><span class="command">lemma</span></span> graph_homomorphism_on_graph<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">A</span> <span class="free">B</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">A</span> <span class="main">(</span>map_graph_fn <span class="free">B</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">R</span> <span class="keyword1">O</span> on_graph <span class="free">B</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Range <span class="free">R</span> <span class="main">⊆</span> vertices <span class="free">B</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ep<span class="main">:</span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">R</span> <span class="main">(</span>edges <span class="free">A</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">B</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> d<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="free">R</span> <span class="main">⊆</span> Domain <span class="main">(</span><span class="free">R</span> <span class="keyword1">O</span> on_graph <span class="free">B</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Domain_id_on <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="main">(</span>map_graph <span class="main">(</span><span class="free">R</span> <span class="keyword1">O</span> on_graph <span class="free">B</span> <span class="free">f</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="main">(</span>map_graph_fn <span class="free">B</span> <span class="free">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> BNF_Def.Gr_def map_graph_selectors <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"edges <span class="main">(</span>map_graph <span class="main">(</span><span class="free">R</span> <span class="keyword1">O</span> on_graph <span class="free">B</span> <span class="free">f</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span> <span class="main">⊆</span> edges <span class="main">(</span>map_graph_fn <span class="free">B</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ep
    <span class="keyword1"><span class="command">unfolding</span></span> BNF_Def.Gr_def map_graph_selectors edge_preserving <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> u<span class="main">:</span><span class="quoted"><span class="quoted">"graph_union <span class="main">(</span>map_graph <span class="main">(</span><span class="free">R</span> <span class="keyword1">O</span> on_graph <span class="free">B</span> <span class="free">f</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">B</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> map_graph_fn <span class="free">B</span> <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> e v graph_unionI <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">from</span></span> d assms u <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">A</span> <span class="main">(</span>map_graph_fn <span class="free">B</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">R</span> <span class="keyword1">O</span> on_graph <span class="free">B</span> <span class="free">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="RulesAndChains">
<div class="head">
<h1>Theory RulesAndChains</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Rules, and the chains we can make with them›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This describes graph rules, and the reasoning is fully on graphs here (no semantics).
      The formalisation builds up to Lemma 4 in the paper.›</span></span>
<span class="keyword1"><span class="command">theory</span></span> RulesAndChains
<span class="keyword2"><span class="keyword">imports</span></span> <a href="LabeledGraphs.html">LabeledGraphs</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> graph_seq <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> labeled_graph<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 8.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">chain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> graph_seq <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">chain</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">≡</span> <span class="main">∀</span> <span class="bound">i</span><span class="main">.</span> subgraph <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RulesAndChains-chain_then_restrict"><span class="command">lemma</span></span> chain_then_restrict<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="free">i</span> <span class="main">=</span> restrict <span class="main">(</span><span class="free">S</span> <span class="free">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> chain_def graph_homomorphism_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-chain"><span class="command">lemma</span></span> chain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">≥</span> <span class="free">i</span> <span class="main">⟹</span> subgraph <span class="main">(</span><span class="free">S</span> <span class="free">i</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="free">j</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">j</span><span class="main">-</span><span class="free">i</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> chain_then_restrict<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> assms<span class="main">[</span><span class="operator">unfolded</span> chain_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> j<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">+</span> <span class="skolem">x</span> <span class="main">+</span> <span class="main">1</span> <span class="main">=</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> subgraph_trans<span class="main">[</span><span class="operator">OF</span> Suc<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> chain_def<span class="main"><span class="main">,</span></span><span class="operator">rule_format</span><span class="main"><span class="main">,</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">+</span><span class="skolem">x</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">,</span><span class="operator">unfolded</span> j<span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> Suc <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RulesAndChains-chain_def2"><span class="command">lemma</span></span> chain_def2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"chain <span class="free">S</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> <span class="bound">j</span> <span class="main">≥</span> <span class="bound">i</span> <span class="main">⟶</span> subgraph <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> <span class="bound">i</span> <span class="main">≤</span> <span class="bound">j</span> <span class="main">⟶</span> subgraph <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="bound">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> chain <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> <span class="bound">i</span> <span class="main">≤</span> <span class="bound">j</span> <span class="main">⟶</span> subgraph <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="bound">j</span><span class="main">)</span> <span class="main">⟹</span> chain <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> chain_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Second part of definition 8.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">chain_sup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> graph_seq <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> labeled_graph"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">chain_sup</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">≡</span> LG <span class="main">(</span><span class="main">⋃</span> <span class="bound">i</span><span class="main">.</span> edges <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">⋃</span> <span class="bound">i</span><span class="main">.</span> vertices <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RulesAndChains-chain_sup_const"><span class="command">lemma</span></span> chain_sup_const<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"chain_sup <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="free">S</span><span class="main">)</span> <span class="main">=</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> chain_sup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-chain_sup_subgraph"><span class="command">lemma</span></span> chain_sup_subgraph<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span><span class="free">S</span> <span class="free">j</span><span class="main">)</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> c1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="skolem">j</span> <span class="main">=</span> restrict <span class="main">(</span><span class="free">S</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">j</span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> chain_def<span class="main">,</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="skolem">j</span></span><span class="main">]</span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> c2<span class="main">:</span> <span class="quoted"><span class="quoted">"chain_sup <span class="free">S</span> <span class="main">=</span> restrict <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> chain_sup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">have</span></span> c3<span class="main">:</span> <span class="quoted"><span class="quoted">"graph_union <span class="main">(</span><span class="free">S</span> <span class="free">j</span><span class="main">)</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="main">=</span> chain_sup <span class="free">S</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> chain_sup_def graph_union_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def <span class="keyword1"><span class="command">using</span></span> c1 c2 c3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RulesAndChains-chain_sup_graph"><span class="command">lemma</span></span> chain_sup_graph<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> chain_sup_subgraph<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-map_graph_chain_sup"><span class="command">lemma</span></span> map_graph_chain_sup<span class="main">:</span>
<span class="quoted"><span class="quoted">"map_graph <span class="free">g</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="main">=</span> chain_sup <span class="main">(</span>map_graph <span class="free">g</span> <span class="keyword1">o</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_graph_def chain_sup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-graph_union_chain_sup"><span class="command">lemma</span></span> graph_union_chain_sup<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span><span class="main">.</span> graph_union <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="free">C</span> <span class="main">=</span> <span class="free">C</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_union <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="free">C</span> <span class="main">=</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"edges <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">⊆</span> edges <span class="free">C</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="free">C</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>graph_union_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="main">⊆</span> edges <span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> e <span class="keyword1"><span class="command">unfolding</span></span> chain_sup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"vertices <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v <span class="keyword1"><span class="command">unfolding</span></span> chain_sup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> Graph_PreRule <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> labeled_graph <span class="main">×</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> labeled_graph"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 9.›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">graph_rule</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> Graph_PreRule <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">graph_rule</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> subgraph <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="main">∧</span> finite_graph <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_of_graph_rules</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> Graph_PreRule set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">set_of_graph_rules</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="main">≡</span> <span class="main">∀</span> <span class="bound">R</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">Rs</span></span></span><span class="main">.</span> graph_rule <span class="bound">R</span>"</span></span>

<span class="keyword1" id="RulesAndChains-set_of_graph_rulesD"><span class="command">lemma</span></span> set_of_graph_rulesD<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set_of_graph_rules <span class="free">Rs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">∈</span> <span class="free">Rs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite_graph <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"finite_graph <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> set_of_graph_rules_def<span class="main">]</span> assms<span class="main">(</span>2<span class="main">)</span>
        rev_finite_subset<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"vertices <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span>"</span></span><span class="main">]</span>
        rev_finite_subset<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def graph_union_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">agree_on</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as an equivalence.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">agree_on</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">agree_on</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">v</span> <span class="main">∈</span> vertices <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">``</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">``</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RulesAndChains-agree_on_empty"><span class="command">lemma</span></span> agree_on_empty<span class="main">[</span><span class="operator">intro</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"agree_on <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{}</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-agree_on_comm"><span class="command">lemma</span></span> agree_on_comm<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"agree_on <span class="free">X</span> <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> agree_on <span class="free">X</span> <span class="free">g</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="RulesAndChains-agree_on_refl"><span class="command">lemma</span></span> agree_on_refl<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"agree_on <span class="free">R</span> <span class="free">f</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="RulesAndChains-agree_on_trans"><span class="command">lemma</span></span> agree_on_trans<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="free">X</span> <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="free">X</span> <span class="free">g</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="free">X</span> <span class="free">f</span> <span class="free">h</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-agree_on_equivp"><span class="command">lemma</span></span> agree_on_equivp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"equivp <span class="main">(</span>agree_on <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>agree_on_trans <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>equivpI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>reflp_def symp_def transp_def agree_on_comm<span class="main">)</span>

<span class="keyword1" id="RulesAndChains-agree_on_subset"><span class="command">lemma</span></span> agree_on_subset<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊆</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">G</span> <span class="main">⊆</span> Domain <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="free">G</span> <span class="free">f</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-agree_iff_subset"><span class="command">lemma</span></span> agree_iff_subset<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">G</span> <span class="free">X</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="free">G</span> <span class="free">f</span> <span class="free">g</span> <span class="main">⟷</span> <span class="free">f</span> <span class="main">⊆</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-agree_on_ext"><span class="command">lemma</span></span> agree_on_ext<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="free">G</span> <span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="free">G</span> <span class="main">(</span><span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">O</span> <span class="free">g</span><span class="main">)</span> <span class="main">(</span><span class="free">f<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">O</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-agree_on_then_eq"><span class="command">lemma</span></span> agree_on_then_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="free">G</span> <span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"Domain <span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"Domain <span class="free">f<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> vertices <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> <span class="free">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> agr<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∈</span>Domain <span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⟹</span> <span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">``</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span> <span class="main">=</span> <span class="free">f<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">``</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> agr2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∉</span>Domain <span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⟹</span> <span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">``</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
            <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∉</span>Domain <span class="free">f<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⟹</span> <span class="free">f<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">``</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> agr agr2 assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">v</span><span class="main">.</span> <span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">``</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span> <span class="main">=</span> <span class="free">f<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">``</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RulesAndChains-agree_on_subg_compose"><span class="command">lemma</span></span> agree_on_subg_compose<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="free">R</span> <span class="free">g</span> <span class="free">h</span>"</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="free">F</span> <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">F</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="free">F</span> <span class="free">f</span> <span class="free">h</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def subgraph_def graph_union_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">extensible</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="tfree">'x</span><span class="main">)</span> Graph_PreRule <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'x</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">extensible</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">g</span><span class="main">.</span> graph_homomorphism <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="bound">g</span> <span class="main">∧</span> agree_on <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">g</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RulesAndChains-extensibleI"><span class="command">lemma</span></span> extensibleI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="comment1">(* not nice as a standard rule, since obtained variables cannot be used *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">R2</span> <span class="free">G</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="free">R1</span> <span class="free">f</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span><span class="free">R1</span><span class="main">,</span><span class="free">R2</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> extensible_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-extensibleD"><span class="command">lemma</span></span> extensibleD<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"extensible <span class="free">R</span> <span class="free">G</span> <span class="free">f</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">g</span><span class="main">.</span> graph_homomorphism <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="free">G</span> <span class="bound">g</span> <span class="main">⟹</span> agree_on <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="free">f</span> <span class="bound">g</span> <span class="main">⟹</span> <span class="free">thesis</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="free">thesis</span></span> <span class="keyword1"><span class="command">using</span></span> assms extensible_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="RulesAndChains-extensible_refl_concr"><span class="command">lemma</span></span> extensible_refl_concr<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">v</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span>LG <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">v</span><span class="main">,</span> LG <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">v</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span> <span class="main">⟷</span> graph_homomorphism <span class="main">(</span>LG <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">v</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span>LG <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">v</span><span class="main">,</span> LG <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">v</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> g<span class="main">:</span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">v</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">g</span>"</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="main">(</span>LG <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">v</span><span class="main">)</span> <span class="free">f</span> <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> extensible_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> d<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="free">f</span> <span class="main">=</span> Domain <span class="skolem">g</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> g <span class="keyword1"><span class="command">have</span></span> subs<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊆</span> <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> agree_iff_subset<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">,</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>graph_homomorphism_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> d <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">=</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">v</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> assms extensible_def<span class="main">)</span>

<span class="keyword1" id="RulesAndChains-extensible_chain_sup"><span class="command">lemma</span></span>   extensible_chain_sup<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"extensible <span class="free">R</span> <span class="main">(</span><span class="free">S</span> <span class="free">j</span><span class="main">)</span> <span class="free">f</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"extensible <span class="free">R</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="free">j</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">∧</span> agree_on <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="free">f</span> <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> extensible_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="keyword1">O</span> Id_on <span class="main">(</span>vertices <span class="main">(</span><span class="free">S</span> <span class="free">j</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g<span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> g assms<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="free">j</span><span class="main">)</span> <span class="skolem">g</span>"</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span><span class="free">S</span> <span class="free">j</span><span class="main">)</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> graph_homomorphism_composes<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> g <span class="keyword1"><span class="command">unfolding</span></span> extensible_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 11.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">maintained</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="tfree">'x</span><span class="main">)</span> Graph_PreRule <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">maintained</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="main">∀</span> <span class="bound">f</span><span class="main">.</span> graph_homomorphism <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="bound">f</span> <span class="main">⟶</span> extensible <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="bound">f</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">maintainedA</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="tfree">'x</span><span class="main">)</span> Graph_PreRule set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">maintainedA</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="main">∀</span> <span class="bound">R</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">Rs</span></span></span><span class="main">.</span> maintained <span class="bound">R</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span>"</span></span>

<span class="keyword1" id="RulesAndChains-maintainedI"><span class="command">lemma</span></span> maintainedI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">f</span><span class="main">.</span> graph_homomorphism <span class="free">A</span> <span class="free">G</span> <span class="bound">f</span> <span class="main">⟹</span> extensible <span class="main">(</span><span class="free">A</span><span class="main">,</span><span class="free">B</span><span class="main">)</span> <span class="free">G</span> <span class="bound">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span><span class="free">A</span><span class="main">,</span><span class="free">B</span><span class="main">)</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> maintained_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="RulesAndChains-maintainedD"><span class="command">lemma</span></span> maintainedD<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span><span class="free">A</span><span class="main">,</span><span class="free">B</span><span class="main">)</span> <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">A</span> <span class="free">G</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span><span class="free">A</span><span class="main">,</span><span class="free">B</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> maintained_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-maintainedD2"><span class="command">lemma</span></span> maintainedD2<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span><span class="free">A</span><span class="main">,</span><span class="free">B</span><span class="main">)</span> <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">A</span> <span class="free">G</span> <span class="free">f</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">g</span><span class="main">.</span> graph_homomorphism <span class="free">B</span> <span class="free">G</span> <span class="bound">g</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">⊆</span> <span class="bound">g</span> <span class="main">⟹</span> <span class="free">thesis</span>"</span></span>
        <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="free">thesis</span></span>
  <span class="keyword1"><span class="command">using</span></span> maintainedD<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">unfolded</span> extensible_def<span class="main">]</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="main">(</span><span class="free">A</span><span class="main">,</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">g</span> <span class="main">∧</span> agree_on <span class="main">(</span>fst <span class="main">(</span><span class="free">A</span><span class="main">,</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="free">f</span> <span class="skolem">g</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">B</span> <span class="free">G</span> <span class="skolem">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊆</span> <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def2 agree_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="free">thesis</span></span><span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RulesAndChains-extensible_refl"><span class="command">lemma</span></span> extensible_refl<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">R</span> <span class="free">G</span> <span class="free">f</span> <span class="main">⟹</span> extensible <span class="main">(</span><span class="free">R</span><span class="main">,</span><span class="free">R</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> extensible_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-maintained_refl"><span class="command">lemma</span></span> maintained_refl<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"maintained <span class="main">(</span><span class="free">R</span><span class="main">,</span><span class="free">R</span><span class="main">)</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Alternate version of definition 8.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fin_maintained</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="tfree">'x</span><span class="main">)</span> Graph_PreRule <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="tfree">'v</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">fin_maintained</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="main">∀</span> <span class="bound">F</span> <span class="bound">f</span><span class="main">.</span> finite_graph <span class="bound">F</span>
                         <span class="main">⟶</span> subgraph <span class="bound">F</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span>
                         <span class="main">⟶</span> extensible <span class="main">(</span><span class="bound">F</span><span class="main">,</span>fst <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="bound">f</span>
                         <span class="main">⟶</span> graph_homomorphism <span class="bound">F</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="bound">f</span>
                         <span class="main">⟶</span> extensible <span class="main">(</span><span class="bound">F</span><span class="main">,</span>snd <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="bound">f</span>"</span></span>

<span class="keyword1" id="RulesAndChains-fin_maintainedI"><span class="command">lemma</span></span> fin_maintainedI <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">F</span> <span class="bound">f</span><span class="main">.</span> finite_graph <span class="bound">F</span>
           <span class="main">⟹</span> subgraph <span class="bound">F</span> <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span>
           <span class="main">⟹</span> extensible <span class="main">(</span><span class="bound">F</span><span class="main">,</span>fst <span class="free">R</span><span class="main">)</span> <span class="free">G</span> <span class="bound">f</span>
           <span class="main">⟹</span> graph_homomorphism <span class="bound">F</span> <span class="free">G</span> <span class="bound">f</span>
           <span class="main">⟹</span> extensible <span class="main">(</span><span class="bound">F</span><span class="main">,</span>snd <span class="free">R</span><span class="main">)</span> <span class="free">G</span> <span class="bound">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fin_maintained <span class="free">R</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> fin_maintained_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-maintained_then_fin_maintained"><span class="command">lemma</span></span> maintained_then_fin_maintained<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> maintained<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="free">R</span> <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fin_maintained <span class="free">R</span> <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">F</span> <span class="skolem">f</span>
  <span class="keyword3"><span class="command">assume</span></span> subg<span class="main">:</span><span class="quoted"><span class="quoted">"subgraph <span class="skolem">F</span> <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> ext<span class="main">:</span><span class="quoted"><span class="quoted">"extensible <span class="main">(</span><span class="skolem">F</span><span class="main">,</span> fst <span class="free">R</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> igh<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="skolem">F</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> ext<span class="main">[</span><span class="operator">unfolded</span> extensible_def prod.sel<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span>
     g<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">g</span>"</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="skolem">F</span> <span class="skolem">f</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> maintained<span class="main">[</span><span class="operator">unfolded</span> maintained_def<span class="main">,</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">OF</span> g<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> g<span class="main">(</span>2<span class="main">)</span> subg
       agree_on_subg_compose
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span><span class="skolem">F</span><span class="main">,</span> snd <span class="free">R</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> extensible_def prod.sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RulesAndChains-fin_maintained_maintained"><span class="command">lemma</span></span> fin_maintained_maintained<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite_graph <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fin_maintained <span class="free">R</span> <span class="free">G</span> <span class="main">⟷</span> maintained <span class="free">R</span> <span class="free">G</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms rev_finite_subset
  <span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="main">(</span>vertices <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span><span class="main">)</span>"</span></span>
           <span class="quoted"><span class="quoted">"finite <span class="main">(</span>edges <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span><span class="main">)</span>"</span></span>
           <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def graph_union_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">with</span></span> fin <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span>fst <span class="free">R</span><span class="main">,</span> fst <span class="free">R</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span> <span class="main">⟹</span> graph_homomorphism <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>
         <span class="main">⟹</span> extensible <span class="free">R</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="keyword1"><span class="command">unfolding</span></span> fin_maintained_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> extensible_refl maintained_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="RulesAndChains-extend_for_chain"><span class="command">lemma</span></span> extend_for_chain<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">0</span> <span class="main">=</span> <span class="free">f</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span><span class="main">.</span> graph_homomorphism <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="free">C</span> <span class="main">(</span><span class="free">g</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span><span class="main">.</span> agree_on <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span><span class="free">S</span> <span class="main">0</span><span class="main">,</span> chain_sup <span class="free">S</span><span class="main">)</span> <span class="free">C</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?g</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> <span class="free">g</span> <span class="bound">i</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>4<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> chain_def subgraph_def graph_union_iff<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="main">(</span><span class="free">S</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"edges <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">⊆</span> edges <span class="main">(</span><span class="free">S</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">i</span>
    <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> vertices <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> agree_on_def<span class="main">,</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">OF</span> this<span class="main">]</span> a
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> gi<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="skolem">i</span> <span class="main">⊆</span> <span class="free">g</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> gij<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> <span class="skolem">j</span> <span class="main">⟹</span> <span class="free">g</span> <span class="skolem">i</span> <span class="main">⊆</span> <span class="free">g</span> <span class="skolem">j</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="skolem">j</span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">j</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> gi<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">j</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> Suc <span class="skolem">j</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> f_subset<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊆</span> <span class="var">?g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="main">0</span></span><span class="main">,</span><span class="operator">unfolded</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> domf<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="free">f</span> <span class="main">=</span> vertices <span class="main">(</span><span class="free">S</span> <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> grC<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="free">C</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> v_dom<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> Domain <span class="main">(</span><span class="free">g</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="skolem">i</span> <span class="skolem">j</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="skolem">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="skolem">j</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> gij<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span> <span class="quoted"><span class="quoted">"max <span class="skolem">i</span> <span class="skolem">j</span>"</span></span><span class="main">]</span> gij<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">j</span></span> <span class="quoted"><span class="quoted">"max <span class="skolem">i</span> <span class="skolem">j</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> univ_strong <span class="main">=</span> this
  <span class="keyword1"><span class="command">hence</span></span> univ<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="var">?g</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xa</span> <span class="skolem">x</span> <span class="skolem">i</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xa</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="main">(</span>map_graph <span class="main">(</span><span class="free">g</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">C</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def2 graph_union_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> eq_v <span class="main">=</span> this
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">x'</span> <span class="skolem">y'</span> <span class="skolem">j</span> <span class="skolem">i</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span><span class="free">S</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="skolem">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">y'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> gij<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span> <span class="quoted"><span class="quoted">"max <span class="skolem">i</span> <span class="skolem">j</span>"</span></span><span class="main">]</span> gij<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">j</span></span> <span class="quoted"><span class="quoted">"max <span class="skolem">i</span> <span class="skolem">j</span>"</span></span><span class="main">]</span>
         chain<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">unfolded</span> subgraph_def graph_union_iff<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span> <span class="quoted"><span class="quoted">"max <span class="skolem">i</span> <span class="skolem">j</span>"</span></span><span class="main">]</span>
         chain<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">unfolded</span> subgraph_def graph_union_iff<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">j</span></span> <span class="quoted"><span class="quoted">"max <span class="skolem">i</span> <span class="skolem">j</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">x'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">y'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span>"</span></span>
         <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x'</span><span class="main">,</span> <span class="skolem">y'</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">C</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def2 graph_union_iff<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> eq_e <span class="main">=</span> this
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_union <span class="main">(</span>map_graph <span class="main">(</span><span class="free">g</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span><span class="main">)</span> <span class="free">C</span> <span class="main">=</span> <span class="free">C</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_union_iff <span class="keyword1"><span class="command">using</span></span> eq_e eq_v
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def2 chain_sup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> subg<span class="main">:</span><span class="quoted"><span class="quoted">"graph_union <span class="main">(</span>map_graph <span class="var">?g</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span><span class="main">)</span> <span class="free">C</span> <span class="main">=</span> <span class="free">C</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> graph_map_union<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> gij <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> vertices <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> Domain <span class="main">(</span><span class="free">g</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v_dom <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> vd<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="main">=</span> Domain <span class="var">?g</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> chain_sup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="free">C</span> <span class="var">?g</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def2
    <span class="keyword1"><span class="command">using</span></span> univ chain_sup_graph<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">]</span> grC vd subg <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="main">(</span><span class="free">S</span> <span class="main">0</span><span class="main">)</span> <span class="free">f</span> <span class="var">?g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> agree_on_subset<span class="main">[</span><span class="operator">OF</span> f_subset _ univ<span class="main">]</span> domf <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 8, second part.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">consequence_graph</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">consequence_graph</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> graph <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">R</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span><span class="main">.</span> subgraph <span class="main">(</span>fst <span class="bound">R</span><span class="main">)</span> <span class="main">(</span>snd <span class="bound">R</span><span class="main">)</span> <span class="main">∧</span> maintained <span class="bound">R</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RulesAndChains-consequence_graphI"><span class="command">lemma</span></span> consequence_graphI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">R</span><span class="main">.</span> <span class="bound">R</span><span class="main">∈</span> <span class="free">Rs</span> <span class="main">⟹</span> maintained <span class="bound">R</span> <span class="free">G</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">R</span><span class="main">.</span> <span class="bound">R</span><span class="main">∈</span> <span class="free">Rs</span> <span class="main">⟹</span> subgraph <span class="main">(</span>fst <span class="bound">R</span><span class="main">)</span> <span class="main">(</span>snd <span class="bound">R</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"consequence_graph <span class="free">Rs</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> consequence_graph_def fin_maintained_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RulesAndChains-consequence_graphD"><span class="command">lemma</span></span> consequence_graphD<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"consequence_graph <span class="free">Rs</span> <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">R</span><span class="main">.</span> <span class="bound">R</span><span class="main">∈</span> <span class="free">Rs</span> <span class="main">⟹</span> maintained <span class="bound">R</span> <span class="free">G</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">R</span><span class="main">.</span> <span class="bound">R</span><span class="main">∈</span> <span class="free">Rs</span> <span class="main">⟹</span> subgraph <span class="main">(</span>fst <span class="bound">R</span><span class="main">)</span> <span class="main">(</span>snd <span class="bound">R</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> consequence_graph_def fin_maintained_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 8 states: If furthermore S is a subgraph of G,
    and (S, G) is maintained in each consequence graph maintaining Rs,
    then G is a least consequence graph of S maintaining Rs.
    Note that the type of 'each consequence graph' isn't given here.
   Taken literally, this should mean 'for every possible type'.
   We avoid quantifying on types by making the type an argument.
   Consequently, when proving 'least', the first argument should be free.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">least</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> itself <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> Graph_PreRule<span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">least</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> subgraph <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> 
            <span class="main">(</span><span class="main">∀</span> <span class="bound">C</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> labeled_graph<span class="main">.</span> consequence_graph <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="bound">C</span> <span class="main">⟶</span> maintained <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="bound">C</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RulesAndChains-leastI"><span class="command">lemma</span></span> leastI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">S</span> <span class="main">(</span><span class="free">G</span><span class="main">::</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> labeled_graph<span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">C</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> labeled_graph<span class="main">.</span> consequence_graph <span class="free">Rs</span> <span class="bound">C</span> <span class="main">⟹</span> maintained <span class="main">(</span><span class="free">S</span><span class="main">,</span><span class="free">G</span><span class="main">)</span> <span class="bound">C</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"least <span class="main">(</span><span class="free">t</span><span class="main">::</span> <span class="tfree">'x</span> itself<span class="main">)</span> <span class="free">Rs</span> <span class="free">S</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> least_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">least_consequence_graph</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> itself <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> Graph_PreRule<span class="main">)</span> set
     <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">least_consequence_graph</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> consequence_graph <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> least <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span>"</span></span>

<span class="keyword1" id="RulesAndChains-least_consequence_graphI"><span class="command">lemma</span></span> least_consequence_graphI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"consequence_graph <span class="free">Rs</span> <span class="main">(</span><span class="free">G</span><span class="main">::</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> labeled_graph<span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"subgraph <span class="free">S</span> <span class="free">G</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">C</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> labeled_graph<span class="main">.</span> consequence_graph <span class="free">Rs</span> <span class="bound">C</span> <span class="main">⟹</span> maintained <span class="main">(</span><span class="free">S</span><span class="main">,</span><span class="free">G</span><span class="main">)</span> <span class="bound">C</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"least_consequence_graph <span class="main">(</span><span class="free">t</span><span class="main">::</span> <span class="tfree">'x</span> itself<span class="main">)</span> <span class="free">Rs</span> <span class="free">S</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> least_consequence_graph_def least_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 12.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fair_chain</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fair_chain</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">≡</span> chain <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">∧</span> 
    <span class="main">(</span><span class="main">∀</span> <span class="bound">R</span> <span class="bound">f</span> <span class="bound">i</span><span class="main">.</span> <span class="main">(</span><span class="bound">R</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="main">∧</span> graph_homomorphism <span class="main">(</span>fst <span class="bound">R</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="bound">f</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">j</span><span class="main">.</span> extensible <span class="bound">R</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="bound">j</span><span class="main">)</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RulesAndChains-fair_chainI"><span class="command">lemma</span></span> fair_chainI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">R</span> <span class="bound">f</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">R</span> <span class="main">∈</span> <span class="free">Rs</span> <span class="main">⟹</span> graph_homomorphism <span class="main">(</span>fst <span class="bound">R</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="bound">f</span> <span class="main">⟹</span> <span class="main">∃</span> <span class="bound">j</span><span class="main">.</span> extensible <span class="bound">R</span> <span class="main">(</span><span class="free">S</span> <span class="bound">j</span><span class="main">)</span> <span class="bound">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fair_chain <span class="free">Rs</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> fair_chain_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="RulesAndChains-fair_chainD"><span class="command">lemma</span></span> fair_chainD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fair_chain <span class="free">Rs</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">∈</span> <span class="free">Rs</span> <span class="main">⟹</span> graph_homomorphism <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="free">i</span><span class="main">)</span> <span class="free">f</span> <span class="main">⟹</span> <span class="main">∃</span> <span class="bound">j</span><span class="main">.</span> extensible <span class="free">R</span> <span class="main">(</span><span class="free">S</span> <span class="bound">j</span><span class="main">)</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> fair_chain_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="RulesAndChains-find_graph_occurence_vertices"><span class="command">lemma</span></span> find_graph_occurence_vertices<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">V</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> <span class="free">V</span> <span class="main">⊆</span> vertices <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">i</span><span class="main">.</span> <span class="free">f</span> <span class="main">``</span> <span class="free">V</span> <span class="main">⊆</span> vertices <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>4<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">V</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> empty <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">v</span> <span class="skolem">V</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> insert.prems <span class="keyword1"><span class="command">have</span></span> V<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> <span class="skolem">V</span> <span class="main">⊆</span> vertices <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="main">⊆</span> vertices <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> insert.hyps<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> V<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> <span class="skolem">V</span> <span class="main">⊆</span> vertices <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">j</span><span class="main">.</span> <span class="free">f</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="main">⊆</span> vertices <span class="main">(</span><span class="free">S</span> <span class="bound">j</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v'</span></span> <span class="keyword2"><span class="keyword">where</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">∈</span> vertices <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> f <span class="keyword1"><span class="command">unfolding</span></span> chain_sup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> j<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="main">⊆</span> vertices <span class="main">(</span><span class="free">S</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> sg<span class="main">:</span><span class="quoted"><span class="quoted">"subgraph <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span><span class="free">S</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chain<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">have</span></span> V<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">∩</span> <span class="skolem">V</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">``</span> <span class="skolem">V</span> <span class="main">⊆</span> vertices <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> i subgraph_subset<span class="main">[</span><span class="operator">OF</span> sg<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="main">⊆</span> vertices <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> j subgraph_subset<span class="main">[</span><span class="operator">OF</span> sg<span class="main"><span class="main"><span class="main">(</span></span></span>2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> insert <span class="skolem">v</span> <span class="skolem">V</span> <span class="main">⊆</span> vertices <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v V <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RulesAndChains-find_graph_occurence_edges"><span class="command">lemma</span></span> find_graph_occurence_edges<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">E</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">f</span>"</span></span>
        <span class="quoted"><span class="quoted">"on_triple <span class="free">f</span> <span class="main">``</span> <span class="free">E</span> <span class="main">⊆</span> edges <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">i</span><span class="main">.</span> on_triple <span class="free">f</span> <span class="main">``</span> <span class="free">E</span> <span class="main">⊆</span> edges <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>4<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">E</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> empty <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">e</span> <span class="skolem">E</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> univ<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="main">(</span>on_triple <span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"restrict <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">S</span> <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span>
    <span class="keyword1"><span class="command">using</span></span> chain<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">unfolded</span> subgraph_def<span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span> <span class="quoted"><span class="skolem">i</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> insert.prems <span class="keyword1"><span class="command">have</span></span> E<span class="main">:</span><span class="quoted"><span class="quoted">"on_triple <span class="free">f</span> <span class="main">``</span> <span class="skolem">E</span> <span class="main">⊆</span> edges <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"on_triple <span class="free">f</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">e</span><span class="main">}</span> <span class="main">⊆</span> edges <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> insert.hyps <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span><span class="quoted"><span class="quoted">"on_triple <span class="free">f</span> <span class="main">``</span> <span class="skolem">E</span> <span class="main">⊆</span> edges <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">j</span><span class="main">.</span> on_triple <span class="free">f</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">e</span><span class="main">}</span> <span class="main">⊆</span> edges <span class="main">(</span><span class="free">S</span> <span class="bound">j</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"on_triple <span class="free">f</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">e</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">e'</span></span> <span class="keyword2"><span class="keyword">where</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">e</span><span class="main">,</span><span class="skolem">e'</span><span class="main">)</span> <span class="main">∈</span> on_triple <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e'</span> <span class="main">∈</span> edges <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> e <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> univ f <span class="keyword1"><span class="command">unfolding</span></span> chain_sup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> j<span class="main">:</span><span class="quoted"><span class="quoted">"on_triple <span class="free">f</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">e</span><span class="main">}</span> <span class="main">⊆</span> edges <span class="main">(</span><span class="free">S</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> sg<span class="main">:</span><span class="quoted"><span class="quoted">"subgraph <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span><span class="free">S</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chain<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">have</span></span> E<span class="main">:</span><span class="quoted"><span class="quoted">"on_triple <span class="free">f</span> <span class="main">``</span> <span class="skolem">E</span> <span class="main">⊆</span> edges <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> i subgraph_subset<span class="main">[</span><span class="operator">OF</span> sg<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"on_triple <span class="free">f</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">e</span><span class="main">}</span> <span class="main">⊆</span> edges <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> j subgraph_subset<span class="main">[</span><span class="operator">OF</span> sg<span class="main"><span class="main"><span class="main">(</span></span></span>2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"on_triple <span class="free">f</span> <span class="main">``</span> insert <span class="skolem">e</span> <span class="skolem">E</span> <span class="main">⊆</span> edges <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> e E <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RulesAndChains-find_graph_occurence"><span class="command">lemma</span></span> find_graph_occurence<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">E</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">V</span>"</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="free">E</span> <span class="free">V</span><span class="main">)</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">i</span><span class="main">.</span> graph_homomorphism <span class="main">(</span>LG <span class="free">E</span> <span class="free">V</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"restrict <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">S</span> <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span>
    <span class="keyword1"><span class="command">using</span></span> chain<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">unfolded</span> subgraph_def<span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span> <span class="quoted"><span class="skolem">i</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def edge_preserving labeled_graph.sel<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> u<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="free">f</span>"</span></span> 
   <span class="keyword2"><span class="keyword">and</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"on_triple <span class="free">f</span> <span class="main">``</span> <span class="free">E</span> <span class="main">⊆</span> edges <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> <span class="free">V</span> <span class="main">⊆</span> vertices <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">from</span></span> find_graph_occurence_edges<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span> u e<span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span><span class="quoted"><span class="quoted">"on_triple <span class="free">f</span> <span class="main">``</span> <span class="free">E</span> <span class="main">⊆</span> edges <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> find_graph_occurence_vertices<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> u v<span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> j<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> <span class="free">V</span> <span class="main">⊆</span> vertices <span class="main">(</span><span class="free">S</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> sg<span class="main">:</span><span class="quoted"><span class="quoted">"subgraph <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span><span class="free">S</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> chain<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">have</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"on_triple <span class="free">f</span> <span class="main">``</span> <span class="free">E</span> <span class="main">⊆</span> edges <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> <span class="free">V</span> <span class="main">⊆</span> vertices <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> i j subgraph_subset<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> sg<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> subgraph_subset<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> sg<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="free">E</span> <span class="free">V</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> graph_homomorphismI<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def edge_preserving labeled_graph.sel<span class="main">]</span> e v
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"vertices <span class="main">(</span>LG <span class="free">E</span> <span class="free">V</span><span class="main">)</span> <span class="main">=</span> Domain <span class="free">f</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">f</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"LG <span class="free">E</span> <span class="free">V</span> <span class="main">=</span> restrict <span class="main">(</span>LG <span class="free">E</span> <span class="free">V</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> vertices <span class="main">(</span>LG <span class="free">E</span> <span class="free">V</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> 
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="free">f</span> <span class="main">(</span>edges <span class="main">(</span>LG <span class="free">E</span> <span class="free">V</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">=</span> restrict <span class="main">(</span><span class="free">S</span> <span class="main">(</span>max <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.
      Recall that in the paper, graph rules use finite graphs, i.e. both sides should be finite.
      We strengthen lemma 3 by requiring only the left hand side to be a finite graph.›</span></span>
<span class="keyword1" id="RulesAndChains-fair_chain_impl_consequence_graph"><span class="command">lemma</span></span> fair_chain_impl_consequence_graph<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fair_chain <span class="free">Rs</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">R</span><span class="main">.</span> <span class="bound">R</span> <span class="main">∈</span> <span class="free">Rs</span> <span class="main">⟹</span> subgraph <span class="main">(</span>fst <span class="bound">R</span><span class="main">)</span> <span class="main">(</span>snd <span class="bound">R</span><span class="main">)</span> <span class="main">∧</span> finite_graph <span class="main">(</span>fst <span class="bound">R</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"consequence_graph <span class="free">Rs</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="main">∈</span> <span class="free">Rs</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> fin_v<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="main">(</span>vertices <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> fin_e<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>edges <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> a<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="main">(</span>edges <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>vertices <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="skolem">f</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> find_graph_occurence<span class="main">[</span><span class="operator">OF</span> fair_chainD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> fin_e fin_v<span class="main">]</span>  
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> fair_chainD<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> a this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span>
         <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"extensible <span class="skolem">R</span> <span class="main">(</span><span class="free">S</span> <span class="skolem">j</span><span class="main">)</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"extensible <span class="skolem">R</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fair_chainD<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"maintained <span class="skolem">R</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> maintained_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> mnt <span class="main">=</span> this
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> fair_chain_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> consequence_graph_def <span class="keyword1"><span class="command">using</span></span> mnt assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We extract the weak universal property from the definition of weak pushout step.
      Again, the paper allows for arbitrary types in the quantifier,
          but we fix the type here in the definition that will be used in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">pushout_step</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
          The type used here should suffice (and we cannot quantify over types anyways)›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">weak_universal</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> itself <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> Graph_PreRule <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> labeled_graph <span class="main">⇒</span>
     <span class="main">(</span><span class="tfree">'c</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">weak_universal</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">h<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">h<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">G</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> labeled_graph<span class="main">.</span>
             <span class="main">(</span>graph_homomorphism <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="bound">G</span> <span class="bound">h<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span> graph_homomorphism <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="bound">G</span> <span class="bound">h<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="keyword1">O</span> <span class="bound">h<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⊆</span> <span class="bound">h<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>
         <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">h</span><span class="main">.</span> graph_homomorphism <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="bound">G</span> <span class="bound">h</span> <span class="main">∧</span> <span class="bound">h<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⊆</span> <span class="bound">h</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RulesAndChains-weak_universalD"><span class="command">lemma</span></span> weak_universalD<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"weak_universal <span class="main">(</span><span class="free">t</span><span class="main">::</span> <span class="tfree">'x</span> itself<span class="main">)</span> <span class="free">R</span> <span class="main">(</span><span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> labeled_graph<span class="main">)</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span>  <span class="bound">h<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">h<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">G</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> labeled_graph<span class="main">.</span>
         graph_homomorphism <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="bound">G</span> <span class="bound">h<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⟹</span> graph_homomorphism <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">G</span> <span class="bound">h<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⟹</span> <span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">O</span> <span class="bound">h<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⊆</span> <span class="bound">h<span class="hidden">⇩</span><sub>1</sub></span>
         <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">h</span><span class="main">.</span> graph_homomorphism <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">G</span> <span class="bound">h</span> <span class="main">∧</span> <span class="bound">h<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⊆</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> weak_universal_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1" id="RulesAndChains-weak_universalI"><span class="command">lemma</span></span> weak_universalI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">h<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">h<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">G</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> labeled_graph<span class="main">.</span>
         graph_homomorphism <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="bound">G</span> <span class="bound">h<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⟹</span> graph_homomorphism <span class="free">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">G</span> <span class="bound">h<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⟹</span> <span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">O</span> <span class="bound">h<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⊆</span> <span class="bound">h<span class="hidden">⇩</span><sub>1</sub></span>
         <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">h</span><span class="main">.</span> graph_homomorphism <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">G</span> <span class="bound">h</span> <span class="main">∧</span> <span class="bound">h<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⊆</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"weak_universal <span class="main">(</span><span class="free">t</span><span class="main">::</span> <span class="tfree">'x</span> itself<span class="main">)</span> <span class="free">R</span> <span class="main">(</span><span class="free">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> labeled_graph<span class="main">)</span> <span class="free">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> weak_universal_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 13›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pushout_step</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> itself <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> Graph_PreRule <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">pushout_step</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">≡</span> subgraph <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">∧</span> 
  <span class="main">(</span><span class="main">∃</span> <span class="bound">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span> graph_homomorphism <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="bound">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span>
           graph_homomorphism <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="bound">f<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span>
           <span class="bound">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> <span class="bound">f<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span>
           weak_universal <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">G<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="bound">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">f<span class="hidden">⇩</span><sub>2</sub></span>
  <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 14›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Simple_WPC</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> itself <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_PreRule<span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> graph_seq<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">Simple_WPC</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">≡</span> set_of_graph_rules <span class="free"><span class="bound"><span class="entity">Rs</span></span></span>
   <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">i</span><span class="main">.</span> <span class="main">(</span>graph <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="bound">i</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">R</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span><span class="main">.</span> pushout_step <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="bound">R</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RulesAndChains-Simple_WPCI"><span class="command">lemma</span></span> Simple_WPCI <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set_of_graph_rules <span class="free">Rs</span>"</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span><span class="free">S</span> <span class="main">0</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span><span class="main">.</span> <span class="main">(</span><span class="free">S</span> <span class="bound">i</span> <span class="main">=</span> <span class="free">S</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">R</span> <span class="main">∈</span> <span class="free">Rs</span><span class="main">.</span> pushout_step <span class="free">t</span> <span class="bound">R</span> <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Simple_WPC <span class="free">t</span> <span class="free">Rs</span> <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> pushout_step_def subgraph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Simple_WPC_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RulesAndChains-Simple_WPC_Chain"><span class="command">lemma</span></span> Simple_WPC_Chain<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Simple_WPC <span class="free">t</span> <span class="free">Rs</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="free">S</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> Simple_WPC_def pushout_step_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">∧</span> <span class="free">S</span> <span class="skolem">i</span> <span class="main">=</span> <span class="free">S</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> chain_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 14, second part. ›</span></span>
<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">WPC</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> itself <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_PreRule<span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span> graph_seq<span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    wpc_simpl <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Simple_WPC <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">⟹</span> <span class="free">WPC</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span>"</span></span>
  <span class="main">|</span> wpc_combo <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"chain <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span> <span class="bound">i</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">S'</span><span class="main">.</span> <span class="bound">S'</span> <span class="main">0</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="bound">i</span> <span class="main">∧</span> chain_sup <span class="bound">S'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="main">∧</span> <span class="free">WPC</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="bound">S'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">WPC</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span>"</span></span>

<span class="keyword1" id="RulesAndChains-extensible_from_chainI"><span class="command">lemma</span></span> extensible_from_chainI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ch<span class="main">:</span><span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> igh<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span><span class="free">S</span> <span class="main">0</span><span class="main">)</span> <span class="free">C</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ind<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">f</span> <span class="bound">i</span><span class="main">.</span> graph_homomorphism <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="free">C</span> <span class="bound">f</span> <span class="main">⟹</span>
                <span class="main">∃</span><span class="bound">h</span><span class="main">.</span> <span class="main">(</span>graph_homomorphism <span class="main">(</span><span class="free">S</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="free">C</span> <span class="bound">h</span><span class="main">)</span> <span class="main">∧</span> agree_on <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="bound">f</span> <span class="bound">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span><span class="free">S</span> <span class="main">0</span><span class="main">,</span>chain_sup <span class="free">S</span><span class="main">)</span> <span class="free">C</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> ch<span class="main">:</span><span class="quoted"><span class="quoted">"chain <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> r0<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> graph_homomorphism <span class="main">(</span><span class="free">S</span> <span class="main">0</span><span class="main">)</span> <span class="free">C</span> <span class="bound">x</span> <span class="main">∧</span> <span class="main">(</span><span class="main">0</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> igh <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="free">C</span> <span class="skolem">x</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟶</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="free">C</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> ind<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span>graph_homomorphism <span class="main">(</span><span class="free">S</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="free">C</span> <span class="bound">y</span> <span class="main">∧</span> <span class="main">(</span>Suc <span class="skolem">i</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟶</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> agree_on <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="skolem">x</span> <span class="bound">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> r0
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">g</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">i</span><span class="main">.</span> <span class="main">(</span>graph_homomorphism <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="free">C</span> <span class="main">(</span><span class="bound">g</span> <span class="bound">i</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">i</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟶</span> <span class="bound">g</span> <span class="bound">i</span> <span class="main">=</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span>
                <span class="main">∧</span> agree_on <span class="main">(</span><span class="free">S</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="bound">g</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="bound">g</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> dependent_nat_choice<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span>
       mtn<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">0</span> <span class="main">=</span> <span class="free">f</span>"</span></span>
           <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="free">C</span> <span class="main">(</span><span class="skolem">g</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
           <span class="quoted"><span class="quoted">"agree_on <span class="main">(</span><span class="free">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> extend_for_chain<span class="main">[</span><span class="operator">OF</span> mtn ch<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span><span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Towards Lemma 4, this is the key inductive property.›</span></span>
<span class="keyword1" id="RulesAndChains-wpc_least"><span class="command">lemma</span></span> wpc_least<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"WPC <span class="main">(</span><span class="free">t</span><span class="main">::</span> <span class="tfree">'x</span> itself<span class="main">)</span> <span class="free">Rs</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"least <span class="free">t</span> <span class="free">Rs</span> <span class="main">(</span><span class="free">S</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>wpc_simpl <span class="skolem">t</span> <span class="skolem">Rs</span> <span class="skolem">S</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"set_of_graph_rules <span class="skolem">Rs</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ps<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span><span class="main">.</span> <span class="skolem">S</span> <span class="bound">i</span> <span class="main">=</span> <span class="skolem">S</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">R</span><span class="main">∈</span><span class="skolem">Rs</span><span class="main">.</span> pushout_step <span class="skolem">t</span> <span class="bound">R</span> <span class="main">(</span><span class="skolem">S</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">S</span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Simple_WPC_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> ch<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"chain <span class="skolem">S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> wpc_simpl <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">C</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'x</span><span class="main">)</span> labeled_graph"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> cgC<span class="main">:</span><span class="quoted"><span class="quoted">"consequence_graph <span class="skolem">Rs</span> <span class="skolem">C</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span><span class="skolem">S</span> <span class="main">0</span><span class="main">,</span> chain_sup <span class="skolem">S</span><span class="main">)</span> <span class="skolem">C</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> extensible_from_chainI<span class="main"><span class="keyword3">,</span></span><span class="operator">goal_cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">f</span> <span class="skolem">x</span> <span class="skolem">i</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="skolem">i</span> <span class="main">=</span> <span class="skolem">S</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">with</span></span> 3 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">with</span></span> ps<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">,</span><span class="operator">unfolded</span> pushout_step_def<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">R</span></span> <span class="skolem"><span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="skolem"><span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span>
        R<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span>fst <span class="skolem">R</span><span class="main">,</span>snd <span class="skolem">R</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">Rs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> f<span class="hidden">⇩</span><sub>1</sub><span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span> <span class="main">(</span><span class="skolem">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> wu<span class="main">:</span><span class="quoted"><span class="quoted">"weak_universal <span class="skolem">t</span> <span class="skolem">R</span> <span class="main">(</span><span class="skolem">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">S</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> graph_homomorphism_composes<span class="main">[</span><span class="operator">OF</span> f<span class="hidden">⇩</span><sub>1</sub> 3<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> ih_comp<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span> <span class="skolem">C</span> <span class="main">(</span><span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">O</span> <span class="skolem">x</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">with</span></span> maintainedD<span class="main">[</span><span class="operator">OF</span> consequence_graphD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> cgC R<span class="main"><span class="main">]</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span>fst <span class="skolem">R</span><span class="main">,</span> snd <span class="skolem">R</span><span class="main">)</span> <span class="skolem">C</span> <span class="main">(</span><span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">O</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> extensible_def prod.sel<span class="main">]</span>
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="skolem">R</span><span class="main">)</span> <span class="skolem">C</span> <span class="skolem">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">O</span> <span class="skolem">x</span> <span class="main">⊆</span> <span class="skolem">g</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> agree_iff_subset<span class="main">[</span><span class="operator">OF</span> ih_comp<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> weak_universalD<span class="main">[</span><span class="operator">OF</span> wu g<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> 3<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> g<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">h</span></span> <span class="keyword2"><span class="keyword">where</span></span>
          h<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span><span class="skolem">S</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="skolem">C</span> <span class="skolem">h</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">⊆</span> <span class="skolem">h</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="main">(</span><span class="skolem">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">h</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> agree_iff_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> 3<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>graph_homomorphism_def<span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> h<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>wpc_combo <span class="skolem">S</span> <span class="skolem">t</span> <span class="skolem">Rs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> ps<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span><span class="main">.</span> <span class="main">∃</span><span class="bound">S'</span><span class="main">.</span> <span class="bound">S'</span> <span class="main">0</span> <span class="main">=</span> <span class="skolem">S</span> <span class="bound">i</span> <span class="main">∧</span>
         chain_sup <span class="bound">S'</span> <span class="main">=</span> <span class="skolem">S</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="main">∧</span>
         WPC <span class="skolem">t</span> <span class="skolem">Rs</span> <span class="bound">S'</span> <span class="main">∧</span>
         least <span class="skolem">t</span> <span class="skolem">Rs</span> <span class="main">(</span><span class="bound">S'</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span>chain_sup <span class="bound">S'</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ch<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"chain <span class="skolem">S</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Simple_WPC_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">C</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> labeled_graph"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> cgC<span class="main">:</span><span class="quoted"><span class="quoted">"consequence_graph <span class="skolem">Rs</span> <span class="skolem">C</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span><span class="skolem">S</span> <span class="main">0</span><span class="main">,</span> chain_sup <span class="skolem">S</span><span class="main">)</span> <span class="skolem">C</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> extensible_from_chainI<span class="main"><span class="keyword3">,</span></span><span class="operator">goal_cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">f</span> <span class="skolem">g</span> <span class="skolem">i</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> ps<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"least <span class="skolem">t</span> <span class="skolem">Rs</span> <span class="main">(</span><span class="skolem">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">S</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> cgC <span class="keyword1"><span class="command">have</span></span> ss<span class="main">:</span><span class="quoted"><span class="quoted">"subgraph <span class="main">(</span><span class="skolem">S</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">S</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span><span class="skolem">S</span> <span class="skolem">i</span><span class="main">,</span> <span class="skolem">S</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="skolem">C</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> least_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> ss<span class="main">(</span>2<span class="main">)</span> 3<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span><span class="skolem">S</span> <span class="skolem">i</span><span class="main">,</span> <span class="skolem">S</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="skolem">C</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> extensible_def prod.sel<span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 4.›</span></span>
<span class="keyword1" id="RulesAndChains-wpc_least_consequence_graph"><span class="command">lemma</span></span> wpc_least_consequence_graph<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"WPC <span class="free">t</span> <span class="free">Rs</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"consequence_graph <span class="free">Rs</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"least_consequence_graph <span class="free">t</span> <span class="free">Rs</span> <span class="main">(</span><span class="free">S</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span>chain_sup <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> wpc_least assms <span class="keyword1"><span class="command">unfolding</span></span> least_consequence_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="GraphRewriting">
<div class="head">
<h1>Theory GraphRewriting</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Graph rewriting and saturation›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Here we describe graph rewriting, again without connecting it to semantics.›</span></span>
<span class="keyword1"><span class="command">theory</span></span> GraphRewriting
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="RulesAndChains.html">RulesAndChains</a> 
    <span class="quoted">"<a href="../../HOL/HOL-Library/Infinite_Set.html">HOL-Library.Infinite_Set</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* Algorithm 1 on page 16 *)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To describe Algorithm 1, we give a single step instead of the recursive call.
This allows us to reason about its effect without dealing with non-termination.
We define a worklist, saying what work can be done.
A valid selection needs to be made in order to ensure fairness.
To do a step, we define the function extend, and use it in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">make_step</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
A function that always makes a valid selection is used in this step. ›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">graph_of</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">graph_of</span> <span class="main">≡</span> <span class="main">λ</span> <span class="bound">X</span><span class="main">.</span> LG <span class="main">(</span>snd <span class="bound">X</span><span class="main">)</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>fst <span class="bound">X</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">nextMax</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set <span class="main">⇒</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nextMax</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> Suc <span class="main">(</span>Max <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="GraphRewriting-nextMax_max"><span class="command">lemma</span></span> nextMax_max<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">&lt;</span> nextMax <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≤</span> nextMax <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Max.coboundedI<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> nextMax_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">worklist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> nat <span class="main">×</span> nat<span class="main">)</span> set
           <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> labeled_graph <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> labeled_graph<span class="main">)</span> set
              <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_PreRule <span class="main">×</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">×</span> nat<span class="main">)</span> set<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">worklist</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="bound">G</span> <span class="main">=</span> graph_of <span class="free"><span class="bound"><span class="entity">G</span></span></span>
  <span class="keyword1">in</span> <span class="main">{</span><span class="main">(</span><span class="bound">N</span><span class="main">,</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="bound">R</span><span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="main">∧</span> graph_homomorphism <span class="main">(</span>fst <span class="bound">R</span><span class="main">)</span> <span class="bound">G</span> <span class="bound">f</span> <span class="main">∧</span> <span class="bound">N</span> <span class="main">=</span> nextMax <span class="main">(</span>Range <span class="bound">f</span><span class="main">)</span>
                 <span class="main">∧</span> <span class="main">¬</span> extensible <span class="bound">R</span> <span class="bound">G</span> <span class="bound">f</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_selection</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">valid_selection</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span>
  <span class="keyword1">let</span> <span class="bound">wl</span> <span class="main">=</span> worklist <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="keyword1">in</span>
    <span class="main">(</span>nextMax <span class="main">(</span>Range <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="bound">wl</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span> <span class="main">(</span><span class="bound">N</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">∈</span> <span class="bound">wl</span><span class="main">.</span> <span class="bound">N</span> <span class="main">≥</span> nextMax <span class="main">(</span>Range <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
    graph_rule <span class="free"><span class="bound"><span class="entity">R</span></span></span>"</span></span>

<span class="keyword1" id="GraphRewriting-valid_selection_exists"><span class="command">lemma</span></span> valid_selection_exists<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"worklist <span class="free">G</span> <span class="free">Rs</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
          <span class="quoted"><span class="quoted">"set_of_graph_rules <span class="free">Rs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">L</span> <span class="bound">R</span> <span class="bound">f</span><span class="main">.</span> valid_selection <span class="free">Rs</span> <span class="free">G</span> <span class="bound">R</span> <span class="bound">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">wl</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">wl</span> <span class="main">=</span> worklist <span class="free">G</span> <span class="free">Rs</span>"</span></span> <span class="keyword1"><span class="command">hence</span></span> wl_ne<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">wl</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?N</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">LEAST</span> <span class="bound">N</span><span class="main">.</span> <span class="bound">N</span> <span class="main">∈</span> Domain <span class="skolem">wl</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> wl_ne <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">N</span><span class="main">.</span> <span class="bound">N</span> <span class="main">∈</span> Domain <span class="skolem">wl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> LeastI2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?N</span> <span class="main">∈</span> Domain <span class="skolem">wl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">L</span></span> <span class="skolem"><span class="skolem">R</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> NLRf<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?N</span><span class="main">,</span><span class="main">(</span><span class="skolem">L</span><span class="main">,</span><span class="skolem">R</span><span class="main">)</span><span class="main">,</span><span class="skolem">f</span><span class="main">)</span><span class="main">∈</span><span class="skolem">wl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> N_def<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="var">?N</span> <span class="main">=</span> nextMax <span class="main">(</span>Range <span class="skolem">f</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> in_Rs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">L</span><span class="main">,</span><span class="skolem">R</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> wl_def worklist_def Let_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> Least_le wl_ne Domain.intros case_prodI2 
  <span class="keyword1"><span class="command">have</span></span> min<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="main">(</span><span class="bound">N'</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">wl</span><span class="main">.</span> <span class="bound">N'</span> <span class="main">≥</span> <span class="var">?N</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> in_Rs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite_graph <span class="skolem">R</span>"</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="skolem">L</span> <span class="skolem">R</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> set_of_graph_rules_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> min NLRf N_def <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> wl_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> valid_selection_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_selector</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">valid_selector</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">selector</span></span></span> <span class="main">≡</span> <span class="main">∀</span> <span class="bound">G</span><span class="main">.</span>
   <span class="main">(</span>worklist <span class="bound">G</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span> <span class="main">(</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">∈</span>UNIV<span class="main">.</span> <span class="free"><span class="bound"><span class="entity">selector</span></span></span> <span class="bound">G</span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span>
                               <span class="main">∧</span> valid_selection <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="bound">G</span> <span class="bound">R</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
   <span class="main">(</span>worklist <span class="bound">G</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">selector</span></span></span> <span class="bound">G</span> <span class="main">=</span> None<span class="main">)</span>"</span></span>

<span class="keyword1" id="GraphRewriting-valid_selectorD"><span class="command">lemma</span></span> valid_selectorD<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_selector <span class="free">Rs</span> <span class="free">selector</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"worklist <span class="free">G</span> <span class="free">Rs</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> <span class="free">selector</span> <span class="free">G</span> <span class="main">=</span> None"</span></span>
        <span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="free">G</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">R</span><span class="main">,</span><span class="free">f</span><span class="main">)</span> <span class="main">⟹</span> valid_selection <span class="free">Rs</span> <span class="free">G</span> <span class="free">R</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> valid_selector_def<span class="main">,</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="free">G</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"worklist <span class="free">G</span> <span class="free">Rs</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following gives a valid selector.
      This selector is not useful as concrete implementation, because it used the choice operation.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">non_constructive_selector</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">non_constructive_selector</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="bound">wl</span> <span class="main">=</span> worklist <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="keyword1">in</span>
   <span class="keyword1">if</span> <span class="bound">wl</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span><span class="keyword1">SOME</span> <span class="main">(</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> valid_selection <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="bound">R</span> <span class="bound">f</span><span class="main">)</span> "</span></span>

<span class="keyword1" id="GraphRewriting-non_constructive_selector"><span class="command">lemma</span></span> non_constructive_selector<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set_of_graph_rules <span class="free">Rs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid_selector <span class="free">Rs</span> <span class="main">(</span>non_constructive_selector <span class="free">Rs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> valid_selector_def <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="main">(</span><span class="operator">clarify</span><span class="main"><span class="keyword3">,</span></span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span><span class="operator">clarify</span><span class="main">)</span><span class="main"><span class="keyword3">,</span></span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">n</span> <span class="skolem">E</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?x</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">SOME</span> <span class="main">(</span><span class="bound">R</span><span class="main">,</span> <span class="bound">f</span><span class="main">)</span><span class="main">.</span> valid_selection <span class="free">Rs</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">E</span><span class="main">)</span> <span class="bound">R</span> <span class="bound">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> valid_selection_exists<span class="main">[</span><span class="operator">OF</span> 1 assms<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">R</span> <span class="bound">f</span><span class="main">.</span> valid_selection <span class="free">Rs</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">E</span><span class="main">)</span> <span class="bound">R</span> <span class="bound">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">x</span><span class="main">.</span> valid_selection <span class="free">Rs</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">E</span><span class="main">)</span> <span class="main">(</span>fst <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> this prod.case_eq_if tfl_some
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> valid_selection <span class="free">Rs</span> <span class="main">(</span><span class="skolem">n</span><span class="main">,</span> <span class="skolem">E</span><span class="main">)</span> <span class="main">(</span>fst <span class="var">?x</span><span class="main">)</span> <span class="main">(</span>snd <span class="var">?x</span><span class="main">)</span> <span class="main">⟹</span> False"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> non_constructive_selector_def Let_def <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>prod_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>non_constructive_selector_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following is used to make a weak pushout step.
      In the paper, we aren't too specific on how this should be done. Here we are.
      We work on natural numbers in order to be able to pick fresh elements easily. ›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">extend</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">::</span>linorder<span class="main">)</span> Graph_PreRule  <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> nat<span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> nat<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">extend</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∪</span> 
   <span class="main">(</span><span class="keyword1">let</span> <span class="bound">V_new</span> <span class="main">=</span> sorted_list_of_set <span class="main">(</span>vertices <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="main">-</span> vertices <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1">in</span> set <span class="main">(</span>zip <span class="bound">V_new</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">..&lt;</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">+</span>length <span class="bound">V_new</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="GraphRewriting-nextMax_set"><span class="command">lemma</span></span> nextMax_set<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nextMax <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">xs</span> <span class="main">=</span> Nil <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> Suc <span class="main">(</span>last <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> nextMax_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">list</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">list</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> fold max <span class="skolem">list</span> <span class="skolem">a</span> <span class="main">=</span> last <span class="skolem">list</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> list_sorted_max <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> last.simps<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> nextMax_def Max.set_eq_fold <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GraphRewriting-nextMax_Un_eq"><span class="command">lemma</span></span> nextMax_Un_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"finite <span class="free">x</span> <span class="main">⟹</span> finite <span class="free">y</span> <span class="main">⟹</span> nextMax <span class="main">(</span><span class="free">x</span> <span class="main">∪</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> max <span class="main">(</span>nextMax <span class="free">x</span><span class="main">)</span> <span class="main">(</span>nextMax <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nextMax_def <span class="keyword1"><span class="command">using</span></span> Max_Un <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="GraphRewriting-extend"><span class="command">lemma</span></span> extend<span class="main">:</span> <span class="comment1">(* extensible into the new graph *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="main">(</span>LG <span class="free">E</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">)</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"graph_rule <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">≡</span> extend <span class="free">n</span> <span class="free">R</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">G'</span> <span class="main">≡</span> LG <span class="main">(</span><span class="main">(</span>on_triple <span class="free">g</span> <span class="main">``</span> <span class="main">(</span>edges <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="free">E</span><span class="main">)</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>max <span class="free">n</span> <span class="main">(</span>nextMax <span class="main">(</span>Range <span class="free">g</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="free">G'</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊆</span> <span class="free">g</span>"</span></span>
        <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>LG <span class="free">E</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">)</span> <span class="free">G'</span>"</span></span>
        <span class="quoted"><span class="quoted">"weak_universal <span class="main">(</span><span class="free">t</span><span class="main">::</span> <span class="tfree">'x</span> itself<span class="main">)</span> <span class="free">R</span> <span class="main">(</span>LG <span class="free">E</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">)</span> <span class="free">G'</span> <span class="free">f</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> ln<span class="main">:</span><span class="quoted"><span class="quoted">"length <span class="skolem">x</span> <span class="main">=</span> length <span class="main">[</span><span class="free">n</span><span class="main">..&lt;</span><span class="free">n</span> <span class="main">+</span> length <span class="skolem">x</span><span class="main">]</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R_L</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"vertices <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="main">-</span> vertices <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_rule <span class="main">(</span>fst <span class="free">R</span><span class="main">,</span>snd <span class="free">R</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> fin_R<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="main">(</span>vertices <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> subsLR<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> gr_R<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def graph_union_iff
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> fin_R_L<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="var">?R_L</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> fin_L<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="main">(</span>vertices <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">using</span></span> finite_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> f_dom<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="free">f</span> <span class="main">=</span> vertices <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> f_uni<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> vertices <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="main">(</span>LG <span class="free">E</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> f_ran<span class="main">:</span><span class="quoted"><span class="quoted">"Range <span class="free">f</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f_dom <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?g</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">let</span> <span class="bound">V_new</span> <span class="main">=</span> sorted_list_of_set <span class="var">?R_L</span>
              <span class="keyword1">in</span> set <span class="main">(</span>zip <span class="bound">V_new</span> <span class="main">[</span><span class="free">n</span><span class="main">..&lt;</span><span class="free">n</span> <span class="main">+</span> length <span class="bound">V_new</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="comment1">(* new part of g *)</span>
  <span class="keyword1"><span class="command">have</span></span> fin_g'<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="var">?g</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Range <span class="var">?g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Let_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Domain <span class="free">f</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> fin_L
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> fin_f<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="main">(</span>Range <span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Range_snd <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> fin_g<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="main">(</span>Range <span class="free">g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> extend_def g_def Let_def Range_Un_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> nextMax_f<span class="main">:</span><span class="quoted"><span class="quoted">"nextMax <span class="main">(</span>Range <span class="free">f</span><span class="main">)</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> f_ran Max_in<span class="main">[</span><span class="operator">OF</span> fin_f<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>nextMax_def Suc_leI subset_eq<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Domain <span class="var">?g</span> <span class="main">⟹</span> <span class="skolem">x</span> <span class="main">∉</span> Domain <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">unfolding</span></span> f_dom Let_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> g_not_f<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?g</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∉</span> <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> uni_g'<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="var">?g</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="main">(</span>converse <span class="var">?g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Let_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> f_uni <span class="keyword1"><span class="command">have</span></span> uni_g<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>g_def extend_def g_not_f<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> fin_g <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="main">⟹</span> <span class="skolem">b</span> <span class="main">&lt;</span> Suc <span class="main">(</span>Max <span class="main">(</span>Range <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
    <span class="keyword1"><span class="command">unfolding</span></span> less_Suc_eq_le <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Max.coboundedI<span class="main">)</span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="main">⟹</span> <span class="skolem">b</span> <span class="main">&lt;</span> nextMax <span class="main">(</span>Range <span class="free">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
    <span class="keyword1"><span class="command">unfolding</span></span> nextMax_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"Range <span class="free">g</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> in_g<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span> <span class="main">⟹</span> <span class="skolem">b</span> <span class="main">&lt;</span> max <span class="free">n</span> <span class="main">(</span>nextMax <span class="main">(</span>Range <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"LG <span class="free">E</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> gr_G<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="var">?G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">aa</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">E</span> <span class="main">⟹</span> <span class="skolem">b</span> <span class="main">&lt;</span> max <span class="free">n</span> <span class="skolem">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">aa</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">E</span> <span class="main">⟹</span> <span class="skolem">aa</span> <span class="main">&lt;</span> max <span class="free">n</span> <span class="skolem">c</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">aa</span> <span class="skolem">b</span> <span class="skolem">c</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">hence</span></span> gr_G'<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> G'_def restrict_def <span class="keyword1"><span class="command">using</span></span> in_g <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>LG <span class="free">E</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">)</span> <span class="free">G'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def2<span class="main">[</span><span class="operator">OF</span> gr_G gr_G'<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> G'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> g_dom<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="main">=</span> Domain <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> subsLR
    <span class="keyword1"><span class="command">unfolding</span></span> g_def extend_def Domain_Un_eq f_dom <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="free">G'</span> <span class="free">g</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> graph_homomorphismI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> g_dom _ uni_g _ gr_R gr_G'<span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>G'_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>in_g<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊆</span> <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>g_def extend_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f_dom uni_g agree_on_subset equalityE <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"weak_universal <span class="free">t</span> <span class="free">R</span> <span class="var">?G</span> <span class="free">G'</span> <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">×</span> <span class="tfree">'x</span><span class="main">)</span> set"</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">b</span> <span class="skolem">G</span>
    <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="skolem">G</span> <span class="skolem">a</span>"</span></span>
             <span class="quoted"><span class="quoted">"graph_homomorphism <span class="var">?G</span> <span class="skolem">G</span> <span class="skolem">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="keyword1">O</span> <span class="skolem">b</span> <span class="main">⊆</span> <span class="skolem">a</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> univ_b<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="skolem">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> univ_a<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="skolem">a</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> rng_b<span class="main">:</span><span class="quoted"><span class="quoted">"Range <span class="skolem">b</span> <span class="main">⊆</span> vertices <span class="skolem">G</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> rng_a<span class="main">:</span><span class="quoted"><span class="quoted">"Range <span class="skolem">a</span> <span class="main">⊆</span> vertices <span class="skolem">G</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> ep_b<span class="main">:</span><span class="quoted"><span class="quoted">"edge_preserving <span class="skolem">b</span> <span class="main">(</span>edges <span class="main">(</span>LG <span class="free">E</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="skolem">G</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> ep_a<span class="main">:</span><span class="quoted"><span class="quoted">"edge_preserving <span class="skolem">a</span> <span class="main">(</span>edges <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="skolem">G</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def prod.sel labeled_graph.sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">from</span></span> a <span class="keyword1"><span class="command">have</span></span> dom_b<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="skolem">b</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> dom_a<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="skolem">a</span> <span class="main">=</span> vertices <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> v6<span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="skolem">G</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def prod.sel labeled_graph.sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">have</span></span> help_dom_b<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">b</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">≤</span> <span class="skolem">y</span> <span class="main">⟹</span> False"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="keyword1"><span class="command">using</span></span> dom_b
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Domain.DomainI atLeastLessThan_iff not_less<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> disj_doms<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="skolem">b</span> <span class="main">∩</span> Domain <span class="main">(</span><span class="var">?g</span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> help_dom_b
      <span class="keyword1"><span class="command">unfolding</span></span> Let_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>set_zip_leftD<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"max <span class="free">n</span> <span class="main">(</span>nextMax <span class="main">(</span>Range <span class="var">?g</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">n</span> <span class="main">+</span> length <span class="main">(</span>sorted_list_of_set <span class="var">?R_L</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?len</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> Let_def Range_snd set_map<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> map_snd_zip<span class="main">[</span><span class="operator">OF</span> ln<span class="main">]</span> nextMax_set<span class="main">[</span><span class="operator">OF</span> sorted_upt<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> length_sorted_list_of_set<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> n_eq<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="var">?len</span> <span class="main">=</span> max <span class="free">n</span> <span class="main">(</span>nextMax <span class="main">(</span>Range <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> Range_snd<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> g_def extend_def Range_Un_eq
                nextMax_Un_eq<span class="main">[</span><span class="operator">OF</span> fin_f fin_g'<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> max.assoc<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> max_absorb1<span class="main">[</span><span class="operator">OF</span> nextMax_f<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?h</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∪</span> <span class="var">?g</span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">a</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> dg<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="main">(</span><span class="var">?g</span><span class="main">¯</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">n</span><span class="main">..&lt;</span>max <span class="free">n</span> <span class="main">(</span>nextMax <span class="main">(</span>Range <span class="free">g</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> Let_def Domain_converse Range_set_zip<span class="main">[</span><span class="operator">OF</span> ln<span class="main">]</span> atLeastLessThan_upt
      <span class="keyword1"><span class="command">unfolding</span></span> Range_snd n_eq <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?g</span> <span class="main">``</span> Domain <span class="skolem">a</span> <span class="main">=</span> <span class="var">?g</span> <span class="main">``</span> <span class="main">(</span><span class="var">?R_L</span> <span class="main">∪</span> vertices <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> dom_a subsLR <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?g</span> <span class="main">``</span> <span class="var">?R_L</span> <span class="main">∪</span> <span class="var">?g</span> <span class="main">``</span> vertices <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?g</span> <span class="main">``</span> vertices <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Image_outside_Domain<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> Let_def Domain_set_zip<span class="main">[</span><span class="operator">OF</span> ln<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?g</span> <span class="main">``</span> <span class="var">?R_L</span> <span class="main">=</span> Range <span class="var">?g</span>"</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Image_Domain<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> Let_def Domain_set_zip<span class="main">[</span><span class="operator">OF</span> ln<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> dg2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="var">?g</span> <span class="main">``</span> Domain <span class="skolem">a</span> <span class="main">=</span> <span class="main">{</span><span class="free">n</span><span class="main">..&lt;</span>max <span class="free">n</span> <span class="main">(</span>nextMax <span class="main">(</span>Range <span class="free">g</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> Let_def Range_set_zip<span class="main">[</span><span class="operator">OF</span> ln<span class="main">]</span> set_sorted_list_of_set<span class="main">[</span><span class="operator">OF</span> fin_R_L<span class="main">]</span> 
      <span class="keyword1"><span class="command">unfolding</span></span> n_eq set_upt <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Domain <span class="main">(</span><span class="var">?g</span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">n</span><span class="main">..&lt;</span>max <span class="free">n</span> <span class="main">(</span>nextMax <span class="main">(</span>Range <span class="free">g</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> Domain_id_on converse_converse dg dg2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> v1<span class="main">:</span> <span class="quoted"><span class="quoted">"vertices <span class="free">G'</span> <span class="main">=</span> Domain <span class="var">?h</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> G'_def Domain_Un_eq dom_b <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">``</span> vertices <span class="free">G'</span> <span class="main">⊆</span> vertices <span class="skolem">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?g</span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">``</span> vertices <span class="free">G'</span> <span class="main">⊆</span> vertices <span class="skolem">G</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> rng_a rng_b <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> v2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?h</span> <span class="main">``</span> vertices <span class="free">G'</span> <span class="main">⊆</span> vertices <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> v3<span class="main">:</span> <span class="quoted"><span class="quoted">"univalent <span class="var">?h</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> disj_doms univalent_union<span class="main">[</span><span class="operator">OF</span> univ_b univalent_composes<span class="main"><span class="main">[</span></span><span class="operator">OF</span> uni_g'<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> univ_a<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="comment1">(* showing edge preservation *)</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">x'</span> <span class="skolem">y'</span> <span class="keyword3"><span class="command">assume</span></span> a2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">x'</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?h</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">y'</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?h</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">x'</span><span class="main">,</span><span class="skolem">y'</span><span class="main">)</span> <span class="main">∈</span> edges <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="var">?G</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">with</span></span> gr_G<span class="main">[</span><span class="operator">THEN</span> restrictD<span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Domain <span class="skolem">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> Domain <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> dom_b <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> Domain <span class="main">(</span>converse <span class="var">?g</span> <span class="keyword1">O</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> Domain <span class="main">(</span>converse <span class="var">?g</span> <span class="keyword1">O</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> disj_doms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">x'</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">y'</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> ep_b True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="keyword1">O</span> <span class="var">?h</span> <span class="main">=</span> <span class="free">f</span> <span class="keyword1">O</span> <span class="skolem">b</span> <span class="main">∪</span> <span class="var">?g</span> <span class="keyword1">O</span> <span class="skolem">b</span> <span class="main">∪</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">O</span> <span class="var">?g</span><span class="main">¯</span><span class="main">)</span> <span class="keyword1">O</span> <span class="skolem">a</span> <span class="main">∪</span> <span class="main">(</span><span class="var">?g</span> <span class="keyword1">O</span> <span class="var">?g</span><span class="main">¯</span><span class="main">)</span> <span class="keyword1">O</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> g_def extend_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?g</span> <span class="keyword1">O</span> <span class="var">?g</span><span class="main">¯</span><span class="main">)</span> <span class="main">=</span> Id_on <span class="var">?R_L</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> univalent_O_converse<span class="main">[</span><span class="operator">OF</span> uni_g'<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> Let_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="keyword1">O</span> <span class="var">?g</span><span class="main">¯</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f_ran <span class="keyword1"><span class="command">unfolding</span></span> Let_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>set_zip_leftD<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?g</span> <span class="keyword1">O</span> <span class="skolem">b</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> help_dom_b <span class="keyword1"><span class="command">unfolding</span></span> Let_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>set_zip_rightD<span class="main">)</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> gOh<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="keyword1">O</span> <span class="var">?h</span> <span class="main">⊆</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> on_triple <span class="free">g</span> <span class="main">``</span> edges <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a2<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> G'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r_x</span></span> <span class="skolem"><span class="skolem">r_y</span></span>
          <span class="keyword2"><span class="keyword">where</span></span> r<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">r_x</span><span class="main">,</span><span class="skolem">r_y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">r_x</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">r_y</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">r_x</span><span class="main">,</span><span class="skolem">x'</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">r_y</span><span class="main">,</span><span class="skolem">y'</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gOh a2<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">x'</span><span class="main">,</span><span class="skolem">y'</span><span class="main">)</span> <span class="main">∈</span> on_triple <span class="skolem">a</span> <span class="main">``</span> edges <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> r<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> on_triple_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ep_a <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">hence</span></span> v4<span class="main">:</span> <span class="quoted"><span class="quoted">"edge_preserving <span class="var">?h</span> <span class="main">(</span>edges <span class="free">G'</span><span class="main">)</span> <span class="main">(</span>edges <span class="skolem">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">G'</span> <span class="skolem">G</span> <span class="var">?h</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> graph_homomorphismI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> v1 v2 v3 v4 gr_G' v6<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">h</span><span class="main">.</span> graph_homomorphism <span class="free">G'</span> <span class="skolem">G</span> <span class="bound">h</span> <span class="main">∧</span> <span class="skolem">b</span> <span class="main">⊆</span> <span class="bound">h</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Showing that the extend function indeed creates a valid pushout.›</span></span>
<span class="keyword1" id="GraphRewriting-selector_pushout"><span class="command">lemma</span></span> selector_pushout<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_selector <span class="free">Rs</span> <span class="free">selector</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="free">G''</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">R</span><span class="main">,</span><span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">≡</span> graph_of <span class="free">G''</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">≡</span> extend <span class="main">(</span>fst <span class="free">G''</span><span class="main">)</span> <span class="free">R</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">G'</span> <span class="main">≡</span> LG <span class="main">(</span>on_triple <span class="free">g</span> <span class="main">``</span> edges <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>snd <span class="free">G''</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>max <span class="main">(</span>fst <span class="free">G''</span><span class="main">)</span> <span class="main">(</span>nextMax <span class="main">(</span>Range <span class="free">g</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pushout_step <span class="main">(</span><span class="free">t</span><span class="main">::</span> <span class="tfree">'x</span> itself<span class="main">)</span> <span class="free">R</span> <span class="free">G</span> <span class="free">G'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"valid_selection <span class="free">Rs</span> <span class="free">G''</span> <span class="free">R</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="free">G''</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> igh<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"graph_rule <span class="free">R</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> valid_selection_def worklist_def G_def Let_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">G</span> <span class="free">G'</span>"</span></span>
       <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span>"</span></span>
       <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="free">G'</span> <span class="free">g</span>"</span></span>
       <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊆</span> <span class="free">g</span>"</span></span>
       <span class="quoted"><span class="quoted">"weak_universal <span class="free">t</span> <span class="free">R</span> <span class="free">G</span> <span class="free">G'</span> <span class="free">f</span> <span class="free">g</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> extend<span class="main">[</span><span class="operator">OF</span> igh<span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span></span></span><span class="operator"><span class="operator"><span class="operator"><span class="operator"><span class="operator">unfolded</span></span></span></span></span> G_def<span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span></span></span><span class="main">,</span><span class="operator">folded</span> g_def<span class="main">,</span><span class="operator">folded</span> G'_def<span class="main">,</span><span class="operator">folded</span> G_def<span class="main">]</span> igh<span class="main">(</span>1<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> pushout_step_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Making a single step in Algorithm 1.
  A prerequisite is that its first argument is a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">valid_selector</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">make_step</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">make_step</span> <span class="free"><span class="bound"><span class="entity">selector</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">≡</span>
   <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">selector</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="keyword1">of</span>
     None <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">|</span>
     Some <span class="main">(</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">g</span> <span class="main">=</span> extend <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span> <span class="bound">R</span> <span class="bound">f</span> <span class="keyword1">in</span>
         <span class="main">(</span>max <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span> <span class="main">(</span>nextMax <span class="main">(</span>Range <span class="bound">g</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>on_triple <span class="bound">g</span> <span class="main">``</span> <span class="main">(</span>edges <span class="main">(</span>snd <span class="bound">R</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="GraphRewriting-WPC_through_make_step"><span class="command">lemma</span></span> WPC_through_make_step<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set_of_graph_rules <span class="free">Rs</span>"</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> makestep<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">i</span><span class="main">.</span> <span class="free">X</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> make_step <span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> selector<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_selector <span class="free">Rs</span> <span class="free">selector</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Simple_WPC <span class="free">t</span> <span class="free">Rs</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> graph_of <span class="main">(</span><span class="free">X</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"chain <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> graph_of <span class="main">(</span><span class="free">X</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">note</span></span> ms <span class="main">=</span> makestep<span class="main">[</span><span class="operator">unfolded</span> make_step_def<span class="main">,</span><span class="operator">rule_format</span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="skolem">i</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> None
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ms Suc <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">a</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">R</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> Some<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">R</span><span class="main">,</span><span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ms<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">,</span><span class="operator">unfolded</span> Some Let_def<span class="main">]</span>
        selector_pushout<span class="main">[</span><span class="operator">OF</span> selector Some Suc<span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="free">t</span></span>
                        <span class="main">,</span><span class="operator">unfolded</span> pushout_step_def subgraph_def<span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"chain <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> graph_of <span class="main">(</span><span class="free">X</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> chain_def
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">clarify</span><span class="main">)</span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="skolem">i</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> None
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ms gr <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>graph_homomorphismI<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> Some
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">R</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> Some<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">R</span><span class="main">,</span><span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ms selector_pushout<span class="main">[</span><span class="operator">OF</span> selector Some gr<span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> pushout_step_def Let_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"graph_of <span class="main">(</span><span class="free">X</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> graph_of <span class="main">(</span><span class="free">X</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span>
         <span class="main">(</span><span class="main">∃</span><span class="bound">R</span><span class="main">∈</span><span class="free">Rs</span><span class="main">.</span> pushout_step <span class="free">t</span> <span class="bound">R</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="skolem">i</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> None <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> Some
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">R</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> Some<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">R</span><span class="main">,</span><span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="main">∈</span> <span class="free">Rs</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> valid_selectorD<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> selector<span class="main">,</span><span class="operator">unfolded</span> valid_selection_def worklist_def Let_def<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">R</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">blast</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ms<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">,</span><span class="operator">unfolded</span> Some Let_def<span class="main">]</span> selector_pushout<span class="main">[</span><span class="operator">OF</span> selector Some gr<span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> make_step_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="GraphRewriting-N_occurs_finitely_often"><span class="command">lemma</span></span> N_occurs_finitely_often<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">Rs</span>"</span></span> <span class="quoted"><span class="quoted">"set_of_graph_rules <span class="free">Rs</span>"</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> makestep<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span><span class="main">.</span> <span class="free">X</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> make_step <span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> selector<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_selector <span class="free">Rs</span> <span class="free">selector</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="main">(</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">R</span><span class="main">∈</span> <span class="free">Rs</span> <span class="main">∧</span> graph_homomorphism <span class="main">(</span>fst <span class="bound">R</span><span class="main">)</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="bound">f</span>
                        <span class="main">∧</span> nextMax <span class="main">(</span>Range <span class="bound">f</span><span class="main">)</span> <span class="main">≤</span> <span class="free">N</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="main">(</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span><span class="var">?P</span> <span class="bound">R</span> <span class="bound">f</span><span class="main">}</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> prod_eq <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="bound">x</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="skolem">A</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">}</span><span class="main">.</span> <span class="skolem">B</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> <span class="skolem">A</span> <span class="main">(</span>fst <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="skolem">B</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">∈</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="skolem">A</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">}</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="skolem">A</span> <span class="main">(</span>fst <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>snd <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="skolem">B</span> <span class="skolem">x</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span><span class="var">?P</span> <span class="bound">R</span> <span class="bound">f</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Q</span> <span class="free">R</span> <span class="free">f</span>"</span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Domain <span class="free">f</span> <span class="main">=</span> vertices <span class="main">(</span>fst <span class="main">(</span><span class="free">R</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> Graph_PreRule<span class="main">)</span><span class="main">)</span> <span class="main">∧</span> univalent <span class="free">f</span> <span class="main">∧</span> nextMax <span class="main">(</span>Range <span class="free">f</span><span class="main">)</span> <span class="main">≤</span> <span class="free">N</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> seteq<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">R</span><span class="main">∈</span><span class="free">Rs</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">R'</span><span class="main">,</span> <span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="bound">R'</span> <span class="main">=</span> <span class="bound">R</span> <span class="main">∧</span> <span class="var">?Q</span> <span class="bound">R</span> <span class="bound">f</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="bound">R</span> <span class="main">∈</span> <span class="free">Rs</span> <span class="main">∧</span> <span class="var">?Q</span> <span class="bound">R</span> <span class="bound">f</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">R</span> <span class="main">∈</span> <span class="free">Rs</span><span class="main">.</span> finite <span class="main">{</span><span class="main">(</span><span class="bound">R'</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="bound">R'</span> <span class="main">=</span> <span class="bound">R</span> <span class="main">∧</span> <span class="var">?Q</span> <span class="bound">R</span> <span class="bound">f</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="main">∈</span> <span class="free">Rs</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> fin<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="main">(</span>vertices <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> fin2<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="main">(</span>Pow <span class="main">(</span>vertices <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span> <span class="main">×</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">N</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="skolem">x</span> <span class="main">=</span> vertices <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span> <span class="main">⟹</span> univalent <span class="skolem">x</span> <span class="main">⟹</span> finite <span class="main">(</span>snd <span class="main">`</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">×</span> nat<span class="main">)</span> set"</span></span> <span class="keyword1"><span class="command">using</span></span> fin univalent_finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Domain <span class="skolem">f</span> <span class="main">=</span> vertices <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span> <span class="main">⟹</span>
      univalent <span class="skolem">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span> <span class="main">⟹</span> nextMax <span class="main">(</span>Range <span class="skolem">f</span><span class="main">)</span> <span class="main">≤</span> <span class="free">N</span> <span class="main">⟹</span> <span class="skolem">b</span> <span class="main">≤</span> <span class="free">N</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">a</span> <span class="skolem">b</span>
      <span class="keyword1"><span class="command">unfolding</span></span> Range_snd <span class="keyword1"><span class="command">using</span></span> image_eqI nextMax_max<span class="main">(</span>2<span class="main">)</span> snd_conv order.trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">hence</span></span> sub<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">f</span><span class="main">.</span> <span class="var">?Q</span> <span class="skolem">R</span> <span class="bound">f</span><span class="main">}</span> <span class="main">⊆</span> Pow <span class="main">(</span>vertices <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span> <span class="main">×</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="free">N</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> nextMax_max<span class="main">[</span><span class="operator">OF</span> fin<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Range_snd image_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> sub fin2<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="main">(</span><span class="bound">R'</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="bound">R'</span> <span class="main">=</span> <span class="skolem">R</span> <span class="main">∧</span> <span class="var">?Q</span> <span class="skolem">R</span> <span class="bound">f</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">folded</span> finite_UN<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span><span class="operator">unfolded</span> seteq<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="main">(</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="bound">R</span> <span class="main">∈</span> <span class="free">Rs</span> <span class="main">∧</span> <span class="var">?Q</span> <span class="bound">R</span> <span class="bound">f</span><span class="main">}</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="skolem">R</span> <span class="skolem">f</span> <span class="main">⟹</span> <span class="skolem">R</span> <span class="main">∈</span> <span class="free">Rs</span> <span class="main">∧</span> <span class="var">?Q</span> <span class="skolem">R</span> <span class="skolem">f</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">(</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="bound">R</span> <span class="main">∈</span> <span class="free">Rs</span> <span class="main">∧</span> <span class="var">?Q</span> <span class="bound">R</span> <span class="bound">f</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> subset_eq prod_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> this fin<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GraphRewriting-inj_on_infinite"><span class="command">lemma</span></span> inj_on_infinite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"infinite <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"range <span class="free">f</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"infinite <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> infinite_iff_countable_subset<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span><span class="main">::</span><span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    g<span class="main">:</span><span class="quoted"><span class="quoted">"inj <span class="skolem">g</span> <span class="main">∧</span> range <span class="skolem">g</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> i<span class="main">:</span><span class="quoted"><span class="quoted">"inj <span class="main">(</span><span class="free">f</span> <span class="keyword1">o</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> comp_inj_on inj_on_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"range <span class="main">(</span><span class="free">f</span> <span class="keyword1">o</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> i <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> infinite_iff_countable_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GraphRewriting-makestep_makes_selector_inj"><span class="command">lemma</span></span> makestep_makes_selector_inj<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">R</span><span class="main">,</span><span class="free">f</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">R</span><span class="main">,</span><span class="free">f</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"valid_selector <span class="free">Rs</span> <span class="free">selector</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">i</span><span class="main">.</span> <span class="free">X</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> make_step <span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> chain<span class="main">:</span><span class="quoted"><span class="quoted">"chain <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> graph_of <span class="main">(</span><span class="free">X</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">y</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">x'</span></span> <span class="skolem"><span class="skolem">y'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">≡</span> min <span class="free">x</span> <span class="free">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">≡</span> max <span class="free">x</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> xy<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="skolem">x'</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">R</span><span class="main">,</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="skolem">y'</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">R</span><span class="main">,</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">&lt;</span> <span class="skolem">y'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> a <span class="keyword1"><span class="command">unfolding</span></span> min_def max_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> valid_selectorD assms
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"valid_selection <span class="free">Rs</span> <span class="main">(</span><span class="free">X</span> <span class="skolem">x'</span><span class="main">)</span> <span class="free">R</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"valid_selection <span class="free">Rs</span> <span class="main">(</span><span class="free">X</span> <span class="skolem">y'</span><span class="main">)</span> <span class="free">R</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> not_ex<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">¬</span> extensible <span class="free">R</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="skolem">y'</span><span class="main">)</span><span class="main">)</span> <span class="free">f</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> hom<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="skolem">x'</span><span class="main">)</span><span class="main">)</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"graph_rule <span class="free">R</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> valid_selection_def Let_def worklist_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> X<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">(</span>Suc <span class="skolem">x'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>max <span class="main">(</span>fst <span class="main">(</span><span class="free">X</span> <span class="skolem">x'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>nextMax <span class="main">(</span>Range <span class="main">(</span>extend <span class="main">(</span>fst <span class="main">(</span><span class="free">X</span> <span class="skolem">x'</span><span class="main">)</span><span class="main">)</span> <span class="free">R</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
          on_triple <span class="main">(</span>extend <span class="main">(</span>fst <span class="main">(</span><span class="free">X</span> <span class="skolem">x'</span><span class="main">)</span><span class="main">)</span> <span class="free">R</span> <span class="free">f</span><span class="main">)</span> <span class="main">``</span> edges <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="main">∪</span> snd <span class="main">(</span><span class="free">X</span> <span class="skolem">x'</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> step<span class="main">[</span><span class="operator">unfolded</span> make_step_def Let_def<span class="main">,</span><span class="operator">rule_format</span><span class="main">]</span> xy <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ex</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"extend <span class="main">(</span>fst <span class="main">(</span><span class="free">X</span> <span class="skolem">x'</span><span class="main">)</span><span class="main">)</span> <span class="free">R</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> hom<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="main">(</span>Suc <span class="skolem">x'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="var">?ex</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> agr<span class="main">:</span><span class="quoted"><span class="quoted">"agree_on <span class="main">(</span>fst <span class="free">R</span><span class="main">)</span> <span class="free">f</span> <span class="var">?ex</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> extend<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> hom<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> X <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> xy <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">x'</span> <span class="main">≤</span> <span class="skolem">y'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> chain<span class="main">[</span><span class="operator">unfolded</span> chain_def2<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="main">(</span>Suc <span class="skolem">x'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="skolem">y'</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> subgraph_preserves_hom<span class="main">[</span><span class="operator">OF</span> this hom<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> hom<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="free">R</span><span class="main">)</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="skolem">y'</span><span class="main">)</span><span class="main">)</span> <span class="var">?ex</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">with</span></span> agr <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"extensible <span class="free">R</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="skolem">y'</span><span class="main">)</span><span class="main">)</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> extensible_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> not_ex <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GraphRewriting-fair_through_make_step"><span class="command">lemma</span></span> fair_through_make_step<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">Rs</span>"</span></span> <span class="quoted"><span class="quoted">"set_of_graph_rules <span class="free">Rs</span>"</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
     <span class="comment1">(* It should suffice to take infinitely many make_steps, 
        rather than having every step be a make_step,
        but we focus on the algorithm as in the paper here *)</span>
     <span class="keyword2"><span class="keyword">and</span></span> makestep<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">i</span><span class="main">.</span> <span class="free">X</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> make_step <span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> selector<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_selector <span class="free">Rs</span> <span class="free">selector</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fair_chain <span class="free">Rs</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> graph_of <span class="main">(</span><span class="free">X</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> chn<span class="main">:</span><span class="quoted"><span class="quoted">"chain <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> graph_of <span class="main">(</span><span class="free">X</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> WPC_through_make_step assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="skolem">f</span> <span class="skolem">i</span>
  <span class="keyword3"><span class="command">assume</span></span> Rs<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="main">∈</span> <span class="free">Rs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> h<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="skolem">f</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> R<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="main">(</span>vertices <span class="main">(</span>snd <span class="skolem">R</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span> <span class="main">(</span>snd <span class="skolem">R</span><span class="main">)</span>"</span></span>  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>vertices <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Range <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Domain <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="skolem">f</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> h <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def Range_snd <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">N</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">N</span> <span class="main">≡</span> nextMax <span class="main">(</span>Range <span class="skolem">f</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="quoted"><span class="quoted">"<span class="var">?Q</span> <span class="free">X'</span> <span class="free">j</span>"</span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">" fst <span class="free">X'</span> <span class="main">∈</span> <span class="free">Rs</span>
                  <span class="main">∧</span> graph_homomorphism <span class="main">(</span>fst <span class="main">(</span>fst <span class="free">X'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="main">(</span><span class="free">j</span><span class="main">+</span><span class="skolem">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>snd <span class="free">X'</span><span class="main">)</span>
                  <span class="main">∧</span> nextMax <span class="main">(</span>Range <span class="main">(</span>snd <span class="free">X'</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">N</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound">j</span><span class="main">.</span> <span class="var">?Q</span> <span class="main">(</span><span class="bound">R</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span> <span class="bound">j</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">ia</span><span class="main">.</span> <span class="free">X</span> <span class="main">(</span>Suc <span class="bound">ia</span> <span class="main">+</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> make_step <span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="main">(</span><span class="bound">ia</span> <span class="main">+</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">note</span></span> r <span class="main">=</span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> chain_then_restrict<span class="main">[</span><span class="operator">OF</span> chn<span class="main">]</span> this assms<span class="main">(</span>5<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> N_occurs_finitely_often<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">Rs</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">j</span><span class="main">.</span> <span class="free">X</span> <span class="main">(</span><span class="bound">j</span> <span class="main">+</span> <span class="skolem">i</span><span class="main">)</span>"</span></span><span class="main">,</span><span class="operator">OF</span> r<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> fin_S<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="var">?S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">j</span><span class="main">.</span> <span class="main">¬</span> extensible <span class="skolem">R</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span> <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="free">X'</span> <span class="free">j</span>"</span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?Q</span> <span class="free">X'</span> <span class="free">j</span> <span class="main">∧</span> Some <span class="free">X'</span> <span class="main">=</span> <span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="main">(</span><span class="free">j</span><span class="main">+</span><span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">j</span> <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?j</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">+</span><span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?j</span> <span class="main">≥</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> subgraph_preserves_hom<span class="main">[</span><span class="operator">OF</span> chain<span class="main"><span class="main">[</span></span><span class="operator">OF</span> chn this<span class="main"><span class="main">]</span></span> h<span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> h<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="var">?j</span><span class="main">)</span><span class="main">)</span> <span class="skolem">f</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> extensible <span class="skolem">R</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="var">?j</span><span class="main">)</span><span class="main">)</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
      <span class="keyword1"><span class="command">with</span></span> h Rs <span class="keyword1"><span class="command">have</span></span> wl<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span>nextMax <span class="main">(</span>Range <span class="skolem">f</span><span class="main">)</span><span class="main">,</span><span class="skolem">R</span><span class="main">,</span><span class="skolem">f</span><span class="main">)</span> <span class="main">∈</span> worklist <span class="main">(</span><span class="free">X</span> <span class="var">?j</span><span class="main">)</span> <span class="free">Rs</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> worklist_def Let_def set_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"worklist <span class="main">(</span><span class="free">X</span> <span class="var">?j</span><span class="main">)</span> <span class="free">Rs</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> valid_selectorD<span class="main">[</span><span class="operator">OF</span> selector<span class="main">]</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">R'</span></span> <span class="skolem"><span class="skolem">f'</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> sel<span class="main">:</span><span class="quoted"><span class="quoted">"Some <span class="main">(</span><span class="skolem">R'</span><span class="main">,</span><span class="skolem">f'</span><span class="main">)</span> <span class="main">=</span> <span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="var">?j</span><span class="main">)</span>"</span></span>
                  <span class="quoted"><span class="quoted">"valid_selection <span class="free">Rs</span> <span class="main">(</span><span class="free">X</span> <span class="var">?j</span><span class="main">)</span> <span class="skolem">R'</span> <span class="skolem">f'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> max<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span>nextMax <span class="main">(</span>Range <span class="skolem">f'</span><span class="main">)</span><span class="main">,</span> <span class="skolem">R'</span><span class="main">,</span> <span class="skolem">f'</span><span class="main">)</span> <span class="main">∈</span> worklist <span class="main">(</span><span class="free">X</span> <span class="var">?j</span><span class="main">)</span> <span class="free">Rs</span>"</span></span>
                <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">N</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">∈</span>worklist <span class="main">(</span><span class="free">X</span> <span class="var">?j</span><span class="main">)</span> <span class="free">Rs</span><span class="main">.</span> nextMax <span class="main">(</span>Range <span class="skolem">f'</span><span class="main">)</span> <span class="main">≤</span> <span class="bound">N</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> valid_selection_def Let_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> wl <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nextMax <span class="main">(</span>Range <span class="skolem">f'</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">N</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> N_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> max<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> worklist_def Let_def mem_Collect_eq prod.case<span class="main">]</span> sel<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">X'</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">X'</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv snd_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ch</span></span> <span class="keyword2"><span class="keyword">where</span></span> ch<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">j</span><span class="main">.</span> <span class="var">?P</span> <span class="main">(</span><span class="skolem">ch</span> <span class="bound">j</span><span class="main">)</span> <span class="bound">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span> <span class="comment1">(* uses 'choice' internally *)</span>
    <span class="keyword1"><span class="command">have</span></span> inj<span class="main">:</span><span class="quoted"><span class="quoted">"inj <span class="skolem">ch</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ch</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">ch</span> <span class="skolem">y</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> ch<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> ch<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">+</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">ch</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">selector</span> <span class="main">(</span><span class="free">X</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">+</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">ch</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> makestep_makes_selector_inj<span class="main">[</span><span class="operator">OF</span> _ _ selector makestep chn<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">+</span> <span class="skolem">i</span> <span class="main">=</span> <span class="skolem">y</span> <span class="main">+</span> <span class="skolem">i</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">ch</span> <span class="skolem">x</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ch</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="var">?S</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">using</span></span> ch<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> mem_Collect_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> case_prodI2<span class="main">)</span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"range <span class="skolem">ch</span> <span class="main">⊆</span> <span class="var">?S</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> UNIV_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> image_Collect_subsetI<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> infinite_iff_countable_subset inj <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"infinite <span class="var">?S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> fin_S <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">j</span><span class="main">.</span> extensible <span class="skolem">R</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="free">X</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">mk_chain</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mk_chain</span> <span class="free"><span class="bound"><span class="entity">sel</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">init</span></span></span> <span class="main">0</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">init</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">mk_chain</span> <span class="free"><span class="bound"><span class="entity">sel</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">init</span></span></span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">mk_chain</span> <span class="free"><span class="bound"><span class="entity">sel</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="main">(</span>make_step <span class="free"><span class="bound"><span class="entity">sel</span></span></span> <span class="free"><span class="bound"><span class="entity">init</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>

<span class="keyword1" id="GraphRewriting-mk_chain"><span class="command">lemma</span></span> mk_chain<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">i</span><span class="main">.</span> mk_chain <span class="free">sel</span> <span class="free">Rs</span> <span class="free">init</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> make_step <span class="free">sel</span> <span class="main">(</span>mk_chain <span class="free">sel</span> <span class="free">Rs</span> <span class="free">init</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"mk_chain <span class="free">sel</span> <span class="free">Rs</span> <span class="free">init</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> make_step <span class="free">sel</span> <span class="main">(</span>mk_chain <span class="free">sel</span> <span class="free">Rs</span> <span class="free">init</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">i</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">init</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Algorithm 1, abstractly.›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">the_lcg</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">the_lcg</span> <span class="free"><span class="bound"><span class="entity">sel</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">init</span></span></span> <span class="main">≡</span> chain_sup <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> graph_of <span class="main">(</span>mk_chain <span class="free"><span class="bound"><span class="entity">sel</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">init</span></span></span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="GraphRewriting-mk_chain_edges"><span class="command">lemma</span></span> mk_chain_edges<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_selector <span class="free">Rules</span> <span class="free">sel</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">⋃</span> <span class="main">(</span><span class="main">(</span>edges <span class="keyword1">o</span> snd<span class="main">)</span> <span class="main">`</span> <span class="free">Rules</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">L</span> <span class="main">×</span> UNIV"</span></span>
          <span class="quoted"><span class="quoted">"edges <span class="main">(</span>graph_of <span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">L</span> <span class="main">×</span> UNIV"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>graph_of <span class="main">(</span>mk_chain <span class="free">sel</span> <span class="free">Rules</span> <span class="free">G</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">L</span> <span class="main">×</span> UNIV"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">i</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">G</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">i</span> <span class="skolem">G</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>graph_of <span class="main">(</span>make_step <span class="free">sel</span> <span class="skolem">G</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">L</span> <span class="main">×</span> UNIV"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">sel</span> <span class="skolem">G</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> None <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> None make_step_def <span class="keyword1"><span class="command">using</span></span> Suc <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">a</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">R</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> Some<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">sel</span> <span class="skolem">G</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">R</span><span class="main">,</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span>snd <span class="skolem">R</span><span class="main">)</span> <span class="main">⟹</span> <span class="skolem">a</span> <span class="main">∈</span> <span class="free">L</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">x</span> <span class="skolem">y</span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> valid_selectorD<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Some<span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> valid_selection_def Let_def worklist_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Some make_step_def Let_def <span class="keyword1"><span class="command">using</span></span> Suc <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> mk_chain.simps <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Suc<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GraphRewriting-the_lcg_edges"><span class="command">lemma</span></span> the_lcg_edges<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_selector <span class="free">Rules</span> <span class="free">sel</span>"</span></span>
          <span class="quoted"><span class="quoted">"fst <span class="main">`</span> <span class="main">(</span><span class="main">⋃</span> <span class="main">(</span><span class="main">(</span>edges <span class="keyword1">o</span> snd<span class="main">)</span> <span class="main">`</span> <span class="free">Rules</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">L</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">`</span><span class="var">?fR</span> <span class="main">⊆</span> <span class="main">_</span>"</span></span><span class="main">)</span>
          <span class="quoted"><span class="quoted">"fst <span class="main">`</span> snd <span class="free">G</span> <span class="main">⊆</span> <span class="free">L</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">`</span> edges <span class="main">(</span>the_lcg <span class="free">sel</span> <span class="free">Rules</span> <span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">L</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">`</span><span class="var">?fR</span> <span class="main">×</span> UNIV <span class="main">⊆</span> <span class="free">L</span> <span class="main">×</span> UNIV"</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">`</span><span class="main">(</span>edges <span class="main">(</span>graph_of <span class="free">G</span><span class="main">)</span><span class="main">)</span> <span class="main">×</span> UNIV <span class="main">⊆</span> <span class="free">L</span> <span class="main">×</span> UNIV"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span> <span class="main">(</span><span class="main">(</span>edges <span class="keyword1">o</span> snd<span class="main">)</span> <span class="main">`</span> <span class="free">Rules</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">L</span> <span class="main">×</span> UNIV"</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>graph_of <span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">L</span> <span class="main">×</span> UNIV"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fst_UNIV<span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?fR</span></span></span><span class="main">]</span> fst_UNIV<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>edges <span class="main">(</span>graph_of <span class="free">G</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">note</span></span> assms <span class="main">=</span> assms<span class="main">(</span>1<span class="main">)</span> this
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>graph_of <span class="main">(</span>mk_chain <span class="free">sel</span> <span class="free">Rules</span> <span class="free">G</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">L</span> <span class="main">×</span> UNIV"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span>
    <span class="keyword1"><span class="command">using</span></span> mk_chain_edges<span class="main">[</span><span class="operator">OF</span> assms<span class="main">,</span><span class="operator">unfolded</span> Times_subset_cancel2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> UNIV_I<span class="main"><span class="main">]</span></span><span class="main">]</span><span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>the_lcg <span class="free">sel</span> <span class="free">Rules</span> <span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">L</span> <span class="main">×</span> UNIV"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> chain_sup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 9.›</span></span>
<span class="keyword1" id="GraphRewriting-lcg_through_make_step"><span class="command">lemma</span></span> lcg_through_make_step<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">Rs</span>"</span></span> <span class="quoted"><span class="quoted">"set_of_graph_rules <span class="free">Rs</span>"</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>graph_of <span class="free">init</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"valid_selector <span class="free">Rs</span> <span class="free">sel</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"least_consequence_graph <span class="free">t</span> <span class="free">Rs</span> <span class="main">(</span>graph_of <span class="free">init</span><span class="main">)</span> <span class="main">(</span>the_lcg <span class="free">sel</span> <span class="free">Rs</span> <span class="free">init</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="main">(</span>graph_of <span class="main">(</span>mk_chain <span class="free">sel</span> <span class="free">Rs</span> <span class="free">init</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">note</span></span> assms <span class="main">=</span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> this mk_chain assms<span class="main">(</span>4<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> set_of_graph_rulesD<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span>2<span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">R</span><span class="main">.</span> <span class="bound">R</span> <span class="main">∈</span> <span class="free">Rs</span> <span class="main">⟹</span> subgraph <span class="main">(</span>fst <span class="bound">R</span><span class="main">)</span> <span class="main">(</span>snd <span class="bound">R</span><span class="main">)</span> <span class="main">∧</span> finite_graph <span class="main">(</span>fst <span class="bound">R</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> fair_chain_impl_consequence_graph<span class="main">[</span><span class="operator">OF</span> fair_through_make_step<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span> this<span class="main">]</span>
       wpc_simpl<span class="main">[</span><span class="operator">OF</span> WPC_through_make_step<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2-<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span><span class="operator">THEN</span> wpc_least<span class="main">]</span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> least_consequence_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="LabeledGraphSemantics">
<div class="head">
<h1>Theory LabeledGraphSemantics</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Semantics in labeled graphs›</span></span>

<span class="keyword1"><span class="command">theory</span></span> LabeledGraphSemantics
<span class="keyword2"><span class="keyword">imports</span></span> <a href="LabeledGraphs.html">LabeledGraphs</a>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹GetRel describes the main way we interpret graphs: as describing a set of binary relations.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">getRel</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">getRel</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1" id="LabeledGraphSemantics-getRel_dom"><span class="command">lemma</span></span> getRel_dom<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span> <span class="main">⟹</span> <span class="free">b</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphSemantics-getRel_subgraph"><span class="command">lemma</span></span> getRel_subgraph<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">G</span> <span class="free">G'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">z</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def subgraph_def graph_union_iff<span class="main">)</span>

<span class="keyword1" id="LabeledGraphSemantics-getRel_homR"><span class="command">lemma</span></span> getRel_homR<span class="main">:</span> <span class="comment1">(* slows down proofs in the common case *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">z</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="main">(</span>map_graph <span class="free">f</span> <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def on_triple_def<span class="main">)</span>

<span class="keyword1" id="LabeledGraphSemantics-getRel_hom"><span class="command">lemma</span></span> getRel_hom<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="comment1">(* faster proofs in the common case *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="free">y</span><span class="main">,</span> <span class="free">f</span> <span class="free">z</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>getRel_homR<span class="main">)</span>

<span class="keyword1" id="LabeledGraphSemantics-getRel_hom_map"><span class="command">lemma</span></span> getRel_hom_map<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"getRel <span class="free">l</span> <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> map_prod <span class="free">f</span> <span class="free">f</span> <span class="main">`</span> <span class="main">(</span>getRel <span class="free">l</span> <span class="free">G</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="skolem">x</span><span class="main">,</span> <span class="free">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"map_prod <span class="free">f</span> <span class="free">f</span> <span class="main">`</span> getRel <span class="free">l</span> <span class="free">G</span> <span class="main">⊆</span> getRel <span class="free">l</span> <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">G</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The thing called term in the paper is called <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">alligorical_term</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> here.
      This naming is chosen because an allegory has precisely these operations, plus identity. ›</span></span>
<span class="comment1">(* Deviating from the paper in having a constant constructor.
   We'll use that constructor for top, bottom, etc.. *)</span>
<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'v</span> allegorical_term
 <span class="main">=</span> A_Int <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> allegorical_term"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> allegorical_term"</span></span>
 <span class="main">|</span> A_Cmp <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> allegorical_term"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> allegorical_term"</span></span>
 <span class="main">|</span> A_Cnv <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> allegorical_term"</span></span>
 <span class="main">|</span> A_Lbl <span class="main">(</span><span class="free"><span class="entity">a_lbl</span></span> <span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span><span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The interpretation of terms, Definition 2.›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">semantics</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">semantics</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">(</span>A_Int <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">semantics</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">∩</span> <span class="free">semantics</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">semantics</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">(</span>A_Cmp <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">semantics</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="keyword1">O</span> <span class="free">semantics</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">semantics</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">(</span>A_Cnv <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">=</span> converse <span class="main">(</span><span class="free">semantics</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">semantics</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">(</span>A_Lbl <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> getRel <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span>"</span></span>

<span class="keyword1"><span class="command">notation</span></span> semantics <span class="main">(</span><span class="quoted">"<span class="keyword1">:</span>_<span class="keyword1">:⟦</span>_<span class="keyword1">⟧</span>"</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'v</span> sentence <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> allegorical_term <span class="main">×</span> <span class="tfree">'v</span> allegorical_term"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'v</span> Standard_Constant <span class="main">=</span> S_Top <span class="main">|</span> S_Bot <span class="main">|</span> S_Idt <span class="main">|</span> S_Const <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 3. We don't define sentences but instead simply work with pairs of terms.›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">holds</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">holds</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">≡</span> <span class="main">:</span><span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">:⟦</span>fst <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">⟧</span> <span class="main">=</span> <span class="main">:</span><span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">:⟦</span>snd <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">⟧</span>"</span></span>
<span class="keyword1"><span class="command">notation</span></span> holds <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊨</span>"</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">subset_sentence</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">subset_sentence</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">,</span>A_Int <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">notation</span></span> subset_sentence <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊑</span>"</span> 60<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 1.›</span></span>
<span class="keyword1" id="LabeledGraphSemantics-sentence_iff"><span class="command">lemma</span></span> sentence_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">⊨</span> <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊑</span> <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="main">(</span><span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="free">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">⟧</span> <span class="main">⊆</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="free">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">⟧</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  eq_as_subsets<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">⊨</span> <span class="main">(</span><span class="free">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">G</span> <span class="main">⊨</span> <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊑</span> <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> <span class="free">G</span> <span class="main">⊨</span> <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⊑</span> <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphSemantics-map_graph_in"><span class="command">lemma</span></span> map_graph_in<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="free">a</span><span class="main">,</span><span class="free">f</span> <span class="free">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">b</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>relcompI<span class="main">)</span>

<span class="keyword1" id="LabeledGraphSemantics-semantics_subset_vertices"><span class="command">lemma</span></span> semantics_subset_vertices<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span> <span class="main">⊆</span> vertices <span class="free">A</span> <span class="main">×</span> vertices <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def<span class="main">)</span>
<span class="keyword1" id="LabeledGraphSemantics-semantics_in_vertices"><span class="command">lemma</span></span> semantics_in_vertices<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> vertices <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∈</span> vertices <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">b</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def<span class="main">)</span>

<span class="keyword1" id="LabeledGraphSemantics-map_graph_semantics"><span class="command">lemma</span></span> map_graph_semantics<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> i<span class="main">:</span><span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> <span class="main">(</span>vertices <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">:</span>map_graph_fn <span class="free">A</span> <span class="free">f</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span> <span class="main">=</span> map_prod <span class="free">f</span> <span class="free">f</span> <span class="main">`</span> <span class="main">(</span><span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> io<span class="main">:</span><span class="quoted"><span class="quoted">"inj_on <span class="main">(</span>map_prod <span class="free">f</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span>vertices <span class="free">A</span> <span class="main">×</span> vertices <span class="free">A</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> i <span class="keyword1"><span class="command">unfolding</span></span> inj_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">note</span></span> s <span class="main">=</span> semantics_subset_vertices<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Int <span class="skolem">e1</span> <span class="skolem">e2</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>inj_on_image_Int<span class="main"><span class="main">[</span></span><span class="operator">OF</span> io s s<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cmp <span class="skolem">e1</span> <span class="skolem">e2</span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span>  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xa</span> <span class="skolem">ya</span> <span class="skolem">xb</span> <span class="skolem">yb</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xa</span><span class="main">,</span> <span class="skolem">ya</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xb</span><span class="main">,</span> <span class="skolem">yb</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">ya</span> <span class="main">=</span> <span class="free">f</span> <span class="skolem">xb</span>"</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ya</span> <span class="main">=</span> <span class="skolem">xb</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> i<span class="main">[</span><span class="operator">unfolded</span> inj_on_def<span class="main">]</span> semantics_in_vertices<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="skolem">xa</span><span class="main">,</span> <span class="free">f</span> <span class="skolem">yb</span><span class="main">)</span> <span class="main">∈</span> map_prod <span class="free">f</span> <span class="free">f</span> <span class="main">`</span> <span class="main">(</span><span class="main">(</span><span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span><span class="main">)</span> <span class="keyword1">O</span> <span class="main">(</span><span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> A_Cmp <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> assms<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="LabeledGraphSemantics-graph_union_semantics"><span class="command">lemma</span></span> graph_union_semantics<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="main">:</span><span class="free">B</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">:</span>graph_union <span class="free">A</span> <span class="free">B</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def<span class="main">)</span>

<span class="keyword1" id="LabeledGraphSemantics-subgraph_semantics"><span class="command">lemma</span></span> subgraph_semantics<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="free">A</span> <span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">B</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">b</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>relcompI<span class="main">)</span>

<span class="keyword1" id="LabeledGraphSemantics-graph_homomorphism_semantics"><span class="command">lemma</span></span> graph_homomorphism_semantics<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">A</span> <span class="free">B</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">a'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">b'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a'</span><span class="main">,</span><span class="free">b'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">B</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">b</span></span> <span class="quoted"><span class="free">a'</span></span> <span class="quoted"><span class="free">b'</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cmp <span class="skolem">e1</span> <span class="skolem">e2</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">∈</span>vertices <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> semantics_in_vertices<span class="main">[</span><span class="operator">OF</span> g<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> A_Cmp <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">y'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> A_Cmp<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> y<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> A_Cmp<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> this<span class="main">]</span> A_Cmp<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> y<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> this A_Cmp<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Lbl <span class="skolem">x</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def graph_homomorphism_def2 graph_union_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="LabeledGraphSemantics-graph_homomorphism_nonempty"><span class="command">lemma</span></span> graph_homomorphism_nonempty<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="free">A</span> <span class="free">B</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">:</span><span class="free">B</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> ab<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">A</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> semantics_in_vertices<span class="main">[</span><span class="operator">OF</span> g ab<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a'</span></span> <span class="skolem"><span class="skolem">b'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">a'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">b</span><span class="main">,</span><span class="skolem">b'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> graph_homomorphism_semantics<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> ab this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="LabeledGraphSemantics-getRel_map_fn"><span class="command">lemma</span></span> getRel_map_fn<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a2</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b2</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a2</span><span class="main">,</span><span class="free">b2</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">a2</span> <span class="main">=</span> <span class="free">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">b2</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
        <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">l</span><span class="main">,</span> <span class="free">a2</span><span class="main">,</span> <span class="free">b2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span> <span class="free">f</span> <span class="free">a2</span><span class="main">,</span> <span class="free">f</span> <span class="free">b2</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> on_triple <span class="main">{</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="free">f</span> <span class="bound">a</span><span class="main">)</span> <span class="main">|</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> vertices <span class="free">G</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3-<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>getRel_def BNF_Def.Gr_def Image_def<span class="main"><span class="keyword3">,</span></span><span class="operator">blast</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
  

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="StandardModels">
<div class="head">
<h1>Theory StandardModels</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Standard Models›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define the kind of models we are interested in here.
      In particular, we care about standard graphs.
      To allow some reuse, we distinguish a generic version called <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">standard</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
      from an instantiated abbreviation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">standard'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
      There is little we can prove about these definition here, except for Lemma 2.›</span></span>
<span class="keyword1"><span class="command">theory</span></span> StandardModels
<span class="keyword2"><span class="keyword">imports</span></span> <a href="LabeledGraphSemantics.html">LabeledGraphSemantics</a> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">a_bot</span> <span class="main">≡</span> A_Lbl S_Bot"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">a_top</span> <span class="main">≡</span> A_Lbl S_Top"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">a_idt</span> <span class="main">≡</span> A_Lbl S_Idt"</span></span>
<span class="keyword1"><span class="command">notation</span></span> a_bot <span class="main">(</span><span class="quoted">"<span class="keyword1">⊥</span>"</span><span class="main">)</span>
<span class="keyword1"><span class="command">notation</span></span> a_top <span class="main">(</span><span class="quoted">"<span class="keyword1">⊤</span>"</span><span class="main">)</span>
<span class="keyword1"><span class="command">notation</span></span> a_idt <span class="main">(</span><span class="quoted">"<span class="keyword1">𝟭</span>"</span><span class="main">)</span>
                                       
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'v</span> std_term <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> Standard_Constant allegorical_term"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'v</span> std_sentence <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> std_term <span class="main">×</span> <span class="tfree">'v</span> std_term"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'a</span><span class="main">)</span> std_graph <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> Standard_Constant<span class="main">,</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">+</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span> labeled_graph"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ident_rel</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">ident_rel</span> <span class="free"><span class="bound"><span class="entity">idt</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> getRel <span class="free"><span class="bound"><span class="entity">idt</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> vertices <span class="free"><span class="bound"><span class="entity">G</span></span></span>"</span></span>

<span class="keyword1" id="StandardModels-ident_relI"><span class="command">lemma</span></span> ident_relI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> min<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">idt</span> <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> max1<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">idt</span> <span class="free">G</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> max2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">idt</span> <span class="free">G</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ident_rel <span class="free">idt</span> <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">from</span></span> max1 max2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">idt</span> <span class="free">G</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"getRel <span class="free">idt</span> <span class="free">G</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> vertices <span class="free">G</span> <span class="main">⊆</span> getRel <span class="free">idt</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> min <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 4, generically.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">standard</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span> <span class="tfree">'v</span><span class="main">)</span> labeled_graph <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">standard</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">idt</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span>
   <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">=</span> restrict <span class="free"><span class="bound"><span class="entity">G</span></span></span>
   <span class="main">∧</span> vertices <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≠</span> <span class="main">{}</span>
   <span class="main">∧</span> ident_rel <span class="free"><span class="bound"><span class="entity">idt</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span>
   <span class="main">∧</span> getRel <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">=</span> <span class="main">{}</span>
   <span class="main">∧</span> getRel <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>vertices <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> <span class="bound">y</span><span class="main">∈</span>vertices <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">}</span>
   <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">.</span> getRel <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 4.›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">standard'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'a</span><span class="main">)</span> std_graph <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">standard'</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">≡</span> standard <span class="main">(</span><span class="main">(</span><span class="main">λ</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span>S_Const <span class="bound">c</span><span class="main">,</span>Inl <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">)</span> S_Bot S_Top S_Idt"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 5.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">model</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'a</span><span class="main">)</span> std_graph <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> std_sentence<span class="main">)</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">model</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">≡</span> standard' <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">S</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">⊨</span> <span class="bound">S</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 5.›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">consistent</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> itself <span class="main">⇒</span> <span class="tfree">'v</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> std_sentence<span class="main">)</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">consistent</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">≡</span> <span class="main">∃</span> <span class="main">(</span><span class="bound">G</span><span class="main">::</span><span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> std_graph<span class="main">)</span><span class="main">.</span> model <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="bound">G</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 6.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">entails</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> itself <span class="main">⇒</span> <span class="tfree">'v</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> std_sentence<span class="main">)</span> set <span class="main">⇒</span> <span class="tfree">'v</span> std_sentence <span class="main">⇒</span> bool"</span></span>  <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">entails</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">≡</span> <span class="main">∀</span> <span class="main">(</span><span class="bound">G</span><span class="main">::</span><span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> std_graph<span class="main">)</span><span class="main">.</span> model <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="bound">G</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">⟶</span> <span class="bound">G</span> <span class="main">⊨</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span>"</span></span>

<span class="keyword1" id="StandardModels-standard_top_not_bot"><span class="command">lemma</span></span> standard_top_not_bot<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"standard' <span class="free">C</span> <span class="free">G</span> <span class="main">⟹</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="main">⊥</span><span class="main">⟧</span> <span class="main">≠</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="main">⊤</span><span class="main">⟧</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> standard_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 2.›</span></span>
<span class="keyword1" id="StandardModels-consistent_iff_entails_nonsense"><span class="command">lemma</span></span> consistent_iff_entails_nonsense<span class="main">:</span>
<span class="quoted"><span class="quoted">"consistent <span class="free">t</span> <span class="free">C</span> <span class="free">T</span> <span class="main">=</span> <span class="main">(</span><span class="main">¬</span> entails <span class="free">t</span> <span class="free">C</span> <span class="free">T</span> <span class="main">(</span><span class="main">⊥</span><span class="main">,</span><span class="main">⊤</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"consistent <span class="free">t</span> <span class="free">C</span> <span class="free">T</span> <span class="main">⟹</span> <span class="main">¬</span> entails <span class="free">t</span> <span class="free">C</span> <span class="free">T</span> <span class="main">(</span><span class="main">⊥</span><span class="main">,</span> <span class="main">⊤</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> standard_top_not_bot <span class="keyword1"><span class="command">unfolding</span></span> entails_def model_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>entails_def model_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="RuleSemanticsConnection">
<div class="head">
<h1>Theory RuleSemanticsConnection</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Translating terms into Graphs›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define the translation function and its properties.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> RuleSemanticsConnection
<span class="keyword2"><span class="keyword">imports</span></span> <a href="LabeledGraphSemantics.html">LabeledGraphSemantics</a> <a href="RulesAndChains.html">RulesAndChains</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 15.›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">translation</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> allegorical_term <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> nat<span class="main">)</span> labeled_graph"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">translation</span> <span class="main">(</span>A_Lbl <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> LG <span class="main">{</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">}</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">translation</span> <span class="main">(</span>A_Cnv <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> map_graph_fn <span class="main">(</span><span class="free">translation</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span><span class="main">&lt;</span><span class="numeral">2</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="bound">x</span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">translation</span> <span class="main">(</span>A_Cmp <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span>
  <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> <span class="free">translation</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">;</span> <span class="bound">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="free">translation</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span>
     <span class="keyword1">in</span> graph_union <span class="main">(</span>map_graph_fn <span class="bound">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span><span class="main">=</span><span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="bound">x</span><span class="main">+</span>card<span class="main">(</span>vertices <span class="bound">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>
                    <span class="main">(</span>map_graph_fn <span class="bound">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span><span class="main">=</span><span class="main">0</span> <span class="keyword1">then</span> card <span class="main">(</span>vertices <span class="bound">G<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">translation</span> <span class="main">(</span>A_Int <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span>
  <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> <span class="free">translation</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">;</span> <span class="bound">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="free">translation</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span>
     <span class="keyword1">in</span> graph_union <span class="bound">G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">(</span>map_graph_fn <span class="bound">G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span><span class="main">&lt;</span><span class="numeral">2</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="bound">x</span><span class="main">+</span>card<span class="main">(</span>vertices <span class="bound">G<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">-</span><span class="numeral">2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">inv_translation</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">inv_translation</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>card <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">}</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">∧</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1" id="RuleSemanticsConnection-inv_translationI4"><span class="command">lemma</span></span> inv_translationI4<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> card <span class="free">r</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main">=</span><span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>card <span class="free">r</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">insert</span> assms<span class="main"><span class="keyword3">,</span></span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"card <span class="free">r</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">r</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">x</span> <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> Suc <span class="keyword1"><span class="command">have</span></span> p<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> card <span class="var">?r</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> p2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">&lt;</span> card <span class="var">?r</span> <span class="main">⟹</span> <span class="skolem">xa</span> <span class="main">∈</span> <span class="var">?r</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xa</span>
    <span class="keyword1"><span class="command">using</span></span> Suc.prems<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">xa</span></span><span class="main">]</span> Suc.hyps<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> p<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> Suc.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> p p2<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?r</span><span class="main">=</span><span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>card <span class="var">?r</span><span class="main">}</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">with</span></span> Suc.hyps<span class="main">(</span>2<span class="main">)</span> Suc.prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> atLeast0_lessThan_Suc card_Diff_singleton_if insert_Diff n_not_Suc_n p<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RuleSemanticsConnection-inv_translationI"><span class="command">lemma</span></span> inv_translationI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> card <span class="free">r</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"Suc <span class="main">0</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inv_translation <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> inv_translationI4<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> c<span class="main">:</span><span class="quoted"><span class="quoted">" <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>card <span class="free">r</span><span class="main">}</span> <span class="main">=</span> <span class="free">r</span> "</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>3<span class="main">,</span>4<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> c inv_translation_def <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RuleSemanticsConnection-verts_in_translation_finite"><span class="command">lemma</span></span> verts_in_translation_finite<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"finite <span class="main">(</span>vertices <span class="main">(</span>translation <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="quoted"><span class="quoted">"finite <span class="main">(</span>edges <span class="main">(</span>translation <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∈</span> vertices <span class="main">(</span>translation <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="quoted"><span class="quoted">"Suc <span class="main">0</span> <span class="main">∈</span> vertices <span class="main">(</span>translation <span class="free">X</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">atomize</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">full</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">induction</span> <span class="quoted"><span class="free">X</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Int <span class="skolem">X1</span> <span class="skolem">X2</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cmp <span class="skolem">X1</span> <span class="skolem">X2</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">x</span><span class="main">::</span>nat<span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cnv <span class="skolem">X</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RuleSemanticsConnection-inv_tr_card_min"><span class="command">lemma</span></span> inv_tr_card_min<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"inv_translation <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="free">r</span> <span class="main">≥</span> <span class="numeral">2</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> inv_translation_def
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="free">r</span> <span class="main">⟹</span> <span class="numeral">2</span> <span class="main">≤</span> <span class="skolem">x</span> <span class="main">⟷</span> <span class="main">0</span> <span class="main">∈</span> <span class="free">r</span> <span class="main">∧</span> <span class="main">1</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> ge2<span class="main">:</span><span class="quoted"><span class="quoted">"card <span class="free">r</span><span class="main">≥</span><span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RuleSemanticsConnection-verts_in_translation"><span class="command">lemma</span></span> verts_in_translation<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"inv_translation <span class="main">(</span>vertices <span class="main">(</span>translation <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">X</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span>
    <span class="keyword3"><span class="command">assume</span></span> assms<span class="main">:</span><span class="quoted"><span class="quoted">"inv_translation <span class="skolem">r</span>"</span></span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> inv_translation_def
    <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> a1<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="skolem">r</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> card_ge_0_finite<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>Suc <span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">note</span></span> ge2 <span class="main">=</span> inv_tr_card_min<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
    <span class="keyword1"><span class="command">from</span></span> ge2 assms <span class="keyword1"><span class="command">have</span></span> r0<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∩</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">r</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">&lt;</span> card <span class="skolem">r</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> g6<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> card <span class="skolem">r</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">r</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> inv_translation_def<span class="main">]</span> atLeastLessThan_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">have</span></span> g4<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="numeral">2</span><span class="main">..&lt;</span>card <span class="skolem">r</span><span class="main">}</span>"</span></span>
            <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∩</span> <span class="main">(</span>Collect <span class="main">(</span><span class="main">(&lt;)</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">1</span><span class="main">..&lt;</span>card <span class="skolem">r</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">have</span></span> ins<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">∈</span> <span class="skolem">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∈</span> <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> d<span class="main">:</span><span class="quoted"><span class="quoted">"Suc <span class="main">(</span>Suc <span class="main">(</span>card <span class="skolem">r</span> <span class="main">-</span> <span class="numeral">2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> card <span class="skolem">r</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ge2 One_nat_def Suc_diff_Suc Suc_pred 
            numeral_2_eq_2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>
    <span class="keyword1"><span class="command">note</span></span> ge2 ins g4 g6 r0 d
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> inv_translationD<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> this
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span>
    <span class="keyword3"><span class="command">assume</span></span> assm<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">≤</span> <span class="main">(</span><span class="skolem">a</span><span class="main">::</span>nat<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">+</span> <span class="skolem">a</span> <span class="main">-</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">`</span> <span class="main">{</span><span class="skolem">b</span><span class="main">..&lt;</span><span class="skolem">c</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">a</span><span class="main">..&lt;</span><span class="skolem">c</span><span class="main">+</span><span class="skolem">a</span><span class="main">-</span><span class="skolem">b</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> assm <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">+</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">-</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="main">{</span><span class="skolem">b</span><span class="main">..&lt;</span><span class="skolem">c</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> linordered_semidom_class.image_add_atLeastLessThan' <span class="keyword1"><span class="command">using</span></span> assm <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> e<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> this
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span> <span class="skolem">z</span>
    <span class="keyword3"><span class="command">assume</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"inv_translation <span class="skolem">z</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> a2<span class="main">:</span> <span class="quoted"><span class="quoted">"inv_translation <span class="skolem">r</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?z2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"card <span class="skolem">z</span> <span class="main">+</span> card <span class="skolem">r</span> <span class="main">-</span> <span class="numeral">2</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?z1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"card <span class="skolem">z</span> <span class="main">+</span> card <span class="skolem">r</span> <span class="main">-</span> Suc <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> a1 a2
    <span class="keyword1"><span class="command">have</span></span> le1<span class="main">:</span><span class="quoted"><span class="quoted">"Suc <span class="main">0</span> <span class="main">≤</span> card <span class="skolem">r</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_leD inv_translationD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> numerals<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> le2<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="skolem">r</span> <span class="main">≤</span> <span class="var">?z1</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_leD a1 inv_translationD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> numerals<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> ordered_cancel_comm_monoid_diff_class.le_add_diff<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> le1 <span class="keyword1"><span class="command">have</span></span> b<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">{</span>card <span class="skolem">r</span> <span class="main">..&lt;</span> <span class="var">?z1</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span>Suc <span class="main">0</span> <span class="main">..&lt;</span> card <span class="skolem">r</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span>Suc <span class="main">0</span> <span class="main">..&lt;</span> <span class="var">?z1</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span>insert <span class="main">(</span>card <span class="skolem">r</span><span class="main">)</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>card <span class="skolem">z</span> <span class="main">+</span> card <span class="skolem">r</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>card <span class="skolem">z</span> <span class="main">+</span> card <span class="skolem">r</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> le1 le2 a1 a2
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_leD add_Suc_right atLeastLessThan_iff diff_Suc_Suc insert_absorb inv_translationD<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> linorder_not_less not_less_eq_eq numerals<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> ordered_cancel_comm_monoid_diff_class.le_add_diff<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> a1 a2
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="skolem">z</span> <span class="main">+</span> card <span class="skolem">r</span> <span class="main">-</span> <span class="numeral">2</span> <span class="main">≥</span> card <span class="main">(</span><span class="skolem">r</span><span class="main">::</span>nat set<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ordered_cancel_comm_monoid_diff_class.le_add_diff<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> a2
    <span class="keyword1"><span class="command">have</span></span> c<span class="main">:</span><span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">r</span> <span class="main">∪</span> <span class="main">{</span>card <span class="skolem">r</span><span class="main">..&lt;</span><span class="var">?z2</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="var">?z2</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> atLeast0LessThan card_atLeastLessThan diff_zero inv_translation_def ivl_disj_un_one<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">note</span></span> a b c
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> this
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">&lt;</span> <span class="skolem">x</span> <span class="main">⟹</span> insert <span class="skolem">a</span> <span class="main">{</span>Suc <span class="skolem">a</span><span class="main">..&lt;</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">a</span><span class="main">..&lt;</span><span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">x</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Int <span class="skolem">X1</span> <span class="skolem">X2</span><span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?v1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"vertices <span class="main">(</span>translation <span class="skolem">X1</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> A_Int <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span>insert <span class="main">0</span> <span class="main">(</span>insert <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span> <span class="main">(</span><span class="var">?v1</span> <span class="main">∪</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="var">?v1</span> <span class="main">∪</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">unfolding</span></span> inv_translation_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> A_Int <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def linorder_not_le<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cmp <span class="skolem">X1</span> <span class="skolem">X2</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span><span class="main">≤</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">X1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span><span class="main">≤</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">X2</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">≤</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">X1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span><span class="main">≤</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">X2</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">X1</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">X2</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> this A_Cmp
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cnv <span class="skolem">X</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RuleSemanticsConnection-translation_graph"><span class="command">lemma</span></span> translation_graph<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"graph <span class="main">(</span>translation <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">X</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>

<span class="keyword1" id="RuleSemanticsConnection-graph_rule_translation"><span class="command">lemma</span></span> graph_rule_translation<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="comment1">(* remark at the end of Def 15 *)</span>
<span class="quoted"><span class="quoted">"graph_rule <span class="main">(</span>translation <span class="free">X</span><span class="main">,</span> translation <span class="main">(</span>A_Int <span class="free">X</span> <span class="free">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> verts_in_translation_finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">X</span></span></span></span></span></span></span></span><span class="main">]</span> verts_in_translation_finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"A_Int <span class="free"><span class="free"><span class="free"><span class="free">X</span></span></span></span> <span class="free"><span class="free"><span class="free"><span class="free">Y</span></span></span></span>"</span></span></span></span></span><span class="main">]</span>
        translation_graph<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">X</span></span><span class="main">]</span> translation_graph<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"A_Int <span class="free">X</span> <span class="free">Y</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def subgraph_def2<span class="main">)</span>

<span class="keyword1" id="RuleSemanticsConnection-graph_hom_translation"><span class="command">lemma</span></span> graph_hom_translation<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>translation <span class="free">X</span><span class="main">)</span> <span class="main">(</span>Id_on <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> verts_in_translation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">X</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> inv_translation_def graph_homomorphism_def2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="RuleSemanticsConnection-translation_right_to_left"><span class="command">lemma</span></span> translation_right_to_left<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="free">e</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> f
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Int <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">f</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"id"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="bound">x</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> f1<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> on_graph <span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">O</span> <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> on_graph <span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">O</span> <span class="skolem">f</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> f2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> on_graph <span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">O</span> <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> on_graph <span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">O</span> <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> A_Int.prems<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>BNF_Def.Gr_def relcomp_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> A_Int.prems<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> uni<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>graph_union <span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">(</span>map_graph_fn <span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> graph_homo_union_id<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> uni translation_graph<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> h1<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">(</span>translation <span class="main">(</span>A_Int <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>on_graph <span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span> id<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def graph_homomorphism_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>map_graph_fn <span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> graph_homo_union_id<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> uni this<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> h2<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">(</span>translation <span class="main">(</span>A_Int <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>on_graph <span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def graph_homomorphism_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> A_Int.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> graph_homomorphism_composes<span class="main"><span class="main">[</span></span><span class="operator">OF</span> h1 A_Int.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> f1<span class="main">]</span>
       A_Int.hyps<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> graph_homomorphism_composes<span class="main"><span class="main">[</span></span><span class="operator">OF</span> h2 A_Int.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> f2<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cmp <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">f</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span><span class="main">=</span><span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="bound">x</span><span class="main">+</span>card<span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span><span class="main">=</span><span class="main">0</span> <span class="keyword1">then</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">x</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?v</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> A_Cmp.prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?v</span> <span class="main">∈</span> Domain <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def graph_homomorphism_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?v</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> f1<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> on_graph <span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">O</span> <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> on_graph <span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">O</span> <span class="skolem">f</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> f2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> on_graph <span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">O</span> <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> on_graph <span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span> <span class="keyword1">O</span> <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> A_Cmp.prems<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> v <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> A_Cmp.prems<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> uni<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>graph_union <span class="main">(</span>map_graph_fn <span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>map_graph_fn <span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> graph_homo_union_id<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> uni this<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> h1<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">(</span>translation <span class="main">(</span>A_Cmp <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>on_graph <span class="var">?G<span class="hidden">⇩</span><sub>1</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def graph_homomorphism_def2<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>map_graph_fn <span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> graph_homo_union_id<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> uni this<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> h2<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">(</span>translation <span class="main">(</span>A_Cmp <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>on_graph <span class="var">?G<span class="hidden">⇩</span><sub>2</sub></span> <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def graph_homomorphism_def2<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> A_Cmp.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> graph_homomorphism_composes<span class="main"><span class="main">[</span></span><span class="operator">OF</span> h1 A_Cmp.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> f1<span class="main">]</span>
       A_Cmp.hyps<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> graph_homomorphism_composes<span class="main"><span class="main">[</span></span><span class="operator">OF</span> h2 A_Cmp.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> f2<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cnv <span class="skolem">e</span> <span class="skolem">f</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">-</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"translation <span class="skolem">e</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> i<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="var">?G</span> <span class="main">(</span>map_graph_fn <span class="var">?G</span> <span class="var">?f</span><span class="main">)</span> <span class="main">(</span>on_graph <span class="var">?G</span> <span class="var">?f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A_Cnv <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> on_graph <span class="var">?G</span> <span class="var">?f</span> <span class="keyword1">O</span> <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> on_graph <span class="var">?G</span> <span class="var">?f</span> <span class="keyword1">O</span> <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> A_Cnv.prems<span class="main">(</span>3<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>BNF_Def.Gr_def relcomp_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> A_Cnv.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> graph_homomorphism_composes<span class="main"><span class="main">[</span></span><span class="operator">OF</span> i<span class="main"><span class="main">]</span></span> this<span class="main">]</span> A_Cnv.prems<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Lbl <span class="skolem">l</span> <span class="skolem">f</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="skolem">f</span> <span class="main">{</span><span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">}</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> A_Lbl<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def edge_preserving_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RuleSemanticsConnection-translation_homomorphism"><span class="command">lemma</span></span> translation_homomorphism<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="free">e</span><span class="main">)</span> <span class="free">G</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">``</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="main">×</span> <span class="free">f</span> <span class="main">``</span> <span class="main">{</span><span class="main">1</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> translation_right_to_left<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> assms<span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def2<span class="main">]</span>
        verts_in_translation_finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">e</span></span></span></span></span></span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 5.›</span></span>
<span class="keyword1" id="RuleSemanticsConnection-translation"><span class="command">lemma</span></span> translation<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">f</span><span class="main">.</span> graph_homomorphism <span class="main">(</span>translation <span class="free">e</span><span class="main">)</span> <span class="free">G</span> <span class="bound">f</span> <span class="main">∧</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">f</span> <span class="main">∧</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">f</span><span class="main">)</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="main">(</span><span class="skolem">e</span><span class="main">::</span><span class="tfree">'a</span> allegorical_term<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">y</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">2</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="skolem">e</span> <span class="keyword1"><span class="command">using</span></span> inv_tr_card_min<span class="main">[</span><span class="operator">OF</span> verts_in_translation<span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>
  <span class="keyword1"><span class="command">{</span></span>  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> allegorical_term"</span></span>
     <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span> <span class="main">∈</span> vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span> <span class="main">&lt;</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command">using</span></span> verts_in_translation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">,</span><span class="operator">unfolded</span> inv_translation_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">&lt;</span> <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> inv_tr_card_min<span class="main">[</span><span class="operator">OF</span> verts_in_translation<span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main">!</span></span><span class="main">]</span> <span class="main">=</span> this
  <span class="keyword1"><span class="command">{</span></span>  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> allegorical_term"</span></span>
     <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> Suc <span class="main">0</span> <span class="main">∈</span> vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> Suc <span class="main">0</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
       <span class="keyword1"><span class="command">using</span></span> verts_in_translation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">,</span><span class="operator">unfolded</span> inv_translation_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
     <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> inv_tr_card_min<span class="main">[</span><span class="operator">OF</span> verts_in_translation<span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
   <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main">!</span></span><span class="main">]</span> <span class="main">=</span> this
   <span class="keyword1"><span class="command">{</span></span>  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> allegorical_term"</span></span>
     <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
       <span class="keyword1"><span class="command">using</span></span> verts_in_translation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">,</span><span class="operator">unfolded</span> inv_translation_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
   <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main">!</span></span><span class="main">]</span> <span class="main">=</span> this
  <span class="keyword1"><span class="command">{</span></span>  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> allegorical_term"</span></span>
     <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> Suc <span class="main">0</span>"</span></span>
     <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">" card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> Suc <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> inv_tr_card_min<span class="main">[</span><span class="operator">OF</span> verts_in_translation<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem">e</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
   <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main">!</span></span><span class="main">]</span> <span class="main">=</span> this
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Int <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> A_Int <span class="keyword1"><span class="command">have</span></span> assm<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">⟧</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> A_Int<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assm<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span>
      f<span class="hidden">⇩</span><sub>1</sub><span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> A_Int<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assm<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span>
      f<span class="hidden">⇩</span><sub>2</sub><span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> f<span class="hidden">⇩</span><sub>1</sub> f<span class="hidden">⇩</span><sub>2</sub> <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"Domain <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="bound">x</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"on_graph <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> inj2<span class="main">:</span><span class="quoted"><span class="quoted">"inj_on <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inj_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="main">1</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">THEN</span> relcompI<span class="main">]</span> f<span class="hidden">⇩</span><sub>2</sub><span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> 
    <span class="keyword1"><span class="command">have</span></span> zero_one<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
                  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">yb</span> <span class="skolem">zb</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">yb</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span><span class="main">,</span> <span class="skolem">zb</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">yb</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span> <span class="main">∈</span> vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> in_f<span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main">!</span></span><span class="main">]</span> <span class="main">=</span> this
    <span class="keyword1"><span class="command">have</span></span> d_a<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∩</span>  Domain <span class="main">(</span><span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> zero_one <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>v<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> d_b<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="main">(</span><span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∩</span> <span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> zero_one f<span class="hidden">⇩</span><sub>1</sub><span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">note</span></span> cmp2 <span class="main">=</span> graph_homomorphism_composes<span class="main">[</span><span class="operator">OF</span> graph_homo_inv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> translation_graph inj2<span class="main"><span class="main">]</span></span> f<span class="hidden">⇩</span><sub>2</sub><span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="main">(</span>A_Int <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="main">(</span><span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∪</span> <span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> graph_homo_union<span class="main">[</span><span class="operator">OF</span> f<span class="hidden">⇩</span><sub>1</sub><span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> cmp2 d_a<span class="main"><span class="main">[</span></span><span class="operator">folded</span> d_b<span class="main"><span class="main">]</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> zero_one<span class="main">[</span><span class="operator">THEN</span> UnI2<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">of</span></span> <span class="main"><span class="main"><span class="main"><span class="main">_</span></span></span></span> <span class="main"><span class="main"><span class="main"><span class="main">_</span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span></span>"</span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cmp <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> A_Cmp <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> assm<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">⟧</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> A_Cmp<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assm<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span>
      f<span class="hidden">⇩</span><sub>1</sub><span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> A_Cmp<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assm<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span>
      f<span class="hidden">⇩</span><sub>2</sub><span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> f<span class="hidden">⇩</span><sub>1</sub> f<span class="hidden">⇩</span><sub>2</sub> <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"Domain <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span><span class="main">=</span><span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="bound">x</span><span class="main">+</span>card<span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span><span class="main">=</span><span class="main">0</span> <span class="keyword1">then</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?tr<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"on_graph <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="var">?f<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"on_graph <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> inj1<span class="main">:</span><span class="quoted"><span class="quoted">"inj_on <span class="var">?f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inj_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> inj2<span class="main">:</span><span class="quoted"><span class="quoted">"inj_on <span class="var">?f<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inj_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="main">1</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span>"</span></span>
         <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?tr<span class="hidden">⇩</span><sub>1</sub></span><span class="main">¯</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="main">1</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?tr<span class="hidden">⇩</span><sub>1</sub></span><span class="main">¯</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">THEN</span> relcompI<span class="main">]</span> f<span class="hidden">⇩</span><sub>2</sub><span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> f<span class="hidden">⇩</span><sub>1</sub><span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> 
    <span class="keyword1"><span class="command">have</span></span> zero_one<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?tr<span class="hidden">⇩</span><sub>1</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
                  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?tr<span class="hidden">⇩</span><sub>1</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
                  <span class="quoted"><span class="quoted">"<span class="main">(</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
                  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
        <span class="quoted"><span class="quoted">"<span class="skolem">ye</span> <span class="main">∈</span> vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">⟹</span>
       <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">ye</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="skolem">ye</span><span class="main">)</span> <span class="main">=</span>
       <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">yd</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="skolem">yd</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">⟷</span> <span class="skolem">ye</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="skolem">yd</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
        <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">ye</span> <span class="skolem">yd</span> <span class="keyword1"><span class="command">using</span></span> v inv_tr_card_min<span class="main">[</span><span class="operator">OF</span> verts_in_translation<span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">ye</span><span class="main">=</span><span class="main">0</span>"</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">yd</span><span class="main">=</span><span class="main">0</span>"</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> d_a<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="main">(</span><span class="var">?tr<span class="hidden">⇩</span><sub>1</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="main">∩</span>  Domain <span class="main">(</span><span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> zero_one <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> defined_all<span class="main">]</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> v<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> d_b<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="main">(</span><span class="var">?tr<span class="hidden">⇩</span><sub>1</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∩</span> <span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> zero_one f<span class="hidden">⇩</span><sub>1</sub><span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> defined_all<span class="main">]</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">note</span></span> cmp1 <span class="main">=</span> graph_homomorphism_composes<span class="main">[</span><span class="operator">OF</span> graph_homo_inv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> translation_graph inj1<span class="main"><span class="main">]</span></span> f<span class="hidden">⇩</span><sub>1</sub><span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">note</span></span> cmp2 <span class="main">=</span> graph_homomorphism_composes<span class="main">[</span><span class="operator">OF</span> graph_homo_inv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> translation_graph inj2<span class="main"><span class="main">]</span></span> f<span class="hidden">⇩</span><sub>2</sub><span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="main">(</span>A_Cmp <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="main">(</span><span class="var">?tr<span class="hidden">⇩</span><sub>1</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∪</span> <span class="var">?tr<span class="hidden">⇩</span><sub>2</sub></span><span class="main">¯</span> <span class="keyword1">O</span> <span class="skolem">f<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> Let_def translation.simps
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> graph_homo_union<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cmp1 cmp2 d_a<span class="main"><span class="main">[</span></span><span class="operator">folded</span> d_b<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> zero_one <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cnv <span class="skolem">e</span><span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"translation <span class="main">(</span>A_Cnv <span class="skolem">e</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> A_Cnv <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      f<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="skolem">f</span> <span class="main">=</span> vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≡</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> verts_in_translation f inv_tr_card_min<span class="main">[</span><span class="operator">OF</span> verts_in_translation<span class="main">]</span> v<span class="main">(</span>1<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> n<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="skolem">n</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="skolem">n</span><span class="main">}</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">1</span><span class="main">,</span><span class="main">0</span><span class="main">}</span>"</span></span>
      <span class="quoted"><span class="quoted">"Domain <span class="skolem">f</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="skolem">n</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="skolem">n</span><span class="main">}</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="numeral">2</span><span class="main">..&lt;</span><span class="skolem">n</span><span class="main">}</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> n2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≥</span> <span class="numeral">2</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>n_def inv_translation_def<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"insert <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span> <span class="main">{</span><span class="numeral">2</span><span class="main">..&lt;</span><span class="skolem">n</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">1</span><span class="main">..&lt;</span><span class="skolem">n</span><span class="main">}</span>"</span></span>
      <span class="quoted"><span class="quoted">"insert <span class="main">0</span> <span class="main">{</span>Suc <span class="main">0</span><span class="main">..&lt;</span><span class="skolem">n</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="skolem">n</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> defined_all<span class="main">]</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"on_graph <span class="var">?G</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">-</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> h<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="var">?G</span> <span class="free">G</span> <span class="main">(</span><span class="var">?f</span> <span class="keyword1">O</span> <span class="skolem">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> graph_homomorphism_composes<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ f<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">rule</span> graph_homomorphismI<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"vertices <span class="var">?G</span> <span class="main">=</span> Domain <span class="var">?f</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Domain_int_univ<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="main">``</span> vertices <span class="var">?G</span> <span class="main">⊆</span> vertices <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"univalent <span class="var">?f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="var">?f</span> <span class="main">(</span>edges <span class="main">(</span>translation <span class="main">(</span>A_Cnv <span class="skolem">e</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="main">(</span>translation <span class="skolem">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> edge_preserving_on_graphI<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> BNF_Def.Gr_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>assms<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> xy<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?f</span> <span class="keyword1">O</span> <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?f</span> <span class="keyword1">O</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n2 f<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> n<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> h <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Lbl <span class="skolem">l</span><span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> xy<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms A_Lbl <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="main">(</span>A_Lbl <span class="skolem">l</span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="var">?f</span> <span class="main">∧</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?f</span> <span class="main">∧</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?f</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms A_Lbl xy <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def2
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>univalent_def getRel_def on_triple_def Image_def graph_union_def insert_absorb<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> translation_right_to_left<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">transl_rule</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> sentence <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> nat<span class="main">)</span> labeled_graph <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> nat<span class="main">)</span> labeled_graph"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">transl_rule</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="main">(</span>translation <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span><span class="main">,</span>translation <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 6.›</span></span>
<span class="keyword1" id="RuleSemanticsConnection-maintained_holds_iff"><span class="command">lemma</span></span> maintained_holds_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">,</span>translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="main">⟷</span> <span class="free">G</span> <span class="main">⊨</span> <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">⊑</span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span> <span class="var">?lhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> lhs<span class="main">:</span><span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> maintained_def <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">clarify</span><span class="main">)</span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span>
    <span class="keyword3"><span class="command">assume</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">,</span> translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> f2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DomainE One_nat_def prod.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> verts_in_translation_finite<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">,</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> f <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span>fst <span class="main">(</span><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">⊑</span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> translation<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> lhs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span>snd <span class="main">(</span><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">⊑</span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> g<span class="main">:</span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">g</span>"</span></span>
                   <span class="keyword2"><span class="keyword">and</span></span> g2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> translation<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="main">(</span>translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Domain <span class="skolem">g</span>"</span></span>
           <span class="quoted"><span class="quoted">"vertices <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">)</span> <span class="main">=</span> Domain <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f g
      <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> subgraph_subset<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"translation <span class="free"><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span></span>"</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"translation <span class="main"><span class="main">(</span></span>A_Int <span class="free"><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span></span> <span class="free"><span class="free">e<span class="hidden">⇩</span><sub>R</sub></span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main">]</span>
         graph_rule_translation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span></span> <span class="quoted"><span class="free">e<span class="hidden">⇩</span><sub>R</sub></span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> dom_sub<span class="main">:</span> <span class="quoted"><span class="quoted">"Domain <span class="skolem">f</span> <span class="main">⊆</span> Domain <span class="skolem">g</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> v <span class="keyword1"><span class="command">unfolding</span></span> prod.sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">argo</span>
    <span class="keyword1"><span class="command">hence</span></span> dom_le<span class="main">:</span><span class="quoted"><span class="quoted">"card <span class="main">(</span>Domain <span class="skolem">f</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>Domain <span class="skolem">g</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> card.infinite card_mono inv_tr_card_min not_less rel_simps<span class="main"><span class="main">(</span></span>51<span class="main"><span class="main">)</span></span> v<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> verts_in_translation<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> c_f<span class="main">:</span><span class="quoted"><span class="quoted">"card <span class="main">(</span>Domain <span class="skolem">f</span><span class="main">)</span> <span class="main">≥</span> <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> inv_tr_card_min<span class="main">[</span><span class="operator">OF</span> verts_in_translation<span class="main">]</span> v <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">from</span></span> f<span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> ep_f<span class="main">:</span><span class="quoted"><span class="quoted">"edge_preserving <span class="skolem">f</span> <span class="main">(</span>edges <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> uni_f<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="bound">x</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">GR</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">GR</span> <span class="main">=</span> map_graph_fn <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span> <span class="var">?f</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> g<span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="skolem">g</span> <span class="main">(</span>edges <span class="main">(</span>translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> uni_g<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> edge_preserving_subset<span class="main">[</span><span class="operator">OF</span> subset_refl _ this<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> ep_g<span class="main">:</span><span class="quoted"><span class="quoted">"edge_preserving <span class="skolem">g</span> <span class="main">(</span>edges <span class="skolem">GR</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def GR_def<span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> vertices <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="skolem">a</span> <span class="main">∈</span> vertices <span class="main">(</span>translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> v<span class="main">]</span> verts_in_translation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span>"</span></span><span class="main">,</span><span class="operator">unfolded</span> inv_translation_def v<span class="main">]</span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">a</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">⟹</span> <span class="skolem">a</span> <span class="main">+</span> card <span class="main">(</span>Domain <span class="skolem">f</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span> <span class="main">&lt;</span> card <span class="main">(</span>Domain <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span><span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span> <span class="main">=</span> this
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="main">¬</span> <span class="skolem">aa</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">⟹</span> card <span class="main">(</span>Domain <span class="skolem">f</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">aa</span> <span class="main">+</span> card <span class="main">(</span>Domain <span class="skolem">f</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">aa</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> v<span class="main">(</span>2<span class="main">)</span> restrictD<span class="main">[</span><span class="operator">OF</span> translation_graph<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> df<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">∉</span> Domain <span class="skolem">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">xa</span><span class="main">,</span><span class="skolem">xb</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">)</span> <span class="main">⟹</span> False"</span></span>
                  <span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">∉</span> Domain <span class="skolem">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">xb</span><span class="main">,</span><span class="skolem">xa</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">)</span> <span class="main">⟹</span> False"</span></span>
                  <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xa</span> <span class="skolem">l</span> <span class="skolem">xb</span> <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="skolem">xa</span> <span class="skolem">xb</span> <span class="skolem">ya</span>
      <span class="keyword3"><span class="command">assume</span></span> assm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">xa</span><span class="main">,</span><span class="skolem">xb</span><span class="main">)</span> <span class="main">∈</span> edges <span class="skolem">GR</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> c_f dom_le
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span>card <span class="main">(</span>Domain <span class="skolem">f</span><span class="main">)</span><span class="main">..&lt;</span>card <span class="main">(</span>Domain <span class="skolem">g</span><span class="main">)</span><span class="main">}</span>"</span></span>
           <span class="quoted"><span class="quoted">"<span class="skolem">xb</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span>card <span class="main">(</span>Domain <span class="skolem">f</span><span class="main">)</span><span class="main">..&lt;</span>card <span class="main">(</span>Domain <span class="skolem">g</span><span class="main">)</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> GR_def v <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> minb<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span> <span class="main">∨</span> <span class="skolem">xa</span> <span class="main">≥</span> card <span class="main">(</span>Domain <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xb</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span> <span class="main">∨</span> <span class="skolem">xb</span> <span class="main">≥</span> card <span class="main">(</span>Domain <span class="skolem">f</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="skolem">xa</span> <span class="keyword3"><span class="command">assume</span></span> minb<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span> <span class="main">∨</span> <span class="skolem">xa</span> <span class="main">≥</span> card <span class="main">(</span>Domain <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> z<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xa</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span>"</span></span> 
        <span class="keyword1"><span class="command">from</span></span> z verts_in_translation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span></span><span class="main">,</span><span class="operator">unfolded</span> inv_translation_def v<span class="main">]</span> 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">&lt;</span> card<span class="main">(</span>Domain <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> minb verts_in_translation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span>"</span></span><span class="main">,</span><span class="operator">unfolded</span> inv_translation_def v<span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> x<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span> <span class="main">∧</span> <span class="skolem">xa</span> <span class="main">∈</span> Domain <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xa</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">consider</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="skolem">z</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="skolem">xa</span> <span class="main">=</span> <span class="main">1</span> <span class="main">∧</span> <span class="skolem">z</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> x f2<span class="main">[</span><span class="operator">THEN</span> univalentD<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">OF</span></span> uni_f<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main">]</span> z <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g g2<span class="main">[</span><span class="operator">THEN</span> univalentD<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">OF</span></span> uni_g<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">xa</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">note</span></span> minb<span class="main">[</span><span class="operator">THEN</span> this<span class="main">]</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> f2 g2<span class="main">[</span><span class="operator">THEN</span> univalentD<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">OF</span></span> uni_g<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> dg<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">xa</span><span class="main">,</span><span class="skolem">xb</span><span class="main">)</span> <span class="main">∈</span> edges <span class="skolem">GR</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">xa</span><span class="main">,</span><span class="skolem">ya</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">xa</span><span class="main">,</span><span class="skolem">ya</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">g</span>"</span></span>
            <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">xb</span><span class="main">,</span><span class="skolem">xa</span><span class="main">)</span> <span class="main">∈</span> edges <span class="skolem">GR</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">xa</span><span class="main">,</span><span class="skolem">ya</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">xa</span><span class="main">,</span><span class="skolem">ya</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">g</span>"</span></span>
            <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xa</span> <span class="skolem">l</span> <span class="skolem">xb</span> <span class="skolem">ya</span>
      <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vertices <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="main">(</span>translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> subgraph_subset<span class="main"><span class="keyword3">,</span></span><span class="operator">insert</span> graph_rule_translation<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> subdom<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="skolem">f</span> <span class="main">⊆</span> Domain <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> v<span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?g</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">∪</span> <span class="main">(</span>Id_on <span class="main">(</span>UNIV <span class="main">-</span> Domain <span class="skolem">f</span><span class="main">)</span> <span class="keyword1">O</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="var">?g</span> <span class="main">=</span> Domain <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> subdom <span class="keyword1"><span class="command">unfolding</span></span> Domain_Un_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> ih<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="var">?g</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> graph_homomorphismI<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?g</span> <span class="main">``</span> vertices <span class="main">(</span>translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> vertices <span class="free">G</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> g<span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main">]</span> f<span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> v <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>translation.simps<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="var">?g</span> <span class="main">(</span>edges <span class="main">(</span>translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> Let_def translation.simps graph_union_edges <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="var">?g</span> <span class="main">(</span>edges <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> edge_preserving_atomic<span class="main">[</span><span class="operator">OF</span> ep_f<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="var">?g</span> <span class="main">(</span>edges <span class="skolem">GR</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> edge_preserving_atomic<span class="main">[</span><span class="operator">OF</span> ep_g<span class="main">]</span> dg <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span><span class="operator">blast</span><span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="var">?g</span> <span class="main">(</span>edges <span class="main">(</span>map_graph_fn <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span> <span class="var">?f</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>GR_def<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> f<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main"><span class="main">]</span></span> g<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> ie<span class="main">:</span><span class="quoted"><span class="quoted">"agree_on <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">)</span> <span class="skolem">f</span> <span class="var">?g</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>v<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> ie ih <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">,</span> translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> extensible_def prod.sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> rhs<span class="main">:</span><span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> translation<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">,</span> translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span>
              <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> rhs<span class="main">[</span><span class="operator">unfolded</span> maintained_def<span class="main">,</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">OF</span> f<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">unfolded</span> extensible_def<span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>translation <span class="main">(</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">g</span>"</span></span>
                     <span class="quoted"><span class="quoted">"agree_on <span class="main">(</span>translation <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span>A_Int <span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def translation<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RuleSemanticsConnection-translation_self"><span class="command">lemma</span></span> translation_self<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span>translation <span class="free">e</span><span class="main">:⟦</span><span class="free">e</span><span class="main">⟧</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Int <span class="skolem">e1</span> <span class="skolem">e2</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="bound">x</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e1</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?f</span> <span class="main">0</span><span class="main">,</span><span class="var">?f</span> <span class="main">1</span><span class="main">)</span> <span class="main">∈</span><span class="main">:</span>map_graph_fn <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span> <span class="var">?f</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> map_graph_in<span class="main">[</span><span class="operator">OF</span> translation_graph A_Int<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"graph_union <span class="main">(</span>translation <span class="skolem">e1</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span> <span class="var">?f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">:</span><span class="main">(</span>translation <span class="skolem">e1</span><span class="main">)</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A_Int <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">:</span>map_graph_fn <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span> <span class="var">?f</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">:</span>map_graph_fn <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span> <span class="var">?f</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span> <span class="main">⊆</span> <span class="main">:</span><span class="var">?G</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">:</span>translation <span class="skolem">e1</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span> <span class="main">⊆</span> <span class="main">:</span><span class="var">?G</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> graph_union_semantics <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cmp <span class="skolem">e1</span> <span class="skolem">e2</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="bound">x</span> <span class="main">+</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?f1</span> <span class="main">0</span><span class="main">,</span><span class="var">?f1</span> <span class="main">1</span><span class="main">)</span> <span class="main">∈</span><span class="main">:</span>map_graph_fn <span class="main">(</span>translation <span class="skolem">e1</span><span class="main">)</span> <span class="var">?f1</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> map_graph_in<span class="main">[</span><span class="operator">OF</span> translation_graph A_Cmp<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?f1</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> f2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?f2</span> <span class="main">0</span><span class="main">,</span><span class="var">?f2</span> <span class="main">1</span><span class="main">)</span> <span class="main">∈</span><span class="main">:</span>map_graph_fn <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span> <span class="var">?f2</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> map_graph_in<span class="main">[</span><span class="operator">OF</span> translation_graph A_Cmp<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?f2</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"graph_union <span class="main">(</span>map_graph_fn <span class="main">(</span>translation <span class="skolem">e1</span><span class="main">)</span> <span class="var">?f1</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span> <span class="var">?f2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">,</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">O</span> <span class="main">{</span><span class="main">(</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">,</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">:</span>map_graph_fn <span class="main">(</span>translation <span class="skolem">e1</span><span class="main">)</span> <span class="var">?f1</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> f1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">:</span>map_graph_fn <span class="main">(</span>translation <span class="skolem">e1</span><span class="main">)</span> <span class="var">?f1</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span> <span class="main">⊆</span> <span class="main">:</span><span class="var">?G</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> graph_union_semantics <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span>card <span class="main">(</span>vertices <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">:</span>map_graph_fn <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span> <span class="var">?f2</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> f2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">:</span>map_graph_fn <span class="main">(</span>translation <span class="skolem">e2</span><span class="main">)</span> <span class="var">?f2</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span> <span class="main">⊆</span> <span class="main">:</span><span class="var">?G</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> graph_union_semantics <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">:</span><span class="var">?G</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span><span class="main">)</span> <span class="keyword1">O</span> <span class="main">(</span><span class="main">:</span><span class="var">?G</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span><span class="main">)</span> <span class="main">=</span> <span class="main">:</span>translation <span class="main">(</span>A_Cmp <span class="skolem">e1</span> <span class="skolem">e2</span><span class="main">)</span><span class="main">:⟦</span>A_Cmp <span class="skolem">e1</span> <span class="skolem">e2</span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cnv <span class="skolem">e</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> map_graph_in<span class="main">[</span><span class="operator">OF</span> translation_graph this<span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="main">(</span><span class="numeral">2</span><span class="main">::</span>nat<span class="main">)</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">-</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="bound">x</span><span class="main">)</span>"</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> map_graph_in<span class="main">[</span><span class="operator">OF</span> translation_graph<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>getRel_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 6 is only used on rules of the form <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span></span> <span class="main"><span class="main">⊑</span></span> <span class="free"><span class="free">e<span class="hidden">⇩</span><sub>R</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
      The requirement of G being a graph can be dropped for one direction.›</span></span>
<span class="keyword1" id="RuleSemanticsConnection-maintained_holds"><span class="command">lemma</span></span> maintained_holds<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">⟧</span> <span class="main">⊆</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">⟧</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>transl_rule <span class="main">(</span><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">⊑</span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span> <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms sentence_iff maintained_holds_iff prod.sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>maintained_def graph_homomorphism_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RuleSemanticsConnection-maintained_holds_subset_iff"><span class="command">lemma</span></span> maintained_holds_subset_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>transl_rule <span class="main">(</span><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">⊑</span> <span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="free">e<span class="hidden">⇩</span><sub>L</sub></span><span class="main">⟧</span> <span class="main">⊆</span> <span class="main">:</span><span class="free">G</span><span class="main">:⟦</span><span class="free">e<span class="hidden">⇩</span><sub>R</sub></span><span class="main">⟧</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms maintained_holds_iff sentence_iff prod.sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="StandardRules">
<div class="head">
<h1>Theory StandardRules</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Standard Rules›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define the standard rules here, and prove the relation to standard rules.
      This means proving that the graph rules do what they say they do.›</span></span>
<span class="keyword1"><span class="command">theory</span></span> StandardRules
<span class="keyword2"><span class="keyword">imports</span></span> <a href="StandardModels.html">StandardModels</a> <a href="RuleSemanticsConnection.html">RuleSemanticsConnection</a>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 16 makes this remark. We don't have a specific version of Definition 16.›</span></span>
<span class="keyword1" id="StandardRules-conflict_free"><span class="command">lemma</span></span> conflict_free<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">:</span><span class="free">G</span><span class="main">:⟦</span>A_Lbl <span class="free">l</span><span class="main">⟧</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="main">(</span><span class="bound">l'</span><span class="main">,</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">G</span><span class="main">.</span> <span class="bound">l'</span> <span class="main">≠</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 17, abstractly.
      It's unlikely that we wish to use the top rule for any symbol except top,
      but stating it abstractly makes it consistent with the other rules.›</span></span>
<span class="comment1">(* Definition 17 *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">top_rule</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span>nat<span class="main">)</span> Graph_PreRule"</span></span> <span class="keyword2"><span class="keyword">where</span></span>	
<span class="quoted"><span class="quoted">"<span class="free">top_rule</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span><span class="main">,</span>LG <span class="main">{</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">}</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span><span class="main">)</span>"</span></span>	

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Proof that definition 17 does what it says it does.›</span></span>
<span class="keyword1" id="StandardRules-top_rule"><span class="command">lemma</span></span> top_rule<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>top_rule <span class="free">r</span><span class="main">)</span> <span class="free">G</span> <span class="main">⟷</span> vertices <span class="free">G</span> <span class="main">×</span> vertices <span class="free">G</span> <span class="main">=</span> getRel <span class="free">r</span> <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>top_rule <span class="free">r</span><span class="main">)</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">}</span><span class="main">)</span> <span class="free">G</span> <span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">,</span><span class="skolem">a</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> a<span class="main">[</span><span class="operator">unfolded</span> maintained_def top_rule_def<span class="main">]</span> extensible_refl_concr
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="main">{</span><span class="main">(</span><span class="free">r</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span><span class="main">}</span> <span class="main">{</span><span class="main">0</span><span class="main">::</span>nat<span class="main">,</span> <span class="main">1</span><span class="main">}</span><span class="main">)</span> <span class="free">G</span> <span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">,</span> <span class="skolem">a</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">r</span> <span class="free">G</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def2 graph_union_iff getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">G</span> <span class="main">×</span> vertices <span class="free">G</span> <span class="main">=</span> getRel <span class="free">r</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> getRel_dom<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"vertices <span class="free">G</span> <span class="main">×</span> vertices <span class="free">G</span> <span class="main">=</span> getRel <span class="free">r</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="keyword3"><span class="command">assume</span></span> a2<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="main">(</span>top_rule <span class="free">r</span><span class="main">)</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">``</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">}</span> <span class="main">⊆</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"on_triple <span class="skolem">f</span> <span class="main">``</span> <span class="main">{}</span> <span class="main">⊆</span> edges <span class="free">G</span>"</span></span>
          <span class="quoted"><span class="quoted">"univalent <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"Domain <span class="skolem">f</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> top_rule_def prod.sel graph_homomorphism_concr_graph<span class="main">[</span><span class="operator">OF</span> assms graph_empty_e<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">argo</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">from</span></span> a2 <span class="keyword1"><span class="command">have</span></span> ih<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">}</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> top_rule_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span>top_rule <span class="free">r</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> top_rule_def extensible_refl_concr<span class="main">[</span><span class="operator">OF</span> ih<span class="main">]</span>
      graph_homomorphism_concr_graph<span class="main">[</span><span class="operator">OF</span> assms graph_single<span class="main">]</span>
      <span class="keyword1"><span class="command">using</span></span> f a<span class="main">[</span><span class="operator">unfolded</span> getRel_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>top_rule <span class="free">r</span><span class="main">)</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> maintained_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 18.›</span></span>
<span class="comment1">(* Definition 18 *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">nonempty_rule</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span><span class="main">,</span>nat<span class="main">)</span> Graph_PreRule"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">nonempty_rule</span> <span class="main">=</span> <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{}</span><span class="main">,</span>LG <span class="main">{}</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span>	

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Proof that definition 18 does what it says it does.›</span></span>
<span class="keyword1" id="StandardRules-nonempty_rule"><span class="command">lemma</span></span> nonempty_rule<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained nonempty_rule <span class="free">G</span> <span class="main">⟷</span> vertices <span class="free">G</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vertices <span class="free">G</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> graph_homomorphism <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">x</span> <span class="main">⟹</span> False"</span></span>
       <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">⟹</span> graph_homomorphism <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="free">G</span> <span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">}</span>"</span></span>
       <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_concr_graph<span class="main">[</span><span class="operator">OF</span> assms graph_empty_e<span class="main">]</span> univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> nonempty_rule_def maintained_def extensible_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>assms<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 19.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">reflexivity_rule</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span>nat<span class="main">)</span> Graph_PreRule"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">reflexivity_rule</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">,</span>LG <span class="main">{</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span><span class="main">}</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span>	
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">symmetry_rule</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span>nat<span class="main">)</span> Graph_PreRule"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">symmetry_rule</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">(</span>transl_rule <span class="main">(</span>A_Cnv <span class="main">(</span>A_Lbl <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">⊑</span> A_Lbl <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">transitive_rule</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span>nat<span class="main">)</span> Graph_PreRule"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">transitive_rule</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">(</span>transl_rule <span class="main">(</span>A_Cmp <span class="main">(</span>A_Lbl <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">(</span>A_Lbl <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">⊑</span> A_Lbl <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">congruence_rule</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> <span class="main">⇒</span> <span class="tfree">'l</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span>nat<span class="main">)</span> Graph_PreRule"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">congruence_rule</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span>transl_rule <span class="main">(</span>A_Cmp <span class="main">(</span>A_Cmp <span class="main">(</span>A_Lbl <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">(</span>A_Lbl <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>A_Lbl <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">⊑</span> A_Lbl <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">congruence_rules</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> <span class="main">⇒</span> <span class="tfree">'l</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'l</span><span class="main">,</span>nat<span class="main">)</span> Graph_PreRule set"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">congruence_rules</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">L</span></span></span> <span class="main">≡</span> congruence_rule <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span>"</span></span>

<span class="keyword1" id="StandardRules-are_rules"><span class="command">lemma</span></span> are_rules<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"graph_rule nonempty_rule"</span></span>	
<span class="quoted"><span class="quoted">"graph_rule <span class="main">(</span>top_rule <span class="free">t</span><span class="main">)</span>"</span></span>	
<span class="quoted"><span class="quoted">"graph_rule <span class="main">(</span>reflexivity_rule <span class="free">i</span><span class="main">)</span>"</span></span>	
  <span class="keyword1"><span class="command">unfolding</span></span> reflexivity_rule_def top_rule_def nonempty_rule_def graph_homomorphism_def	
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Just before Lemma 7, we remark that if I is an identity, it maintains the identity rules.›</span></span>

<span class="keyword1" id="StandardRules-ident_rel_refl"><span class="command">lemma</span></span> ident_rel_refl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"ident_rel <span class="free">idt</span> <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>reflexivity_rule <span class="free">idt</span><span class="main">)</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> reflexivity_rule_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> maintainedI<span class="main">)</span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{</span><span class="main">0</span><span class="main">::</span>nat<span class="main">}</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="skolem">f</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">``</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="main">⊆</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"univalent <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span> univalentD<span class="main">[</span><span class="operator">OF</span> f<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">]</span> f<span class="main">(</span>3<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="skolem">f</span> <span class="main">{</span><span class="main">(</span><span class="free">idt</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">}</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def set_eq_iff image_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> f <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="main">{</span><span class="main">(</span><span class="free">idt</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">}</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span>
              <span class="quoted"><span class="quoted">"agree_on <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def labeled_graph.sel agree_on_def univalent_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">,</span> LG <span class="main">{</span><span class="main">(</span><span class="free">idt</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">}</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> extensible_def prod.sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ident_rel <span class="free">idt</span> <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> ident_rel_trans<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>transitive_rule <span class="free">idt</span><span class="main">)</span> <span class="free">G</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ident_rel_symm <span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>symmetry_rule <span class="free">idt</span><span class="main">)</span> <span class="free">G</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ident_rel_cong <span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>congruence_rule <span class="free">idt</span> <span class="free">l</span><span class="main">)</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> transitive_rule_def symmetry_rule_def congruence_rule_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> maintained_holds<span class="main"><span class="keyword3">,</span></span><span class="operator">insert</span> assms<span class="main"><span class="keyword3">,</span></span><span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 19.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">identity_rules</span> <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Standard_Constant set <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> Standard_Constant<span class="main">,</span> nat<span class="main">)</span> Graph_PreRule<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">identity_rules</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span> <span class="main">≡</span> <span class="main">{</span>reflexivity_rule S_Idt<span class="main">,</span>transitive_rule S_Idt<span class="main">,</span>symmetry_rule S_Idt<span class="main">}</span>
                       <span class="main">∪</span> congruence_rules S_Idt <span class="free"><span class="bound"><span class="entity">L</span></span></span>"</span></span>

<span class="keyword1" id="StandardRules-identity_rules_graph_rule"><span class="command">lemma</span></span> identity_rules_graph_rule<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> identity_rules <span class="free">L</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_rule <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> graph_rule_translation
  <span class="keyword1"><span class="command">have</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">u</span> <span class="bound">v</span> <span class="main">.</span> graph_rule <span class="main">(</span>transl_rule <span class="main">(</span><span class="bound">u</span> <span class="main">⊑</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">consider</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> reflexivity_rule S_Idt"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> transitive_rule S_Idt"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> symmetry_rule S_Idt"</span></span>
    <span class="main">|</span>  <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">v</span> <span class="bound">w</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> congruence_rule <span class="bound">v</span> <span class="bound">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> identity_rules_def Un_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> gr are_rules<span class="main">(</span>3<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> congruence_rule_def transitive_rule_def symmetry_rule_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">fast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 19, showing that the properties indeed do what they claim to do.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> g<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="main">(</span><span class="free">G</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> labeled_graph<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> reflexivity_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>reflexivity_rule <span class="free">l</span><span class="main">)</span> <span class="free">G</span> <span class="main">⟹</span> refl_on <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span> <span class="main">(</span>getRel <span class="free">l</span> <span class="free">G</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> transitive_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>transitive_rule <span class="free">l</span><span class="main">)</span> <span class="free">G</span> <span class="main">⟹</span> trans <span class="main">(</span>getRel <span class="free">l</span> <span class="free">G</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> symmetry_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>symmetry_rule <span class="free">l</span><span class="main">)</span> <span class="free">G</span> <span class="main">⟹</span> sym <span class="main">(</span>getRel <span class="free">l</span> <span class="free">G</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"getRel <span class="free">l</span> <span class="free">G</span> <span class="main">⊆</span> vertices <span class="free">G</span> <span class="main">×</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> m<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>reflexivity_rule <span class="free">l</span><span class="main">)</span> <span class="free">G</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"maintained <span class="var">?r</span> <span class="free">G</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> reflexivity_rule_def
    <span class="keyword3"><span class="command">show</span></span> r<span class="main">:</span><span class="quoted"><span class="quoted">"refl_on <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span> <span class="main">(</span>getRel <span class="free">l</span> <span class="free">G</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> refl_onI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gr<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> assm<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span>  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="var">?r</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assm
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>graph_homomorphism_def univalent_def f_def<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> m<span class="main">[</span><span class="operator">unfolded</span> maintained_def<span class="main">]</span> this 
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">×</span><span class="tfree">'b</span><span class="main">)</span> set"</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="var">?r</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">g</span>"</span></span>
                <span class="quoted"><span class="quoted">"agree_on <span class="main">(</span>fst <span class="var">?r</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">g</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> extensible_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">n</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">g</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">n</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span> <span class="main">=</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g <span class="keyword1"><span class="command">unfolding</span></span>
        agree_on_def graph_homomorphism_def f_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> g<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def f_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> g<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def edge_preserving getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> m<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>transitive_rule <span class="free">l</span><span class="main">)</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> m<span class="main">[</span><span class="operator">unfolded</span> maintained_holds_subset_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> g<span class="main"><span class="main">]</span></span> transitive_rule_def<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"trans <span class="main">(</span>getRel <span class="free">l</span> <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> trans_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> m<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>symmetry_rule <span class="free">l</span><span class="main">)</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> m<span class="main">[</span><span class="operator">unfolded</span> maintained_holds_subset_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> g<span class="main"><span class="main">]</span></span> symmetry_rule_def<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sym <span class="main">(</span>getRel <span class="free">l</span> <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> sym_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StandardRules-finite_identity_rules"><span class="command">lemma</span></span> finite_identity_rules<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">L</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>identity_rules <span class="free">L</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> identity_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="StandardRules-equivalence"><span class="command">lemma</span></span> equivalence<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> m<span class="main">:</span><span class="quoted"><span class="quoted">"maintainedA <span class="main">{</span>reflexivity_rule <span class="free">I</span><span class="main">,</span>transitive_rule <span class="free">I</span><span class="main">,</span>symmetry_rule <span class="free">I</span><span class="main">}</span> <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"equiv <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span> <span class="main">(</span>getRel <span class="free">I</span> <span class="free">G</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> equivI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"refl_on <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span> <span class="main">(</span>getRel <span class="free">I</span> <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> m <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> reflexivity_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gr<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sym <span class="main">(</span>getRel <span class="free">I</span> <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> m <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> symmetry_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gr<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"trans <span class="main">(</span>getRel <span class="free">I</span> <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> m <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> transitive_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gr<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StandardRules-congruence_rule"><span class="command">lemma</span></span> congruence_rule<span class="main">:</span>
 <span class="comment1">(* Transitivity is not needed for this proof, but it's more convenient to reuse in this form *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> mA<span class="main">:</span><span class="quoted"><span class="quoted">"maintainedA <span class="main">{</span>reflexivity_rule <span class="free">I</span><span class="main">,</span>transitive_rule <span class="free">I</span><span class="main">,</span>symmetry_rule <span class="free">I</span><span class="main">}</span> <span class="free">G</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> m<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>congruence_rule <span class="free">I</span> <span class="free">l</span><span class="main">)</span> <span class="free">G</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">v</span><span class="main">.</span> getRel <span class="free">l</span> <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">respects</span> <span class="main">(</span>getRel <span class="free">I</span> <span class="free">G</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?g1</span>"</span></span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span>getRel <span class="free">l</span> <span class="free">G</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">respects</span> <span class="main">(</span>getRel <span class="free">I</span> <span class="free">G</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?g2</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="comment1">(* Both parts of this lemma are proved using roughly the same proof. *)</span>
  <span class="keyword1"><span class="command">note</span></span> eq <span class="main">=</span> equivalence<span class="main">[</span><span class="operator">OF</span> g mA<span class="main">]</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="skolem">z</span>
    <span class="keyword3"><span class="command">assume</span></span> aI<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span><span class="main">∈</span>getRel <span class="free">I</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> a2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span><span class="main">∈</span>getRel <span class="free">I</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq<span class="main">[</span><span class="operator">unfolded</span> equiv_def sym_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> a3<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span><span class="main">∈</span>getRel <span class="free">I</span> <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span><span class="main">∈</span>getRel <span class="free">I</span> <span class="free">G</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> eq<span class="main">[</span><span class="operator">unfolded</span> equiv_def refl_on_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> al<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> r<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">I</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq<span class="main">[</span><span class="operator">unfolded</span> equiv_def refl_on_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">note</span></span> relcompI<span class="main">[</span><span class="operator">OF</span> relcompI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> a2 al<span class="main"><span class="main">]</span></span> r<span class="main">]</span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> yx <span class="main">=</span> this
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> al<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> r<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">I</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq<span class="main">[</span><span class="operator">unfolded</span> equiv_def refl_on_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">note</span></span> relcompI<span class="main">[</span><span class="operator">OF</span> relcompI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> aI al<span class="main"><span class="main">]</span></span> r<span class="main">]</span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> zx <span class="main">=</span> this
      <span class="keyword1"><span class="command">from</span></span> zx yx m<span class="main">[</span><span class="operator">unfolded</span> maintained_holds_subset_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> g<span class="main"><span class="main">]</span></span> congruence_rule_def<span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span> <span class="main">⟷</span> <span class="main">(</span><span class="skolem">z</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> v1 <span class="main">=</span> this
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> al<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> r<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">I</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq<span class="main">[</span><span class="operator">unfolded</span> equiv_def refl_on_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">note</span></span> relcompI<span class="main">[</span><span class="operator">OF</span> relcompI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> r al<span class="main"><span class="main">]</span></span> aI<span class="main">]</span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> yx <span class="main">=</span> this
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> al<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> r<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">I</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq<span class="main">[</span><span class="operator">unfolded</span> equiv_def refl_on_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">note</span></span> relcompI<span class="main">[</span><span class="operator">OF</span> relcompI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> r al<span class="main"><span class="main">]</span></span> a2<span class="main">]</span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> zx <span class="main">=</span> this
      <span class="keyword1"><span class="command">from</span></span> zx yx m<span class="main">[</span><span class="operator">unfolded</span> maintained_holds_subset_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> g<span class="main"><span class="main">]</span></span> congruence_rule_def<span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span> <span class="main">⟷</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="free">l</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> v2 <span class="main">=</span> this
    <span class="keyword1"><span class="command">from</span></span> v1 v2
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"getRel <span class="free">l</span> <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">=</span> getRel <span class="free">l</span> <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span>"</span></span>
         <span class="quoted"><span class="quoted">"<span class="main">(</span>getRel <span class="free">l</span> <span class="free">G</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span> <span class="main">=</span> <span class="main">(</span>getRel <span class="free">l</span> <span class="free">G</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">z</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?g1</span></span></span> <span class="var"><span class="quoted"><span class="var">?g2</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> congruent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 7, strengthened with an extra property to make subsequent proofs easier to carry out.›</span></span>
<span class="keyword1" id="StandardRules-identity_rules"><span class="command">lemma</span></span> identity_rules<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
          <span class="quoted"><span class="quoted">"maintainedA <span class="main">(</span>identity_rules <span class="free">L</span><span class="main">)</span> <span class="free">G</span>"</span></span>
          <span class="quoted"><span class="quoted">"fst <span class="main">`</span> edges <span class="free">G</span> <span class="main">⊆</span> <span class="free">L</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="keyword1">o</span> <span class="bound">f</span> <span class="main">=</span> <span class="bound">f</span>
         <span class="main">∧</span> ident_rel S_Idt <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="bound">f</span><span class="main">)</span>
         <span class="main">∧</span> subgraph <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="bound">f</span><span class="main">)</span> <span class="free">G</span>
         <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">l</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span> <span class="main">⟷</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">f</span> <span class="bound">x</span><span class="main">,</span><span class="bound">f</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="comment1">(* While this proof defines a concrete f, we only expose it using an existential quantifier.
     The reason is that the f of our choice is non-constructive,
     and its definition relies on the axiom of choice.
     In fact, this theorem applies to the infinite case too,
     which means that it's probably equivalent to the axiom of choice.
     We therefore have no hopes of giving an executable concrete f here.
     In the implementation, we will be able to use finiteness of G (which is not required here),
     and therefore we can construct an f with these properties again.
     Unfortunately, this does mean doing roughly the same proof twice. *)</span>
  <span class="keyword1"><span class="command">have</span></span> ma<span class="main">:</span><span class="quoted"><span class="quoted">"maintainedA <span class="main">{</span>reflexivity_rule S_Idt<span class="main">,</span> transitive_rule S_Idt<span class="main">,</span> symmetry_rule S_Idt<span class="main">}</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>identity_rules_def<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> equiv <span class="main">=</span> equivalence<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> this<span class="main">]</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="skolem">l</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">hence</span></span> l<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">∈</span> <span class="free">L</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> r1<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> getRel <span class="skolem">l</span> <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">respects</span> getRel S_Idt <span class="free">G</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> congruence_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> ma<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> l <span class="keyword1"><span class="command">unfolding</span></span> identity_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> r2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span>getRel <span class="skolem">l</span> <span class="free">G</span><span class="main">)</span><span class="main">¯</span> <span class="main">``</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">respects</span> getRel S_Idt <span class="free">G</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> congruence_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> ma<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> l <span class="keyword1"><span class="command">unfolding</span></span> identity_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">note</span></span> congr <span class="main">=</span> r1 r2
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> congr <span class="main">=</span> this
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">P</span></span> <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> getRel S_Idt <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"getRel S_Idt <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">y</span><span class="main">.</span> <span class="skolem">P</span> <span class="skolem">x</span> <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> P <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> p<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="skolem">x</span> <span class="main">(</span>Eps <span class="main">(</span><span class="skolem">P</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> some_eq_ex <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span>
      <span class="keyword3"><span class="command">assume</span></span> b<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> P <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> equiv_class_eq<span class="main">[</span><span class="operator">OF</span> equiv this<span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"getRel S_Idt <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> getRel S_Idt <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> u <span class="main">=</span> this<span class="main">[</span><span class="operator">OF</span> p<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"getRel S_Idt <span class="free">G</span> <span class="main">``</span> <span class="main">{</span>Eps <span class="main">(</span><span class="skolem">P</span> <span class="skolem">x</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> getRel S_Idt <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> u <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> refl<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Eps <span class="main">(</span><span class="skolem">P</span> <span class="main">(</span>Eps <span class="main">(</span><span class="skolem">P</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Eps <span class="main">(</span><span class="skolem">P</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> P <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> P_eq <span class="main">=</span> this
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">if</span> getRel S_Idt <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">y</span><span class="main">.</span> <span class="skolem">P</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f</span> <span class="main">∘</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"getRel S_Idt <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> P_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>o_def f<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>o_def f<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> idemp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="keyword1">o</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
 
  <span class="keyword1"><span class="command">from</span></span> equivE equiv <span class="keyword1"><span class="command">have</span></span> refl<span class="main">:</span><span class="quoted"><span class="quoted">"refl_on <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span> <span class="main">(</span>getRel S_Idt <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="free">G</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">unfolding</span></span> refl_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> vert_P<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> Eps <span class="main">(</span><span class="skolem">P</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="free">G</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
     <span class="keyword1"><span class="command">unfolding</span></span> P getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> tfl_some Image_singleton_iff getRel_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> r1<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">⟷</span> <span class="skolem">P</span> <span class="skolem">x</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">using</span></span> refl <span class="keyword1"><span class="command">unfolding</span></span> refl_on_def P <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> r2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"getRel S_Idt <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> <span class="skolem">x</span> <span class="main">∉</span> vertices <span class="free">G</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">using</span></span> refl assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> refl_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>S_Idt<span class="main">,</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">∈</span> edges <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"getRel S_Idt <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> getRel S_Idt <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">y</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> equiv_class_eq<span class="main">[</span><span class="operator">OF</span> equiv<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Eps <span class="main">(</span><span class="skolem">P</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> Eps <span class="main">(</span><span class="skolem">P</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> P <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> idt_eq <span class="main">=</span> this
  <span class="keyword1"><span class="command">have</span></span> ident<span class="main">:</span><span class="quoted"><span class="quoted">"ident_rel S_Idt <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="skolem">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ident_relI<span class="main"><span class="keyword3">,</span></span><span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> f <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>f <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>idt_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f</span> <span class="skolem">y</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="free">G</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> vert_P equivE<span class="main">[</span><span class="operator">OF</span> equiv<span class="main">]</span> sym_def <span class="keyword1"><span class="command">unfolding</span></span> f <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> a <span class="keyword1"><span class="command">have</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="skolem">l</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> congruentD<span class="main">[</span><span class="operator">OF</span> congr<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> gr<span class="main"><span class="main">]</span></span> f<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> congruentD<span class="main">[</span><span class="operator">OF</span> congr<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> gr<span class="main"><span class="main">]</span></span> f<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> a<span class="main">(</span>1<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span><span class="skolem">f</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> set_eq_iff getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> gu1 <span class="main">=</span> this
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> vert_P <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span>Eps <span class="main">(</span><span class="skolem">P</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Eps <span class="main">(</span><span class="skolem">P</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">unfolding</span></span> f <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> gu2 <span class="main">=</span> this
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_union <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="skolem">f</span><span class="main">)</span> <span class="free">G</span> <span class="main">=</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> gu1 gu2 assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> graph_union_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">G</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> subg<span class="main">:</span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="skolem">f</span><span class="main">)</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">have</span></span> congr<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">f</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">f</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="skolem">l</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> a <span class="keyword1"><span class="command">have</span></span> fv<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">y</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> vertices <span class="free">G</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"getRel S_Idt <span class="free">G</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> a f <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> fv <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> gx<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="free">G</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> gy<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> f v vert_P<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> congruentD<span class="main">[</span><span class="operator">OF</span> congr<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> gr<span class="main"><span class="main">]</span></span> gx<span class="main">]</span> gr
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="skolem">l</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> congruentD<span class="main">[</span><span class="operator">OF</span> congr<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> gr<span class="main"><span class="main">]</span></span> gy<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="skolem">l</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> gu1<span class="main">[</span><span class="operator">OF</span> e this<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">f</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  
  <span class="keyword1"><span class="command">from</span></span> idemp ident subg congr <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The idempotency property of Lemma 7 suffices to show that 'maintained' is preserved.›</span></span>
<span class="keyword1" id="StandardRules-idemp_embedding_maintained_preserved"><span class="command">lemma</span></span> idemp_embedding_maintained_preserved<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> subg<span class="main">:</span><span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span> <span class="free">G</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>vertices <span class="free">G</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">f</span> <span class="keyword1">o</span> <span class="free">f</span><span class="main">)</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">x</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> maint<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="free">r</span> <span class="free">G</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained <span class="free">r</span> <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="keyword3"><span class="command">assume</span></span> hom_h<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="free">r</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span> <span class="skolem">h</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> subgraph_preserves_hom<span class="main">[</span><span class="operator">OF</span> subg this<span class="main">]</span> maint<span class="main">[</span><span class="operator">unfolded</span> maintained_def extensible_def<span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>snd <span class="free">r</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">g</span>"</span></span>
                     <span class="quoted"><span class="quoted">"agree_on <span class="main">(</span>fst <span class="free">r</span><span class="main">)</span> <span class="skolem">h</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">have</span></span> subs<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="main">⊆</span> vertices <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> hom_h<span class="main">[</span><span class="operator">unfolded</span> graph_homomorphism_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>vertices <span class="main">(</span>fst <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> x<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">g</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">h</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> agree_on_def<span class="main">,</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="main">⊆</span> vertices <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> subs <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> x2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="free">f</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> f x2 <span class="keyword1"><span class="command">unfolding</span></span> o_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command">from</span></span> x2 subgraph_subset<span class="main">[</span><span class="operator">OF</span> subg<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="free">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> on_graph <span class="free">G</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">g</span> <span class="keyword1">O</span> on_graph <span class="free">G</span> <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> f <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">hence</span></span> agr<span class="main">:</span><span class="quoted"><span class="quoted">"agree_on <span class="main">(</span>fst <span class="free">r</span><span class="main">)</span> <span class="skolem">h</span> <span class="main">(</span><span class="skolem">g</span> <span class="keyword1">O</span> on_graph <span class="free">G</span> <span class="free">f</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> g<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"extensible <span class="free">r</span> <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">f</span><span class="main">)</span> <span class="skolem">h</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> extensible_def <span class="keyword1"><span class="command">using</span></span> graph_homomorphism_on_graph<span class="main">[</span><span class="operator">OF</span> g<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> agr <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> maintained_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 20.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">const_exists</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">const_exists</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">≡</span> transl_rule <span class="main">(</span><span class="main">⊤</span> <span class="main">⊑</span> A_Cmp <span class="main">(</span>A_Cmp <span class="main">⊤</span> <span class="main">(</span>A_Lbl <span class="main">(</span>S_Const <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⊤</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">const_exists_rev</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">const_exists_rev</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">≡</span> transl_rule <span class="main">(</span>A_Cmp <span class="main">(</span>A_Cmp <span class="main">(</span>A_Lbl <span class="main">(</span>S_Const <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⊤</span><span class="main">)</span> <span class="main">(</span>A_Lbl <span class="main">(</span>S_Const <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⊑</span> A_Lbl <span class="main">(</span>S_Const <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">const_prop</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">const_prop</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">≡</span> transl_rule <span class="main">(</span>A_Lbl <span class="main">(</span>S_Const <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">⊑</span> <span class="main">𝟭</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">const_disj</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">const_disj</span> <span class="free"><span class="bound"><span class="entity">c<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">c<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">≡</span> transl_rule <span class="main">(</span>A_Cmp <span class="main">(</span>A_Lbl <span class="main">(</span>S_Const <span class="free"><span class="bound"><span class="entity">c<span class="hidden">⇩</span><sub>1</sub></span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>A_Lbl <span class="main">(</span>S_Const <span class="free"><span class="bound"><span class="entity">c<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⊑</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="StandardRules-constant_rules"><span class="command">lemma</span></span> constant_rules<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"standard' <span class="free">C</span> <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">∈</span> <span class="free">C</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>const_exists <span class="free">c</span><span class="main">)</span> <span class="free">G</span>"</span></span>
        <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>const_exists_rev <span class="free">c</span><span class="main">)</span> <span class="free">G</span>"</span></span>
        <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>const_prop <span class="free">c</span><span class="main">)</span> <span class="free">G</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="free">c'</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">≠</span> <span class="free">c'</span> <span class="main">⟹</span> maintained <span class="main">(</span>const_disj <span class="free">c</span> <span class="free">c'</span><span class="main">)</span> <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> a <span class="main">=</span> assms<span class="main">[</span><span class="operator">unfolded</span> standard_def<span class="main">]</span>
  <span class="keyword1"><span class="command">from</span></span> a <span class="keyword1"><span class="command">have</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> a
  <span class="keyword1"><span class="command">have</span></span> gr_c<span class="main">:</span><span class="quoted"><span class="quoted">"getRel <span class="main">(</span>S_Const <span class="free">c</span><span class="main">)</span> <span class="free">G</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>Inl <span class="free">c</span><span class="main">,</span> Inl <span class="free">c</span><span class="main">)</span><span class="main">}</span>"</span></span>
       <span class="quoted"><span class="quoted">"getRel S_Idt <span class="free">G</span> <span class="main">=</span> Id_on <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"getRel S_Bot <span class="free">G</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
       <span class="quoted"><span class="quoted">"getRel S_Top <span class="free">G</span> <span class="main">=</span> vertices <span class="free">G</span> <span class="main">×</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> g <span class="keyword1"><span class="command">have</span></span> inlc<span class="main">:</span><span class="quoted"><span class="quoted">"Inl <span class="free">c</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> getRel_dom<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> singletonI<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>const_exists <span class="free">c</span><span class="main">)</span> <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>const_exists_rev <span class="free">c</span><span class="main">)</span> <span class="free">G</span>"</span></span>
       <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>const_prop <span class="free">c</span><span class="main">)</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> const_prop_def const_exists_rev_def const_exists_def maintained_holds_subset_iff<span class="main">[</span><span class="operator">OF</span> g<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>gr_c relcomp_unfold<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">c'</span> <span class="main">∈</span> <span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> a <span class="keyword1"><span class="command">have</span></span> gr_c'<span class="main">:</span><span class="quoted"><span class="quoted">"getRel <span class="main">(</span>S_Const <span class="free">c'</span><span class="main">)</span> <span class="free">G</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>Inl <span class="free">c'</span><span class="main">,</span> Inl <span class="free">c'</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">≠</span> <span class="free">c'</span> <span class="main">⟹</span>  maintained <span class="main">(</span>const_disj <span class="free">c</span> <span class="free">c'</span><span class="main">)</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> const_disj_def maintained_holds_subset_iff<span class="main">[</span><span class="operator">OF</span> g<span class="main">]</span> <span class="keyword1"><span class="command">using</span></span> gr_c <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">constant_rules</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">constant_rules</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">≡</span> const_exists <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">∪</span> const_exists_rev <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">∪</span> const_prop <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span>
                  <span class="main">∪</span> <span class="main">{</span>const_disj <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">|</span> <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span> <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">∧</span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">∧</span> <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">≠</span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span><span class="main">}</span>"</span></span>

<span class="keyword1" id="StandardRules-constant_rules_graph_rule"><span class="command">lemma</span></span> constant_rules_graph_rule<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> constant_rules <span class="free">C</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_rule <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> graph_rule_translation
  <span class="keyword1"><span class="command">have</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">u</span> <span class="bound">v</span> <span class="main">.</span> graph_rule <span class="main">(</span>transl_rule <span class="main">(</span><span class="bound">u</span> <span class="main">⊑</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">consider</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">v</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> const_exists <span class="bound">v</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">v</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> const_exists_rev <span class="bound">v</span>"</span></span> <span class="main">|</span>  <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">v</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> const_prop <span class="bound">v</span>"</span></span>
    <span class="main">|</span>  <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">v</span> <span class="bound">w</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> const_disj <span class="bound">v</span> <span class="bound">w</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> constant_rules_def Un_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> gr
    <span class="keyword1"><span class="command">unfolding</span></span> const_exists_def const_exists_rev_def const_prop_def const_disj_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">fast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StandardRules-finite_constant"><span class="command">lemma</span></span> finite_constant<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">C</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>constant_rules <span class="free">C</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>const_disj <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">|</span> <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span> <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∈</span> <span class="free">C</span> <span class="main">∧</span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∈</span> <span class="free">C</span> <span class="main">∧</span> <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">≠</span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span><span class="main">}</span> <span class="main">⊆</span> case_prod const_disj <span class="main">`</span> <span class="main">(</span><span class="free">C</span> <span class="main">×</span> <span class="free">C</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span>const_disj <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">|</span> <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span> <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∈</span> <span class="free">C</span> <span class="main">∧</span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∈</span> <span class="free">C</span> <span class="main">∧</span> <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">≠</span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> constant_rules_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StandardRules-standard_maintains_constant_rules"><span class="command">lemma</span></span> standard_maintains_constant_rules<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"standard' <span class="free">C</span> <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span><span class="main">∈</span>constant_rules <span class="free">C</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained <span class="free">R</span> <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> constant_rules_def<span class="main">]</span>
  <span class="keyword1"><span class="command">consider</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">c</span> <span class="main">∈</span> <span class="free">C</span><span class="main">.</span> <span class="free">R</span> <span class="main">=</span> const_exists <span class="bound">c</span>"</span></span>
         <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">c</span> <span class="main">∈</span> <span class="free">C</span><span class="main">.</span> <span class="free">R</span> <span class="main">=</span> const_exists_rev <span class="bound">c</span>"</span></span>
         <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">c</span> <span class="main">∈</span> <span class="free">C</span><span class="main">.</span> <span class="free">R</span> <span class="main">=</span> const_prop <span class="bound">c</span>"</span></span>
         <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span> <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∈</span> <span class="free">C</span> <span class="main">∧</span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∈</span> <span class="free">C</span> <span class="main">∧</span> <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">≠</span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> <span class="free">R</span> <span class="main">=</span> const_disj <span class="bound">c<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">c<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> this assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>constant_rules<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StandardRules-constant_rules_empty"><span class="command">lemma</span></span> constant_rules_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"constant_rules <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>constant_rules_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition 20, continued.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">standard_rules</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> Standard_Constant set <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> Standard_Constant<span class="main">,</span> nat<span class="main">)</span> labeled_graph <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span> Standard_Constant<span class="main">,</span> nat<span class="main">)</span> labeled_graph<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">standard_rules</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">L</span></span></span> <span class="main">≡</span> constant_rules <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">∪</span> identity_rules <span class="free"><span class="bound"><span class="entity">L</span></span></span> <span class="main">∪</span> <span class="main">{</span>top_rule S_Top<span class="main">,</span>nonempty_rule<span class="main">}</span>"</span></span>

<span class="keyword1" id="StandardRules-constant_rules_mono"><span class="command">lemma</span></span> constant_rules_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">C<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> <span class="free">C<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"constant_rules <span class="free">C<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> constant_rules <span class="free">C<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> constant_rules_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> Un_mono<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span> <span class="comment1">(* also works with just auto, this is faster *)</span>

<span class="keyword1" id="StandardRules-identity_rules_mono"><span class="command">lemma</span></span> identity_rules_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">C<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> <span class="free">C<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"identity_rules <span class="free">C<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> identity_rules <span class="free">C<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
   <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> identity_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="StandardRules-standard_rules_mono"><span class="command">lemma</span></span> standard_rules_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">C<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> <span class="free">C<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">L<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> <span class="free">L<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"standard_rules <span class="free">C<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">L<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> standard_rules <span class="free">C<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">L<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> constant_rules_mono<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> identity_rules_mono<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> standard_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="StandardRules-maintainedA_invmono"><span class="command">lemma</span></span> maintainedA_invmono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">C<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> <span class="free">C<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">L<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊆</span> <span class="free">L<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintainedA <span class="main">(</span>standard_rules <span class="free">C<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">L<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="free">G</span> <span class="main">⟹</span> maintainedA <span class="main">(</span>standard_rules <span class="free">C<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">L<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> standard_rules_mono<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="StandardRules-maintained_preserved_by_isomorphism"><span class="command">lemma</span></span> maintained_preserved_by_isomorphism<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span>"</span></span> <span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"maintained <span class="free">r</span> <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained <span class="free">r</span> <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Pair <span class="skolem">L</span> <span class="skolem">R</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Pair <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span><span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">h</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> maintained_def Pair<span class="main">]</span> graph_homomorphism_on_graph<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">g</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span><span class="skolem">L</span><span class="main">,</span> <span class="skolem">R</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">g</span><span class="main">)</span> <span class="main">(</span><span class="skolem">h</span> <span class="keyword1">O</span> on_graph <span class="free">G</span> <span class="free">g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">h2</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> h2<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="skolem">R</span> <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">g</span><span class="main">)</span> <span class="skolem">h2</span>"</span></span> <span class="quoted"><span class="quoted">"agree_on <span class="skolem">L</span> <span class="main">(</span><span class="skolem">h</span> <span class="keyword1">O</span> on_graph <span class="free">G</span> <span class="free">g</span><span class="main">)</span> <span class="skolem">h2</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> extensible_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword1"><span class="command">have</span></span> h_id<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="keyword1">O</span> Id_on <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">h</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?h</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">h2</span> <span class="keyword1">O</span> on_graph <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">g</span><span class="main">)</span> <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"on_graph <span class="free">G</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> Id_on <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"map_graph_fn <span class="free">G</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> map_graph_fn_id <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> graph_homomorphism_on_graph<span class="main">[</span><span class="operator">OF</span> h2<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> igh<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="skolem">R</span> <span class="free">G</span> <span class="var">?h</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">g</span> <span class="skolem">xa</span> <span class="main">⟹</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span> <span class="main">⟹</span> <span class="skolem">xa</span> <span class="main">∈</span> <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span> <span class="main">⟹</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">xa</span>"</span></span> 
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">xa</span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> o_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">g</span> <span class="skolem">xa</span> <span class="main">⟹</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span> <span class="main">⟹</span> <span class="skolem">xa</span> <span class="main">∈</span> <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">xa</span><span class="main">)</span> <span class="main">∈</span> Id_on <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">xa</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> id<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span>on_graph <span class="free">G</span> <span class="free">g</span><span class="main">)</span> <span class="keyword1">O</span> on_graph <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">g</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> Id_on <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> agree_on_ext<span class="main">[</span><span class="operator">OF</span> h2<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"on_graph <span class="main">(</span>map_graph_fn <span class="free">G</span> <span class="free">g</span><span class="main">)</span> <span class="free">f</span>"</span></span><span class="main">,</span><span class="operator">unfolded</span> O_assoc<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> agh<span class="main">:</span><span class="quoted"><span class="quoted">"agree_on <span class="skolem">L</span> <span class="skolem">h</span> <span class="var">?h</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> agree_on_def id h_id<span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">from</span></span> igh agh <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> extensible_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StandardRules-standard_identity_rules"><span class="command">lemma</span></span> standard_identity_rules<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"standard' <span class="free">C</span> <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>reflexivity_rule S_Idt<span class="main">)</span> <span class="free">G</span>"</span></span>
        <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>transitive_rule S_Idt<span class="main">)</span> <span class="free">G</span>"</span></span>
        <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>symmetry_rule S_Idt<span class="main">)</span> <span class="free">G</span>"</span></span>
        <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>congruence_rule S_Idt <span class="free">l</span><span class="main">)</span> <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> a <span class="main">=</span> assms<span class="main">[</span><span class="operator">unfolded</span> standard_def<span class="main">]</span>
  <span class="keyword1"><span class="command">from</span></span> a <span class="keyword1"><span class="command">have</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> a
  <span class="keyword1"><span class="command">have</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"getRel S_Idt <span class="free">G</span> <span class="main">=</span> Id_on <span class="main">(</span>vertices <span class="free">G</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"getRel S_Bot <span class="free">G</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
       <span class="quoted"><span class="quoted">"getRel S_Top <span class="free">G</span> <span class="main">=</span> vertices <span class="free">G</span> <span class="main">×</span> vertices <span class="free">G</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> v_gr<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span>S_Idt<span class="main">,</span> <span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a</span> <span class="main">∈</span> vertices <span class="free">G</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">=</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>transitive_rule S_Idt<span class="main">)</span> <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>symmetry_rule S_Idt<span class="main">)</span> <span class="free">G</span>"</span></span>
       <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>congruence_rule S_Idt <span class="free">l</span><span class="main">)</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> transitive_rule_def symmetry_rule_def congruence_rule_def
              maintained_holds_subset_iff<span class="main">[</span><span class="operator">OF</span> g<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>gr relcomp_unfold<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span><span class="main">)</span> set"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="main">{}</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> u<span class="main">:</span><span class="quoted"><span class="quoted">"univalent <span class="skolem">f</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> d<span class="main">:</span><span class="quoted"><span class="quoted">"Domain <span class="skolem">f</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> r<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">``</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="main">⊆</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">from</span></span> d <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> d insert_iff mk_disjoint_insert all_not_in_conv old.prod.exhaust
            u<span class="main">[</span><span class="operator">unfolded</span> univalent_def<span class="main">]</span> Domain.intros<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="skolem">f</span></span><span class="main">,</span><span class="operator">unfolded</span> d<span class="main">,</span><span class="operator">THEN</span> singletonD<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> v r <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> vertices <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> v_gr <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>S_Idt<span class="main">,</span> <span class="skolem">v</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"edge_preserving <span class="main">{</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">}</span> <span class="main">{</span><span class="main">(</span>S_Idt<span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">}</span> <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>LG <span class="main">{</span><span class="main">(</span>S_Idt<span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">}</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="free">G</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> f
      graph_homomorphism_def <span class="keyword1"><span class="command">using</span></span> g v <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>univalent_def<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>reflexivity_rule S_Idt<span class="main">)</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> reflexivity_rule_def maintained_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StandardRules-standard_maintains_identity_rules"><span class="command">lemma</span></span> standard_maintains_identity_rules<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"standard' <span class="free">C</span> <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">∈</span>identity_rules <span class="free">L</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintained <span class="free">x</span> <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">consider</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> reflexivity_rule S_Idt"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> transitive_rule S_Idt"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> symmetry_rule S_Idt"</span></span>
    <span class="main">|</span>  <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">l</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> congruence_rule S_Idt <span class="bound">l</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> identity_rules_def Un_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> standard_identity_rules<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span></span>1<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StandardRules-standard_maintains_rules"><span class="command">lemma</span></span> standard_maintains_rules<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"standard' <span class="free">C</span> <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"maintainedA <span class="main">(</span>standard_rules <span class="free">C</span> <span class="free">L</span><span class="main">)</span> <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="main">∈</span> standard_rules <span class="free">C</span> <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">consider</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="main">∈</span> constant_rules <span class="free">C</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="main">∈</span> identity_rules <span class="free">L</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="main">=</span> top_rule S_Top"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="main">=</span> nonempty_rule"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>standard_rules_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"maintained <span class="skolem">R</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms standard_maintains_constant_rules<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
          standard_maintains_identity_rules<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>standard_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A case-split rule.›</span></span>
<span class="keyword1" id="StandardRules-standard_rules_edges"><span class="command">lemma</span></span> standard_rules_edges<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">lhs</span><span class="main">,</span> <span class="free">rhs</span><span class="main">)</span> <span class="main">∈</span> standard_rules <span class="free">C</span> <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">rhs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l</span> <span class="main">=</span> S_Bot <span class="main">⟹</span> <span class="free">thesis</span><span class="main">)</span> <span class="main">⟹</span>
         <span class="main">(</span><span class="free">l</span> <span class="main">=</span> S_Top <span class="main">⟹</span> <span class="free">thesis</span><span class="main">)</span> <span class="main">⟹</span>
         <span class="main">(</span><span class="free">l</span> <span class="main">=</span> S_Idt <span class="main">⟹</span> <span class="free">thesis</span><span class="main">)</span> <span class="main">⟹</span>
         <span class="main">(</span><span class="free">l</span> <span class="main">∈</span> S_Const <span class="main">`</span> <span class="free">C</span> <span class="main">⟹</span> <span class="free">thesis</span><span class="main">)</span> <span class="main">⟹</span>
         <span class="main">(</span><span class="free">l</span> <span class="main">∈</span> <span class="free">L</span> <span class="main">⟹</span> <span class="free">thesis</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">thesis</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> defined_all<span class="main">]</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def standard_rules_def constant_rules_def identity_rules_def
   const_exists_def const_exists_rev_def const_prop_def const_disj_def
   reflexivity_rule_def transitive_rule_def symmetry_rule_def congruence_rule_def
   top_rule_def nonempty_rule_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 8.

   This is a slightly stronger version of Lemma 8:
   we reason about maintained rather than holds,
   and the quantification for maintained happens within the existential quantifier, rather than outside.

   Due to the type system of Isabelle, we construct the concrete type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">std_graph</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for G.
   This in contrast to arguing that 'there exists a type large enough', as in the paper.›</span></span>

<span class="keyword1" id="StandardRules-maintained_standard_noconstants"><span class="command">lemma</span></span> maintained_standard_noconstants<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mnt<span class="main">:</span><span class="quoted"><span class="quoted">"maintainedA <span class="main">(</span>standard_rules <span class="free">C</span> <span class="free">L</span><span class="main">)</span> <span class="free">G'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="main">(</span><span class="free">G'</span><span class="main">::</span><span class="main">(</span><span class="tfree">'V</span> Standard_Constant<span class="main">,</span> <span class="tfree">'V'</span><span class="main">)</span> labeled_graph<span class="main">)</span>"</span></span>
         <span class="quoted"><span class="quoted">"fst <span class="main">`</span> edges <span class="free">G'</span> <span class="main">⊆</span> <span class="free">L</span>"</span></span> <span class="comment1">(* Graph on labels L *)</span>
  <span class="keyword2"><span class="keyword">and</span></span> cf<span class="main">:</span><span class="quoted"><span class="quoted">"getRel S_Bot <span class="free">G'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="comment1">(* Conflict free *)</span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">f</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">G</span><span class="main">::</span><span class="main">(</span><span class="tfree">'V</span><span class="main">,</span> <span class="tfree">'V'</span><span class="main">)</span> std_graph<span class="main">)</span><span class="main">.</span> <span class="bound">G</span> <span class="main">=</span> map_graph_fn <span class="bound">G</span> <span class="main">(</span><span class="bound">f</span> <span class="keyword1">o</span> <span class="bound">g</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">G</span> <span class="main">=</span> map_graph_fn <span class="free">G'</span> <span class="bound">f</span>
              <span class="main">∧</span> subgraph <span class="main">(</span>map_graph_fn <span class="bound">G</span> <span class="bound">g</span><span class="main">)</span> <span class="free">G'</span>
              <span class="main">∧</span> standard' <span class="free">C</span> <span class="bound">G</span>
              <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">r</span><span class="main">.</span> maintained <span class="bound">r</span> <span class="free">G'</span> <span class="main">⟶</span> maintained <span class="bound">r</span> <span class="bound">G</span><span class="main">)</span>
              <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">e</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="free">G'</span> <span class="main">⟶</span> <span class="bound">y</span> <span class="main">∈</span> vertices <span class="free">G'</span> <span class="main">⟶</span> 
                          <span class="main">(</span><span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">,</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span>map_graph_fn <span class="bound">G</span> <span class="bound">g</span><span class="main">:⟦</span><span class="bound">e</span><span class="main">⟧</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G'</span><span class="main">:⟦</span><span class="bound">e</span><span class="main">⟧</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> mnt <span class="main">=</span> mnt<span class="main">[</span><span class="operator">unfolded</span> standard_rules_def<span class="main">]</span>
  <span class="keyword1"><span class="command">from</span></span> mnt <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"maintainedA <span class="main">(</span>identity_rules <span class="free">L</span><span class="main">)</span> <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> identity_rules<span class="main">[</span><span class="operator">OF</span> gr<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> this gr<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">h</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    h<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="main">∘</span> <span class="skolem">h</span> <span class="main">=</span> <span class="skolem">h</span>"</span></span> <span class="quoted"><span class="quoted">"ident_rel S_Idt <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span> <span class="free">G'</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">h</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">h</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> mg<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">r</span><span class="main">.</span> maintained <span class="bound">r</span> <span class="free">G'</span> <span class="main">⟹</span> maintained <span class="bound">r</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command">using</span></span> idemp_embedding_maintained_preserved<span class="main">[</span><span class="operator">OF</span> h<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> h<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> mnt <span class="keyword1"><span class="command">have</span></span> tr<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>top_rule S_Top<span class="main">)</span> <span class="free">G'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> ne<span class="main">:</span><span class="quoted"><span class="quoted">"maintained nonempty_rule <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> nonempty_rule<span class="main">[</span><span class="operator">OF</span> gr<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> ne <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> tr<span class="main">[</span><span class="operator">unfolded</span> top_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gr<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span> x <span class="keyword1"><span class="command">have</span></span> top_nonempty<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel S_Top <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">c</span><span class="main">.</span> <span class="bound">c</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="bound">c</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">c</span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> mnt <span class="keyword1"><span class="command">have</span></span> cr5<span class="main">:</span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>const_exists <span class="skolem">c</span><span class="main">)</span> <span class="free">G'</span>"</span></span>
              <span class="keyword2"><span class="keyword">and</span></span> cr7<span class="main">:</span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>const_prop <span class="skolem">c</span><span class="main">)</span> <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> constant_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">from</span></span> top_nonempty cr5<span class="main">[</span><span class="operator">unfolded</span> maintained_holds_subset_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gr<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> const_exists_def<span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> yz<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="skolem">c</span><span class="main">)</span> <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> this gr<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> yzv<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> getRel_hom<span class="main">[</span><span class="operator">OF</span> yz yzv<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> hi<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">h</span> <span class="skolem">y</span><span class="main">,</span><span class="skolem">h</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="skolem">c</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">with</span></span> h<span class="main">(</span>2<span class="main">)</span> cr7<span class="main">[</span><span class="operator">THEN</span> mg<span class="main">,</span><span class="operator">unfolded</span> maintained_holds_subset_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> map_graph_fn_graphI<span class="main"><span class="main">]</span></span> const_prop_def<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">h</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="skolem">c</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> hi <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">c</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">c</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="bound">c</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> choice<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> m<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">m</span> <span class="bound">x</span><span class="main">,</span> <span class="skolem">m</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?m'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">m</span> <span class="main">`</span> <span class="free">C</span> <span class="keyword1">then</span> Inl <span class="main">(</span>the_inv_into <span class="free">C</span> <span class="skolem">m</span> <span class="bound">x</span><span class="main">)</span> <span class="keyword1">else</span> Inr <span class="bound">x</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">≡</span> <span class="var">?m'</span> <span class="keyword1">o</span> <span class="skolem">h</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">⟹</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">⟹</span> <span class="skolem">m</span> <span class="bound">x</span> <span class="main">=</span> <span class="skolem">m</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> m <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">,</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span>
                <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">,</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">hence</span></span> mx<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">,</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="skolem">y</span><span class="main">)</span> <span class="free">G'</span>"</span></span>
              <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">,</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="skolem">x</span><span class="main">)</span> <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> h<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">from</span></span> 1<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> mnt <span class="keyword1"><span class="command">have</span></span> cr8<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span> <span class="main">⟹</span> maintained <span class="main">(</span>const_disj <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="free">G'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> constant_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> cr8<span class="main">[</span><span class="operator">unfolded</span> maintained_holds_subset_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gr<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span> const_disj_def<span class="main">]</span> mx
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">≠</span><span class="skolem">y</span><span class="main">⟹</span><span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">,</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G'</span><span class="main">:⟦</span><span class="main">⊥</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> cf <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"univalent <span class="main">(</span>converse <span class="main">(</span>BNF_Def.Gr <span class="free">C</span> <span class="skolem">m</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> univalent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> inj_m<span class="main">:</span><span class="quoted"><span class="quoted">"inj_on <span class="skolem">m</span> <span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inj_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> inj_on_the_inv_into<span class="main">[</span><span class="operator">OF</span> inj_m<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> inj_m'<span class="main">:</span><span class="quoted"><span class="quoted">"inj <span class="var">?m'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inj_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">G</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">G</span> <span class="main">=</span> map_graph_fn <span class="free">G'</span> <span class="skolem">f</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> G<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="skolem">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">x</span> <span class="main">∈</span> vertices <span class="skolem">G</span>"</span></span> <span class="quoted"><span class="quoted">"getRel S_Bot <span class="skolem">G</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x cf <span class="keyword1"><span class="command">unfolding</span></span> getRel_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">from</span></span> comp_inj_on<span class="main">[</span><span class="operator">OF</span> inj_on_the_inv_into<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inj_m<span class="main"><span class="main">]</span></span> inj_Inl<span class="main">,</span> <span class="operator">unfolded</span> o_def<span class="main">]</span> inj_Inr
  <span class="keyword1"><span class="command">have</span></span> inj_m'<span class="main">:</span><span class="quoted"><span class="quoted">"inj_on <span class="var">?m'</span> <span class="main">(</span>vertices <span class="free">G'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inj_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">=</span> the_inv_into <span class="main">(</span>vertices <span class="free">G'</span><span class="main">)</span> <span class="var">?m'</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> gf_h<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="free">G'</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">g</span> <span class="keyword1">o</span> <span class="skolem">f</span><span class="main">)</span> <span class="bound">x</span> <span class="main">=</span> <span class="skolem">h</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> g_def f_def o_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> the_inv_into_f_f<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inj_m'<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> h <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def graph_union_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> mg_eq<span class="main">:</span><span class="quoted"><span class="quoted">"map_graph_fn <span class="free">G'</span> <span class="main">(</span><span class="skolem">g</span> <span class="main">∘</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> map_graph_fn <span class="free">G'</span> <span class="skolem">h</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> map_graph_fn_eqI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gf_h<span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="free">G'</span> <span class="main">⟹</span> <span class="skolem">h</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> h<span class="main">(</span>3<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> subgraph_def graph_union_iff <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">G'</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> gf_id<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="free">G'</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">g</span> <span class="keyword1">o</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="skolem">h</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">h</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> h<span class="main">(</span>1<span class="main">)</span> gf_h <span class="keyword1"><span class="command">unfolding</span></span> o_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="skolem">G</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> G_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> gf_h<span class="main">[</span><span class="operator">OF</span> y<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f</span> <span class="keyword1">o</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">(</span><span class="skolem">h</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> o_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> h<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> f_def o_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f</span> <span class="keyword1">o</span> <span class="skolem">g</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> y<span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> fg_id <span class="main">=</span> this

  <span class="keyword1"><span class="command">have</span></span> fg_inv<span class="main">:</span><span class="quoted"><span class="quoted">"map_graph_fn <span class="skolem">G</span> <span class="main">(</span><span class="skolem">f</span> <span class="keyword1">o</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">G</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> h<span class="main">(</span>1<span class="main">)</span> G_def f_def mg_eq map_graph_fn_comp <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> ir<span class="main">:</span><span class="quoted"><span class="quoted">"ident_rel S_Idt <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> set_eq_iff <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span><span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> G_def<span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v1</span></span> <span class="skolem"><span class="skolem">v2</span></span> <span class="keyword2"><span class="keyword">where</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v1</span><span class="main">,</span><span class="skolem">v2</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="free">G'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">v1</span><span class="main">,</span><span class="skolem">f</span> <span class="skolem">v2</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> getRel_def map_graph_def on_triple_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> vv<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">v1</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v2</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gr <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> h<span class="main">(</span>2<span class="main">)</span> v<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="skolem">v1</span> <span class="main">=</span> <span class="skolem">h</span> <span class="skolem">v2</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> image_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> x<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">v1</span><span class="main">,</span><span class="skolem">f</span> <span class="skolem">v1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> f_def v <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> vv<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> x G_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> x<span class="main">:</span><span class="quoted"><span class="quoted">"fst <span class="skolem">x</span> <span class="main">=</span> snd <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"fst <span class="skolem">x</span> <span class="main">∈</span> vertices <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>fst <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span> <span class="main">`</span> vertices <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> G_def o_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">v</span> <span class="main">=</span> fst <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> hv<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="skolem">v</span> <span class="main">∈</span> vertices <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">h</span> <span class="skolem">v</span><span class="main">,</span><span class="skolem">h</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> h<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> getRel_hom<span class="main">[</span><span class="operator">OF</span> this hv hv<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?m'</span> <span class="main">(</span><span class="skolem">h</span> <span class="skolem">v</span><span class="main">)</span><span class="main">,</span><span class="var">?m'</span> <span class="main">(</span><span class="skolem">h</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="main">(</span><span class="var">?m'</span> <span class="keyword1">o</span> <span class="skolem">h</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> map_graph_fn_comp <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f</span> <span class="skolem">v</span><span class="main">,</span><span class="skolem">f</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> f_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>fst <span class="skolem">x</span><span class="main">,</span>snd <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> x v G_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> G_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">from</span></span> tr<span class="main">[</span><span class="operator">unfolded</span> top_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gr<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> tr0<span class="main">:</span><span class="quoted"><span class="quoted">"getRel S_Top <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>
          <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> vertices <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> tr<span class="main">:</span><span class="quoted"><span class="quoted">"getRel S_Top <span class="skolem">G</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="skolem">G</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> vertices <span class="skolem">G</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> G_def getRel_def on_triple_def map_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> m<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">C</span> <span class="main">⟹</span> <span class="main">{</span><span class="main">(</span><span class="skolem">m</span> <span class="bound">x</span><span class="main">,</span> <span class="skolem">m</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> getRel <span class="main">(</span>S_Const <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">C</span>"</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="skolem">z</span> <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?t</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"getRel S_Top <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"getRel <span class="main">(</span>S_Const <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> mx<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">,</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> m x <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> a <span class="keyword1"><span class="command">have</span></span> v<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> vertices <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span>
                    <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> vertices <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span>
                    <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="skolem">x</span> <span class="main">∈</span> vertices <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">with</span></span> tr0 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> a mx <span class="keyword1"><span class="command">have</span></span> lhs<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?r</span> <span class="keyword1">O</span> <span class="var">?t</span> <span class="keyword1">O</span> <span class="var">?r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?r</span> <span class="keyword1">O</span> <span class="var">?t</span> <span class="keyword1">O</span> <span class="var">?r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> x mnt <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>const_exists_rev <span class="skolem">x</span><span class="main">)</span> <span class="free">G'</span>"</span></span>
                  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"maintained <span class="main">(</span>const_prop <span class="skolem">x</span><span class="main">)</span> <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> constant_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">hence</span></span> cr6<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>const_exists_rev <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> cr7<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>const_prop <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> mg<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span>
            <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel S_Idt <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> lhs
        <span class="keyword1"><span class="command">unfolding</span></span> maintained_holds_subset_iff<span class="main">[</span><span class="operator">OF</span> map_graph_fn_graphI<span class="main">]</span>
                  const_exists_rev_def const_prop_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="skolem">m</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="skolem">m</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> h<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"getRel <span class="main">(</span>S_Const <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> m<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> mg_eq <span class="keyword1"><span class="command">have</span></span> mg_eq<span class="main">:</span><span class="quoted"><span class="quoted">"map_graph_fn <span class="skolem">G</span> <span class="skolem">g</span> <span class="main">=</span> map_graph_fn <span class="free">G'</span> <span class="skolem">h</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> G_def map_graph_fn_comp<span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">+</span> <span class="tfree">'V'</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span>S_Const <span class="bound">c</span><span class="main">,</span> Inl <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">C</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"getRel <span class="skolem">l</span> <span class="skolem">G</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> m <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>S_Const <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> x<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> S_Const <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> Inl <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> mx<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">m</span> <span class="main">`</span> <span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> m<span class="main">[</span><span class="operator">OF</span> x<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">,</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> getRel <span class="main">(</span>S_Const <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>S_Const <span class="skolem">x</span><span class="main">,</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">,</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="skolem">x</span> <span class="main">∈</span> vertices <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">h</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> map_graph_def Image_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x'</span></span> <span class="keyword2"><span class="keyword">where</span></span> x'<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">h</span> <span class="skolem">x'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> h<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> hmx<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> x' o_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command">hence</span></span> fmx<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> x f_def
        <span class="keyword1"><span class="command">using</span></span> the_inv_into_f_f<span class="main">[</span><span class="operator">OF</span> inj_m<span class="main">]</span> inj_m<span class="main">[</span><span class="operator">unfolded</span> inj_on_def<span class="main">,</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">OF</span> x<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> mx <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span><span class="main">,</span> <span class="skolem">f</span> <span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> getRel <span class="skolem">l</span> <span class="main">(</span>map_graph_fn <span class="skolem">G</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">∘</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> map_graph_fn_comp getRel_hom_map<span class="main">[</span><span class="operator">OF</span> map_graph_fn_graphI<span class="main">]</span>
                  m<span class="main">[</span><span class="operator">OF</span> x<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">folded</span> mg_eq x<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"getRel <span class="skolem">l</span> <span class="skolem">G</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="skolem">f</span> <span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span><span class="main">,</span> <span class="skolem">f</span> <span class="main">(</span><span class="skolem">m</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> fg_inv <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> gr fmx <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> refl<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> cr <span class="main">=</span> this

  <span class="keyword1"><span class="command">have</span></span> sg<span class="main">:</span><span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>map_graph_fn <span class="skolem">G</span> <span class="skolem">g</span><span class="main">)</span> <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> mg_eq <span class="keyword1"><span class="command">using</span></span> h<span class="main">(</span>3<span class="main">)</span><span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">have</span></span> std<span class="main">:</span><span class="quoted"><span class="quoted">"standard' <span class="free">C</span> <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> standard_def <span class="keyword1"><span class="command">using</span></span> G ir tr cr <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> mtd<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">r</span><span class="main">.</span> maintained <span class="bound">r</span> <span class="free">G'</span> <span class="main">⟹</span> maintained <span class="bound">r</span> <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">r</span><span class="main">)</span> <span class="keyword1"><span class="command">from</span></span> mg<span class="main">[</span><span class="operator">OF</span> 1<span class="main">,</span><span class="operator">folded</span> mg_eq<span class="main">]</span> maintained_preserved_by_isomorphism<span class="main">[</span><span class="operator">OF</span> fg_id G<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">e</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span>
           <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span><span class="main">,</span> <span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span>map_graph_fn <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span><span class="main">:⟦</span><span class="skolem">e</span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G'</span><span class="main">:⟦</span><span class="skolem">e</span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">e</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Cmp <span class="skolem">e1</span> <span class="skolem">e2</span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span>map_graph_fn <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span>"</span></span>
                              <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span> <span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span>map_graph_fn <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> vertices <span class="main">(</span>map_graph_fn <span class="main">(</span>map_graph_fn <span class="free">G'</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> semantics_in_vertices<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> map_graph_fn_graphI<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z'</span></span> <span class="keyword2"><span class="keyword">where</span></span> z'<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">=</span> <span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">z'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z'</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> A_Cmp<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> A_Cmp<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> z'<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> z<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> z'<span class="main"><span class="main">]</span></span><span class="main">]</span>
             A_Cmp<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> z'<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> A_Cmp<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> z<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> z'<span class="main"><span class="main">]</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="main">:</span><span class="free">G'</span><span class="main">:⟦</span><span class="skolem">e1</span><span class="main">⟧</span><span class="main">)</span> <span class="keyword1">O</span> <span class="main">(</span><span class="main">:</span><span class="free">G'</span><span class="main">:⟦</span><span class="skolem">e2</span><span class="main">⟧</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>A_Lbl <span class="skolem">l</span><span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span><span class="main">,</span> <span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span>map_graph_fn <span class="skolem">G</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>getRel_def G_def<span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x'</span></span> <span class="skolem"><span class="skolem">y'</span></span>
          <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x'</span><span class="main">,</span> <span class="skolem">y'</span><span class="main">)</span> <span class="main">∈</span> edges <span class="skolem">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">g</span> <span class="skolem">x'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">g</span> <span class="skolem">y'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x'</span></span> <span class="skolem"><span class="skolem">y'</span></span>
          <span class="keyword2"><span class="keyword">where</span></span> xy<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x'</span><span class="main">,</span> <span class="skolem">y'</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">x'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">y'</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> G_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">∈</span> vertices <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gr<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">THEN</span> gf_h<span class="main">,</span><span class="operator">unfolded</span> o_def<span class="main">]</span> A_Lbl<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span><span class="main">[</span><span class="operator">THEN</span> gf_h<span class="main">,</span><span class="operator">unfolded</span> o_def<span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">h</span> <span class="skolem">x'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">h</span> <span class="skolem">y'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xy<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">G'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> h<span class="main">(</span>4<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">l</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span> h<span class="main">(</span>4<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">l</span></span> <span class="quoted"><span class="skolem">x'</span></span> <span class="quoted"><span class="skolem">y'</span></span><span class="main">]</span> xy<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>getRel_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> cons<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">e</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="free">G'</span> <span class="main">⟶</span> <span class="bound">y</span> <span class="main">∈</span> vertices <span class="free">G'</span> <span class="main">⟶</span> <span class="main">(</span><span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">,</span> <span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span>map_graph_fn <span class="skolem">G</span> <span class="skolem">g</span><span class="main">:⟦</span><span class="bound">e</span><span class="main">⟧</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="free">G'</span><span class="main">:⟦</span><span class="bound">e</span><span class="main">⟧</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> G_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> cons G_def fg_inv<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> sg std mtd <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="CombinedCorrectness">
<div class="head">
<h1>Theory CombinedCorrectness</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Combined correctness›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This section does not correspond to any theorems in the paper.
      However, the main correctness proof is not a theorem in the paper either.
      As the paper sets out to prove that we can decide entailment and consistency,
      this file shows how to combine the results so far and indeed establish those properties. ›</span></span>
<span class="keyword1"><span class="command">theory</span></span> CombinedCorrectness
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="GraphRewriting.html">GraphRewriting</a> <a href="StandardRules.html">StandardRules</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* a somewhat concrete function to get the model if one exists *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">the_model</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">the_model</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span>
  <span class="main">≡</span> <span class="keyword1">let</span> <span class="bound">L</span> <span class="main">=</span> fst <span class="main">`</span> <span class="main">⋃</span> <span class="main">(</span><span class="main">(</span>edges <span class="keyword1">o</span> snd<span class="main">)</span> <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span>S_Bot<span class="main">,</span>S_Top<span class="main">,</span>S_Idt<span class="main">}</span> <span class="main">∪</span> S_Const <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">;</span>
        <span class="bound">Rules</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="main">∪</span> <span class="main">(</span>standard_rules <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="bound">L</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">sel</span> <span class="main">=</span> non_constructive_selector <span class="bound">Rules</span> 
     <span class="keyword1">in</span> the_lcg <span class="bound">sel</span> <span class="bound">Rules</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">entailment_model</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">entailment_model</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">init</span></span></span>
  <span class="main">≡</span> <span class="keyword1">let</span> <span class="bound">L</span> <span class="main">=</span> fst <span class="main">`</span> <span class="main">⋃</span> <span class="main">(</span><span class="main">(</span>edges <span class="keyword1">o</span> snd<span class="main">)</span> <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span>S_Bot<span class="main">,</span>S_Top<span class="main">,</span>S_Idt<span class="main">}</span> <span class="main">∪</span> S_Const <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">∪</span> fst <span class="main">`</span> edges <span class="free"><span class="bound"><span class="entity">init</span></span></span><span class="main">;</span>
        <span class="bound">Rules</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="main">∪</span> <span class="main">(</span>standard_rules <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="bound">L</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">sel</span> <span class="main">=</span> non_constructive_selector <span class="bound">Rules</span> 
     <span class="keyword1">in</span> the_lcg <span class="bound">sel</span> <span class="bound">Rules</span> <span class="main">(</span>card <span class="main">(</span>vertices <span class="free"><span class="bound"><span class="entity">init</span></span></span><span class="main">)</span><span class="main">,</span>edges <span class="free"><span class="bound"><span class="entity">init</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">check_consistency</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">check_consistency</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="main">≡</span> getRel S_Bot <span class="main">(</span>the_model <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">check_entailment</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">check_entailment</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> 
     <span class="keyword1">let</span> <span class="bound">mdl</span> <span class="main">=</span> entailment_model <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">Rs</span></span></span> <span class="main">(</span>translation <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span><span class="main">)</span>
     <span class="keyword1">in</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="bound">mdl</span><span class="main">:⟦</span>snd <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">⟧</span> <span class="main">∨</span> getRel S_Bot <span class="bound">mdl</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">transl_rules</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">transl_rules</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">T</span></span></span><span class="main">.</span> <span class="main">{</span><span class="main">(</span>translation <span class="bound">x</span><span class="main">,</span> translation <span class="main">(</span>A_Int <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>translation <span class="bound">y</span><span class="main">,</span> translation <span class="main">(</span>A_Int <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="CombinedCorrectness-gr_transl_rules"><span class="command">lemma</span></span> gr_transl_rules<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> transl_rules <span class="free">T</span> <span class="main">⟹</span> graph_rule <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> graph_rule_translation <span class="keyword1"><span class="command">unfolding</span></span> transl_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted">entails</span>

<span class="keyword1" id="CombinedCorrectness-check_consistency"><span class="command">lemma</span></span> check_consistency<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">T</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">C</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"check_consistency <span class="free">C</span> <span class="main">(</span>transl_rules <span class="free">T</span><span class="main">)</span> <span class="main">⟷</span> consistent <span class="main">(</span><span class="free">t</span><span class="main">::</span>nat itself<span class="main">)</span> <span class="free">C</span> <span class="free">T</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> fin_t<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="main">(</span>transl_rules <span class="free">T</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> transl_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">L</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="skolem">L</span> <span class="main">=</span> fst <span class="main">`</span> <span class="main">⋃</span> <span class="main">(</span><span class="main">(</span>edges <span class="main">∘</span> snd<span class="main">)</span> <span class="main">`</span> transl_rules <span class="free">T</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span>S_Bot<span class="main">,</span>S_Top<span class="main">,</span>S_Idt<span class="main">}</span> <span class="main">∪</span> S_Const <span class="main">`</span> <span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">⋃</span> <span class="main">(</span><span class="main">(</span>edges <span class="main">∘</span> snd<span class="main">)</span> <span class="main">`</span> transl_rules <span class="free">T</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fin_t gr_transl_rules <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> fin_l<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="skolem">L</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> L_def <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">Rules</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Rules</span> <span class="main">=</span> transl_rules <span class="free">T</span> <span class="main">∪</span> standard_rules <span class="free">C</span> <span class="skolem">L</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> fin_r<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="skolem">Rules</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> fin_t fin_l <span class="keyword1"><span class="command">unfolding</span></span> standard_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> incl_L<span class="main">:</span><span class="quoted"><span class="quoted">"fst <span class="main">`</span> <span class="main">(</span><span class="main">⋃</span> <span class="main">(</span><span class="main">(</span>edges <span class="keyword1">o</span> snd<span class="main">)</span> <span class="main">`</span> <span class="skolem">Rules</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">L</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> L_def Rules_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span>standard_rules_edges<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">R</span><span class="main">∈</span>transl_rules <span class="free">T</span><span class="main">.</span> graph_rule <span class="bound">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gr_transl_rules <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">R</span><span class="main">∈</span> constant_rules <span class="free">C</span><span class="main">.</span> graph_rule <span class="bound">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> constant_rules_graph_rule <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">R</span><span class="main">∈</span> identity_rules <span class="skolem">L</span><span class="main">.</span> graph_rule <span class="bound">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> identity_rules_graph_rule <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">R</span><span class="main">∈</span> <span class="main">{</span>top_rule S_Top<span class="main">,</span>nonempty_rule<span class="main">}</span><span class="main">.</span> graph_rule <span class="bound">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> are_rules<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"set_of_graph_rules <span class="skolem">Rules</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> set_of_graph_rules_def Rules_def ball_Un standard_rules_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">sel</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">sel</span> <span class="main">=</span> non_constructive_selector <span class="skolem">Rules</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> sel<span class="main">:</span><span class="quoted"><span class="quoted">"valid_selector <span class="skolem">Rules</span> <span class="skolem">sel</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gr non_constructive_selector <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cfg</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cfg</span> <span class="main">=</span> the_lcg <span class="skolem">sel</span> <span class="skolem">Rules</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> cfg<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">cfg</span> <span class="main">=</span> the_model <span class="free">C</span> <span class="main">(</span>transl_rules <span class="free">T</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cfg_def sel_def Rules_def L_def the_model_def Let_def<span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">have</span></span> cfg_c<span class="main">:</span><span class="quoted"><span class="quoted">"least_consequence_graph <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> nat<span class="main">)</span> <span class="skolem">Rules</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">)</span> <span class="skolem">cfg</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cfg_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lcg_through_make_step<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fin_r gr _ sel<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> cfg_sdt<span class="main">:</span><span class="quoted"><span class="quoted">"maintainedA <span class="main">(</span>standard_rules <span class="free">C</span> <span class="skolem">L</span><span class="main">)</span> <span class="skolem">cfg</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> cfg_g<span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="skolem">cfg</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> cfg_l<span class="main">:</span><span class="quoted"><span class="quoted">"least <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> nat<span class="main">)</span> <span class="skolem">Rules</span> <span class="main">(</span>graph_of <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span> <span class="skolem">cfg</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> cfg_m<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> transl_rules <span class="free">T</span> <span class="main">⟹</span> maintained <span class="skolem">r</span> <span class="skolem">cfg</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">r</span>
    <span class="keyword1"><span class="command">unfolding</span></span> Rules_def least_consequence_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> cfg_lbl<span class="main">:</span><span class="quoted"><span class="quoted">"fst <span class="main">`</span> edges <span class="skolem">cfg</span> <span class="main">⊆</span> <span class="skolem">L</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> cfg_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> the_lcg_edges<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sel incl_L<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> d1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟹</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">from</span></span> maintained_standard_noconstants<span class="main">[</span><span class="operator">OF</span> cfg_sdt cfg_g cfg_lbl this<span class="main"><span class="main">[</span></span><span class="operator">folded</span> cfg<span class="main"><span class="main">]</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">G</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> Standard_Constant<span class="main">,</span> <span class="tfree">'a</span> <span class="main">+</span> nat<span class="main">)</span> labeled_graph"</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> G_std<span class="main">:</span><span class="quoted"><span class="quoted">"standard' <span class="free">C</span> <span class="skolem">G</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> m<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="skolem">r</span> <span class="skolem">cfg</span> <span class="main">⟹</span> maintained <span class="skolem">r</span> <span class="skolem">G</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> Standard_Constant<span class="main">,</span> nat<span class="main">)</span> Graph_PreRule"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> standard_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span><span class="free">T</span> <span class="main">⟹</span> <span class="skolem">G</span> <span class="main">⊨</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">subst</span> eq_as_subsets<span class="main"><span class="keyword3">,</span></span><span class="operator">standard</span><span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span><span class="free">T</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> a cfg_m<span class="main">[</span><span class="operator">unfolded</span> transl_rules_def<span class="main">,</span><span class="operator">THEN</span> m<span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">G</span> <span class="main">⊨</span> <span class="skolem">a</span> <span class="main">⊑</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> maintained_holds_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> g<span class="main"><span class="main">,</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">from</span></span> a cfg_m<span class="main">[</span><span class="operator">unfolded</span> transl_rules_def<span class="main">,</span><span class="operator">THEN</span> m<span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">G</span> <span class="main">⊨</span> <span class="skolem">b</span> <span class="main">⊑</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> maintained_holds_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> g<span class="main"><span class="main">,</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">hence</span></span> h<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">S</span><span class="main">∈</span><span class="free">T</span><span class="main">.</span> <span class="skolem">G</span> <span class="main">⊨</span> <span class="bound">S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> G_std <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> model_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">have</span></span> d2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?lhs</span> <span class="main">⟹</span> <span class="var">?rhs</span> <span class="main">⟹</span> False"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> ab<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span>S_Bot<span class="main">,</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> edges <span class="skolem">cfg</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> vertices <span class="skolem">cfg</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> vertices <span class="skolem">cfg</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cfg_g <span class="keyword1"><span class="command">unfolding</span></span> cfg getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">G</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> Standard_Constant<span class="main">,</span> <span class="tfree">'a</span> <span class="main">+</span> nat<span class="main">)</span> labeled_graph"</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> G<span class="main">:</span><span class="quoted"><span class="quoted">"model <span class="free">C</span> <span class="skolem">G</span> <span class="free">T</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> model_def <span class="keyword1"><span class="command">have</span></span> std<span class="main">:</span><span class="quoted"><span class="quoted">"standard' <span class="free">C</span> <span class="skolem">G</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> holds<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">S</span><span class="main">∈</span><span class="free">T</span><span class="main">.</span> <span class="skolem">G</span> <span class="main">⊨</span> <span class="bound">S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">hence</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> standard_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> maintained_holds_iff<span class="main">[</span><span class="operator">OF</span> g<span class="main">]</span> holds
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"maintainedA <span class="main">(</span>transl_rules <span class="free">T</span><span class="main">)</span> <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> transl_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> mnt<span class="main">:</span><span class="quoted"><span class="quoted">"maintainedA <span class="skolem">Rules</span> <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Rules_def
      <span class="keyword1"><span class="command">using</span></span> standard_maintains_rules<span class="main">[</span><span class="operator">OF</span> std<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> consequence_graphI<span class="main">[</span><span class="operator">OF</span> _ _ g<span class="main">]</span> gr<span class="main">[</span><span class="operator">unfolded</span> set_of_graph_rules_def<span class="main">]</span> mnt
    <span class="keyword1"><span class="command">have</span></span> cg<span class="main">:</span><span class="quoted"><span class="quoted">"consequence_graph <span class="skolem">Rules</span> <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
    <span class="keyword1"><span class="command">with</span></span> cfg_l<span class="main">[</span><span class="operator">unfolded</span> least_def<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> mtd<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>graph_of <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">,</span> <span class="skolem">cfg</span><span class="main">)</span> <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>fst <span class="main">(</span>graph_of <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">,</span> <span class="skolem">cfg</span><span class="main">)</span><span class="main">)</span> <span class="skolem">G</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> graph_homomorphism_def <span class="keyword1"><span class="command">using</span></span> g <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> mtd maintained_def <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"extensible <span class="main">(</span>graph_of <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">,</span> <span class="skolem">cfg</span><span class="main">)</span> <span class="skolem">G</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>map_graph <span class="skolem">g</span> <span class="skolem">cfg</span><span class="main">)</span> <span class="main">⊆</span> edges <span class="skolem">G</span>"</span></span> <span class="quoted"><span class="quoted">"vertices <span class="skolem">cfg</span> <span class="main">=</span> Domain <span class="skolem">g</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> extensible_def graph_homomorphism_def2 graph_union_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span>S_Bot<span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> edges <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ab <span class="keyword1"><span class="command">unfolding</span></span> edge_preserving <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> std <span class="keyword1"><span class="command">unfolding</span></span> standard_def getRel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> d1 d2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="CombinedCorrectness-check_entailment"><span class="command">lemma</span></span> check_entailment<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">T</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">C</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"check_entailment <span class="free">C</span> <span class="main">(</span>transl_rules <span class="free">T</span><span class="main">)</span> <span class="free">S</span> <span class="main">⟷</span> entails <span class="main">(</span><span class="free">t</span><span class="main">::</span>nat itself<span class="main">)</span> <span class="free">C</span> <span class="free">T</span> <span class="main">(</span>fst <span class="free">S</span><span class="main">,</span> <span class="main">(</span>A_Int <span class="main">(</span>fst <span class="free">S</span><span class="main">)</span> <span class="main">(</span>snd <span class="free">S</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
   <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> fin_t<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="main">(</span>transl_rules <span class="free">T</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> transl_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">R</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="main">=</span> transl_rule <span class="free">S</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">init</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">init</span> <span class="main">=</span> <span class="main">(</span>card <span class="main">(</span>vertices <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> edges <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> gi<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="main">(</span>graph_of <span class="skolem">init</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> init<span class="main">:</span><span class="quoted"><span class="quoted">"graph_of <span class="skolem">init</span> <span class="main">=</span> translation <span class="main">(</span>fst <span class="free">S</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> verts_in_translation<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"fst <span class="free">S</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> inv_translation_def init_def R_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">Rs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Rs</span> <span class="main">=</span> transl_rules <span class="free">T</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">L</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="skolem">L</span> <span class="main">=</span> fst <span class="main">`</span> <span class="main">(</span><span class="main">⋃</span> <span class="main">(</span><span class="main">(</span>edges <span class="keyword1">o</span> snd<span class="main">)</span> <span class="main">`</span> <span class="skolem">Rs</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span>S_Bot<span class="main">,</span>S_Top<span class="main">,</span>S_Idt<span class="main">}</span> <span class="main">∪</span> S_Const <span class="main">`</span> <span class="free">C</span> <span class="main">∪</span> fst <span class="main">`</span> edges <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">⋃</span> <span class="main">(</span><span class="main">(</span>edges <span class="main">∘</span> snd<span class="main">)</span> <span class="main">`</span> transl_rules <span class="free">T</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fin_t gr_transl_rules <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> fin_l<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="skolem">L</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> L_def Rs_def R_def <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> fin_t<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="skolem">Rs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fin_t Rs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">Rules</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Rules</span> <span class="main">=</span> <span class="skolem">Rs</span> <span class="main">∪</span> standard_rules <span class="free">C</span> <span class="skolem">L</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> fin_r<span class="main">:</span><span class="quoted"><span class="quoted">"finite <span class="skolem">Rules</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> fin_t fin_l <span class="keyword1"><span class="command">unfolding</span></span> standard_rules_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> incl_L<span class="main">:</span><span class="quoted"><span class="quoted">"fst <span class="main">`</span> <span class="main">(</span><span class="main">⋃</span> <span class="main">(</span><span class="main">(</span>edges <span class="keyword1">o</span> snd<span class="main">)</span> <span class="main">`</span> <span class="skolem">Rules</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">L</span>"</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">`</span> snd <span class="skolem">init</span> <span class="main">⊆</span> <span class="skolem">L</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> L_def Rules_def init_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span>standard_rules_edges<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">R</span><span class="main">∈</span>transl_rules <span class="free">T</span><span class="main">.</span> graph_rule <span class="bound">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gr_transl_rules <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">R</span><span class="main">∈</span> constant_rules <span class="free">C</span><span class="main">.</span> graph_rule <span class="bound">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> constant_rules_graph_rule <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">R</span><span class="main">∈</span> identity_rules <span class="skolem">L</span><span class="main">.</span> graph_rule <span class="bound">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> identity_rules_graph_rule <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">R</span><span class="main">∈</span> <span class="main">{</span>top_rule S_Top<span class="main">,</span>nonempty_rule<span class="main">}</span><span class="main">.</span> graph_rule <span class="bound">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> are_rules<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"set_of_graph_rules <span class="skolem">Rules</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> set_of_graph_rules_def Rules_def ball_Un standard_rules_def Rs_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">sel</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">sel</span> <span class="main">=</span> non_constructive_selector <span class="skolem">Rules</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> sel<span class="main">:</span><span class="quoted"><span class="quoted">"valid_selector <span class="skolem">Rules</span> <span class="skolem">sel</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gr non_constructive_selector <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cfg</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cfg</span> <span class="main">=</span> the_lcg <span class="skolem">sel</span> <span class="skolem">Rules</span> <span class="skolem">init</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> cfg<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">cfg</span> <span class="main">=</span> entailment_model <span class="free">C</span> <span class="skolem">Rs</span> <span class="main">(</span>fst <span class="skolem">R</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cfg_def sel_def Rules_def L_def entailment_model_def Let_def init_def<span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">have</span></span> cfg_c<span class="main">:</span><span class="quoted"><span class="quoted">"least_consequence_graph <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> nat<span class="main">)</span> <span class="skolem">Rules</span> <span class="main">(</span>graph_of <span class="skolem">init</span><span class="main">)</span> <span class="skolem">cfg</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cfg_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lcg_through_make_step<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fin_r gr gi sel<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> cfg_sdt<span class="main">:</span><span class="quoted"><span class="quoted">"maintainedA <span class="main">(</span>standard_rules <span class="free">C</span> <span class="skolem">L</span><span class="main">)</span> <span class="skolem">cfg</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> cfg_g<span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="skolem">cfg</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> cfg_l<span class="main">:</span><span class="quoted"><span class="quoted">"least <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> nat<span class="main">)</span> <span class="skolem">Rules</span> <span class="main">(</span>graph_of <span class="skolem">init</span><span class="main">)</span> <span class="skolem">cfg</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> cfg_m<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">∈</span> <span class="skolem">Rs</span> <span class="main">⟹</span> maintained <span class="skolem">r</span> <span class="skolem">cfg</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">r</span>
    <span class="keyword1"><span class="command">unfolding</span></span> Rules_def least_consequence_graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> cfg_lbl<span class="main">:</span><span class="quoted"><span class="quoted">"fst <span class="main">`</span> edges <span class="skolem">cfg</span> <span class="main">⊆</span> <span class="skolem">L</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cfg_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> the_lcg_edges<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sel incl_L<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span>translation <span class="main">(</span>fst <span class="free">S</span><span class="main">)</span><span class="main">:⟦</span>fst <span class="free">S</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> translation_self<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span>graph_of <span class="skolem">init</span><span class="main">:⟦</span>fst <span class="free">S</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> init <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> subgraph_semantics<span class="main">[</span><span class="operator">OF</span> _ this<span class="main">]</span> cfg_l<span class="main">[</span><span class="operator">unfolded</span> least_def<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> cfg_fst<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="skolem">cfg</span><span class="main">:⟦</span>fst <span class="free">S</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cfg_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> semantics_in_vertices<span class="main">[</span><span class="operator">OF</span> cfg_g this<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> cfg_01<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∈</span> vertices <span class="skolem">cfg</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">∈</span> vertices <span class="skolem">cfg</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">∈</span>vertices <span class="skolem">cfg</span><span class="main">×</span>vertices <span class="skolem">cfg</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> d1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?lhs</span> <span class="main">⟹</span> <span class="var">?rhs</span> <span class="main">⟹</span> False"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> gr<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span> <span class="main">∉</span> <span class="main">:</span><span class="skolem">cfg</span><span class="main">:⟦</span>snd <span class="free">S</span><span class="main">⟧</span>"</span></span> <span class="quoted"><span class="quoted">"getRel S_Bot <span class="skolem">cfg</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> entailment_model_def cfg R_def Rs_def Let_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> maintained_standard_noconstants<span class="main">[</span><span class="operator">OF</span> cfg_sdt cfg_g cfg_lbl gr<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">G</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> Standard_Constant<span class="main">,</span> <span class="tfree">'a</span> <span class="main">+</span> nat<span class="main">)</span> labeled_graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="skolem"><span class="skolem">g</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> fg<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">G</span> <span class="main">=</span> map_graph_fn <span class="skolem">G</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">∘</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">G</span> <span class="main">=</span> map_graph_fn <span class="skolem">cfg</span> <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"subgraph <span class="main">(</span>map_graph_fn <span class="skolem">G</span> <span class="skolem">g</span><span class="main">)</span> <span class="skolem">cfg</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> G_std<span class="main">:</span><span class="quoted"><span class="quoted">"standard' <span class="free">C</span> <span class="skolem">G</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> m<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">r</span><span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> Standard_Constant<span class="main">,</span> nat<span class="main">)</span> Graph_PreRule<span class="main">.</span> maintained <span class="bound">r</span> <span class="skolem">cfg</span> <span class="main">⟹</span> maintained <span class="bound">r</span> <span class="skolem">G</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> e<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">e</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vertices <span class="skolem">cfg</span> <span class="main">⟹</span> <span class="bound">y</span> <span class="main">∈</span> vertices <span class="skolem">cfg</span> <span class="main">⟹</span> 
                          <span class="main">(</span><span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">,</span> <span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span>map_graph_fn <span class="skolem">G</span> <span class="skolem">g</span><span class="main">:⟦</span><span class="bound">e</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="skolem">cfg</span><span class="main">:⟦</span><span class="bound">e</span><span class="main">⟧</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarify</span> <span class="operator">blast</span> <span class="comment1">(* just blast also works, but clarify blast is much faster *)</span>
    <span class="keyword1"><span class="command">hence</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> standard_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span><span class="free">T</span> <span class="main">⟹</span> <span class="skolem">G</span> <span class="main">⊨</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> eq_as_subsets<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> cfg_m<span class="main">[</span><span class="operator">unfolded</span> transl_rules_def Rs_def<span class="main">,</span><span class="operator">THEN</span> m<span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> maintained_holds_iff<span class="main">[</span><span class="operator">OF</span> g<span class="main">,</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> h<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">S</span><span class="main">∈</span><span class="free">T</span><span class="main">.</span> <span class="skolem">G</span> <span class="main">⊨</span> <span class="bound">S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> entails_def model_def<span class="main">]</span> G_std h <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">G</span> <span class="main">⊨</span> fst <span class="free">S</span> <span class="main">⊑</span> snd <span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> cfg_fst cfg_g f<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f</span> <span class="main">0</span><span class="main">,</span> <span class="skolem">f</span> <span class="main">1</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="skolem">G</span><span class="main">:⟦</span>snd <span class="free">S</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">0</span><span class="main">)</span><span class="main">,</span> <span class="skolem">g</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span>map_graph_fn <span class="skolem">G</span> <span class="skolem">g</span><span class="main">:⟦</span>snd <span class="free">S</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> map_graph_in<span class="main">[</span><span class="operator">OF</span> g<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> e cfg_01<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> gr<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟹</span> model <span class="free">C</span> <span class="skolem">G</span> <span class="free">T</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="skolem">G</span><span class="main">:⟦</span>fst <span class="free">S</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="skolem">G</span><span class="main">:⟦</span>snd <span class="free">S</span><span class="main">⟧</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> Standard_Constant<span class="main">,</span> <span class="tfree">'a</span> <span class="main">+</span> nat<span class="main">)</span> labeled_graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> mod<span class="main">:</span><span class="quoted"><span class="quoted">"model <span class="free">C</span> <span class="skolem">G</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> mod model_def <span class="keyword1"><span class="command">have</span></span> std<span class="main">:</span><span class="quoted"><span class="quoted">"standard' <span class="free">C</span> <span class="skolem">G</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> holds<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">S</span><span class="main">∈</span><span class="free">T</span><span class="main">.</span> <span class="skolem">G</span> <span class="main">⊨</span> <span class="bound">S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">hence</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> standard_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> maintained_holds_iff<span class="main">[</span><span class="operator">OF</span> g<span class="main">]</span> holds
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"maintainedA <span class="skolem">Rs</span> <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> transl_rules_def Rs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> mnt<span class="main">:</span><span class="quoted"><span class="quoted">"maintainedA <span class="skolem">Rules</span> <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Rules_def
      <span class="keyword1"><span class="command">using</span></span> standard_maintains_rules<span class="main">[</span><span class="operator">OF</span> std<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> consequence_graphI<span class="main">[</span><span class="operator">OF</span> _ _ g<span class="main">]</span> gr<span class="main">[</span><span class="operator">unfolded</span> set_of_graph_rules_def<span class="main">]</span> mnt
    <span class="keyword1"><span class="command">have</span></span> cg<span class="main">:</span><span class="quoted"><span class="quoted">"consequence_graph <span class="skolem">Rules</span> <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
    <span class="keyword1"><span class="command">with</span></span> cfg_l<span class="main">[</span><span class="operator">unfolded</span> least_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> mtd<span class="main">:</span><span class="quoted"><span class="quoted">"maintained <span class="main">(</span>graph_of <span class="skolem">init</span><span class="main">,</span> <span class="skolem">cfg</span><span class="main">)</span> <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">assume</span></span> ab<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="skolem">G</span><span class="main">:⟦</span>fst <span class="free">S</span><span class="main">⟧</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> abv<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> vertices <span class="skolem">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> vertices <span class="skolem">G</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> semantics_in_vertices<span class="main">[</span><span class="operator">OF</span> g<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> ab translation<span class="main">[</span><span class="operator">OF</span> g<span class="main">]</span> init
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> f<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="main">(</span>graph_of <span class="skolem">init</span><span class="main">)</span> <span class="skolem">G</span> <span class="skolem">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span> <span class="main">∧</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">f</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> maintainedD2<span class="main">[</span><span class="operator">OF</span> mtd f<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> g<span class="main">:</span><span class="quoted"><span class="quoted">"graph_homomorphism <span class="skolem">cfg</span> <span class="skolem">G</span> <span class="skolem">g</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">⊆</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> f <span class="keyword1"><span class="command">have</span></span> g01<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">consider</span></span> <span class="main">(</span>maintained<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="skolem">cfg</span><span class="main">:⟦</span>snd <span class="free">S</span><span class="main">⟧</span>"</span></span> <span class="main">|</span> <span class="main">(</span>no_models<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="main">:</span><span class="skolem">cfg</span><span class="main">:⟦</span><span class="main">⊥</span><span class="main">⟧</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cfg_g <span class="keyword1"><span class="command">unfolding</span></span> cfg entailment_model_def Let_def Rs_def R_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">:</span><span class="skolem">G</span><span class="main">:⟦</span>snd <span class="free">S</span><span class="main">⟧</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> maintained
      <span class="keyword1"><span class="command">from</span></span> graph_homomorphism_semantics<span class="main">[</span><span class="operator">OF</span> g maintained g01<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span><span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> no_models
      <span class="keyword1"><span class="command">from</span></span> graph_homomorphism_nonempty<span class="main">[</span><span class="operator">OF</span> g no_models<span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"getRel S_Bot <span class="skolem">G</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> std <span class="keyword1"><span class="command">unfolding</span></span> standard_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> d2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">⟹</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> entails_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> d1 d2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>