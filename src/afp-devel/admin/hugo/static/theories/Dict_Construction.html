<div id="Introduction">
<div class="head">
<h1>Theory Introduction</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Dictionary Construction›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Introduction
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Introduction›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
 Isabelle's logic features \emph{type classes}~\cite{haftmann2007typeclasses,wenzel1997typeclasses}.
 These are built into the kernel and are used extensively in theory developments.
 The existing \emph{code generator}, when targeting Standard ML, performs the well-known dictionary
 construction or \emph{dictionary translation}~\cite{haftmann2010codegeneration}.
 This works by replacing type classes with records, instances with values, and occurrences with
 explicit parameters.

 Haftmann and Nipkow give a pen-and-paper correctness proof of this construction
 \cite[<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>§›</span></span></span></span>4.1]{haftmann2010codegeneration}, based on a notion of \emph{higher-order rewrite
 systems.}
 The resulting theorem then states that any well-typed term is reduction-equivalent before and after
 class elimination.
 In this work, the dictionary construction is performed in a certified fashion, that is, the
 equivalence is a theorem inside the logic.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Encoding classes›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The choice of representation of a dictionary itself is straightforward: We model it as a
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> datatype<span class="antiquote"><span class="antiquote">}</span></span></span></span>, along with functions returning values of that type. The alternative here
  would have been to use the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> record<span class="antiquote"><span class="antiquote">}</span></span></span></span> package. The obvious advantage is that we could
  easily model subclass relationships through record inheritance. However, records do not support
  multiple inheritance. Since records offer no advantage over datatypes in that regard, we opted for
  the more modern <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> datatype<span class="antiquote"><span class="antiquote">}</span></span></span></span> package.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Consider the following example:›</span></span>

<span class="keyword1"><span class="command">class</span></span> plus <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">plus</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This will get translated to a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> datatype<span class="antiquote"><span class="antiquote">}</span></span></span></span> with a single constructor taking a single
  argument:
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> dict_plus <span class="main">=</span>
  mk_plus <span class="main">(</span><span class="free"><span class="entity">param_plus</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A function using the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> plus<span class="antiquote"><span class="antiquote">}</span></span></span></span> constraint:›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">double</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>plus <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">double</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> plus <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">double'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dict_plus <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">double'</span> <span class="free"><span class="bound"><span class="entity">dict</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> param_plus <span class="free"><span class="bound"><span class="entity">dict</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Encoding instances›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A more controversial design decision is how to represent dictionary certificates. For example,
  given a value of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"nat dict_plus"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, how do we know that this is a faithful representation
  of the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> plus<span class="antiquote"><span class="antiquote">}</span></span></span></span> instance for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">nat</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>?
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  <span class="antiquoted"><span class="antiquoted">▪</span></span> Florian Haftmann proposed a ``shallow encoding''. It works by exploiting the internal treatment
    of constants with sort constraints in the Isabelle kernel. Constants themselves do not carry
    sort constraints, only their definitional equations. The fact that a constant only appears with
    these constraints on the surface of the system is a feature of type inference.

    Instead, we can instruct the system to ignore these constraints. However, any attempt at
    ``hiding'' the constraints behind a type definition ultimately does not work: The nonemptiness
    proof requires a witness of a valid dictionary for an arbitrary, but fixed type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which
    is of course not possible (see <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>§›</span></span></span></span>\ref{sec:impossibility} for details).

  <span class="antiquoted"><span class="antiquoted">▪</span></span> The certificates contain the class axioms directly. For example, the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> semigroup_add<span class="antiquote"><span class="antiquote">}</span></span></span></span>
    class requires <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="free"><span class="free">a</span></span> <span class="main"><span class="main">+</span></span> <span class="free"><span class="free">b</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">+</span></span> <span class="free"><span class="free">c</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">a</span></span> <span class="main"><span class="main">+</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">b</span></span> <span class="main"><span class="main">+</span></span> <span class="free"><span class="free">c</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

    Translated into a definition, this would look as follows:

    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
      <span class="quoted"><span class="quoted">"<span class="free"><span class="free">cert_plus</span></span> <span class="free"><span class="free">dict</span></span> <span class="main"><span class="main">⟷</span></span>
        <span class="main"><span class="main">(</span></span><span class="main"><span class="main">∀</span></span><span class="bound"><span class="bound">a</span></span> <span class="bound"><span class="bound">b</span></span> <span class="bound"><span class="bound">c</span></span><span class="main"><span class="main">.</span></span> param_plus <span class="free"><span class="free">dict</span></span> <span class="main"><span class="main">(</span></span>param_plus <span class="free"><span class="free">dict</span></span> <span class="bound"><span class="bound">a</span></span> <span class="bound"><span class="bound">b</span></span><span class="main"><span class="main">)</span></span> <span class="bound"><span class="bound">c</span></span> <span class="main"><span class="main">=</span></span> param_plus <span class="free"><span class="free">dict</span></span> <span class="bound"><span class="bound">a</span></span> <span class="main"><span class="main">(</span></span>param_plus <span class="free"><span class="free">dict</span></span> <span class="bound"><span class="bound">b</span></span> <span class="bound"><span class="bound">c</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>

    Proving that instances satisfy this certificate is trivial.

    However, the equality proof of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f'›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span> is impossible: they are simply not equal in general.
    Nothing would prevent someone from defining an alternative dictionary using multiplication
    instead of addition and the certificate would still hold; but obviously functions using
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> plus<span class="antiquote"><span class="antiquote">}</span></span></span></span> on numbers would expect addition.

    Intuitively, this makes sense: the above notion of ``certificate'' establishes no connection
    between original instantiation and newly-generated dictionaries.

    Instead of proving equality, one would have to ``lift'' all existing theorems over the old
    constants to the new constants.

  <span class="antiquoted"><span class="antiquoted">▪</span></span> In order for equality between new and old constants to hold, the certificate needs to capture
    that the dictionary corresponds exactly to the class constants. This is achieved by the
    representation below.
    It literally states that the fields of the dictionary are equal to the class constants.
    The condition of the resulting equation can only be instantiated with dictionaries corresponding
    to existing class instances. This constitutes a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹closed world›</span></span> assumption, i.e., callers of
    generated code may not invent own instantiations.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cert_plus</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>plus dict_plus <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">cert_plus</span> <span class="free"><span class="bound"><span class="entity">dict</span></span></span> <span class="main">⟷</span> <span class="main">(</span>param_plus <span class="free"><span class="bound"><span class="entity">dict</span></span></span> <span class="main">=</span> plus<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Based on that definition, we can prove that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> double<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> double'<span class="antiquote"><span class="antiquote">}</span></span></span></span> are equivalent:
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"cert_plus <span class="free">dict</span> <span class="main">⟹</span> double' <span class="free">dict</span> <span class="main">=</span> double"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> cert_plus_def double'_def double_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  An unconditional equation can be obtained by specializing the theorem to a ground type and
  supplying a valid dictionary.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  When translating a constant <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span>, we use existing mechanisms in Isabelle to obtain its
  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹code graph›</span></span>. The graph contains the code equations of all transitive dependencies (i.e.,
  other constants) of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span>. In general, we have to re-define each of these dependencies. For that,
  we use the internal interface of the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> function<span class="antiquote"><span class="antiquote">}</span></span></span></span> package and feed it the code equations
  after performing the dictionary construction. In the standard case, where the user has not
  performed a custom code setup, the resulting function looks similar to its original definition.
  But the user may have also changed the implementation of a function significantly afterwards.
  This imposes some restrictions:

  <span class="antiquoted"><span class="antiquoted">▪</span></span> The new constant needs to be proven terminating. We apply some heuristics to transfer the
    original termination proof to the new definition. This only works when the termination condition
    does not rely on class axioms. (See <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>§›</span></span></span></span>\ref{sec:termination} for details.)
  <span class="antiquoted"><span class="antiquoted">▪</span></span> Pattern matching must be performed on datatypes, instead of the more general
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> code_datatype<span class="antiquote"><span class="antiquote">}</span></span></span></span>s.
  <span class="antiquoted"><span class="antiquoted">▪</span></span> The set of code equations must be exhaustive and non-overlapping.
›</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Impossibility">
<div class="head">
<h1>Theory Impossibility</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Impossibility of hiding sort constraints›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:impossibility}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Coauthor of this section: Florian Haftmann›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Impossibility
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">axiomatization</span></span> <span class="free">of_prop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prop <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
of_prop_Trueprop <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">of_prop</span> <span class="main">(</span>Trueprop <span class="free">P</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">P</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
Trueprop_of_prop <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Trueprop <span class="main">(</span><span class="free">of_prop</span> <span class="free">Q</span><span class="main">)</span> <span class="main">≡</span> <span class="keyword1">PROP</span> <span class="free">Q</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A type satisfies the certificate if there is an instance of the class.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_sg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itself <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">is_sg</span> <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> of_prop <span class="keyword1">OFCLASS</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> semigroup_add_class<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We trick the parser into ignoring the sort constraint of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> plus<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹Sign.add_const_constraint <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> plus<span class="antiquote">}</span></span><span class="main">,</span> SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{}</span> <span class="main">=&gt;</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span><span class="antiquote">}</span></span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">sg</span> <span class="free"><span class="bound"><span class="entity">plus</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">plus</span></span></span> <span class="main">=</span> Groups.plus <span class="main">∧</span> is_sg <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">plus</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Attempt: Define a type that contains all legal <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> plus<span class="antiquote"><span class="antiquote">}</span></span></span></span> functions.›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span> Sg <span class="main">=</span> <span class="quoted"><span class="quoted">"Collect sg <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">morphisms</span></span> the_plus Sg
  <span class="keyword1"><span class="command">unfolding</span></span> sg_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_sg_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We need to prove <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">OFCLASS</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> semigroup_add_class<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for arbitrary <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which is
impossible.›</span></span>

<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Dict_Construction">
<div class="head">
<h1>Theory Dict_Construction</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Setup›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Dict_Construction
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../Automatic_Refinement/Refine_Util.html">Automatic_Refinement.Refine_Util</a>
<span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"declassify"</span> <span class="main">::</span> thy_decl
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_of</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">set_of</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">x</span> <span class="bound">y</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wfP_implies_wf_set_of<span class="main">:</span> <span class="quoted"><span class="quoted">"wfP <span class="free">P</span> <span class="main">⟹</span> wf <span class="main">(</span>set_of <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> wfP_def set_of_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wf_set_of_implies_wfP<span class="main">:</span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span>set_of <span class="free">P</span><span class="main">)</span> <span class="main">⟹</span> wfP <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> wfP_def set_of_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wf_simulate_simple<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r'</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">,</span> <span class="free">g</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf <span class="free">r'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_inv_image wf_eq_minimal wf_inv_image<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_ofI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span> <span class="free">y</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> set_of <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> set_of_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> set_ofD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> set_of <span class="free">P</span> <span class="main">⟹</span> <span class="free">P</span> <span class="free">x</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> set_of_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> wfP_simulate_simple<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wfP <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">r'</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wfP <span class="free">r'</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wf_set_of_implies_wfP<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wf_simulate_simple<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">g</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wfP_implies_wf_set_of<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> set_ofI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> set_ofD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> wf_implies_dom<span class="main">:</span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span>set_of <span class="free">R</span><span class="main">)</span> <span class="main">⟹</span> All <span class="main">(</span>Wellfounded.accp <span class="free">R</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> allI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> accp_wfPD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wf_set_of_implies_wfP<span class="main">)</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wfP_implies_dom<span class="main">:</span> <span class="quoted"><span class="quoted">"wfP <span class="free">R</span> <span class="main">⟹</span> All <span class="main">(</span>Wellfounded.accp <span class="free">R</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> wfP_implies_wf_set_of wf_implies_dom<span class="main">)</span>

<span class="keyword1"><span class="command">named_theorems</span></span> dict_construction_specs

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹dict_construction_util.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹transfer_termination.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹congruences.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹side_conditions.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹class_graph.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹dict_construction.ML›</span>

<span class="keyword1"><span class="command">method_setup</span></span> fo_cong_rule <span class="main">=</span> <span class="quoted">‹
  <span class="entity">Attrib.thm</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span><span class="entity">Dict_Construction_Util.fo_cong_tac</span> <span class="entity">ctxt</span> <span class="entity">thm</span><span class="main">)</span><span class="main">)</span>
›</span> <span class="quoted">"resolve congruence rule using first-order matching"</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"<span class="main">(∧)</span>"</span></span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"True <span class="main">∧</span> <span class="free">p</span> <span class="main">⟷</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"False <span class="main">∧</span> <span class="free">p</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"<span class="main">(∨)</span>"</span></span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"True <span class="main">∨</span> <span class="free">p</span> <span class="main">⟷</span> True"</span></span> <span class="quoted"><span class="quoted">"False <span class="main">∨</span> <span class="free">p</span> <span class="main">⟷</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> comp_cong<span class="main">[</span><span class="operator">fundef_cong</span> <span class="quasi_keyword">del</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> fun.map_cong<span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/dict_construction_util.ML">
<div class="head">
<h1>File ‹dict_construction_util.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">infixr</span></span> <span class="inner_numeral">5</span> ==&gt;
<span class="keyword1"><span class="keyword">infixr</span></span> ===&gt;
<span class="keyword1"><span class="keyword">infix</span></span> <span class="inner_numeral">1</span> CONTINUE_WITH CONTINUE_WITH_FW

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DICT_CONSTRUCTION_UTIL</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* general *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> split_list3<span class="main">:</span> <span class="main">(</span>'a * 'b * 'c<span class="main">)</span> list <span class="main">-&gt;</span> 'a list * 'b list * 'c list
  <span class="keyword1"><span class="keyword">val</span></span> symreltab_of_symtab<span class="main">:</span> 'a Symtab.table Symtab.table <span class="main">-&gt;</span> 'a Symreltab.table
  <span class="keyword1"><span class="keyword">val</span></span> zip_symtabs<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'b <span class="main">-&gt;</span> 'c<span class="main">)</span> <span class="main">-&gt;</span> 'a Symtab.table <span class="main">-&gt;</span> 'b Symtab.table <span class="main">-&gt;</span> 'c Symtab.table
  <span class="keyword1"><span class="keyword">val</span></span> cat_options<span class="main">:</span> 'a option list <span class="main">-&gt;</span> 'a list
  <span class="keyword1"><span class="keyword">val</span></span> partition<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> 'a list * 'a list
  <span class="keyword1"><span class="keyword">val</span></span> unappend<span class="main">:</span> 'a list * 'b <span class="main">-&gt;</span> 'c list <span class="main">-&gt;</span> 'c list * 'c list
  <span class="keyword1"><span class="keyword">val</span></span> flat_right<span class="main">:</span> <span class="main">(</span>'a * 'b list<span class="main">)</span> list <span class="main">-&gt;</span> <span class="main">(</span>'a * 'b<span class="main">)</span> list

  <span class="comment1">(* logic *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> ===&gt; <span class="main">:</span> term list * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> ==&gt; <span class="main">:</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> sortify<span class="main">:</span> sort <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> sortify_typ<span class="main">:</span> sort <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> typify<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> typify_typ<span class="main">:</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> all_frees<span class="main">:</span> term <span class="main">-&gt;</span> <span class="main">(</span>string * typ<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> all_frees'<span class="main">:</span> term <span class="main">-&gt;</span> string list
  <span class="keyword1"><span class="keyword">val</span></span> all_tfrees<span class="main">:</span> typ <span class="main">-&gt;</span> <span class="main">(</span>string * sort<span class="main">)</span> list

  <span class="comment1">(* printing *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> pretty_const<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> Pretty.T

  <span class="comment1">(* conversion/tactic *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> ANY<span class="main">:</span> tactic list <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> ANY'<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> tactic<span class="main">)</span> list <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> CONTINUE_WITH<span class="main">:</span> <span class="main">(</span>int <span class="main">-&gt;</span> tactic<span class="main">)</span> * <span class="main">(</span>int <span class="main">-&gt;</span> tactic<span class="main">)</span> list <span class="main">-&gt;</span> int <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm Seq.seq
  <span class="keyword1"><span class="keyword">val</span></span> CONTINUE_WITH_FW<span class="main">:</span> <span class="main">(</span>int <span class="main">-&gt;</span> tactic<span class="main">)</span> * <span class="main">(</span>int <span class="main">-&gt;</span> tactic<span class="main">)</span> list <span class="main">-&gt;</span> int <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm Seq.seq
  <span class="keyword1"><span class="keyword">val</span></span> SOLVED<span class="main">:</span> tactic <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> TRY'<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> descend_fun_conv<span class="main">:</span> conv <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> lhs_conv<span class="main">:</span> conv <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> rhs_conv<span class="main">:</span> conv <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> rewr_lhs_head_conv<span class="main">:</span> thm <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> rewr_rhs_head_conv<span class="main">:</span> thm <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> conv_result<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> thm<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> changed_conv<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> thm<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> maybe_induct_tac<span class="main">:</span> thm list option <span class="main">-&gt;</span> term list list <span class="main">-&gt;</span> term list list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> multi_induct_tac<span class="main">:</span> thm list <span class="main">-&gt;</span> term list list <span class="main">-&gt;</span> term list list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> print_tac'<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> fo_cong_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic

  <span class="comment1">(* theorem manipulation *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> contract<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> on_thms_complete<span class="main">:</span> <span class="main">(</span>unit <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm list

  <span class="comment1">(* theory *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> define_params_nosyn<span class="main">:</span> term <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm * local_theory
  <span class="keyword1"><span class="keyword">val</span></span> note_thm<span class="main">:</span> binding <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm * local_theory
  <span class="keyword1"><span class="keyword">val</span></span> note_thms<span class="main">:</span> binding <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm list * local_theory

  <span class="comment1">(* timing *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> with_timeout<span class="main">:</span> Time.time <span class="main">-&gt;</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> 'a

  <span class="comment1">(* debugging *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> debug<span class="main">:</span> bool Config.T
  <span class="keyword1"><span class="keyword">val</span></span> if_debug<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span>unit <span class="main">-&gt;</span> unit<span class="main">)</span> <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> ALLGOALS'<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span>int <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> prove'<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term <span class="main">-&gt;</span>
    <span class="main">(</span><span class="main">{</span>prems<span class="main">:</span> thm list<span class="main">,</span> context<span class="main">:</span> <span class="entity">Proof.context</span><span class="main">}</span> <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> prove_common'<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span>
    <span class="main">(</span><span class="main">{</span>prems<span class="main">:</span> thm list<span class="main">,</span> context<span class="main">:</span> <span class="entity">Proof.context</span><span class="main">}</span> <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> thm list
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dict_Construction_Util</span> <span class="main">:</span> <span class="entity">DICT_CONSTRUCTION_UTIL</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* general *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">symreltab_of_symtab</span> <span class="entity">tab</span> <span class="main">=</span>
  Symtab.map <span class="main">(</span>K Symtab.dest<span class="main">)</span> <span class="entity">tab</span> |&gt;
    Symtab.dest |&gt;
    maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">k</span><span class="main">,</span> <span class="entity">kvs</span><span class="main">)</span> <span class="main">=&gt;</span> map <span class="main">(</span>apfst <span class="main">(</span>pair <span class="entity">k</span><span class="main">)</span><span class="main">)</span> <span class="entity">kvs</span><span class="main">)</span> |&gt;
    Symreltab.make

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_list3</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">split_list3</span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">z</span><span class="main">)</span> :: <span class="entity">rest</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="entity">ys</span><span class="main">,</span> <span class="entity">zs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">split_list3</span> <span class="entity">rest</span> <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">x</span> :: <span class="entity">xs</span><span class="main">,</span> <span class="entity">y</span> :: <span class="entity">ys</span><span class="main">,</span> <span class="entity">z</span> :: <span class="entity">zs</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">zip_symtabs</span> <span class="entity">f</span> <span class="entity">t1</span> <span class="entity">t2</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword3"><span class="keyword">open</span></span> Symtab
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ord</span> <span class="main">=</span> fast_string_ord
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">aux</span> <span class="entity">acc</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="entity">acc</span>
      <span class="main">|</span> <span class="entity">aux</span> <span class="entity">acc</span> <span class="main">(</span><span class="main">(</span><span class="entity">k1</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="entity">k2</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> :: <span class="entity">ys</span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ord</span> <span class="main">(</span><span class="entity">k1</span><span class="main">,</span> <span class="entity">k2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
           EQUAL   <span class="main">=&gt;</span> <span class="entity">aux</span> <span class="main">(</span>update_new <span class="main">(</span><span class="entity">k1</span><span class="main">,</span> <span class="entity">f</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">)</span> <span class="entity">acc</span><span class="main">)</span> <span class="entity">xs</span> <span class="entity">ys</span>
         <span class="main">|</span> LESS    <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> UNDEF <span class="entity">k1</span>
         <span class="main">|</span> GREATER <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> UNDEF <span class="entity">k2</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">aux</span> <span class="main">_</span> <span class="main">(</span><span class="main">(</span><span class="entity">k</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> :: <span class="main">_</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span>
          <span class="keyword3"><span class="keyword">raise</span></span> UNDEF <span class="entity">k</span>
      <span class="main">|</span> <span class="entity">aux</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="main">(</span><span class="entity">k</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> :: <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword3"><span class="keyword">raise</span></span> UNDEF <span class="entity">k</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">aux</span> empty <span class="main">(</span>dest <span class="entity">t1</span><span class="main">)</span> <span class="main">(</span>dest <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cat_options</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">cat_options</span> <span class="main">(</span>SOME <span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">x</span> :: <span class="entity">cat_options</span> <span class="entity">xs</span>
  <span class="main">|</span> <span class="entity">cat_options</span> <span class="main">(</span>NONE :: <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">cat_options</span> <span class="entity">xs</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">partition</span> <span class="entity">f</span> <span class="entity">xs</span> <span class="main">=</span> <span class="main">(</span>filter <span class="entity">f</span> <span class="entity">xs</span><span class="main">,</span> filter_out <span class="entity">f</span> <span class="entity">xs</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unappend</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> chop <span class="main">(</span>length <span class="entity">xs</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">flat_right</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">flat_right</span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span> :: <span class="entity">rest</span><span class="main">)</span> <span class="main">=</span> map <span class="main">(</span>pair <span class="entity">x</span><span class="main">)</span> <span class="entity">ys</span> @ <span class="entity">flat_right</span> <span class="entity">rest</span>

<span class="comment1">(* logic *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">x</span> <span class="entity">==&gt;</span> <span class="entity">y</span> <span class="main">=</span> Logic.mk_implies <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="keyword1"><span class="keyword">op</span></span> <span class="entity">===&gt;</span> <span class="main">=</span> Library.foldr <span class="keyword1"><span class="keyword">op</span></span> <span class="entity">==&gt;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sortify_typ</span> <span class="entity">sort</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> map <span class="main">(</span><span class="entity">sortify_typ</span> <span class="entity">sort</span><span class="main">)</span> <span class="entity">args</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">sortify_typ</span> <span class="entity">sort</span> <span class="main">(</span>TFree <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> TFree <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">sortify_typ</span> <span class="main">_</span> <span class="main">(</span>TVar <span class="main">_</span><span class="main">)</span> <span class="main">=</span> error <span class="inner_quoted">"TVar encountered"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sortify</span> <span class="entity">sort</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">sortify_typ</span> <span class="entity">sort</span> <span class="entity">typ</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">sortify</span> <span class="entity">sort</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">sortify_typ</span> <span class="entity">sort</span> <span class="entity">typ</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">sortify</span> <span class="entity">sort</span> <span class="main">(</span><span class="entity">t</span> $ <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="entity">sortify</span> <span class="entity">sort</span> <span class="entity">t</span> $ <span class="entity">sortify</span> <span class="entity">sort</span> <span class="entity">u</span>
  <span class="main">|</span> <span class="entity">sortify</span> <span class="entity">sort</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">,</span> <span class="entity">term</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Abs <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">sortify_typ</span> <span class="entity">sort</span> <span class="entity">typ</span><span class="main">,</span> <span class="entity">sortify</span> <span class="entity">sort</span> <span class="entity">term</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">sortify</span> <span class="main">_</span> <span class="main">(</span>Bound <span class="entity">n</span><span class="main">)</span> <span class="main">=</span> Bound <span class="entity">n</span>
  <span class="main">|</span> <span class="entity">sortify</span> <span class="main">_</span> <span class="main">(</span>Var <span class="main">_</span><span class="main">)</span> <span class="main">=</span> error <span class="inner_quoted">"Var encountered"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typify_typ</span> <span class="main">=</span> <span class="entity">sortify_typ</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typify</span> <span class="main">=</span> <span class="entity">sortify</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_frees</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">all_frees</span> <span class="main">(</span><span class="entity">t</span> $ <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> union <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">all_frees</span> <span class="entity">t</span><span class="main">)</span> <span class="main">(</span><span class="entity">all_frees</span> <span class="entity">u</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">all_frees</span> <span class="main">(</span>Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">all_frees</span> <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">all_frees</span> <span class="main">_</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_frees'</span> <span class="main">=</span> map fst o <span class="entity">all_frees</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_tfrees</span> <span class="main">(</span>TFree <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">all_tfrees</span> <span class="main">(</span>Type <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> fold <span class="main">(</span>union <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map <span class="entity">all_tfrees</span> <span class="entity">ts</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">all_tfrees</span> <span class="main">_</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>

<span class="comment1">(* printing *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_const</span> <span class="entity">ctxt</span> <span class="entity">const</span> <span class="main">=</span>
  Syntax.pretty_term <span class="entity">ctxt</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">const</span><span class="main">,</span> Sign.the_const_type <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">const</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* conversion/tactic *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ANY</span> <span class="entity">tacs</span> <span class="main">=</span> fold <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> APPEND<span class="main">)</span> <span class="entity">tacs</span> no_tac
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ANY'</span> <span class="entity">tacs</span> <span class="entity">n</span> <span class="main">=</span> fold <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> APPEND<span class="main">)</span> <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">t</span> <span class="entity">n</span><span class="main">)</span> <span class="entity">tacs</span><span class="main">)</span> no_tac
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">TRY'</span> <span class="entity">tac</span> <span class="entity">n</span> <span class="main">=</span> TRY <span class="main">(</span><span class="entity">tac</span> <span class="entity">n</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">descend_fun_conv</span> <span class="entity">cv</span> <span class="main">=</span>
  <span class="entity">cv</span> else_conv <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ct</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ct</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> Conv.fun_conv <span class="main">(</span><span class="entity">descend_fun_conv</span> <span class="entity">cv</span><span class="main">)</span> <span class="entity">ct</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Conv.no_conv <span class="entity">ct</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lhs_conv</span> <span class="entity">cv</span> <span class="main">=</span>
  <span class="entity">cv</span> |&gt; Conv.arg1_conv |&gt; Conv.arg_conv

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rhs_conv</span> <span class="entity">cv</span> <span class="main">=</span>
  <span class="entity">cv</span> |&gt; Conv.arg_conv |&gt; Conv.arg_conv

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewr_lhs_head_conv</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="entity">safe_mk_meta_eq</span> <span class="entity">thm</span> |&gt; Conv.rewr_conv |&gt; <span class="entity">descend_fun_conv</span> |&gt; <span class="entity">lhs_conv</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewr_rhs_head_conv</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="entity">safe_mk_meta_eq</span> <span class="entity">thm</span> |&gt; Conv.rewr_conv |&gt; <span class="entity">descend_fun_conv</span> |&gt; <span class="entity">rhs_conv</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">conv_result</span> <span class="entity">cv</span> <span class="entity">ct</span> <span class="main">=</span>
  Thm.prop_of <span class="main">(</span><span class="entity">cv</span> <span class="entity">ct</span><span class="main">)</span> |&gt; Logic.dest_equals |&gt; snd

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">changed_conv</span> <span class="entity">cv</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ct</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="entity">cv</span> <span class="entity">ct</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Thm.prop_of <span class="entity">res</span> |&gt; Logic.dest_equals
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">lhs</span> aconv <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword3"><span class="keyword">raise</span></span> CTERM <span class="main">(</span><span class="inner_quoted">"no conversion"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">res</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">multi_induct_tac</span> <span class="entity">rules</span> <span class="entity">insts</span> <span class="entity">arbitrary</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts'</span> <span class="main">=</span> map <span class="main">(</span>map <span class="main">(</span>SOME o pair NONE o rpair false<span class="main">)</span><span class="main">)</span> <span class="entity">insts</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arbitrary'</span> <span class="main">=</span> map <span class="main">(</span>map dest_Free<span class="main">)</span> <span class="entity">arbitrary</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    DETERM <span class="main">(</span><span class="entity">Induct.induct_tac</span> <span class="entity">ctxt</span> false <span class="entity">insts'</span> <span class="entity">arbitrary'</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span>SOME <span class="entity">rules</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">maybe_induct_tac</span> <span class="main">(</span>SOME <span class="entity">rules</span><span class="main">)</span> <span class="entity">insts</span> <span class="entity">arbitrary</span> <span class="main">=</span> <span class="entity">multi_induct_tac</span> <span class="entity">rules</span> <span class="entity">insts</span> <span class="entity">arbitrary</span>
  <span class="main">|</span> <span class="entity">maybe_induct_tac</span> NONE <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> K all_tac

<span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="entity">tac</span> <span class="entity">CONTINUE_WITH</span> <span class="entity">tacs</span><span class="main">)</span> <span class="entity">i</span> <span class="entity">st</span> <span class="main">=</span>
  <span class="entity">st</span> |&gt; <span class="main">(</span><span class="entity">tac</span> <span class="entity">i</span> THEN <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">st'</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n'</span> <span class="main">=</span> Thm.nprems_of <span class="entity">st'</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> Thm.nprems_of <span class="entity">st</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">aux</span> <span class="main">[</span><span class="main">]</span> <span class="main">_</span> <span class="main">=</span> all_tac
        <span class="main">|</span> <span class="entity">aux</span> <span class="main">(</span><span class="entity">tac</span> :: <span class="entity">tacs</span><span class="main">)</span> <span class="entity">i</span> <span class="main">=</span> <span class="entity">tac</span> <span class="entity">i</span> THEN <span class="entity">aux</span> <span class="entity">tacs</span> <span class="main">(</span><span class="entity">i</span> - <span class="inner_numeral">1</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n'</span> - <span class="entity">n</span> + <span class="inner_numeral">1</span> &lt;&gt; length <span class="entity">tacs</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"CONTINUE_WITH: unexpected number of emerging subgoals"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">,</span> <span class="main">[</span><span class="entity">st'</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">aux</span> <span class="main">(</span>rev <span class="entity">tacs</span><span class="main">)</span> <span class="main">(</span><span class="entity">i</span> + <span class="entity">n'</span> - <span class="entity">n</span><span class="main">)</span> <span class="entity">st'</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="entity">tac</span> <span class="entity">CONTINUE_WITH_FW</span> <span class="entity">tacs</span><span class="main">)</span> <span class="entity">i</span> <span class="entity">st</span> <span class="main">=</span>
  <span class="entity">st</span> |&gt; <span class="main">(</span><span class="entity">tac</span> <span class="entity">i</span> THEN <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">st'</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n'</span> <span class="main">=</span> Thm.nprems_of <span class="entity">st'</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> Thm.nprems_of <span class="entity">st</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">aux</span> <span class="main">[</span><span class="main">]</span> <span class="main">_</span> <span class="entity">st</span> <span class="main">=</span> all_tac <span class="entity">st</span>
        <span class="main">|</span> <span class="entity">aux</span> <span class="main">(</span><span class="entity">tac</span> :: <span class="entity">tacs</span><span class="main">)</span> <span class="entity">i</span> <span class="entity">st</span> <span class="main">=</span> <span class="entity">st</span> |&gt;
            <span class="main">(</span><span class="entity">tac</span> <span class="entity">i</span> THEN <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">st'</span> <span class="main">=&gt;</span>
             <span class="entity">aux</span> <span class="entity">tacs</span> <span class="main">(</span><span class="entity">i</span> + <span class="inner_numeral">1</span> + Thm.nprems_of <span class="entity">st'</span> - Thm.nprems_of <span class="entity">st</span><span class="main">)</span> <span class="entity">st'</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n'</span> - <span class="entity">n</span> + <span class="inner_numeral">1</span> &lt;&gt; length <span class="entity">tacs</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> THM <span class="main">(</span><span class="inner_quoted">"unexpected number of emerging subgoals"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">,</span> <span class="main">[</span><span class="entity">st'</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">aux</span> <span class="entity">tacs</span> <span class="entity">i</span> <span class="entity">st'</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">SOLVED</span> <span class="entity">tac</span> <span class="main">=</span> <span class="entity">tac</span> THEN ALLGOALS <span class="main">(</span>K no_tac<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_tac'</span> <span class="entity">ctxt</span> <span class="entity">str</span> <span class="main">=</span> SELECT_GOAL <span class="main">(</span>print_tac <span class="entity">ctxt</span> <span class="entity">str</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fo_cong_tac</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span> SUBGOAL <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">concl</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_of</span> <span class="main">=</span> <span class="entity">HOLogic.dest_Trueprop</span> #&gt; <span class="entity">HOLogic.dest_eq</span> #&gt; fst
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl_pat</span> <span class="main">=</span> <span class="entity">lhs_of</span> <span class="main">(</span>Thm.concl_of <span class="entity">thm</span><span class="main">)</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">lhs_of</span> <span class="entity">concl</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts</span> <span class="main">=</span> Thm.first_order_match <span class="main">(</span><span class="entity">concl_pat</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    resolve_tac <span class="entity">ctxt</span> <span class="main">[</span>Drule.instantiate_normalize <span class="entity">insts</span> <span class="entity">thm</span><span class="main">]</span> <span class="entity">i</span>
  <span class="keyword2"><span class="keyword">end</span></span> <span class="keyword3"><span class="keyword">handle</span></span> Pattern.MATCH <span class="main">=&gt;</span> no_tac<span class="main">)</span>

<span class="comment1">(* theorem manipulation *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">contract</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">frees</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm'</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.import true <span class="main">[</span><span class="entity">thm</span><span class="main">]</span> <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> Thm.prop_of <span class="entity">thm'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span> Logic.strip_imp_prems <span class="entity">prop</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span>
      Logic.strip_imp_concl <span class="entity">prop</span>
      |&gt; <span class="entity">HOLogic.dest_Trueprop</span>
      |&gt; <span class="entity">HOLogic.dest_eq</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">used</span> <span class="entity">x</span> <span class="main">=</span>
      exists <span class="main">(</span>exists_subterm <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span> <span class="entity">prems</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">lhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">g</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">rhs</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">loop</span> <span class="main">[</span><span class="main">]</span> <span class="entity">ys</span> <span class="main">=</span> <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> list_comb <span class="main">(</span><span class="entity">g</span><span class="main">,</span> rev <span class="entity">ys</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">loop</span> <span class="entity">xs</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">f</span><span class="main">,</span> rev <span class="entity">xs</span><span class="main">)</span><span class="main">,</span> <span class="entity">g</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">loop</span> <span class="main">(</span><span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">(</span><span class="entity">y</span> :: <span class="entity">ys</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">y</span> <span class="keyword1"><span class="keyword">andalso</span></span> is_Free <span class="entity">x</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span><span class="entity">used</span> <span class="entity">x</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">loop</span> <span class="entity">xs</span> <span class="entity">ys</span> |&gt; apfst <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> + <span class="inner_numeral">1</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">f</span><span class="main">,</span> rev <span class="main">(</span><span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> list_comb <span class="main">(</span><span class="entity">g</span><span class="main">,</span> rev <span class="main">(</span><span class="entity">y</span> :: <span class="entity">ys</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">count</span><span class="main">,</span> <span class="main">(</span><span class="entity">lhs'</span><span class="main">,</span> <span class="entity">rhs'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">loop</span> <span class="main">(</span>rev <span class="entity">xs</span><span class="main">)</span> <span class="main">(</span>rev <span class="entity">ys</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl'</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs'</span><span class="main">,</span> <span class="entity">rhs'</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">0</span> <span class="main">=</span> resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span> THEN_ALL_NEW <span class="main">(</span><span class="entity">Method.assm_tac</span> <span class="entity">ctxt</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="entity">n</span> <span class="main">=</span> resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ext<span class="antiquote">}</span></span></span> THEN' <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">n</span> - <span class="inner_numeral">1</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> <span class="entity">prems</span> <span class="entity">===&gt;</span> <span class="entity">concl'</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Goal.prove_future <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">prop</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> HEADGOAL <span class="main">(</span><span class="entity">tac</span> <span class="entity">context</span> <span class="entity">count</span><span class="main">)</span><span class="main">)</span>
    |&gt; singleton <span class="main">(</span>Variable.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">on_thms_complete</span> <span class="entity">f</span> <span class="entity">thms</span> <span class="main">=</span>
  <span class="main">(</span>Future.fork <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>Thm.consolidate <span class="entity">thms</span><span class="main">;</span> <span class="entity">f</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> <span class="entity">thms</span><span class="main">)</span>

<span class="comment1">(* theory *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_params_nosyn</span> <span class="entity">term</span> <span class="main">=</span>
  <span class="entity">Specification.definition</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">term</span><span class="main">)</span>
  #&gt;&gt; snd #&gt;&gt; snd

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">note_thm</span> <span class="entity">binding</span> <span class="entity">thm</span> <span class="main">=</span>
  Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">binding</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span> #&gt;&gt; snd #&gt;&gt; the_single

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">note_thms</span> <span class="entity">binding</span> <span class="entity">thms</span> <span class="main">=</span>
  Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">binding</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">thms</span><span class="main">)</span> #&gt;&gt; snd

<span class="comment1">(* timing *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">with_timeout</span> <span class="entity">time</span> <span class="entity">f</span> <span class="entity">x</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> Exn.interruptible_capture <span class="main">(</span>Timeout.apply <span class="entity">time</span> <span class="entity">f</span><span class="main">)</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">of</span></span>
    Exn.Res <span class="entity">y</span> <span class="main">=&gt;</span> <span class="entity">y</span>
  <span class="main">|</span> Exn.Exn <span class="main">(</span>Timeout.TIMEOUT <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">x</span>
  <span class="main">|</span> Exn.Exn <span class="entity">e</span> <span class="main">=&gt;</span> Exn.reraise <span class="entity">e</span>

<span class="comment1">(* debugging *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">debug</span> <span class="main">=</span> <span class="entity">Attrib.setup_config_bool</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "dict_construction_debug"<span class="antiquote">}</span></span></span> <span class="main">(</span>K false<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">if_debug</span> <span class="entity">ctxt</span> <span class="entity">f</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> Config.get <span class="entity">ctxt</span> <span class="entity">debug</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">f</span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ALLGOALS'</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Config.get <span class="entity">ctxt</span> <span class="entity">debug</span> <span class="keyword2"><span class="keyword">then</span></span> ALLGOALS <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">PARALLEL_ALLGOALS</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove'</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Config.get <span class="entity">ctxt</span> <span class="entity">debug</span> <span class="keyword2"><span class="keyword">then</span></span> Goal.prove <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">else</span></span> Goal.prove_future <span class="entity">ctxt</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_common'</span> <span class="entity">ctxt</span> <span class="main">=</span> Goal.prove_common <span class="entity">ctxt</span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> Config.get <span class="entity">ctxt</span> <span class="entity">debug</span> <span class="keyword2"><span class="keyword">then</span></span> NONE <span class="keyword2"><span class="keyword">else</span></span> SOME <span class="inner_numeral">~1</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/transfer_termination.ML">
<div class="head">
<h1>File ‹transfer_termination.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">TRANSFER_TERMINATION</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> termination_tac<span class="main">:</span> <span class="entity">Function.info</span> <span class="main">-&gt;</span> <span class="entity">Function.info</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Transfer_Termination</span> <span class="main">:</span> <span class="entity">TRANSFER_TERMINATION</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Dict_Construction_Util

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">termination_tac</span> <span class="main">(</span><span class="main">{</span>R <span class="main">=</span> <span class="entity">new_R</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">:</span> <span class="entity">Function.info</span><span class="main">)</span> <span class="main">(</span><span class="entity">old_info</span><span class="main">:</span> <span class="entity">Function.info</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fallback_tac</span> <span class="entity">warn</span> <span class="main">_</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">warn</span> <span class="keyword2"><span class="keyword">then</span></span> warning <span class="inner_quoted">"Falling back to another termination proof"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
        Seq.empty<span class="main">)</span>

    <span class="comment1">(*copied from BNF_Comp, in turn copied from Envir.expand_term_free*)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">expand_term_const</span> <span class="entity">defs</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqs</span> <span class="main">=</span> map <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">(</span><span class="entity">U</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> o apfst dest_Const<span class="main">)</span> <span class="entity">defs</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> Const <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">eqs</span> <span class="entity">x</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> Envir.expand_term <span class="entity">get</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_comp_bnf</span> <span class="entity">typ</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="comment1">(* we start from a fresh lthy to avoid local hyps interfering with BNF *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span>
          Proof_Context.theory_of <span class="entity">ctxt</span>
          |&gt; <span class="entity">Named_Target.theory_init</span>
          |&gt; Config.put <span class="entity">BNF_Comp.typedef_threshold</span> <span class="inner_numeral">~1</span>
        <span class="comment1">(* we just pretend that they're all live here *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">live_As</span> <span class="main">=</span> <span class="entity">all_tfrees</span> <span class="entity">typ</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">flatten_tyargs</span> <span class="entity">Ass</span> <span class="main">=</span>
          <span class="entity">live_As</span>
          |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">Ts</span> <span class="main">=&gt;</span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">Ts</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">Ass</span><span class="main">)</span>
        <span class="comment1">(* Dont_Inline would create new definitions, always *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">bnf</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">{</span><span class="entity">map_unfolds</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">BNF_Comp.bnf_of_typ</span> false <span class="entity">BNF_Def.Do_Inline</span> I <span class="entity">flatten_tyargs</span> <span class="entity">live_As</span> <span class="main">[</span><span class="main">]</span> <span class="entity">typ</span>
            <span class="main">(</span><span class="main">(</span><span class="entity">BNF_Comp.empty_comp_cache</span><span class="main">,</span> <span class="entity">BNF_Comp.empty_unfolds</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subst</span> <span class="main">=</span> map <span class="main">(</span>Logic.dest_equals o Thm.prop_of<span class="main">)</span> <span class="entity">map_unfolds</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">BNF_Def.map_of_bnf</span> <span class="entity">bnf</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">live_As</span><span class="main">,</span> <span class="entity">expand_term_const</span> <span class="entity">subst</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">old_info</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">{</span>R <span class="main">=</span> <span class="entity">old_R</span><span class="main">,</span> totality <span class="main">=</span> SOME <span class="entity">totality</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_eq</span> <span class="entity">R</span> <span class="main">=</span>
              <span class="entity">Inductive.the_inductive</span> <span class="entity">ctxt</span> <span class="entity">R</span>
              |&gt; snd |&gt; <span class="main">#</span>eqs
              |&gt; the_single
              |&gt; Local_Defs.abs_def_rule <span class="entity">ctxt</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">old_R_eq</span><span class="main">,</span> <span class="entity">new_R_eq</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="entity">get_eq</span> <span class="main">(</span><span class="entity">old_R</span><span class="main">,</span> <span class="entity">new_R</span><span class="main">)</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_typ</span> <span class="entity">R</span> <span class="main">=</span>
              fastype_of <span class="entity">R</span>
              |&gt; strip_type
              |&gt; fst |&gt; hd
              |&gt; Type.legacy_freeze_type
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">old_R_typ</span><span class="main">,</span> <span class="entity">new_R_typ</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="entity">get_typ</span> <span class="main">(</span><span class="entity">old_R</span><span class="main">,</span> <span class="entity">new_R</span><span class="main">)</span>

            <span class="comment1">(* simple strategy: old_R and new_R are identical *)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simple_tac</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">totality'</span> <span class="main">=</span> Local_Defs.unfold <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">old_R_eq</span><span class="main">]</span> <span class="entity">totality</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                Local_Defs.unfold_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">new_R_eq</span><span class="main">]</span> THEN
                  HEADGOAL <span class="main">(</span>SOLVED' <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">totality'</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">end</span></span>

            <span class="comment1">(* smart strategy: new_R can be simulated by old_R *)</span>
            <span class="comment1">(* FIXME this is trigger-happy *)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">smart_tac</span> <span class="main">=</span> Exn.interruptible_capture <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">st</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old_R_stripped</span> <span class="main">=</span>
                  Thm.prop_of <span class="entity">old_R_eq</span>
                  |&gt; Logic.dest_equals |&gt; snd
                  |&gt; map_types <span class="main">(</span>K dummyT<span class="main">)</span>
                  |&gt; Syntax.check_term <span class="entity">ctxt</span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">futile</span> <span class="main">=</span>
                  <span class="entity">old_R_stripped</span> |&gt; exists_type <span class="main">(</span>exists_subtype
                    <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> TFree <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">sort</span> &lt;&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span>
                      <span class="main">|</span> TVar <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">sort</span> &lt;&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span>
                      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span><span class="main">)</span>

                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">costrip_prodT</span> <span class="entity">new_t</span> <span class="entity">old_t</span> <span class="main">=</span>
                  <span class="keyword2"><span class="keyword">if</span></span> Type.could_match <span class="main">(</span><span class="entity">old_t</span><span class="main">,</span> <span class="entity">new_t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                    <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="entity">new_t</span><span class="main">)</span>
                  <span class="keyword2"><span class="keyword">else</span></span>
                    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">costrip_prodT</span> <span class="main">(</span>snd <span class="main">(</span><span class="entity">HOLogic.dest_prodT</span> <span class="entity">new_t</span><span class="main">)</span><span class="main">)</span> <span class="entity">old_t</span> <span class="keyword2"><span class="keyword">of</span></span>
                      <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">stripped_t</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">n</span> + <span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">stripped_t</span><span class="main">)</span>

                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">construct_inner_proj</span> <span class="entity">new_t</span> <span class="entity">old_t</span> <span class="main">=</span>
                  <span class="keyword2"><span class="keyword">let</span></span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">diff</span><span class="main">,</span> <span class="entity">stripped_t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">costrip_prodT</span> <span class="entity">new_t</span> <span class="entity">old_t</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tfrees</span><span class="main">,</span> <span class="entity">f_head</span><span class="main">)</span> <span class="main">=</span> <span class="entity">map_comp_bnf</span> <span class="entity">stripped_t</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f_args</span> <span class="main">=</span> map <span class="main">(</span>K <span class="main">(</span>Abs <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> dummyT<span class="main">,</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> undefined<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">tfrees</span>
                    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_snd</span> <span class="inner_numeral">0</span> <span class="main">=</span> list_comb <span class="main">(</span>map_types <span class="main">(</span>K dummyT<span class="main">)</span> <span class="entity">f_head</span><span class="main">,</span> <span class="entity">f_args</span><span class="main">)</span>
                      <span class="main">|</span> <span class="entity">add_snd</span> <span class="entity">n</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> comp<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span> $ <span class="entity">add_snd</span> <span class="main">(</span><span class="entity">n</span> - <span class="inner_numeral">1</span><span class="main">)</span> $ Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> snd<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span>
                  <span class="keyword2"><span class="keyword">in</span></span>
                    <span class="entity">add_snd</span> <span class="entity">diff</span>
                  <span class="keyword2"><span class="keyword">end</span></span>

                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">construct_outer_proj</span> <span class="entity">new_t</span> <span class="entity">old_t</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">new_t</span><span class="main">,</span> <span class="entity">old_t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
                  <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> sum<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">new_ts</span><span class="main">)</span><span class="main">,</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> sum<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">old_ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
                    <span class="keyword2"><span class="keyword">let</span></span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ps</span> <span class="main">=</span> map2 <span class="entity">construct_outer_proj</span> <span class="entity">new_ts</span> <span class="entity">old_ts</span>
                    <span class="keyword2"><span class="keyword">in</span></span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> map_sum<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">,</span> <span class="entity">ps</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
                <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">construct_inner_proj</span> <span class="entity">new_t</span> <span class="entity">old_t</span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">outer_proj</span> <span class="main">=</span> <span class="entity">construct_outer_proj</span> <span class="entity">new_R_typ</span> <span class="entity">old_R_typ</span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old_R_typ_imported</span> <span class="main">=</span>
                  yield_singleton Variable.importT_terms <span class="entity">old_R</span> <span class="entity">ctxt</span>
                  |&gt; fst |&gt; <span class="entity">get_typ</span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span>
                  <span class="entity">outer_proj</span>
                  |&gt; Type.constraint <span class="main">(</span><span class="entity">new_R_typ</span> --&gt; <span class="entity">old_R_typ_imported</span><span class="main">)</span>
                  |&gt; Syntax.check_term <span class="entity">ctxt</span>
                  |&gt; Thm.cterm_of <span class="entity">ctxt</span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wf_simulate</span> <span class="main">=</span>
                  Drule.infer_instantiate <span class="entity">ctxt</span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="inner_quoted">"g"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span><span class="main">]</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> wf_simulate_simple<span class="antiquote">}</span></span></span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old_wf</span> <span class="main">=</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> wfP_implies_wf_set_of<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> accp_wfPI<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">totality</span><span class="main">]</span><span class="main">]</span><span class="main">)</span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inner_tac</span> <span class="main">=</span>
                  match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> wf_implies_dom<span class="antiquote">}</span></span></span> THEN'
                    match_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">wf_simulate</span><span class="main">]</span> <span class="entity">CONTINUE_WITH_FW</span>
                      <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">old_wf</span><span class="main">]</span><span class="main">,</span>
                       match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> set_ofI<span class="antiquote">}</span></span></span> THEN'
                         dmatch_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> set_ofD<span class="antiquote">}</span></span></span> THEN'
                         SELECT_GOAL <span class="main">(</span>Local_Defs.unfold_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">old_R_eq</span><span class="main">,</span> <span class="entity">new_R_eq</span><span class="main">]</span><span class="main">)</span> THEN'
                         <span class="entity">TRY'</span>
                           <span class="main">(</span>REPEAT_ALL_NEW <span class="main">(</span>ematch_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjE exE<span class="antiquote">}</span></span></span><span class="main">)</span> THEN'
                             <span class="entity">hyp_subst_tac_thin</span> true <span class="entity">ctxt</span> THEN'
                             REPEAT_ALL_NEW <span class="main">(</span>match_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjI exI<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">]</span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unfold_tac</span> <span class="main">=</span>
                  Local_Defs.unfold_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> comp_apply id_apply prod.sel<span class="antiquote">}</span></span></span> THEN
                    <span class="entity">auto_tac</span> <span class="entity">ctxt</span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span> <span class="entity">SOLVED</span> <span class="main">(</span>HEADGOAL <span class="entity">inner_tac</span> THEN <span class="entity">unfold_tac</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">futile</span> <span class="keyword2"><span class="keyword">then</span></span>
                  <span class="main">(</span>warning <span class="inner_quoted">"Termination relation has sort constraints; termination proof is unlikely to be automatic or may even be impossible"</span><span class="main">;</span>
                   Seq.empty<span class="main">)</span>
                <span class="keyword2"><span class="keyword">else</span></span>
                  <span class="main">(</span>tracing <span class="inner_quoted">"Trying to re-use termination proof"</span><span class="main">;</span>
                   <span class="entity">tac</span> <span class="entity">st</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
            #&gt; Exn.get_res
            #&gt; the_default Seq.empty
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">simple_tac</span> ORELSE <span class="entity">smart_tac</span> ORELSE <span class="entity">fallback_tac</span> true
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">fallback_tac</span> false
  <span class="keyword2"><span class="keyword">in</span></span> SELECT_GOAL <span class="entity">tac</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/congruences.ML">
<div class="head">
<h1>File ‹congruences.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CONGRUENCES</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">rule</span> <span class="main">=</span>
    <span class="main">{</span>rule<span class="main">:</span> thm<span class="main">,</span>
     concl<span class="main">:</span> term<span class="main">,</span>
     prems<span class="main">:</span> term list<span class="main">,</span>
     proper<span class="main">:</span> bool<span class="main">}</span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ctx</span> <span class="main">=</span> <span class="main">(</span>string * typ<span class="main">)</span> list * term list
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">ctx_tree</span> <span class="main">=</span>
    <span class="entity">Tree</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>term * <span class="main">(</span>rule * <span class="main">(</span>ctx * ctx_tree<span class="main">)</span> list<span class="main">)</span> option<span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> export_term_ctx<span class="main">:</span> <span class="entity">ctx</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> import_rule<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="entity">rule</span>
  <span class="keyword1"><span class="keyword">val</span></span> import_term<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">rule</span> list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">ctx_tree</span>

  <span class="keyword1"><span class="keyword">val</span></span> fold_tree<span class="main">:</span>
    <span class="main">(</span>term <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span>
    <span class="main">(</span>term <span class="main">-&gt;</span> <span class="entity">rule</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">ctx</span> * 'a<span class="main">)</span> list <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span>
    <span class="entity">ctx_tree</span> <span class="main">-&gt;</span> 'a
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Congruences</span><span class="main">:</span> <span class="entity">CONGRUENCES</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">rule</span> <span class="main">=</span>
  <span class="main">{</span>rule<span class="main">:</span> thm<span class="main">,</span>
   concl<span class="main">:</span> term<span class="main">,</span>
   prems<span class="main">:</span> term list<span class="main">,</span>
   proper<span class="main">:</span> bool<span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ctx</span> <span class="main">=</span> <span class="main">(</span>string * typ<span class="main">)</span> list * term list

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">export_term_ctx</span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">)</span> <span class="main">=</span>
  fold_rev <span class="main">(</span>curry Logic.mk_implies<span class="main">)</span> <span class="entity">assumes</span>
  #&gt; fold_rev <span class="main">(</span>Logic.all o Free<span class="main">)</span> <span class="entity">fixes</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">ctx_tree</span> <span class="main">=</span>
  <span class="entity">Tree</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>term * <span class="main">(</span>rule * <span class="main">(</span>ctx * ctx_tree<span class="main">)</span> list<span class="main">)</span> option<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fold_tree</span> <span class="entity">atom</span> <span class="entity">cong</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">go</span> <span class="main">(</span><span class="entity">Tree</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> NONE<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">atom</span> <span class="entity">t</span>
      <span class="main">|</span> <span class="entity">go</span> <span class="main">(</span><span class="entity">Tree</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> SOME <span class="main">(</span><span class="entity">r</span><span class="main">,</span> <span class="entity">ctxs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">cong</span> <span class="entity">t</span> <span class="entity">r</span> <span class="main">(</span>map <span class="main">(</span>apsnd <span class="entity">go</span><span class="main">)</span> <span class="entity">ctxs</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">go</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_import_rule</span> <span class="main">{</span><span class="entity">check</span><span class="main">:</span> bool<span class="main">,</span> <span class="entity">proper</span><span class="main">:</span> bool<span class="main">}</span> <span class="entity">ctxt</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> Thm.concl_of <span class="entity">thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Logic.dest_equals <span class="entity">concl</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span> Thm.prems_of <span class="entity">thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rule</span> <span class="main">=</span> <span class="main">{</span>rule <span class="main">=</span> <span class="entity">thm</span><span class="main">,</span> concl <span class="main">=</span> <span class="entity">concl</span><span class="main">,</span> prems <span class="main">=</span> <span class="entity">prems</span><span class="main">,</span> proper <span class="main">=</span> <span class="entity">proper</span><span class="main">}</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">check</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">f_lhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">lhs</span> |&gt;&gt; dest_Const
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">r_lhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">rhs</span> |&gt;&gt; dest_Const
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">f_lhs</span> &lt;&gt; <span class="entity">r_lhs</span> <span class="keyword2"><span class="keyword">then</span></span>
          error <span class="main">(</span><span class="inner_quoted">"invalid cong rule "</span> ^ Syntax.string_of_term <span class="entity">ctxt</span> <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="entity">rule</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">rule</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">import_rule</span> <span class="main">=</span> <span class="entity">raw_import_rule</span> <span class="main">{</span>check <span class="main">=</span> true<span class="main">,</span> proper <span class="main">=</span> true<span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_cong</span> <span class="entity">n</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> &lt;= <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> cong<span class="antiquote">}</span></span></span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">mk_cong</span> <span class="main">(</span><span class="entity">n</span> - <span class="inner_numeral">1</span><span class="main">)</span> OF <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> cong<span class="antiquote">}</span></span></span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cong_rule</span> <span class="entity">n</span> <span class="main">=</span>
  <span class="entity">raw_import_rule</span> <span class="main">{</span>check <span class="main">=</span> false<span class="main">,</span> proper <span class="main">=</span> false<span class="main">}</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">mk_cong</span> <span class="entity">n</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eq_reflection<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ext_rule</span> <span class="main">=</span>
  <span class="entity">raw_import_rule</span> <span class="main">{</span>check <span class="main">=</span> false<span class="main">,</span> proper <span class="main">=</span> false<span class="main">}</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> ext<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eq_reflection<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">import_term</span> <span class="entity">ctxt</span> <span class="entity">rules</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_of</span> <span class="main">=</span> fst o <span class="entity">HOLogic.dest_eq</span> o <span class="entity">HOLogic.dest_Trueprop</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">go</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="comment1">(* FIXME eventually, this should be the arity of fst (strip_comb t) *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arity</span> <span class="main">=</span> length <span class="main">(</span>snd <span class="main">(</span>strip_comb <span class="entity">t</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rules</span> <span class="main">=</span> <span class="entity">rules</span> @ <span class="main">[</span><span class="entity">cong_rule</span> <span class="entity">arity</span><span class="main">,</span> <span class="entity">ext_rule</span><span class="main">]</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_branch</span> <span class="entity">subst</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">params</span><span class="main">,</span> <span class="entity">impl</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.focus NONE <span class="entity">t</span> <span class="entity">ctxt</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">assms</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span> Logic.strip_horn <span class="entity">impl</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assms</span> <span class="main">=</span> map <span class="main">(</span>Envir.subst_term <span class="entity">subst</span><span class="main">)</span> <span class="entity">assms</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">params</span><span class="main">,</span> <span class="entity">assms</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">lhs_of</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match</span> <span class="entity">concl</span> <span class="main">=</span>
          try <span class="main">(</span>Pattern.match <span class="entity">thy</span> <span class="main">(</span><span class="entity">concl</span><span class="main">,</span> Logic.mk_equals <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Vartab.empty<span class="main">,</span> Vartab.empty<span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_rule</span> <span class="main">(</span><span class="entity">rule</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">concl</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">match</span> <span class="entity">concl</span> <span class="keyword2"><span class="keyword">of</span></span>
            NONE <span class="main">=&gt;</span> NONE
          <span class="main">|</span> SOME <span class="entity">subst</span> <span class="main">=&gt;</span>
              SOME <span class="main">(</span><span class="entity">rule</span><span class="main">,</span> map <span class="main">(</span><span class="entity">mk_branch</span> <span class="entity">subst</span> o Envir.beta_norm o Envir.subst_term <span class="entity">subst</span><span class="main">)</span> <span class="entity">prems</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_atom</span> <span class="main">=</span> is_Const <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> is_Free <span class="entity">t</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_atom</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="entity">Tree</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> NONE<span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">case</span></span> get_first <span class="entity">apply_rule</span> <span class="entity">rules</span> <span class="keyword2"><span class="keyword">of</span></span>
            NONE <span class="main">=&gt;</span> error <span class="inner_quoted">"this shouldn't happen"</span>
          <span class="main">|</span> SOME <span class="main">(</span><span class="entity">rule</span><span class="main">,</span> <span class="entity">branches</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Tree</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> SOME <span class="main">(</span><span class="entity">rule</span><span class="main">,</span> map <span class="main">(</span>apsnd <span class="main">(</span>uncurry <span class="entity">go</span><span class="main">)</span><span class="main">)</span> <span class="entity">branches</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">go</span> <span class="entity">ctxt</span> <span class="entity">t</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/side_conditions.ML">
<div class="head">
<h1>File ‹side_conditions.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">SIDE_CONDITIONS</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">predicate</span> <span class="main">=</span>
    <span class="main">{</span>f<span class="main">:</span> term<span class="main">,</span>
     index<span class="main">:</span> int<span class="main">,</span>
     inductive<span class="main">:</span> <span class="entity">Inductive.result</span><span class="main">,</span>
     alt<span class="main">:</span> thm option<span class="main">}</span>

  <span class="keyword1"><span class="keyword">val</span></span> transform_predicate<span class="main">:</span> morphism <span class="main">-&gt;</span> <span class="entity">predicate</span> <span class="main">-&gt;</span> <span class="entity">predicate</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_predicate<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">predicate</span> option
  <span class="keyword1"><span class="keyword">val</span></span> set_alt<span class="main">:</span> term <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> Context.generic <span class="main">-&gt;</span> Context.generic
  <span class="keyword1"><span class="keyword">val</span></span> is_total<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool

  <span class="keyword1"><span class="keyword">val</span></span> mk_side<span class="main">:</span> thm list <span class="main">-&gt;</span> thm list option <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">predicate</span> list * local_theory

  <span class="keyword1"><span class="keyword">val</span></span> time_limit<span class="main">:</span> real Config.T
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Side_Conditions</span> <span class="main">:</span> <span class="entity">SIDE_CONDITIONS</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Dict_Construction_Util

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">time_limit</span> <span class="main">=</span> <span class="entity">Attrib.setup_config_real</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> side_conditions_time_limit<span class="antiquote">}</span></span></span> <span class="main">(</span>K <span class="inner_numeral">5.0</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inductive_config</span> <span class="main">=</span>
  <span class="main">{</span>quiet_mode <span class="main">=</span> true<span class="main">,</span> verbose <span class="main">=</span> true<span class="main">,</span> alt_name <span class="main">=</span> Binding.empty<span class="main">,</span> coind <span class="main">=</span> false<span class="main">,</span>
    no_elim <span class="main">=</span> false<span class="main">,</span> no_ind <span class="main">=</span> false<span class="main">,</span> skip_mono <span class="main">=</span> false<span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">predicate</span> <span class="main">=</span>
  <span class="main">{</span>f<span class="main">:</span> term<span class="main">,</span>
   index<span class="main">:</span> int<span class="main">,</span>
   inductive<span class="main">:</span> <span class="entity">Inductive.result</span><span class="main">,</span>
   alt<span class="main">:</span> thm option<span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transform_predicate</span> <span class="entity">phi</span> <span class="main">{</span><span class="entity">f</span><span class="main">,</span> <span class="entity">index</span><span class="main">,</span> <span class="entity">inductive</span><span class="main">,</span> <span class="entity">alt</span><span class="main">}</span> <span class="main">=</span>
  <span class="main">{</span>f <span class="main">=</span> Morphism.term <span class="entity">phi</span> <span class="entity">f</span><span class="main">,</span>
   index <span class="main">=</span> <span class="entity">index</span><span class="main">,</span>
   inductive <span class="main">=</span> <span class="entity">Inductive.transform_result</span> <span class="entity">phi</span> <span class="entity">inductive</span><span class="main">,</span>
   alt <span class="main">=</span> Option.map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">alt</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Predicates</span> <span class="main">=</span> Generic_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">predicate</span> Item_Net.T
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Item_Net.init <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv o apply2 <span class="main">#</span>f<span class="main">)</span> <span class="main">(</span>single o <span class="main">#</span>f<span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Item_Net.merge
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I
<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_predicate</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
  Item_Net.retrieve <span class="main">(</span>Predicates.get <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">t</span>
  |&gt; try hd
  |&gt; Option.map <span class="main">(</span><span class="entity">transform_predicate</span> <span class="main">(</span>Morphism.transfer_morphism <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_total</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> SOME <span class="main">{</span>alt <span class="main">=</span> SOME <span class="entity">alt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">get_predicate</span> <span class="entity">ctxt</span> <span class="entity">t</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Logic.dest_equals <span class="main">(</span>Thm.prop_of <span class="entity">alt</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">True</span><span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* must be of the form [f_side ?x ?y = True] *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">set_alt</span> <span class="entity">t</span> <span class="entity">thm</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">safe_mk_meta_eq</span> <span class="entity">thm</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Logic.dest_equals <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">f</span><span class="main">,</span> <span class="entity">index</span><span class="main">,</span> <span class="entity">inductive</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> hd <span class="main">(</span>Item_Net.retrieve <span class="main">(</span>Predicates.get <span class="entity">context</span><span class="main">)</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pred</span> <span class="main">=</span> nth <span class="main">(</span><span class="main">#</span>preds <span class="entity">inductive</span><span class="main">)</span> <span class="entity">index</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg_typs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> strip_type <span class="main">(</span>fastype_of <span class="entity">pred</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span>
      Name.invent_names <span class="main">(</span>Variable.names_of <span class="main">(</span>Context.proof_of <span class="entity">context</span><span class="main">)</span><span class="main">)</span> <span class="inner_quoted">"x"</span> <span class="entity">arg_typs</span>
      |&gt; map Free
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_pred</span> <span class="main">=</span> <span class="main">{</span>f <span class="main">=</span> <span class="entity">f</span><span class="main">,</span> index <span class="main">=</span> <span class="entity">index</span><span class="main">,</span> inductive <span class="main">=</span> <span class="entity">inductive</span><span class="main">,</span> alt <span class="main">=</span> SOME <span class="entity">thm</span><span class="main">}</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> Pattern.matches <span class="main">(</span>Context.theory_of <span class="entity">context</span><span class="main">)</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> list_comb <span class="main">(</span><span class="entity">pred</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      Predicates.map <span class="main">(</span>Item_Net.update <span class="entity">new_pred</span><span class="main">)</span> <span class="entity">context</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      error <span class="inner_quoted">"Alternative is not fully general"</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_simps</span> <span class="entity">ctxt</span> <span class="entity">clear</span> <span class="entity">thms</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span>
      Context_Position.not_really <span class="entity">ctxt</span>
      |&gt; <span class="entity">clear</span> ? put_simpset <span class="entity">HOL_ss</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">conv_result</span> <span class="main">(</span><span class="entity">Simplifier.asm_full_rewrite</span> <span class="main">(</span><span class="entity">ctxt'</span> addsimps <span class="entity">thms</span><span class="main">)</span><span class="main">)</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_alts</span> <span class="entity">ctxt</span> <span class="main">=</span>
  Item_Net.content <span class="main">(</span>Predicates.get <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
  |&gt; map <span class="main">#</span>alt
  |&gt; <span class="entity">cat_options</span>
  |&gt; <span class="entity">apply_simps</span> <span class="entity">ctxt</span> true

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_intros</span> <span class="entity">ctxt</span> <span class="main">=</span>
  Item_Net.content <span class="main">(</span>Predicates.get <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
  |&gt; map <span class="main">#</span>inductive
  |&gt; maps <span class="main">#</span>intrs
  |&gt; <span class="entity">apply_simps</span> <span class="entity">ctxt</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_head</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">dest_head</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Long_Name.base_name <span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sideN</span> <span class="main">=</span> <span class="inner_quoted">"_side"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_side</span> <span class="entity">simps</span> <span class="entity">inducts</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">simps</span><span class="main">)</span><span class="main">,</span> <span class="entity">names</span><span class="main">)</span> <span class="main">=</span>
      Variable.import true <span class="entity">simps</span> <span class="entity">lthy</span>
      ||&gt; Variable.names_of

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhss</span><span class="main">,</span> <span class="entity">rhss</span><span class="main">)</span> <span class="main">=</span>
      map <span class="main">(</span><span class="entity">HOLogic.dest_eq</span> o <span class="entity">HOLogic.dest_Trueprop</span> o Thm.prop_of<span class="main">)</span> <span class="entity">simps</span>
      |&gt; split_list

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">heads</span> <span class="main">=</span> map <span class="main">(</span>`<span class="entity">dest_head</span> o <span class="main">(</span>fst o strip_comb<span class="main">)</span><span class="main">)</span> <span class="entity">lhss</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_typ</span> <span class="entity">t</span> <span class="main">=</span> binder_types <span class="entity">t</span> ---&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sides</span> <span class="main">=</span> map <span class="main">(</span>apfst <span class="main">(</span>suffix <span class="entity">sideN</span><span class="main">)</span> o apsnd <span class="entity">mk_typ</span> o fst<span class="main">)</span> <span class="entity">heads</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_pred_app</span> <span class="entity">pred</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pred_typs</span> <span class="main">=</span> binder_types <span class="main">(</span>fastype_of <span class="entity">pred</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exp_param_count</span> <span class="main">=</span> length <span class="entity">pred_typs</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f_typs</span> <span class="main">=</span> take <span class="entity">exp_param_count</span> <span class="main">(</span>binder_types <span class="main">(</span>fastype_of <span class="entity">f</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pred'</span> <span class="main">=</span>
          Envir.subst_term_types <span class="main">(</span>fold <span class="main">(</span>Sign.typ_match <span class="entity">thy</span><span class="main">)</span> <span class="main">(</span><span class="entity">pred_typs</span> ~~ <span class="entity">f_typs</span><span class="main">)</span> Vartab.empty<span class="main">)</span> <span class="entity">pred</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">diff</span> <span class="main">=</span> <span class="entity">exp_param_count</span> - length <span class="entity">xs</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">diff</span> &gt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bounds</span> <span class="main">=</span> map Bound <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="entity">diff</span> - <span class="inner_numeral">1</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alls</span> <span class="main">=</span> map <span class="main">(</span>K <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="entity">diff</span> - <span class="inner_numeral">1</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> Logic.list_all <span class="main">(</span><span class="entity">alls</span><span class="main">,</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">pred'</span><span class="main">,</span> <span class="entity">xs</span> @ <span class="entity">bounds</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">prop</span> <span class="comment1">(* fishy *)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">pred'</span><span class="main">,</span> take <span class="entity">exp_param_count</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_cond</span> <span class="entity">f</span> <span class="entity">xs</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_Abs</span> <span class="entity">f</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="comment1">(* do not look this up in the Item_Net, it'll only end in tears *)</span>
        NONE
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_predicate</span> <span class="entity">lthy</span> <span class="entity">f</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span>
            <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> find_index <span class="main">(</span>equal <span class="entity">f</span> o snd<span class="main">)</span> <span class="entity">heads</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="inner_numeral">~1</span> <span class="main">=&gt;</span> NONE <span class="comment1">(* in this case we don't know anything about f; it may be a constructor *)</span>
            <span class="main">|</span> <span class="entity">index</span> <span class="main">=&gt;</span> SOME <span class="main">(</span><span class="entity">mk_pred_app</span> <span class="main">(</span>Free <span class="main">(</span>nth <span class="entity">sides</span> <span class="entity">index</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> SOME <span class="main">{</span><span class="entity">index</span><span class="main">,</span> inductive <span class="main">=</span> <span class="main">{</span><span class="entity">preds</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
            SOME <span class="main">(</span><span class="entity">mk_pred_app</span> <span class="main">(</span>nth <span class="entity">preds</span> <span class="entity">index</span><span class="main">)</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_atom</span> <span class="entity">f</span> <span class="main">=</span>
      <span class="comment1">(* in this branch, if f has a non-const-true predicate, it is most likely that there is a
         missing congruence rule *)</span>
      the_list <span class="main">(</span><span class="entity">mk_cond</span> <span class="entity">f</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_cong</span> <span class="entity">t</span> <span class="main">_</span> <span class="entity">cs</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cs'</span> <span class="main">=</span> maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ctx</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span> <span class="main">=&gt;</span> map <span class="main">(</span><span class="entity">Congruences.export_term_ctx</span> <span class="entity">ctx</span><span class="main">)</span> <span class="entity">ts</span><span class="main">)</span> <span class="main">(</span>tl <span class="entity">cs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">t</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cs</span> <span class="main">=</span> <span class="entity">mk_cond</span> <span class="entity">f</span> <span class="entity">xs</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        the_list <span class="entity">cs</span> @ <span class="entity">cs'</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rules</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">Congruences.import_rule</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">(</span><span class="entity">Function.get_congs</span> <span class="entity">lthy</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">premss</span> <span class="main">=</span>
      map <span class="main">(</span><span class="entity">Congruences.import_term</span> <span class="entity">lthy</span> <span class="entity">rules</span><span class="main">)</span> <span class="entity">rhss</span>
      |&gt; map <span class="main">(</span><span class="entity">Congruences.fold_tree</span> <span class="entity">mk_atom</span> <span class="entity">mk_cong</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concls</span> <span class="main">=</span>
      map Free <span class="entity">sides</span> ~~ map <span class="main">(</span>snd o strip_comb<span class="main">)</span> <span class="entity">lhss</span>
      |&gt; map <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> o list_comb<span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">time</span> <span class="main">=</span> Time.fromReal <span class="main">(</span>Config.get <span class="entity">lthy</span> <span class="entity">time_limit</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intros</span> <span class="main">=</span>
      map Logic.list_implies <span class="main">(</span><span class="entity">premss</span> ~~ <span class="entity">concls</span><span class="main">)</span>
      |&gt; Syntax.check_terms <span class="entity">lthy</span>
      |&gt; map <span class="main">(</span><span class="entity">apply_alts</span> <span class="entity">lthy</span> o Thm.cterm_of <span class="entity">lthy</span><span class="main">)</span>
      |&gt; Par_List.map <span class="main">(</span><span class="entity">with_timeout</span> <span class="entity">time</span> <span class="main">(</span><span class="entity">apply_intros</span> <span class="entity">lthy</span> o Thm.cterm_of <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inds</span> <span class="main">=</span> map <span class="main">(</span>rpair NoSyn o apfst Binding.name<span class="main">)</span> <span class="main">(</span>distinct <span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span> <span class="entity">sides</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">result</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">Inductive.add_inductive</span> <span class="entity">inductive_config</span> <span class="entity">inds</span> <span class="main">[</span><span class="main">]</span>
        <span class="main">(</span>map <span class="main">(</span>pair <span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">intros</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_impartial_goal</span> <span class="entity">pred</span> <span class="entity">names</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param_typs</span> <span class="main">=</span> binder_types <span class="main">(</span>fastype_of <span class="entity">pred</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">args</span><span class="main">,</span> <span class="entity">names</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">typ</span> <span class="main">=&gt;</span> apfst <span class="main">(</span>Free o rpair <span class="entity">typ</span><span class="main">)</span> o Name.variant <span class="inner_quoted">"x"</span><span class="main">)</span> <span class="entity">param_typs</span> <span class="entity">names</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">pred</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">goal</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">,</span> <span class="entity">names</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">props</span><span class="main">,</span> <span class="entity">instss</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
      fold_map <span class="entity">mk_impartial_goal</span> <span class="main">(</span><span class="main">#</span>preds <span class="entity">result</span><span class="main">)</span> <span class="entity">names</span>
      |&gt;&gt; split_list
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees</span> <span class="main">=</span> flat <span class="entity">instss</span> |&gt; map <span class="main">(</span>fst o dest_Free<span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tactic</span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_context</span> <span class="main">=</span>
          put_simpset <span class="entity">HOL_ss</span> <span class="main">(</span>Context_Position.not_really <span class="entity">ctxt</span><span class="main">)</span> addsimps <span class="main">(</span><span class="main">#</span>intrs <span class="entity">result</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
       <span class="entity">maybe_induct_tac</span> <span class="entity">inducts</span> <span class="entity">instss</span> <span class="main">[</span><span class="main">]</span> <span class="entity">ctxt</span> THEN
          <span class="entity">PARALLEL_ALLGOALS</span> <span class="main">(</span><span class="entity">Nitpick_Util.DETERM_TIMEOUT</span> <span class="entity">time</span> o <span class="entity">asm_full_simp_tac</span> <span class="entity">simp_context</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">alts</span> <span class="main">=</span>
      try <span class="main">(</span>Goal.prove_common <span class="entity">lthy'</span> NONE <span class="entity">frees</span> <span class="main">[</span><span class="main">]</span> <span class="entity">props</span><span class="main">)</span> <span class="entity">tactic</span>
      |&gt; Option.map <span class="main">(</span>map <span class="main">(</span><span class="entity">mk_eq</span> o Thm.close_derivation <span class="antiquoted"><span class="operator"><span class="entity">⌂</span></span></span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> is_none <span class="entity">alts</span> <span class="keyword2"><span class="keyword">then</span></span>
        Pretty.str <span class="inner_quoted">"Potentially underspecified function(s): "</span> ::
          Pretty.commas <span class="main">(</span>map <span class="main">(</span>Syntax.pretty_term <span class="entity">lthy</span> o snd<span class="main">)</span> <span class="main">(</span>distinct <span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span> <span class="entity">heads</span><span class="main">)</span><span class="main">)</span>
        |&gt; Pretty.block
        |&gt; Pretty.string_of
        |&gt; warning
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="main">(</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_pred</span> <span class="entity">n</span> <span class="entity">t</span> <span class="main">=</span>
      <span class="main">{</span>f <span class="main">=</span> <span class="entity">t</span><span class="main">,</span> index <span class="main">=</span> <span class="entity">n</span><span class="main">,</span> inductive <span class="main">=</span> <span class="entity">result</span><span class="main">,</span>
       alt <span class="main">=</span> Option.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">alts</span> <span class="main">=&gt;</span> nth <span class="entity">alts</span> <span class="entity">n</span><span class="main">)</span> <span class="entity">alts</span><span class="main">}</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">preds</span> <span class="main">=</span> map_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_pred</span> <span class="entity">n</span> <span class="entity">t</span><span class="main">)</span> <span class="main">(</span>distinct <span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span> <span class="entity">heads</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy''</span> <span class="main">=</span>
      Local_Theory.declaration <span class="main">{</span>pervasive <span class="main">=</span> false<span class="main">,</span> syntax <span class="main">=</span> false<span class="main">}</span>
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">phi</span> <span class="main">=&gt;</span> fold <span class="main">(</span>Predicates.map o Item_Net.update o <span class="entity">transform_predicate</span> <span class="entity">phi</span><span class="main">)</span> <span class="entity">preds</span><span class="main">)</span> <span class="entity">lthy'</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">preds</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/class_graph.ML">
<div class="head">
<h1>File ‹class_graph.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CLASS_GRAPH</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">selector</span> <span class="main">=</span> typ <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">node</span> <span class="main">=</span>
    <span class="main">{</span>class<span class="main">:</span> string<span class="main">,</span>
     qname<span class="main">:</span> string<span class="main">,</span>
     selectors<span class="main">:</span> <span class="entity">selector</span> Symtab.table<span class="main">,</span>
     make<span class="main">:</span> typ <span class="main">-&gt;</span> term<span class="main">,</span>
     data_thms<span class="main">:</span> thm list<span class="main">,</span>
     cert<span class="main">:</span> typ <span class="main">-&gt;</span> term<span class="main">,</span>
     cert_thms<span class="main">:</span> thm * thm * thm list<span class="main">}</span>

  <span class="keyword1"><span class="keyword">val</span></span> dict_typ<span class="main">:</span> <span class="entity">node</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> typ

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">edge</span> <span class="main">=</span>
    <span class="main">{</span>super_selector<span class="main">:</span> <span class="entity">selector</span><span class="main">,</span>
     subclass<span class="main">:</span> thm<span class="main">}</span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">path</span> <span class="main">=</span> <span class="entity">edge</span> list

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ev</span>

  <span class="keyword1"><span class="keyword">val</span></span> class_of<span class="main">:</span> <span class="entity">ev</span> <span class="main">-&gt;</span> class
  <span class="keyword1"><span class="keyword">val</span></span> node_of<span class="main">:</span> <span class="entity">ev</span> <span class="main">-&gt;</span> <span class="entity">node</span>
  <span class="keyword1"><span class="keyword">val</span></span> parents_of<span class="main">:</span> <span class="entity">ev</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">edge</span> * <span class="entity">ev</span><span class="main">)</span> Symtab.table

  <span class="keyword1"><span class="keyword">val</span></span> find_path'<span class="main">:</span> <span class="entity">ev</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">ev</span> <span class="main">-&gt;</span> 'a option<span class="main">)</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">path</span> * 'a<span class="main">)</span> option
  <span class="keyword1"><span class="keyword">val</span></span> find_path<span class="main">:</span> <span class="entity">ev</span> <span class="main">-&gt;</span> class <span class="main">-&gt;</span> <span class="entity">path</span> option
  <span class="keyword1"><span class="keyword">val</span></span> fold_path<span class="main">:</span> <span class="entity">path</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> ensure_class<span class="main">:</span> class <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">ev</span> * local_theory<span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> edges<span class="main">:</span> local_theory <span class="main">-&gt;</span> class <span class="main">-&gt;</span> <span class="entity">edge</span> Symtab.table option
  <span class="keyword1"><span class="keyword">val</span></span> node<span class="main">:</span> local_theory <span class="main">-&gt;</span> class <span class="main">-&gt;</span> <span class="entity">node</span> option
  <span class="keyword1"><span class="keyword">val</span></span> all_edges<span class="main">:</span> local_theory <span class="main">-&gt;</span> <span class="entity">edge</span> Symreltab.table
  <span class="keyword1"><span class="keyword">val</span></span> all_nodes<span class="main">:</span> local_theory <span class="main">-&gt;</span> <span class="entity">node</span> Symtab.table

  <span class="keyword1"><span class="keyword">val</span></span> pretty_ev<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">ev</span> <span class="main">-&gt;</span> Pretty.T

  <span class="comment1">(* utilities *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mangle<span class="main">:</span> string <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> param_sorts<span class="main">:</span> string <span class="main">-&gt;</span> class <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> class list list
  <span class="keyword1"><span class="keyword">val</span></span> super_classes<span class="main">:</span> class <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> string list
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Class_Graph</span><span class="main">:</span> <span class="entity">CLASS_GRAPH</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Dict_Construction_Util

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mangle</span> <span class="main">=</span>
  translate_string <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">"."</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="inner_quoted">"_"</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">"_"</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="inner_quoted">"__"</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">x</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">param_sorts</span> <span class="entity">tyco</span> <span class="entity">class</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">algebra</span> <span class="main">=</span> Sign.classes_of <span class="entity">thy</span> <span class="keyword2"><span class="keyword">in</span></span>
    Sorts.mg_domain <span class="entity">algebra</span> <span class="entity">tyco</span> <span class="main">[</span><span class="entity">class</span><span class="main">]</span> |&gt; map <span class="main">(</span>filter <span class="main">(</span><span class="entity">Class.is_class</span> <span class="entity">thy</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">super_classes</span> <span class="entity">class</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">algebra</span> <span class="main">=</span> Sign.classes_of <span class="entity">thy</span> <span class="keyword2"><span class="keyword">in</span></span>
    Sorts.super_classes <span class="entity">algebra</span> <span class="entity">class</span> |&gt;
      Sorts.minimize_sort <span class="entity">algebra</span> |&gt;
      filter <span class="main">(</span><span class="entity">Class.is_class</span> <span class="entity">thy</span><span class="main">)</span> |&gt;
      sort fast_string_ord
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">selector</span> <span class="main">=</span> typ <span class="main">-&gt;</span> term

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">node</span> <span class="main">=</span>
  <span class="main">{</span>class<span class="main">:</span> string<span class="main">,</span>
   qname<span class="main">:</span> string<span class="main">,</span>
   selectors<span class="main">:</span> <span class="entity">selector</span> Symtab.table<span class="main">,</span>
   make<span class="main">:</span> typ <span class="main">-&gt;</span> term<span class="main">,</span>
   data_thms<span class="main">:</span> thm list<span class="main">,</span>
   cert<span class="main">:</span> typ <span class="main">-&gt;</span> term<span class="main">,</span>
   cert_thms<span class="main">:</span> thm * thm * thm list<span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">edge</span> <span class="main">=</span>
  <span class="main">{</span>super_selector<span class="main">:</span> <span class="entity">selector</span><span class="main">,</span>
   subclass<span class="main">:</span> thm<span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">path</span> <span class="main">=</span> <span class="entity">edge</span> list

<span class="keyword1"><span class="keyword">abstype</span></span> <span class="entity">ev</span> <span class="main">=</span> <span class="entity">Evidence</span> <span class="keyword2"><span class="keyword">of</span></span> class * node * <span class="main">(</span>edge * ev<span class="main">)</span> Symtab.table
<span class="keyword2"><span class="keyword">with</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">class_of</span> <span class="main">(</span><span class="entity">Evidence</span> <span class="main">(</span><span class="entity">class</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">class</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">node_of</span> <span class="main">(</span><span class="entity">Evidence</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">node</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">node</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">parents_of</span> <span class="main">(</span><span class="entity">Evidence</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">tab</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">tab</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_evidence</span> <span class="entity">class</span> <span class="entity">node</span> <span class="entity">tab</span> <span class="main">=</span> <span class="entity">Evidence</span> <span class="main">(</span><span class="entity">class</span><span class="main">,</span> <span class="entity">node</span><span class="main">,</span> <span class="entity">tab</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_path'</span> <span class="entity">ev</span> <span class="entity">is_goal</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">is_goal</span> <span class="entity">ev</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="entity">a</span> <span class="main">=&gt;</span>
      SOME <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">a</span><span class="main">)</span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">f</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">edge</span><span class="main">,</span> <span class="entity">ev</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Option.map <span class="main">(</span>apfst <span class="main">(</span>cons <span class="entity">edge</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">find_path'</span> <span class="entity">ev</span> <span class="entity">is_goal</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> Symtab.get_first <span class="entity">f</span> <span class="main">(</span><span class="entity">parents_of</span> <span class="entity">ev</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_path</span> <span class="entity">ev</span> <span class="entity">goal</span> <span class="main">=</span>
  <span class="entity">find_path'</span> <span class="entity">ev</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ev</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">class_of</span> <span class="entity">ev</span> <span class="main">=</span> <span class="entity">goal</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> NONE<span class="main">)</span> |&gt; Option.map fst

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_ev</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Evidence</span> <span class="main">(</span><span class="entity">class</span><span class="main">,</span> <span class="main">{</span><span class="entity">qname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">tab</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted"><span class="tfree">'a</span></span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_super</span> <span class="main">(</span><span class="main">{</span><span class="entity">super_selector</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">super_ev</span><span class="main">)</span> <span class="main">=</span> Pretty.block
      <span class="main">[</span>Pretty.str <span class="inner_quoted">"selector:"</span><span class="main">,</span>
       Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span>
       Syntax.pretty_term <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">super_selector</span> <span class="entity">typ</span><span class="main">)</span><span class="main">,</span>
       Pretty.fbrk<span class="main">,</span>
       <span class="entity">pretty_ev</span> <span class="entity">ctxt</span> <span class="entity">super_ev</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">supers</span> <span class="main">=</span> Symtab.dest <span class="entity">tab</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">super</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_super</span> <span class="entity">super</span><span class="main">)</span>
      |&gt; Pretty.big_list <span class="inner_quoted">"super classes"</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Pretty.block
      <span class="main">[</span>Pretty.str <span class="inner_quoted">"Evidence for "</span><span class="main">,</span>
       Syntax.pretty_sort <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">class</span><span class="main">]</span><span class="main">,</span>
       Pretty.str <span class="inner_quoted">": "</span><span class="main">,</span>
       Syntax.pretty_typ <span class="entity">ctxt</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">qname</span><span class="main">,</span> <span class="main">[</span><span class="entity">typ</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
       Pretty.str <span class="main">(</span><span class="inner_quoted">" (qname = "</span> ^ <span class="entity">qname</span> ^ <span class="inner_quoted">")"</span><span class="main">)</span><span class="main">,</span>
       Pretty.fbrk<span class="main">,</span>
       <span class="entity">supers</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Classes</span> <span class="main">=</span> Generic_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">(</span><span class="entity">edge</span> Symtab.table * <span class="entity">node</span><span class="main">)</span> Symtab.table
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> Symtab.is_empty <span class="entity">t1</span> <span class="keyword1"><span class="keyword">andalso</span></span> Symtab.is_empty <span class="entity">t2</span> <span class="keyword2"><span class="keyword">then</span></span>
      Symtab.empty
    <span class="keyword2"><span class="keyword">else</span></span>
      error <span class="inner_quoted">"merging not supported"</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I
<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">node</span> <span class="entity">lthy</span> <span class="entity">class</span> <span class="main">=</span>
  Symtab.lookup <span class="main">(</span>Classes.get <span class="main">(</span>Context.Proof <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="entity">class</span> |&gt; Option.map snd

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">edges</span> <span class="entity">lthy</span> <span class="entity">class</span> <span class="main">=</span>
  Symtab.lookup <span class="main">(</span>Classes.get <span class="main">(</span>Context.Proof <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="entity">class</span> |&gt; Option.map fst

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_nodes</span> <span class="main">=</span>
  Context.Proof #&gt; Classes.get #&gt; Symtab.map <span class="main">(</span>K snd<span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_edges</span> <span class="main">=</span>
  Context.Proof #&gt; Classes.get #&gt; Symtab.map <span class="main">(</span>K fst<span class="main">)</span> #&gt; <span class="entity">symreltab_of_symtab</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dict_typ</span> <span class="main">{</span><span class="entity">qname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">typ</span> <span class="main">=</span>
  Type <span class="main">(</span><span class="entity">qname</span><span class="main">,</span> <span class="main">[</span><span class="entity">typ</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fold_path</span> <span class="entity">path</span> <span class="entity">typ</span> <span class="main">=</span>
  fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>super_selector <span class="main">=</span> <span class="entity">s</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">acc</span> <span class="main">=&gt;</span> <span class="entity">s</span> <span class="entity">typ</span> $ <span class="entity">acc</span><span class="main">)</span> <span class="entity">path</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_super_selector'</span> <span class="entity">qualified</span> <span class="entity">qname</span> <span class="entity">super_ev</span> <span class="entity">typ</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>class <span class="main">=</span> <span class="entity">super_class</span><span class="main">,</span> qname <span class="main">=</span> <span class="entity">super_qname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">node_of</span> <span class="entity">super_ev</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_name</span> <span class="main">=</span> <span class="entity">mangle</span> <span class="entity">super_class</span> ^ <span class="inner_quoted">"__super"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">qualified</span> <span class="keyword2"><span class="keyword">then</span></span> Long_Name.append <span class="entity">qname</span> <span class="entity">raw_name</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">raw_name</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> Type <span class="main">(</span><span class="entity">qname</span><span class="main">,</span> <span class="main">[</span><span class="entity">typ</span><span class="main">]</span><span class="main">)</span> --&gt; Type <span class="main">(</span><span class="entity">super_qname</span><span class="main">,</span> <span class="main">[</span><span class="entity">typ</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_node</span> <span class="entity">class</span> <span class="entity">info</span> <span class="entity">super_evs</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_info</span> <span class="entity">ctxt</span> <span class="main">=</span>
      Pretty.block <span class="main">[</span>Pretty.str <span class="inner_quoted">"Defining record for class "</span><span class="main">,</span> Syntax.pretty_sort <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">class</span><span class="main">]</span><span class="main">]</span>
      |&gt; Pretty.writeln

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="entity">mangle</span> <span class="entity">class</span> ^ <span class="inner_quoted">"__dict"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qname</span> <span class="main">=</span> Local_Theory.full_name <span class="entity">lthy</span> <span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tvar</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted"><span class="tfree">'a</span></span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ</span> <span class="main">=</span> Type <span class="main">(</span><span class="entity">qname</span><span class="main">,</span> <span class="main">[</span><span class="entity">tvar</span><span class="main">]</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_field</span> <span class="entity">name</span> <span class="entity">ftyp</span> <span class="main">=</span> <span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">,</span> <span class="entity">ftyp</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span> <span class="main">=</span> <span class="main">#</span>params <span class="entity">info</span>
      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">name'</span><span class="main">,</span> <span class="entity">ftyp</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ftyp'</span> <span class="main">=</span> typ_subst_atomic <span class="main">[</span><span class="main">(</span>TFree <span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="main">[</span><span class="entity">class</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted"><span class="tfree">'a</span></span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">]</span> <span class="entity">ftyp</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">field_name</span> <span class="main">=</span> <span class="entity">mangle</span> <span class="entity">name'</span> ^ <span class="inner_quoted">"__field"</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">field</span> <span class="main">=</span> <span class="entity">mk_field</span> <span class="entity">field_name</span> <span class="entity">ftyp'</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sel</span> <span class="entity">tvar'</span> <span class="main">=</span>
            Const <span class="main">(</span>Long_Name.append <span class="entity">qname</span> <span class="entity">field_name</span><span class="main">,</span>
                   typ_subst_atomic <span class="main">[</span><span class="main">(</span><span class="entity">tvar</span><span class="main">,</span> <span class="entity">tvar'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="entity">typ</span> --&gt; <span class="entity">ftyp'</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">field</span><span class="main">,</span> <span class="main">(</span><span class="entity">name'</span><span class="main">,</span> <span class="entity">sel</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fields</span><span class="main">,</span> <span class="entity">selectors</span><span class="main">)</span> <span class="main">=</span> split_list <span class="entity">params</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">super_params</span> <span class="main">=</span> Symtab.dest <span class="entity">super_evs</span> |&gt;
      map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">super_ev</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>cert <span class="main">=</span> <span class="entity">raw_super_cert</span><span class="main">,</span> qname <span class="main">=</span> <span class="entity">super_qname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">node_of</span> <span class="entity">super_ev</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">field_name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_super_selector'</span> false <span class="entity">qname</span> <span class="entity">super_ev</span> <span class="entity">tvar</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">field</span> <span class="main">=</span> <span class="entity">mk_field</span> <span class="entity">field_name</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">super_qname</span><span class="main">,</span> <span class="main">[</span><span class="entity">tvar</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sel</span> <span class="entity">typ</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">mk_super_selector'</span> true <span class="entity">qname</span> <span class="entity">super_ev</span> <span class="entity">typ</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">super_cert</span> <span class="entity">dict</span> <span class="main">=</span> <span class="entity">raw_super_cert</span> <span class="entity">tvar</span> $ <span class="main">(</span><span class="entity">sel</span> <span class="entity">tvar</span> $ <span class="entity">dict</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_edge</span> <span class="main">=</span> <span class="main">(</span><span class="entity">class_of</span> <span class="entity">super_ev</span><span class="main">,</span> <span class="entity">sel</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">field</span><span class="main">,</span> <span class="entity">raw_edge</span><span class="main">,</span> <span class="entity">super_cert</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">super_fields</span><span class="main">,</span> <span class="entity">raw_edges</span><span class="main">,</span> <span class="entity">super_certs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">split_list3</span> <span class="entity">super_params</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_fields</span> <span class="main">=</span> <span class="entity">super_fields</span> @ <span class="entity">fields</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">make</span> <span class="entity">typ'</span> <span class="main">=</span>
      Const <span class="main">(</span>Long_Name.append <span class="entity">qname</span> <span class="inner_quoted">"Dict"</span><span class="main">,</span>
        typ_subst_atomic <span class="main">[</span><span class="main">(</span><span class="entity">tvar</span><span class="main">,</span> <span class="entity">typ'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">all_fields</span> ---&gt; <span class="entity">typ</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert_name</span> <span class="main">=</span> <span class="entity">name</span> ^ <span class="inner_quoted">"__cert"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert_binding</span> <span class="main">=</span> Binding.name <span class="entity">cert_name</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert_body</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">local_param_eq</span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">sel</span><span class="main">)</span><span class="main">)</span> <span class="entity">dict</span> <span class="main">=</span>
          <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">sel</span> <span class="entity">tvar</span> $ <span class="entity">dict</span><span class="main">,</span> Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        map <span class="entity">local_param_eq</span> <span class="entity">params</span> @ <span class="entity">super_certs</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert_var_name</span> <span class="main">=</span> <span class="inner_quoted">"dict"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert_term</span> <span class="main">=</span>
      Abs <span class="main">(</span><span class="entity">cert_var_name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">,</span>
        List.foldr <span class="entity">HOLogic.mk_conj</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">True</span><span class="antiquote">}</span></span> <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span> <span class="entity">cert_body</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_thms</span> <span class="main">(</span><span class="entity">cert</span><span class="main">,</span> <span class="entity">cert_def</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">cert_var_name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span> Local_Defs.unfold_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">cert_def</span><span class="main">]</span> THEN <span class="entity">blast_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove</span> <span class="entity">prop</span> <span class="main">=</span>
          Goal.prove_future <span class="entity">lthy</span> <span class="main">[</span><span class="entity">cert_var_name</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">prop</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">tac</span> <span class="entity">context</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_dest_props</span> <span class="entity">raw_prop</span> <span class="main">=</span>
          <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">cert</span> $ <span class="entity">var</span><span class="main">)</span> <span class="entity">==&gt;</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">raw_prop</span> <span class="entity">var</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_intro_cond</span> <span class="entity">raw_prop</span> <span class="main">=</span>
          <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">raw_prop</span> <span class="entity">var</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dests</span> <span class="main">=</span>
          map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">raw_prop</span> <span class="main">=&gt;</span> <span class="entity">prove</span> <span class="main">(</span><span class="entity">mk_dest_props</span> <span class="entity">raw_prop</span><span class="main">)</span><span class="main">)</span> <span class="entity">cert_body</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intro</span> <span class="main">=</span>
          <span class="entity">prove</span> <span class="main">(</span>map <span class="entity">mk_intro_cond</span> <span class="entity">cert_body</span> <span class="entity">===&gt;</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">cert</span> $ <span class="entity">var</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">dests'</span><span class="main">,</span> <span class="main">(</span><span class="entity">intro'</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">note_thms</span> Binding.empty <span class="entity">dests</span> <span class="entity">lthy</span> ||&gt; <span class="entity">note_thm</span> Binding.empty <span class="entity">intro</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">param_dests</span><span class="main">,</span> <span class="entity">super_dests</span><span class="main">)</span> <span class="main">=</span> chop <span class="main">(</span>length <span class="entity">params</span><span class="main">)</span> <span class="entity">dests'</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_edges</span> <span class="entity">phi</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_edge</span> <span class="entity">thm</span> <span class="main">(</span><span class="entity">sc</span><span class="main">,</span> <span class="entity">sel</span><span class="main">)</span> <span class="main">=</span>
              <span class="main">(</span><span class="entity">sc</span><span class="main">,</span> <span class="main">{</span>super_selector <span class="main">=</span> <span class="entity">sel</span><span class="main">,</span> subclass <span class="main">=</span> Morphism.thm <span class="entity">phi</span> <span class="entity">thm</span><span class="main">}</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span> Symtab.make <span class="main">(</span>map2 <span class="entity">mk_edge</span> <span class="entity">super_dests</span> <span class="entity">raw_edges</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="main">(</span><span class="entity">param_dests</span><span class="main">,</span> <span class="entity">pre_edges</span><span class="main">,</span> <span class="entity">intro'</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">constructor</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> Binding.name <span class="inner_quoted">"Dict"</span><span class="main">)</span><span class="main">,</span> <span class="entity">all_fields</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">datatyp</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="main">(</span>NONE<span class="main">,</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted"><span class="tfree">'a</span></span><span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> Binding.name <span class="entity">name</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dtspec</span> <span class="main">=</span>
      <span class="main">(</span><span class="entity">Ctr_Sugar.default_ctr_options</span><span class="main">,</span>
       <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">datatyp</span><span class="main">,</span> <span class="main">[</span><span class="entity">constructor</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>Binding.empty<span class="main">,</span> Binding.empty<span class="main">,</span> Binding.empty<span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">raw_cert</span><span class="main">,</span> <span class="entity">raw_cert_def</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">param_dests</span><span class="main">,</span> <span class="entity">pre_edges</span><span class="main">,</span> <span class="entity">intro</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">lthy'</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lthy</span>
      |&gt; tap <span class="entity">print_info</span>
      |&gt; <span class="entity">BNF_FP_Def_Sugar.co_datatypes</span> <span class="entity">BNF_Util.Least_FP</span> <span class="entity">BNF_LFP.construct_lfp</span> <span class="entity">dtspec</span>
      <span class="comment1">(* FIXME ideally BNF would return a fp_sugar value right here so that I can avoid constructing
         long names by hand above *)</span>
      |&gt; <span class="main">(</span>snd o Local_Theory.begin_nested<span class="main">)</span>
      |&gt; Local_Theory.define <span class="main">(</span><span class="main">(</span><span class="entity">cert_binding</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span>Thm.def_binding <span class="entity">cert_binding</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">cert_term</span><span class="main">)</span><span class="main">)</span>
      |&gt;&gt; apsnd snd
      |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">raw_cert</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">prove_thms</span> <span class="entity">raw_cert</span> <span class="entity">lthy</span> |&gt;&gt; pair <span class="entity">raw_cert</span><span class="main">)</span>
      ||&gt; `Local_Theory.end_nested

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">phi</span> <span class="main">=</span> Proof_Context.export_morphism <span class="entity">lthy</span> <span class="entity">lthy'</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cert</span> <span class="entity">typ</span> <span class="main">=</span> subst_TVars <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span>Morphism.term <span class="entity">phi</span> <span class="entity">raw_cert</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert_def</span> <span class="main">=</span> Morphism.thm <span class="entity">phi</span> <span class="entity">raw_cert_def</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">edges</span> <span class="main">=</span> <span class="entity">pre_edges</span> <span class="entity">phi</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param_dests'</span> <span class="main">=</span> map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">param_dests</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intro'</span> <span class="main">=</span> Morphism.thm <span class="entity">phi</span> <span class="entity">intro</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data_thms</span> <span class="main">=</span>
      <span class="entity">BNF_FP_Def_Sugar.fp_sugar_of</span> <span class="entity">lthy'</span> <span class="entity">qname</span>
      |&gt; the |&gt; <span class="main">#</span>fp_ctr_sugar |&gt; <span class="main">#</span>ctr_sugar |&gt; <span class="main">#</span>sel_thmss |&gt; flat
      |&gt; map <span class="entity">safe_mk_meta_eq</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">node</span> <span class="main">=</span>
      <span class="main">{</span>class <span class="main">=</span> <span class="entity">class</span><span class="main">,</span>
       qname <span class="main">=</span> <span class="entity">qname</span><span class="main">,</span>
       selectors <span class="main">=</span> Symtab.make <span class="entity">selectors</span><span class="main">,</span>
       make <span class="main">=</span> <span class="entity">make</span><span class="main">,</span>
       data_thms <span class="main">=</span> <span class="entity">data_thms</span><span class="main">,</span>
       cert <span class="main">=</span> <span class="entity">cert</span><span class="main">,</span>
       cert_thms <span class="main">=</span> <span class="main">(</span><span class="entity">cert_def</span><span class="main">,</span> <span class="entity">intro'</span><span class="main">,</span> <span class="entity">param_dests'</span><span class="main">)</span><span class="main">}</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">node</span><span class="main">,</span> <span class="entity">edges</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ensure_class</span> <span class="entity">class</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">Class.is_class</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="entity">class</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
    error <span class="main">(</span><span class="inner_quoted">"not a proper class: "</span> ^ <span class="entity">class</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">lthy</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">super_classes</span> <span class="main">=</span> <span class="entity">super_classes</span> <span class="entity">class</span> <span class="entity">thy</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">collect_super</span> <span class="entity">mk_node</span> <span class="main">=</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">super_evs</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="entity">ensure_class</span> <span class="entity">super_classes</span> <span class="entity">lthy</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_tab</span> <span class="main">=</span> Symtab.make <span class="main">(</span><span class="entity">super_classes</span> ~~ <span class="entity">super_evs</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">node</span><span class="main">,</span> <span class="entity">edges</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_node</span> <span class="entity">raw_tab</span> <span class="entity">lthy'</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tab</span> <span class="main">=</span> <span class="entity">zip_symtabs</span> pair <span class="entity">edges</span> <span class="entity">raw_tab</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ev</span> <span class="main">=</span> <span class="entity">mk_evidence</span> <span class="entity">class</span> <span class="entity">node</span> <span class="entity">tab</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">ev</span><span class="main">,</span> <span class="entity">edges</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup <span class="main">(</span>Classes.get <span class="main">(</span>Context.Proof <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="entity">class</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="main">(</span><span class="entity">edge_tab</span><span class="main">,</span> <span class="entity">node</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">super_classes</span> <span class="main">=</span> Symtab.keys <span class="entity">edge_tab</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ev</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">collect_super</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">lthy</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">node</span><span class="main">,</span> <span class="entity">edge_tab</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">in</span></span>
              <span class="main">(</span><span class="entity">ev</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="comment1">(* This happens when a new subclass relationship is established which subsumes or
               augments previous superclasses. *)</span>
            error <span class="inner_quoted">"class with different super classes"</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ax_info</span> <span class="main">=</span> <span class="entity">Axclass.get_info</span> <span class="entity">thy</span> <span class="entity">class</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ev</span><span class="main">,</span> <span class="entity">edges</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">collect_super</span> <span class="main">(</span><span class="entity">mk_node</span> <span class="entity">class</span> <span class="entity">ax_info</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">upd</span> <span class="main">=</span> Symtab.update_new <span class="main">(</span><span class="entity">class</span><span class="main">,</span> <span class="main">(</span><span class="entity">edges</span><span class="main">,</span> <span class="entity">node_of</span> <span class="entity">ev</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="entity">ev</span><span class="main">,</span> Local_Theory.declaration <span class="main">{</span>pervasive <span class="main">=</span> false<span class="main">,</span> syntax <span class="main">=</span> false<span class="main">}</span> <span class="main">(</span>K <span class="main">(</span>Classes.map <span class="entity">upd</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/dict_construction.ML">
<div class="head">
<h1>File ‹dict_construction.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">DICT_CONSTRUCTION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">cert_proof</span> <span class="main">=</span> <span class="entity">Cert</span> <span class="main">|</span> <span class="entity">Skip</span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">const</span>

  <span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">sccs</span> <span class="main">=</span> <span class="main">(</span>string * 'a<span class="main">)</span> list list

  <span class="keyword1"><span class="keyword">val</span></span> annotate_code_eqs<span class="main">:</span> local_theory <span class="main">-&gt;</span> string list <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">const</span> <span class="entity">sccs</span> * local_theory<span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> new_names<span class="main">:</span> local_theory <span class="main">-&gt;</span> <span class="entity">const</span> <span class="entity">sccs</span> <span class="main">-&gt;</span> <span class="main">(</span>string * <span class="entity">const</span><span class="main">)</span> <span class="entity">sccs</span>
  <span class="keyword1"><span class="keyword">val</span></span> symtab_of_sccs<span class="main">:</span> 'a <span class="entity">sccs</span> <span class="main">-&gt;</span> 'a Symtab.table

  <span class="keyword1"><span class="keyword">val</span></span> axclass<span class="main">:</span> class <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="entity">Class_Graph.node</span> * local_theory
  <span class="keyword1"><span class="keyword">val</span></span> instance<span class="main">:</span> <span class="main">(</span>string * <span class="entity">const</span><span class="main">)</span> Symtab.table <span class="main">-&gt;</span> string <span class="main">-&gt;</span> class <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> term * local_theory
  <span class="keyword1"><span class="keyword">val</span></span> term<span class="main">:</span> term Symreltab.table <span class="main">-&gt;</span> <span class="main">(</span>string * <span class="entity">const</span><span class="main">)</span> Symtab.table <span class="main">-&gt;</span> term <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> <span class="main">(</span>term * local_theory<span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> consts<span class="main">:</span> <span class="main">(</span>string * <span class="entity">const</span><span class="main">)</span> Symtab.table <span class="main">-&gt;</span> <span class="entity">cert_proof</span> <span class="main">-&gt;</span> <span class="main">(</span>string * <span class="entity">const</span><span class="main">)</span> list <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory

  <span class="comment1">(* certification *)</span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">const_info</span> <span class="main">=</span>
    <span class="main">{</span>fun_info<span class="main">:</span> <span class="entity">Function.info</span> option<span class="main">,</span>
     inducts<span class="main">:</span> thm list option<span class="main">,</span>
     base_thms<span class="main">:</span> thm list<span class="main">,</span>
     base_certs<span class="main">:</span> thm list<span class="main">,</span>
     simps<span class="main">:</span> thm list<span class="main">,</span>
     code_thms<span class="main">:</span> thm list<span class="main">,</span> <span class="comment1">(* old defining theorems *)</span>
     congs<span class="main">:</span> thm list option<span class="main">}</span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">fun_target</span> <span class="main">=</span> <span class="main">(</span>string * class<span class="main">)</span> list * <span class="main">(</span>term * term<span class="main">)</span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">dict_thms</span> <span class="main">=</span>
    <span class="main">{</span>base_thms<span class="main">:</span> thm list<span class="main">,</span>
     def_thm<span class="main">:</span> thm<span class="main">}</span>

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">dict_target</span> <span class="main">=</span> <span class="main">(</span>string * class<span class="main">)</span> list * <span class="main">(</span>term * string * class<span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> prove_fun_cert<span class="main">:</span> <span class="entity">fun_target</span> list <span class="main">-&gt;</span> <span class="entity">const_info</span> <span class="main">-&gt;</span> <span class="entity">cert_proof</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> prove_dict_cert<span class="main">:</span> <span class="entity">dict_target</span> <span class="main">-&gt;</span> <span class="entity">dict_thms</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> thm

  <span class="keyword1"><span class="keyword">val</span></span> the_info<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">const_info</span>

  <span class="comment1">(* utilities *)</span>

  <span class="keyword1"><span class="keyword">val</span></span> normalizer_conv<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> cong_of_const<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm option
  <span class="keyword1"><span class="keyword">val</span></span> get_code_eqs<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> group_code_eqs<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string list <span class="main">-&gt;</span>
    <span class="main">(</span>string * <span class="main">(</span><span class="main">(</span><span class="main">(</span>string * sort<span class="main">)</span> list * typ<span class="main">)</span> * <span class="main">(</span><span class="main">(</span>term list * term<span class="main">)</span> * thm option<span class="main">)</span> list<span class="main">)</span><span class="main">)</span> list list
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Dict_Construction</span><span class="main">:</span> <span class="entity">DICT_CONSTRUCTION</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Class_Graph
<span class="keyword3"><span class="keyword">open</span></span> Dict_Construction_Util

<span class="comment1">(* FIXME copied from skip_proof.ML *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">make_thm_cterm</span><span class="main">)</span> <span class="main">=</span>
  Context.&gt;&gt;&gt;
    <span class="main">(</span>Context.map_theory_result <span class="main">(</span>Thm.add_oracle <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> cert_oracle<span class="antiquote">}</span></span></span><span class="main">,</span> I<span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">make_thm</span> <span class="entity">ctxt</span> <span class="entity">prop</span> <span class="main">=</span> <span class="entity">make_thm_cterm</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">prop</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cheat_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span> <span class="entity">st</span> <span class="main">=</span>
  resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">make_thm</span> <span class="entity">ctxt</span> <span class="main">(</span>Var <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"A"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> propT<span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="entity">i</span> <span class="entity">st</span>

<span class="comment1">(** utilities **)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">normalizer_conv</span> <span class="main">=</span> <span class="entity">Axclass.overload_conv</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cong_of_const</span> <span class="entity">ctxt</span> <span class="entity">name</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head</span> <span class="main">=</span>
      Thm.concl_of
      #&gt; Logic.dest_equals #&gt; fst
      #&gt; strip_comb #&gt; fst
      #&gt; dest_Const #&gt; fst
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">applicable</span> <span class="entity">thm</span> <span class="main">=</span>
      try <span class="entity">head</span> <span class="entity">thm</span> <span class="main">=</span> SOME <span class="entity">name</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Function_Context_Tree.get_function_congs</span> <span class="entity">ctxt</span>
    |&gt; filter <span class="entity">applicable</span>
    |&gt; try hd
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">group_code_eqs</span> <span class="entity">ctxt</span> <span class="entity">consts</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">graph</span> <span class="main">=</span> <span class="main">#</span>eqngr <span class="main">(</span><span class="entity">Code_Preproc.obtain</span> true <span class="main">{</span> ctxt <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> consts <span class="main">=</span> <span class="entity">consts</span><span class="main">,</span> terms <span class="main">=</span> <span class="main">[</span><span class="main">]</span> <span class="main">}</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eqs</span> <span class="entity">name</span> <span class="main">=</span> <span class="entity">name</span>
      |&gt; <span class="entity">Code_Preproc.cert</span> <span class="entity">graph</span>
      |&gt; <span class="entity">Code.equations_of_cert</span> <span class="entity">thy</span> ||&gt; these
      ||&gt; map <span class="main">(</span>apsnd fst o apfst <span class="main">(</span>apsnd fst o apfst <span class="main">(</span>map fst<span class="main">)</span><span class="main">)</span><span class="main">)</span>
      |&gt; pair <span class="entity">name</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map <span class="main">(</span>map <span class="entity">mk_eqs</span><span class="main">)</span> <span class="main">(</span>rev <span class="main">(</span>Graph.strong_conn <span class="entity">graph</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_code_eqs</span> <span class="entity">ctxt</span> <span class="entity">const</span> <span class="main">=</span>
  AList.lookup <span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span> <span class="main">(</span>flat <span class="main">(</span><span class="entity">group_code_eqs</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">const</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">const</span>
  |&gt; the |&gt; snd
  |&gt; map snd
  |&gt; <span class="entity">cat_options</span>
  |&gt; map <span class="main">(</span>Conv.fconv_rule <span class="main">(</span><span class="entity">normalizer_conv</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(** certification **)</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">cert_proof</span> <span class="main">=</span> <span class="entity">Cert</span> <span class="main">|</span> <span class="entity">Skip</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">const_info</span> <span class="main">=</span>
  <span class="main">{</span>fun_info<span class="main">:</span> <span class="entity">Function.info</span> option<span class="main">,</span>
   inducts<span class="main">:</span> thm list option<span class="main">,</span>
   base_thms<span class="main">:</span> thm list<span class="main">,</span>
   base_certs<span class="main">:</span> thm list<span class="main">,</span>
   simps<span class="main">:</span> thm list<span class="main">,</span>
   code_thms<span class="main">:</span> thm list<span class="main">,</span>
   congs<span class="main">:</span> thm list option<span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_const_info</span> <span class="entity">f1</span> <span class="entity">f2</span> <span class="entity">f3</span> <span class="entity">f4</span> <span class="entity">f5</span> <span class="entity">f6</span> <span class="entity">f7</span> <span class="main">{</span><span class="entity">fun_info</span><span class="main">,</span> <span class="entity">inducts</span><span class="main">,</span> <span class="entity">base_thms</span><span class="main">,</span> <span class="entity">base_certs</span><span class="main">,</span> <span class="entity">simps</span><span class="main">,</span> <span class="entity">code_thms</span><span class="main">,</span> <span class="entity">congs</span><span class="main">}</span> <span class="main">=</span>
  <span class="main">{</span>fun_info <span class="main">=</span> <span class="entity">f1</span> <span class="entity">fun_info</span><span class="main">,</span>
   inducts <span class="main">=</span> <span class="entity">f2</span> <span class="entity">inducts</span><span class="main">,</span>
   base_thms <span class="main">=</span> <span class="entity">f3</span> <span class="entity">base_thms</span><span class="main">,</span>
   base_certs <span class="main">=</span> <span class="entity">f4</span> <span class="entity">base_certs</span><span class="main">,</span>
   simps <span class="main">=</span> <span class="entity">f5</span> <span class="entity">simps</span><span class="main">,</span>
   code_thms <span class="main">=</span> <span class="entity">f6</span> <span class="entity">code_thms</span><span class="main">,</span>
   congs <span class="main">=</span> <span class="entity">f7</span> <span class="entity">congs</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">morph_const_info</span> <span class="entity">phi</span> <span class="main">=</span>
  <span class="entity">map_const_info</span>
    <span class="main">(</span>Option.map <span class="main">(</span><span class="entity">Function_Common.transform_function_data</span> <span class="entity">phi</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>Option.map <span class="main">(</span>map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span><span class="main">)</span>
    I <span class="comment1">(* sic *)</span>
    <span class="main">(</span>Option.map <span class="main">(</span>map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">fun_target</span> <span class="main">=</span> <span class="main">(</span>string * class<span class="main">)</span> list * <span class="main">(</span>term * term<span class="main">)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">dict_thms</span> <span class="main">=</span>
  <span class="main">{</span>base_thms<span class="main">:</span> thm list<span class="main">,</span>
   def_thm<span class="main">:</span> thm<span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">dict_target</span> <span class="main">=</span> <span class="main">(</span>string * class<span class="main">)</span> list * <span class="main">(</span>term * string * class<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fun_cert_tac</span> <span class="entity">base_thms</span> <span class="entity">base_certs</span> <span class="entity">simps</span> <span class="entity">code_thms</span> <span class="main">=</span>
  SOLVED' o <span class="entity">Subgoal.FOCUS</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">concl</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
        <span class="entity">if_debug</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">)</span> <span class="main">=&gt;</span>
          tracing <span class="main">(</span><span class="inner_quoted">"Proving "</span> ^ Syntax.string_of_term <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">concl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_ih</span> <span class="entity">prem</span> <span class="main">=</span>
        Thm.prop_of <span class="entity">prem</span> |&gt; Logic.strip_imp_concl |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; can <span class="entity">HOLogic.dest_eq</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ihs</span><span class="main">,</span> <span class="entity">certs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">partition</span> <span class="entity">is_ih</span> <span class="entity">prems</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">super_certs</span> <span class="main">=</span> <span class="entity">all_edges</span> <span class="entity">ctxt</span> |&gt; Symreltab.dest |&gt; map <span class="main">(</span><span class="main">#</span>subclass o snd<span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param_dests</span> <span class="main">=</span> <span class="entity">all_nodes</span> <span class="entity">ctxt</span> |&gt; Symtab.dest |&gt; maps <span class="main">(</span><span class="main">#</span><span class="inner_numeral">3</span> o <span class="main">#</span>cert_thms o snd<span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">congs</span> <span class="main">=</span> <span class="entity">Function_Context_Tree.get_function_congs</span> <span class="entity">ctxt</span> @ map <span class="entity">safe_mk_meta_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> cong<span class="antiquote">}</span></span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_context</span> <span class="main">=</span> <span class="main">(</span>clear_simpset <span class="entity">ctxt</span><span class="main">)</span> addsimps <span class="main">(</span><span class="entity">certs</span> @ <span class="entity">super_certs</span> @ <span class="entity">base_certs</span> @ <span class="entity">base_thms</span> @ <span class="entity">param_dests</span><span class="main">)</span>
        addloop <span class="main">(</span><span class="inner_quoted">"overload"</span><span class="main">,</span> CONVERSION o <span class="entity">changed_conv</span> o <span class="entity">Axclass.overload_conv</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ihs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">Simplifier.asm_full_simplify</span> <span class="entity">simp_context</span><span class="main">)</span> <span class="entity">ihs</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ih_tac</span> <span class="main">=</span>
        resolve_tac <span class="entity">ctxt</span> <span class="entity">ihs</span> THEN_ALL_NEW
          <span class="main">(</span><span class="entity">TRY'</span> <span class="main">(</span>SOLVED' <span class="main">(</span><span class="entity">Simplifier.asm_full_simp_tac</span> <span class="entity">simp_context</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unfold_new</span> <span class="main">=</span>
        <span class="entity">ANY'</span> <span class="main">(</span>map <span class="main">(</span>CONVERSION o <span class="entity">rewr_lhs_head_conv</span><span class="main">)</span> <span class="entity">simps</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">normalize</span> <span class="main">=</span>
        CONVERSION <span class="main">(</span><span class="entity">normalizer_conv</span> <span class="entity">ctxt</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unfold_old</span> <span class="main">=</span>
        <span class="entity">ANY'</span> <span class="main">(</span>map <span class="main">(</span>CONVERSION o <span class="entity">rewr_rhs_head_conv</span><span class="main">)</span> <span class="entity">code_thms</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp</span> <span class="main">=</span>
        CONVERSION <span class="main">(</span><span class="entity">lhs_conv</span> <span class="main">(</span><span class="entity">Simplifier.asm_full_rewrite</span> <span class="entity">simp_context</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">walk_congs</span> <span class="entity">i</span> <span class="main">=</span> <span class="entity">i</span> |&gt;
        <span class="main">(</span><span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> refl<span class="antiquote">}</span></span></span> ORELSE'
          SOLVED' <span class="main">(</span><span class="entity">Simplifier.asm_full_simp_tac</span> <span class="entity">simp_context</span><span class="main">)</span> ORELSE'
          <span class="entity">ih_tac</span> ORELSE'
          <span class="entity">Method.assm_tac</span> <span class="entity">ctxt</span> ORELSE'
          <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> meta_eq_to_obj_eq<span class="antiquote">}</span></span></span> THEN'
            <span class="entity">fo_resolve_tac</span> <span class="entity">congs</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> THEN_ALL_NEW <span class="entity">walk_congs</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tacs</span> <span class="main">=</span>
        <span class="main">[</span><span class="entity">unfold_new</span><span class="main">,</span> <span class="entity">normalize</span><span class="main">,</span> <span class="entity">unfold_old</span><span class="main">,</span> <span class="entity">simp</span><span class="main">,</span> <span class="entity">walk_congs</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      EVERY' <span class="entity">tacs</span> <span class="inner_numeral">1</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dict_cert_tac</span> <span class="entity">class</span> <span class="entity">def_thm</span> <span class="entity">base_thms</span> <span class="main">=</span>
  SOLVED' o <span class="entity">Subgoal.FOCUS</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">intro</span><span class="main">,</span> <span class="entity">sels</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">node</span> <span class="entity">ctxt</span> <span class="entity">class</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="main">{</span>cert_thms <span class="main">=</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">intro</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> data_thms <span class="main">=</span> <span class="entity">sels</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">intro</span><span class="main">,</span> <span class="entity">sels</span><span class="main">)</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"class "</span> ^ <span class="entity">class</span> ^ <span class="inner_quoted">" is not defined"</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">apply_intro</span> <span class="main">=</span>
        resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">intro</span><span class="main">]</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unfold_dict</span> <span class="main">=</span>
        CONVERSION <span class="main">(</span>Conv.rewr_conv <span class="entity">def_thm</span> |&gt; Conv.arg_conv |&gt; <span class="entity">lhs_conv</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">normalize</span> <span class="main">=</span>
        CONVERSION <span class="main">(</span><span class="entity">normalizer_conv</span> <span class="entity">ctxt</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">smash_sels</span> <span class="main">=</span>
        CONVERSION <span class="main">(</span><span class="entity">lhs_conv</span> <span class="main">(</span>Conv.rewrs_conv <span class="entity">sels</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">solve</span> <span class="main">=</span>
        resolve_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.refl<span class="antiquote">}</span></span></span> :: <span class="entity">base_thms</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">finally</span> <span class="main">=</span>
        resolve_tac <span class="entity">ctxt</span> <span class="entity">prems</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tacs</span> <span class="main">=</span>
        <span class="main">[</span><span class="entity">apply_intro</span><span class="main">,</span> <span class="entity">unfold_dict</span><span class="main">,</span> <span class="entity">normalize</span><span class="main">,</span> <span class="entity">smash_sels</span><span class="main">,</span> <span class="entity">solve</span><span class="main">,</span> <span class="entity">finally</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      EVERY <span class="main">(</span>map <span class="main">(</span><span class="entity">ALLGOALS'</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">tacs</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_dicts</span> <span class="entity">classes</span> <span class="entity">names</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sorts</span> <span class="main">=</span> Symtab.make_list <span class="entity">classes</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_dicts</span> <span class="main">(</span><span class="entity">param_name</span><span class="main">,</span> <span class="main">(</span><span class="entity">tvar</span><span class="main">,</span> <span class="entity">class</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">node</span> <span class="entity">lthy</span> <span class="entity">class</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span>
          error <span class="main">(</span><span class="inner_quoted">"unknown class "</span> ^ <span class="entity">class</span><span class="main">)</span>
      <span class="main">|</span> SOME <span class="main">{</span><span class="entity">cert</span><span class="main">,</span> <span class="entity">qname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> the <span class="main">(</span>Symtab.lookup <span class="entity">sorts</span> <span class="entity">tvar</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">param_name</span><span class="main">,</span> Type <span class="main">(</span><span class="entity">qname</span><span class="main">,</span> <span class="main">[</span>TFree <span class="main">(</span><span class="entity">tvar</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="entity">param</span><span class="main">,</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">cert</span> dummyT $ <span class="entity">param</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dict_names</span> <span class="main">=</span> Name.invent_names <span class="entity">names</span> <span class="inner_quoted">"a"</span> <span class="entity">classes</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">names</span> <span class="main">=</span> fold Name.declare <span class="main">(</span>map fst <span class="entity">dict_names</span><span class="main">)</span> <span class="entity">names</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">dict_params</span><span class="main">,</span> <span class="entity">prems</span><span class="main">)</span> <span class="main">=</span> split_list <span class="main">(</span>map <span class="entity">mk_dicts</span> <span class="entity">dict_names</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">dict_params</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="entity">names</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_fun_goal</span> <span class="entity">targets</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">classes</span><span class="main">,</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> <span class="entity">names</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs_name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> dest_Const <span class="entity">lhs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">rhs_name</span><span class="main">,</span> <span class="entity">rhs_typ</span><span class="main">)</span> <span class="main">=</span> dest_Const <span class="entity">rhs</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">dict_params</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="entity">names</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prepare_dicts</span> <span class="entity">classes</span> <span class="entity">names</span> <span class="entity">lthy</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param_names</span> <span class="main">=</span> fst <span class="main">(</span>strip_type <span class="entity">rhs_typ</span><span class="main">)</span> |&gt; map <span class="main">(</span>K dummyT<span class="main">)</span> |&gt; Name.invent_names <span class="entity">names</span> <span class="inner_quoted">"a"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">names</span> <span class="main">=</span> fold Name.declare <span class="main">(</span>map fst <span class="entity">param_names</span><span class="main">)</span> <span class="entity">names</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span> <span class="main">=</span> map Free <span class="entity">param_names</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="entity">lhs_name</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">,</span> <span class="entity">dict_params</span> @ <span class="entity">params</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="entity">rhs_name</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">,</span> <span class="entity">params</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.eq<span class="antiquote">}</span></span><span class="main">,</span> dummyT<span class="main">)</span> $ <span class="entity">lhs</span> $ <span class="entity">rhs</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_params</span> <span class="main">=</span> <span class="entity">dict_params</span> @ <span class="entity">params</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> :: <span class="entity">rest</span> <span class="main">=</span> Syntax.check_terms <span class="entity">lthy</span> <span class="main">(</span><span class="entity">eq</span> :: <span class="entity">prems</span> @ <span class="entity">all_params</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">all_params</span><span class="main">)</span> <span class="main">=</span> <span class="entity">unappend</span> <span class="main">(</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">all_params</span><span class="main">)</span> <span class="entity">rest</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> is_some <span class="main">(</span><span class="entity">Axclass.inst_of_param</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="entity">rhs_name</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
            Thm.cterm_of <span class="entity">lthy</span> <span class="entity">eq</span> |&gt; <span class="entity">conv_result</span> <span class="main">(</span>Conv.arg_conv <span class="main">(</span><span class="entity">normalizer_conv</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="entity">eq</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> <span class="entity">prems</span> <span class="entity">===&gt;</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="entity">eq</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">all_params</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span><span class="main">,</span> <span class="entity">names</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    fold_map <span class="entity">mk_eq</span> <span class="entity">targets</span> Name.context
    |&gt; fst
    |&gt; split_list
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_dict_goal</span> <span class="main">(</span><span class="entity">classes</span><span class="main">,</span> <span class="main">(</span><span class="entity">term</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">class</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">node</span> <span class="entity">lthy</span> <span class="entity">class</span> <span class="keyword2"><span class="keyword">of</span></span>
      NONE <span class="main">=&gt;</span>
        error <span class="main">(</span><span class="inner_quoted">"unknown class "</span> ^ <span class="entity">class</span><span class="main">)</span>
    <span class="main">|</span> SOME <span class="main">{</span><span class="entity">cert</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="entity">cert</span> dummyT

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">names</span> <span class="main">=</span> Name.context
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">dict_params</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prepare_dicts</span> <span class="entity">classes</span> <span class="entity">names</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">term_name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> dest_Const <span class="entity">term</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dict</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="entity">term_name</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">,</span> <span class="entity">dict_params</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> <span class="entity">prems</span> <span class="entity">===&gt;</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">cert</span> $ <span class="entity">dict</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> :: <span class="entity">dict_params</span> <span class="main">=</span> Syntax.check_terms <span class="entity">lthy</span> <span class="main">(</span><span class="entity">prop</span> :: <span class="entity">dict_params</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">dict_params</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_fun_cert</span> <span class="entity">targets</span> <span class="main">{</span><span class="entity">inducts</span><span class="main">,</span> <span class="entity">base_thms</span><span class="main">,</span> <span class="entity">base_certs</span><span class="main">,</span> <span class="entity">simps</span><span class="main">,</span> <span class="entity">code_thms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">proof</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="comment1">(* the props contain dictionary certs as prems
       we can't exclude them from the induction because the dicts are part of the function
       definition
       excluding them would mean that applying the induction rules becomes tricky or impossible
       proper fix would be if fun, akin to inductive, supported a "for" clause that marks parameters
       as "not changing" *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">argss</span><span class="main">,</span> <span class="entity">props</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prepare_fun_goal</span> <span class="entity">targets</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees</span> <span class="main">=</span> flat <span class="entity">argss</span> |&gt; map <span class="main">(</span>fst o dest_Free<span class="main">)</span>

    <span class="comment1">(* we first prove the extensional variant (easier to prove), and then derive the
       contracted variant
       abs_def can't deal with premises, so we use our own version here *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">proof</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Cert</span> <span class="main">=&gt;</span> <span class="entity">fun_cert_tac</span> <span class="entity">base_thms</span> <span class="entity">base_certs</span> <span class="entity">simps</span> <span class="entity">code_thms</span>
      <span class="main">|</span> <span class="entity">Skip</span> <span class="main">=&gt;</span> <span class="entity">cheat_tac</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">long_thms</span> <span class="main">=</span>
       <span class="entity">prove_common'</span> <span class="entity">lthy</span> <span class="entity">frees</span> <span class="main">[</span><span class="main">]</span> <span class="entity">props</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
          <span class="entity">maybe_induct_tac</span> <span class="entity">inducts</span> <span class="entity">argss</span> <span class="main">[</span><span class="main">]</span> <span class="entity">context</span> THEN
            <span class="entity">ALLGOALS'</span> <span class="entity">context</span> <span class="main">(</span><span class="entity">tac</span> <span class="entity">context</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    map <span class="main">(</span><span class="entity">contract</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">long_thms</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_dict_cert</span> <span class="entity">target</span> <span class="main">{</span><span class="entity">base_thms</span><span class="main">,</span> <span class="entity">def_thm</span><span class="main">}</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">args</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prepare_dict_goal</span> <span class="entity">target</span> <span class="entity">lthy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees</span> <span class="main">=</span> map <span class="main">(</span>fst o dest_Free<span class="main">)</span> <span class="entity">args</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">class</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">target</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">prove'</span> <span class="entity">lthy</span> <span class="entity">frees</span> <span class="main">[</span><span class="main">]</span> <span class="entity">prop</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
      <span class="entity">dict_cert_tac</span> <span class="entity">class</span> <span class="entity">def_thm</span> <span class="entity">base_thms</span> <span class="entity">context</span> <span class="inner_numeral">1</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(** background data **)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">definitions</span> <span class="main">=</span>
  <span class="main">{</span>instantiations<span class="main">:</span> <span class="main">(</span>term * thm<span class="main">)</span> Symreltab.table<span class="main">,</span> <span class="comment1">(* key: (class, tyco) *)</span>
   constants<span class="main">:</span> <span class="main">(</span>string * <span class="main">(</span>thm option * <span class="entity">const_info</span><span class="main">)</span><span class="main">)</span> Symtab.table <span class="comment1">(* key: constant name *)</span> <span class="main">}</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Definitions</span> <span class="main">=</span> Generic_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">definitions</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> <span class="main">{</span>instantiations <span class="main">=</span> Symreltab.empty<span class="main">,</span> constants <span class="main">=</span> Symtab.empty<span class="main">}</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="main">(</span><span class="main">{</span>instantiations <span class="main">=</span> <span class="entity">i1</span><span class="main">,</span> constants <span class="main">=</span> <span class="entity">c1</span><span class="main">}</span><span class="main">,</span> <span class="main">{</span>instantiations <span class="main">=</span> <span class="entity">i2</span><span class="main">,</span> constants <span class="main">=</span> <span class="entity">c2</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> Symreltab.is_empty <span class="entity">i1</span> <span class="keyword1"><span class="keyword">andalso</span></span> Symtab.is_empty <span class="entity">c1</span> <span class="keyword1"><span class="keyword">andalso</span></span>
       Symreltab.is_empty <span class="entity">i2</span> <span class="keyword1"><span class="keyword">andalso</span></span> Symtab.is_empty <span class="entity">c2</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">empty</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      error <span class="inner_quoted">"merging not supported"</span>
<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_definitions</span> <span class="entity">map_insts</span> <span class="entity">map_consts</span> <span class="main">=</span>
  Definitions.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">instantiations</span><span class="main">,</span> <span class="entity">constants</span><span class="main">}</span> <span class="main">=&gt;</span>
    <span class="main">{</span>instantiations <span class="main">=</span> <span class="entity">map_insts</span> <span class="entity">instantiations</span><span class="main">,</span>
     constants <span class="main">=</span> <span class="entity">map_consts</span> <span class="entity">constants</span><span class="main">}</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">the_info</span> <span class="entity">ctxt</span> <span class="entity">name</span> <span class="main">=</span>
  Symtab.lookup <span class="main">(</span><span class="main">#</span>constants <span class="main">(</span>Definitions.get <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">name</span>
  |&gt; the
  |&gt; snd
  |&gt; snd

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_instantiation</span> <span class="main">(</span><span class="entity">class</span><span class="main">,</span> <span class="entity">tyco</span><span class="main">)</span> <span class="entity">term</span> <span class="entity">cert</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">upd</span> <span class="entity">phi</span> <span class="main">=</span>
      <span class="entity">map_definitions</span>
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tab</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> Symreltab.defined <span class="entity">tab</span> <span class="main">(</span><span class="entity">class</span><span class="main">,</span> <span class="entity">tyco</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
            error <span class="main">(</span><span class="inner_quoted">"Duplicate instantiation "</span> ^ quote <span class="entity">tyco</span> ^ <span class="inner_quoted">" :: "</span> ^ quote <span class="entity">class</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="entity">tab</span>
            |&gt; Symreltab.update <span class="main">(</span><span class="main">(</span><span class="entity">class</span><span class="main">,</span> <span class="entity">tyco</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>Morphism.term <span class="entity">phi</span> <span class="entity">term</span><span class="main">,</span> Morphism.thm <span class="entity">phi</span> <span class="entity">cert</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> I
  <span class="keyword2"><span class="keyword">in</span></span>
    Local_Theory.declaration <span class="main">{</span>pervasive <span class="main">=</span> false<span class="main">,</span> syntax <span class="main">=</span> false<span class="main">}</span> <span class="entity">upd</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_constant</span> <span class="entity">name</span> <span class="entity">name'</span> <span class="main">(</span><span class="entity">cert</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">qname</span> <span class="main">=</span> Local_Theory.full_name <span class="entity">lthy</span> <span class="main">(</span>Binding.name <span class="entity">name'</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">upd</span> <span class="entity">phi</span> <span class="main">=</span>
      <span class="entity">map_definitions</span> I
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">tab</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> Symtab.defined <span class="entity">tab</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">then</span></span>
            error <span class="main">(</span><span class="inner_quoted">"Duplicate constant "</span> ^ quote <span class="entity">name</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="entity">tab</span>
            |&gt; Symtab.update <span class="main">(</span><span class="entity">name</span><span class="main">,</span>
                <span class="main">(</span><span class="entity">qname</span><span class="main">,</span> <span class="main">(</span>Option.map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">cert</span><span class="main">,</span> <span class="entity">morph_const_info</span> <span class="entity">phi</span> <span class="entity">info</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Local_Theory.declaration <span class="main">{</span>pervasive <span class="main">=</span> false<span class="main">,</span> syntax <span class="main">=</span> false<span class="main">}</span> <span class="entity">upd</span> <span class="entity">lthy</span>
    |&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">dict_construction_specs</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="main">#</span>simps <span class="entity">info</span><span class="main">)</span>
    |&gt; snd
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(** classes **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">axclass</span> <span class="entity">class</span> <span class="main">=</span>
  <span class="entity">ensure_class</span> <span class="entity">class</span>
  #&gt;&gt; <span class="entity">node_of</span>

<span class="comment1">(** grouping and annotating constants **)</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">const</span> <span class="main">=</span>
  <span class="entity">Fun</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">{</span>dicts<span class="main">:</span> <span class="main">(</span><span class="main">(</span>string * class<span class="main">)</span> * typ<span class="main">)</span> list<span class="main">,</span>
     certs<span class="main">:</span> term list<span class="main">,</span>
     param_typs<span class="main">:</span> typ list<span class="main">,</span>
     typ<span class="main">:</span> typ<span class="main">,</span> <span class="comment1">(* typified *)</span>
     new_typ<span class="main">:</span> typ<span class="main">,</span>
     eqs<span class="main">:</span> <span class="main">{</span>params<span class="main">:</span> term list<span class="main">,</span> rhs<span class="main">:</span> term<span class="main">,</span> thm<span class="main">:</span> thm<span class="main">}</span> list<span class="main">,</span>
     info<span class="main">:</span> Function_Common.info option<span class="main">,</span>
     cong<span class="main">:</span> thm option<span class="main">}</span> <span class="main">|</span>
  <span class="entity">Constructor</span> <span class="main">|</span>
  <span class="entity">Classparam</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">{</span>class<span class="main">:</span> class<span class="main">,</span>
     typ<span class="main">:</span> typ<span class="main">,</span> <span class="comment1">(* varified *)</span>
     selector<span class="main">:</span> term <span class="comment1">(* varified *)</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> 'a <span class="entity">sccs</span> <span class="main">=</span> <span class="main">(</span>string * 'a<span class="main">)</span> list list

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">symtab_of_sccs</span> <span class="entity">x</span> <span class="main">=</span> Symtab.make <span class="main">(</span>flat <span class="entity">x</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">raw_dict_params</span> <span class="entity">tparams</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_dict</span> <span class="entity">tparam</span> <span class="entity">class</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">node</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">axclass</span> <span class="entity">class</span> <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">targ</span> <span class="main">=</span> TFree <span class="main">(</span><span class="entity">tparam</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ</span> <span class="main">=</span> <span class="entity">dict_typ</span> <span class="entity">node</span> <span class="entity">targ</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cert</span> <span class="main">=</span> <span class="main">#</span>cert <span class="entity">node</span> <span class="entity">targ</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">tparam</span><span class="main">,</span> <span class="entity">class</span><span class="main">)</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">,</span> <span class="entity">cert</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_dicts</span> <span class="main">(</span><span class="entity">tparam</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span> <span class="main">=</span> fold_map
      <span class="main">(</span><span class="entity">mk_dict</span> <span class="entity">tparam</span><span class="main">)</span>
      <span class="main">(</span>filter <span class="main">(</span><span class="entity">Class.is_class</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="entity">sort</span><span class="main">)</span>
   <span class="keyword2"><span class="keyword">in</span></span> fold_map <span class="entity">mk_dicts</span> <span class="entity">tparams</span> <span class="entity">lthy</span> |&gt;&gt; flat <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dict_params</span> <span class="entity">context</span> <span class="entity">dicts</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dict_param</span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">class</span><span class="main">)</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=</span>
      Name.variant <span class="main">(</span><span class="entity">mangle</span> <span class="entity">class</span><span class="main">)</span> #&gt;&gt; rpair <span class="entity">typ</span> #&gt;&gt; Free
  <span class="keyword2"><span class="keyword">in</span></span>
    fold_map <span class="entity">dict_param</span> <span class="entity">dicts</span> <span class="entity">context</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_sel</span> <span class="entity">class</span> <span class="entity">param</span> <span class="entity">typ</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">{</span><span class="entity">selectors</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">axclass</span> <span class="entity">class</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup <span class="entity">selectors</span> <span class="entity">param</span> <span class="keyword2"><span class="keyword">of</span></span>
      NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"unknown class parameter "</span> ^ <span class="entity">param</span><span class="main">)</span>
    <span class="main">|</span> SOME <span class="entity">sel</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">sel</span> <span class="entity">typ</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">annotate_const</span> <span class="entity">name</span> <span class="main">(</span><span class="main">(</span><span class="entity">tparams</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">,</span> <span class="entity">raw_eqs</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Code.is_constr</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">then</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">Constructor</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">raw_eqs</span> <span class="keyword2"><span class="keyword">then</span></span>
    <span class="comment1">(* this detection is reliable, because code equations with overloaded heads are not allowed *)</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">class</span><span class="main">)</span> <span class="main">=</span> the_single <span class="entity">tparams</span> ||&gt; the_single
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">selector</span><span class="main">,</span> <span class="entity">thy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_sel</span> <span class="entity">class</span> <span class="entity">name</span> <span class="main">(</span>TVar <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ</span> <span class="main">=</span> range_type <span class="main">(</span>fastype_of <span class="entity">selector</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">Classparam</span> <span class="main">{</span>class <span class="main">=</span> <span class="entity">class</span><span class="main">,</span> typ <span class="main">=</span> <span class="entity">typ</span><span class="main">,</span> selector <span class="main">=</span> <span class="entity">selector</span><span class="main">}</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> try <span class="main">(</span><span class="entity">Function.get_info</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cong</span> <span class="main">=</span> <span class="entity">cong_of_const</span> <span class="entity">lthy</span> <span class="entity">name</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">raw_dicts</span><span class="main">,</span> <span class="entity">certs</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">raw_dict_params</span> <span class="entity">tparams</span> <span class="entity">lthy</span> |&gt;&gt; split_list
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dict_typs</span> <span class="main">=</span> map snd <span class="entity">raw_dicts</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ'</span> <span class="main">=</span> <span class="entity">typify_typ</span> <span class="entity">typ</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eq</span> <span class="main">(</span><span class="main">(</span><span class="entity">raw_params</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">,</span> SOME <span class="entity">thm</span><span class="main">)</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">norm</span> <span class="main">=</span> <span class="entity">normalizer_conv</span> <span class="entity">lthy'</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transform</span> <span class="main">=</span> Thm.cterm_of <span class="entity">lthy'</span> #&gt; <span class="entity">conv_result</span> <span class="entity">norm</span> #&gt; <span class="entity">typify</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span> <span class="main">=</span> map <span class="entity">transform</span> <span class="entity">raw_params</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword2"><span class="keyword">if</span></span> has_duplicates <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>flat <span class="main">(</span>map <span class="entity">all_frees'</span> <span class="entity">params</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="main">(</span>warning <span class="inner_quoted">"ignoring code equation with non-linear pattern"</span><span class="main">;</span> NONE<span class="main">)</span>
              <span class="keyword2"><span class="keyword">else</span></span>
                SOME <span class="main">{</span>params <span class="main">=</span> <span class="entity">params</span><span class="main">,</span> rhs <span class="main">=</span> <span class="entity">rhs</span><span class="main">,</span> thm <span class="main">=</span> Conv.fconv_rule <span class="entity">norm</span> <span class="entity">thm</span><span class="main">}</span>
            <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> <span class="entity">mk_eq</span> <span class="main">_</span> <span class="main">=</span>
            error <span class="inner_quoted">"no theorem"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const</span> <span class="main">=</span>
        <span class="entity">Fun</span>
          <span class="main">{</span>dicts <span class="main">=</span> <span class="entity">raw_dicts</span><span class="main">,</span> certs <span class="main">=</span> <span class="entity">certs</span><span class="main">,</span> typ <span class="main">=</span> <span class="entity">typ'</span><span class="main">,</span> param_typs <span class="main">=</span> binder_types <span class="entity">typ'</span><span class="main">,</span>
           new_typ <span class="main">=</span> <span class="entity">dict_typs</span> ---&gt; <span class="entity">typ'</span><span class="main">,</span> eqs <span class="main">=</span> map_filter <span class="entity">mk_eq</span> <span class="entity">raw_eqs</span><span class="main">,</span> info <span class="main">=</span> <span class="entity">info</span><span class="main">,</span> cong <span class="main">=</span> <span class="entity">cong</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">const</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">annotate_code_eqs</span> <span class="entity">lthy</span> <span class="entity">consts</span> <span class="main">=</span>
  fold_map <span class="main">(</span>fold_map <span class="main">(</span>uncurry <span class="entity">annotate_const</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">group_code_eqs</span> <span class="entity">lthy</span> <span class="entity">consts</span><span class="main">)</span> <span class="entity">lthy</span>

<span class="comment1">(** instances and terms **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_path</span> <span class="main">[</span><span class="main">]</span> <span class="main">_</span> <span class="main">_</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="main">(</span>NONE<span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">mk_path</span> <span class="main">(</span><span class="main">(</span><span class="entity">class</span><span class="main">,</span> <span class="entity">term</span><span class="main">)</span> :: <span class="entity">rest</span><span class="main">)</span> <span class="entity">typ</span> <span class="entity">goal</span> <span class="entity">lthy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ev</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ensure_class</span> <span class="entity">class</span> <span class="entity">lthy</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">find_path</span> <span class="entity">ev</span> <span class="entity">goal</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">path</span> <span class="main">=&gt;</span> <span class="main">(</span>SOME <span class="main">(</span><span class="entity">fold_path</span> <span class="entity">path</span> <span class="entity">typ</span> <span class="entity">term</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span>      <span class="entity">mk_path</span> <span class="entity">rest</span> <span class="entity">typ</span> <span class="entity">goal</span> <span class="entity">lthy'</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">instance</span> <span class="entity">consts</span> <span class="entity">tyco</span> <span class="entity">class</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> Symreltab.lookup <span class="main">(</span><span class="main">#</span>instantiations <span class="main">(</span>Definitions.get <span class="main">(</span>Context.Proof <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">class</span><span class="main">,</span> <span class="entity">tyco</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="main">(</span><span class="entity">inst</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="main">(</span><span class="entity">inst</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tparam_sorts</span> <span class="main">=</span> <span class="entity">param_sorts</span> <span class="entity">tyco</span> <span class="entity">class</span> <span class="entity">thy</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_info</span> <span class="entity">ctxt</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tvars</span> <span class="main">=</span>
              Name.invent_list <span class="main">[</span><span class="main">]</span> Name.aT <span class="main">(</span>length <span class="entity">tparam_sorts</span><span class="main">)</span> ~~ <span class="entity">tparam_sorts</span>
              |&gt; map TFree
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">[</span>Pretty.str <span class="inner_quoted">"Defining instance "</span><span class="main">,</span> Syntax.pretty_typ <span class="entity">ctxt</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">tvars</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
              Pretty.str <span class="inner_quoted">" :: "</span><span class="main">,</span> Syntax.pretty_sort <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">class</span><span class="main">]</span><span class="main">]</span>
            |&gt; Pretty.block
            |&gt; Pretty.writeln
          <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">{</span><span class="entity">make</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">axclass</span> <span class="entity">class</span> <span class="entity">lthy</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="entity">mangle</span> <span class="entity">class</span> ^ <span class="inner_quoted">"__instance__"</span> ^ <span class="entity">mangle</span> <span class="entity">tyco</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tparams</span> <span class="main">=</span> Name.invent_names Name.context Name.aT <span class="entity">tparam_sorts</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">dict_params</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">raw_dict_params</span> <span class="entity">tparams</span> <span class="entity">lthy</span>
          |&gt;&gt; map fst
          |&gt;&gt; <span class="entity">dict_params</span> <span class="main">(</span>Name.make_context <span class="main">[</span><span class="entity">name</span><span class="main">]</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dict_context</span> <span class="main">=</span> Symreltab.make <span class="main">(</span><span class="entity">flat_right</span> <span class="entity">tparams</span> ~~ <span class="entity">dict_params</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">params</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Axclass.get_info</span> <span class="entity">thy</span> <span class="entity">class</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">super_fields</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> fold_map
          <span class="main">(</span><span class="entity">obtain_dict</span> <span class="entity">dict_context</span> <span class="entity">consts</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> map TFree <span class="entity">tparams</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span><span class="entity">super_classes</span> <span class="entity">class</span> <span class="entity">thy</span><span class="main">)</span>
          <span class="entity">lthy</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tparams'</span> <span class="main">=</span> map <span class="main">(</span>TFree o rpair <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span> o fst<span class="main">)</span> <span class="entity">tparams</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_inst</span> <span class="main">=</span> <span class="main">(</span>TFree <span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="main">[</span><span class="entity">class</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">tparams'</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_field</span> <span class="main">(</span><span class="entity">field</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param</span> <span class="main">=</span> <span class="entity">Axclass.param_of_inst</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">field</span><span class="main">,</span> <span class="entity">tyco</span><span class="main">)</span>
            <span class="comment1">(* check: did we already define all required fields? *)</span>
            <span class="comment1">(* if not: abort (else we would run into an infinite loop) *)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup <span class="main">(</span><span class="main">#</span>constants <span class="main">(</span>Definitions.get <span class="main">(</span>Context.Proof <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">param</span> <span class="keyword2"><span class="keyword">of</span></span>
              NONE <span class="main">=&gt;</span>
                <span class="comment1">(* necessary for zero_nat *)</span>
                <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Code.is_constr</span> <span class="entity">thy</span> <span class="entity">param</span> <span class="keyword2"><span class="keyword">then</span></span>
                  <span class="main">(</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">else</span></span>
                  error <span class="main">(</span><span class="inner_quoted">"cyclic dependency: "</span> ^ <span class="entity">param</span> ^ <span class="inner_quoted">" not yet defined in the definition of "</span> ^ <span class="entity">tyco</span> ^ <span class="inner_quoted">" :: "</span> ^ <span class="entity">class</span><span class="main">)</span>
            <span class="main">|</span> SOME <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">term</span> <span class="entity">dict_context</span> <span class="entity">consts</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">param</span><span class="main">,</span> typ_subst_atomic <span class="main">[</span><span class="entity">typ_inst</span><span class="main">]</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span>
           <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fields</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="entity">mk_field</span> <span class="entity">params</span> <span class="entity">lthy</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">make</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">tparams'</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">super_fields</span> @ <span class="entity">fields</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ</span> <span class="main">=</span> map fastype_of <span class="entity">dict_params</span> ---&gt; fastype_of <span class="entity">rhs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="entity">dict_params</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term</span> <span class="main">=</span> Logic.mk_equals <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">def</span><span class="main">,</span> <span class="main">(</span><span class="entity">lthy'</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lthy</span>
          |&gt; tap <span class="entity">print_info</span>
          |&gt; <span class="main">(</span>snd o Local_Theory.begin_nested<span class="main">)</span>
          |&gt; <span class="entity">define_params_nosyn</span> <span class="entity">term</span>
          ||&gt; `Local_Theory.end_nested
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">phi</span> <span class="main">=</span> Proof_Context.export_morphism <span class="entity">lthy</span> <span class="entity">lthy'</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def</span> <span class="main">=</span> Morphism.thm <span class="entity">phi</span> <span class="entity">def</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_thms</span> <span class="main">=</span>
          Definitions.get <span class="main">(</span>Context.Proof <span class="entity">lthy'</span><span class="main">)</span> |&gt; <span class="main">#</span>constants |&gt; Symtab.dest
          |&gt; map <span class="main">(</span>apsnd fst o snd<span class="main">)</span>
          |&gt; map_filter snd

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">target</span> <span class="main">=</span> <span class="main">(</span><span class="entity">flat_right</span> <span class="entity">tparams</span><span class="main">,</span> <span class="main">(</span>Morphism.term <span class="entity">phi</span> <span class="entity">head</span><span class="main">,</span> <span class="entity">tyco</span><span class="main">,</span> <span class="entity">class</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="main">{</span>base_thms <span class="main">=</span> <span class="entity">base_thms</span><span class="main">,</span> def_thm <span class="main">=</span> <span class="entity">def</span><span class="main">}</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">prove_dict_cert</span> <span class="entity">target</span> <span class="entity">args</span> <span class="entity">lthy'</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const</span> <span class="main">=</span> Const <span class="main">(</span>Local_Theory.full_name <span class="entity">lthy'</span> <span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">)</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">const</span><span class="main">,</span> <span class="entity">add_instantiation</span> <span class="main">(</span><span class="entity">class</span><span class="main">,</span> <span class="entity">tyco</span><span class="main">)</span> <span class="entity">const</span> <span class="entity">thm</span> <span class="entity">lthy'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">obtain_dict</span> <span class="entity">dict_context</span> <span class="entity">consts</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dict_context'</span> <span class="main">=</span> Symreltab.dest <span class="entity">dict_context</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">for_class</span> <span class="main">(</span>Type <span class="main">(</span><span class="entity">tyco</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">)</span> <span class="entity">class</span> <span class="entity">lthy</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_param_sorts</span> <span class="main">=</span> <span class="entity">param_sorts</span> <span class="entity">tyco</span> <span class="entity">class</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">raw_inst</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">instance</span> <span class="entity">consts</span> <span class="entity">tyco</span> <span class="entity">class</span> <span class="entity">lthy</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">const_name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> dest_Const <span class="entity">raw_inst</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">inst_args</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="entity">for_sort</span> <span class="main">(</span><span class="entity">inst_param_sorts</span> ~~ <span class="entity">args</span><span class="main">)</span> <span class="entity">lthy'</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head</span> <span class="main">=</span> Sign.mk_const <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy''</span><span class="main">)</span> <span class="main">(</span><span class="entity">const_name</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">head</span><span class="main">,</span> flat <span class="entity">inst_args</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">for_class</span> <span class="main">(</span>TFree <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="entity">class</span> <span class="entity">lthy</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">available</span> <span class="main">=</span> map_filter
              <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">tp</span><span class="main">,</span> <span class="entity">class</span><span class="main">)</span><span class="main">,</span> <span class="entity">term</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">tp</span> <span class="main">=</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="entity">class</span><span class="main">,</span> <span class="entity">term</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> NONE<span class="main">)</span>
              <span class="entity">dict_context'</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">path</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_path</span> <span class="entity">available</span> <span class="main">(</span>TFree <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">type</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span> <span class="entity">class</span> <span class="entity">lthy</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">path</span> <span class="keyword2"><span class="keyword">of</span></span>
              SOME <span class="entity">term</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">term</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
            <span class="main">|</span> NONE <span class="main">=&gt;</span> error <span class="inner_quoted">"no path found"</span>
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">for_class</span> <span class="main">(</span>TVar <span class="main">_</span><span class="main">)</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> error <span class="inner_quoted">"unexpected type variable"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">for_sort</span> <span class="main">(</span><span class="entity">sort</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=</span>
          fold_map <span class="main">(</span><span class="entity">for_class</span> <span class="entity">typ</span><span class="main">)</span> <span class="entity">sort</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">for_class</span> <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">term</span> <span class="entity">dict_context</span> <span class="entity">consts</span> <span class="entity">term</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">traverse</span> <span class="main">(</span><span class="entity">t</span> <span class="keyword1"><span class="keyword">as</span></span> Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup <span class="entity">consts</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"unknown constant "</span> ^ <span class="entity">name</span><span class="main">)</span>
        <span class="main">|</span> SOME <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">Constructor</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="main">(</span><span class="entity">typify</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
        <span class="main">|</span> SOME <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">Classparam</span> <span class="main">{</span><span class="entity">class</span><span class="main">,</span> typ <span class="main">=</span> <span class="entity">typ'</span><span class="main">,</span> <span class="entity">selector</span><span class="main">}</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subst</span> <span class="main">=</span> Sign.typ_match <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span> <span class="main">(</span><span class="entity">typ'</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> Vartab.empty
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">targ</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span>Vartab.lookup <span class="entity">subst</span> <span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">dict</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">obtain_dict</span> <span class="entity">dict_context</span> <span class="entity">consts</span> <span class="entity">targ</span> <span class="entity">class</span> <span class="entity">lthy</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="main">(</span>subst_TVars <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="inner_quoted">"'a"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">targ</span><span class="main">)</span><span class="main">]</span> <span class="entity">selector</span> $ <span class="entity">dict</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> SOME <span class="main">(</span><span class="entity">name'</span><span class="main">,</span> <span class="entity">Fun</span> <span class="main">{</span>dicts <span class="main">=</span> <span class="entity">dicts</span><span class="main">,</span> typ <span class="main">=</span> <span class="entity">typ'</span><span class="main">,</span> <span class="entity">new_typ</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subst</span> <span class="main">=</span> Type.raw_match <span class="main">(</span>Logic.varifyT_global <span class="entity">typ'</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> Vartab.empty
                |&gt; Vartab.dest |&gt; map <span class="main">(</span>apsnd snd<span class="main">)</span>
              <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup</span> <span class="entity">tparam</span> <span class="main">=</span> the <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">subst</span> <span class="main">(</span><span class="entity">tparam</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">dicts</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span>
                fold_map <span class="main">(</span>uncurry <span class="main">(</span><span class="entity">obtain_dict</span> <span class="entity">dict_context</span> <span class="entity">consts</span> o <span class="entity">lookup</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map fst <span class="entity">dicts</span><span class="main">)</span> <span class="entity">lthy</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ</span> <span class="main">=</span> typ_subst_TVars <span class="entity">subst</span> <span class="main">(</span>Logic.varifyT_global <span class="entity">new_typ</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup <span class="main">(</span><span class="main">#</span>constants <span class="main">(</span>Definitions.get <span class="main">(</span>Context.Proof <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">of</span></span>
                  NONE <span class="main">=&gt;</span> Free <span class="main">(</span><span class="entity">name'</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>
                <span class="main">|</span> SOME <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> Const <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="entity">dicts</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="main">(</span><span class="entity">res</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">traverse</span> <span class="main">(</span><span class="entity">f</span> $ <span class="entity">x</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f'</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>  <span class="main">=</span> <span class="entity">traverse</span> <span class="entity">f</span> <span class="entity">lthy</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x'</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">traverse</span> <span class="entity">x</span> <span class="entity">lthy'</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">f'</span> $ <span class="entity">x'</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">traverse</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">,</span> <span class="entity">term</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">term'</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">traverse</span> <span class="entity">term</span> <span class="entity">lthy</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typify_typ</span> <span class="entity">typ</span><span class="main">,</span> <span class="entity">term'</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">traverse</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typify_typ</span> <span class="entity">typ</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">traverse</span> <span class="main">(</span>Var <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>  <span class="main">=</span> <span class="main">(</span>Var <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typify_typ</span> <span class="entity">typ</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">traverse</span> <span class="main">(</span>Bound <span class="entity">n</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="main">(</span>Bound <span class="entity">n</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">traverse</span> <span class="entity">term</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(** group of constants **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">new_names</span> <span class="entity">lthy</span> <span class="entity">consts</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">all_names</span><span class="main">,</span> <span class="entity">all_consts</span><span class="main">)</span> <span class="main">=</span> split_list <span class="main">(</span>flat <span class="entity">consts</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_frees</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">Fun</span> <span class="main">{</span><span class="entity">eqs</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">eqs</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">all_consts</span> |&gt; flat
      |&gt; map <span class="main">#</span>params |&gt; flat
      |&gt; map <span class="entity">all_frees'</span> |&gt; flat
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">context</span> <span class="main">=</span> fold Name.declare <span class="main">(</span><span class="entity">all_names</span> @ <span class="entity">all_frees</span><span class="main">)</span> <span class="main">(</span>Variable.names_of <span class="entity">lthy</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">new_name</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">const</span><span class="main">)</span> <span class="entity">context</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">name'</span><span class="main">,</span> <span class="entity">context'</span><span class="main">)</span> <span class="main">=</span> Name.variant <span class="main">(</span><span class="entity">mangle</span> <span class="entity">name</span><span class="main">)</span> <span class="entity">context</span> <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">(</span><span class="entity">name'</span><span class="main">,</span> <span class="entity">const</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">context'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    fst <span class="main">(</span>fold_map <span class="main">(</span>fold_map <span class="entity">new_name</span><span class="main">)</span> <span class="entity">consts</span> <span class="entity">context</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">consts</span> <span class="entity">consts</span> <span class="entity">proof</span> <span class="entity">group</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fun_config</span> <span class="main">=</span> <span class="entity">Function_Common.FunctionConfig</span>
      <span class="main">{</span>sequential<span class="main">=</span>true<span class="main">,</span> default<span class="main">=</span>NONE<span class="main">,</span> domintros<span class="main">=</span>false<span class="main">,</span> partials<span class="main">=</span>false<span class="main">}</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pat_completeness_auto</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="entity">Pat_Completeness.pat_completeness_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span> THEN <span class="entity">auto_tac</span> <span class="entity">ctxt</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_names</span> <span class="main">=</span> map fst <span class="entity">group</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pretty_consts</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">pretty_const</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">all_names</span> |&gt; Pretty.commas

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_info</span> <span class="entity">msg</span> <span class="main">=</span>
      Pretty.str <span class="main">(</span><span class="entity">msg</span> ^ <span class="inner_quoted">" "</span><span class="main">)</span> :: <span class="entity">pretty_consts</span>
      |&gt; Pretty.block
      |&gt; Pretty.writeln

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">print_info</span> <span class="inner_quoted">"Redefining constant(s)"</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_eqs</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">Fun</span> <span class="main">{</span><span class="entity">dicts</span><span class="main">,</span> <span class="entity">param_typs</span><span class="main">,</span> <span class="entity">new_typ</span><span class="main">,</span> <span class="entity">eqs</span><span class="main">,</span> <span class="entity">info</span><span class="main">,</span> <span class="entity">cong</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup <span class="entity">consts</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">of</span></span>
              NONE <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"no new name for "</span> ^ <span class="entity">name</span><span class="main">)</span>
            <span class="main">|</span> SOME <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">n</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_frees</span> <span class="main">=</span> map <span class="main">#</span>params <span class="entity">eqs</span> |&gt; flat |&gt; map <span class="entity">all_frees'</span> |&gt; flat
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">context</span> <span class="main">=</span> Name.make_context <span class="main">(</span><span class="entity">all_names</span> @ <span class="entity">all_frees</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">dict_params</span><span class="main">,</span> <span class="entity">context'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dict_params</span> <span class="entity">context</span> <span class="entity">dicts</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">adapt_params</span> <span class="entity">param_typs</span> <span class="entity">params</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">real_params</span> <span class="main">=</span> <span class="entity">dict_params</span> @ <span class="entity">params</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ext_params</span> <span class="main">=</span> drop <span class="main">(</span>length <span class="entity">params</span><span class="main">)</span> <span class="entity">param_typs</span>
                  |&gt; map <span class="entity">typify_typ</span>
                  |&gt; Name.invent_names <span class="entity">context'</span> <span class="inner_quoted">"e0"</span> |&gt; map Free
              <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">real_params</span><span class="main">,</span> <span class="entity">ext_params</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eq</span> <span class="main">{</span><span class="entity">params</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="entity">thm</span><span class="main">}</span> <span class="entity">lthy</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">real_params</span><span class="main">,</span> <span class="entity">ext_params</span><span class="main">)</span> <span class="main">=</span> <span class="entity">adapt_params</span> <span class="entity">param_typs</span> <span class="entity">params</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs'</span> <span class="main">=</span> list_comb <span class="main">(</span>Free <span class="main">(</span><span class="entity">new_name</span><span class="main">,</span> <span class="entity">new_typ</span><span class="main">)</span><span class="main">,</span> <span class="entity">real_params</span> @ <span class="entity">ext_params</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">rhs'</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">term</span> <span class="main">(</span>Symreltab.make <span class="main">(</span>map fst <span class="entity">dicts</span> ~~ <span class="entity">dict_params</span><span class="main">)</span><span class="main">)</span> <span class="entity">consts</span> <span class="entity">rhs</span> <span class="entity">lthy</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs''</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">rhs'</span><span class="main">,</span> <span class="entity">ext_params</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="main">(</span><span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs'</span><span class="main">,</span> <span class="entity">rhs''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">end</span></span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_fun</span> <span class="main">=</span> length <span class="entity">param_typs</span> + length <span class="entity">dicts</span> &gt; <span class="inner_numeral">0</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            fold_map <span class="entity">mk_eq</span> <span class="entity">eqs</span> <span class="entity">lthy</span>
            |&gt;&gt; rpair <span class="main">(</span><span class="entity">new_typ</span><span class="main">,</span> <span class="entity">is_fun</span><span class="main">)</span>
            |&gt;&gt; SOME
            |&gt;&gt; pair <span class="main">(</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">new_name</span><span class="main">,</span> map fst <span class="entity">dicts</span><span class="main">)</span><span class="main">,</span> <span class="main">{</span>info <span class="main">=</span> <span class="entity">info</span><span class="main">,</span> cong <span class="main">=</span> <span class="entity">cong</span><span class="main">}</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">process_eqs</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
          <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">name</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">{</span>info <span class="main">=</span> NONE<span class="main">,</span> cong <span class="main">=</span> NONE<span class="main">}</span><span class="main">)</span><span class="main">,</span> NONE<span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">items</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="entity">process_eqs</span> <span class="entity">group</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">metas</span><span class="main">,</span> <span class="entity">infos</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">eqs</span><span class="main">,</span> <span class="entity">code_thms</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">new_typs</span><span class="main">,</span> <span class="entity">is_funs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">items</span>
      |&gt; map_filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">meta</span><span class="main">,</span> <span class="entity">eqs</span><span class="main">)</span> <span class="main">=&gt;</span> Option.map <span class="main">(</span>pair <span class="entity">meta</span><span class="main">)</span> <span class="entity">eqs</span><span class="main">)</span>
      |&gt; split_list
      ||&gt; split_list ||&gt; apfst <span class="main">(</span>flat #&gt; split_list #&gt;&gt; map <span class="entity">typify</span><span class="main">)</span>
      ||&gt; apsnd split_list
      |&gt;&gt; split_list

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">if_debug</span> <span class="entity">lthy</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">code_thms</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        map <span class="main">(</span>Syntax.pretty_term <span class="entity">lthy</span> o Thm.prop_of<span class="main">)</span> <span class="entity">code_thms</span>
        |&gt; Pretty.big_list <span class="inner_quoted">"Equations:"</span>
        |&gt; Pretty.string_of
        |&gt; tracing<span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_fun</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">is_funs</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="entity">b</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">b</span>
      <span class="main">|</span> <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> false
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"unsupported feature: mixed non-function and function definitions"</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_binding</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">new_name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="entity">typ</span> <span class="main">=</span>
      <span class="main">(</span>Binding.name <span class="entity">new_name</span><span class="main">,</span> SOME <span class="entity">typ</span><span class="main">,</span> NoSyn<span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bindings</span> <span class="main">=</span> map2 <span class="entity">mk_binding</span> <span class="entity">metas</span> <span class="entity">new_typs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">constants</span><span class="main">,</span> <span class="entity">instantiations</span><span class="main">}</span> <span class="main">=</span> Definitions.get <span class="main">(</span>Context.Proof <span class="entity">lthy'</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_thms</span> <span class="main">=</span> Symtab.dest <span class="entity">constants</span> |&gt; map <span class="main">(</span>apsnd fst o snd<span class="main">)</span> |&gt; map_filter snd
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_certs</span> <span class="main">=</span> Symreltab.dest <span class="entity">instantiations</span> |&gt; map <span class="main">(</span>snd o snd<span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">consts</span> <span class="main">=</span> Sign.consts_of <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy'</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_eq_fun</span> <span class="main">(</span><span class="entity">info</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span>simps <span class="main">=</span> SOME <span class="entity">simps</span><span class="main">,</span> <span class="entity">fs</span><span class="main">,</span> inducts <span class="main">=</span> SOME <span class="entity">inducts</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_target</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">classes</span><span class="main">)</span> <span class="entity">new</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">classes</span><span class="main">,</span> <span class="main">(</span><span class="entity">new</span><span class="main">,</span> Const <span class="main">(</span>Consts.the_const <span class="entity">consts</span> <span class="entity">name</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">targets</span> <span class="main">=</span> map2 <span class="entity">mk_target</span> <span class="entity">metas</span> <span class="entity">fs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span>
          <span class="main">{</span>fun_info <span class="main">=</span> SOME <span class="entity">info</span><span class="main">,</span> inducts <span class="main">=</span> SOME <span class="entity">inducts</span><span class="main">,</span> simps <span class="main">=</span> <span class="entity">simps</span><span class="main">,</span> base_thms <span class="main">=</span> <span class="entity">base_thms</span><span class="main">,</span>
           base_certs <span class="main">=</span> <span class="entity">base_certs</span><span class="main">,</span> code_thms <span class="main">=</span> <span class="entity">code_thms</span><span class="main">,</span> congs <span class="main">=</span> NONE<span class="main">}</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">prove_fun_cert</span> <span class="entity">targets</span> <span class="entity">args</span> <span class="entity">proof</span> <span class="entity">lthy</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_eq_def</span> <span class="entity">defs</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_target</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">classes</span><span class="main">)</span> <span class="entity">new</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">classes</span><span class="main">,</span> <span class="main">(</span><span class="entity">new</span><span class="main">,</span> Const <span class="main">(</span>Consts.the_const <span class="entity">consts</span> <span class="entity">name</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">targets</span> <span class="main">=</span> map2 <span class="entity">mk_target</span> <span class="entity">metas</span> <span class="main">(</span>map <span class="main">(</span>fst o <span class="entity">HOLogic.dest_eq</span> o <span class="entity">HOLogic.dest_Trueprop</span> o Thm.prop_of<span class="main">)</span> <span class="entity">defs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span>
          <span class="main">{</span>fun_info <span class="main">=</span> NONE<span class="main">,</span> inducts <span class="main">=</span> NONE<span class="main">,</span> simps <span class="main">=</span> <span class="entity">defs</span><span class="main">,</span>
           base_thms <span class="main">=</span> <span class="entity">base_thms</span><span class="main">,</span> base_certs <span class="main">=</span> <span class="entity">base_certs</span><span class="main">,</span> code_thms <span class="main">=</span> <span class="entity">code_thms</span><span class="main">,</span> congs <span class="main">=</span> NONE<span class="main">}</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">prove_fun_cert</span> <span class="entity">targets</span> <span class="entity">args</span> <span class="entity">proof</span> <span class="entity">lthy</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_constants</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">name'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> SOME <span class="main">_</span><span class="main">)</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="entity">thm</span> :: <span class="entity">thms</span><span class="main">)</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">add_constant</span> <span class="entity">name</span> <span class="entity">name'</span> <span class="main">(</span>SOME <span class="entity">thm</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span> #&gt; <span class="entity">add_constants</span> <span class="entity">xs</span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">add_constants</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">name'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> NONE<span class="main">)</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">add_constant</span> <span class="entity">name</span> <span class="entity">name'</span> <span class="main">(</span>NONE<span class="main">,</span> <span class="entity">info</span><span class="main">)</span> #&gt; <span class="entity">add_constants</span> <span class="entity">xs</span> <span class="main">(</span><span class="entity">thms</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">add_constants</span> <span class="main">[</span><span class="main">]</span> <span class="main">_</span> <span class="main">=</span>
          I

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_termination</span> <span class="entity">new_info</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">termination_ctxt</span> <span class="main">=</span>
          <span class="entity">ctxt</span> addsimps <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> equal<span class="antiquote">}</span></span></span> @ <span class="entity">base_thms</span><span class="main">)</span>
            addloop <span class="main">(</span><span class="inner_quoted">"overload"</span><span class="main">,</span> CONVERSION o <span class="entity">changed_conv</span> o <span class="entity">Axclass.overload_conv</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fallback_tac</span> <span class="main">=</span>
          <span class="entity">Function_Common.termination_prover_tac</span> true <span class="entity">termination_ctxt</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> try hd <span class="main">(</span><span class="entity">cat_options</span> <span class="main">(</span>map <span class="main">#</span>info <span class="entity">infos</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          SOME <span class="entity">old_info</span> <span class="main">=&gt;</span> HEADGOAL <span class="main">(</span><span class="entity">Transfer_Termination.termination_tac</span> <span class="entity">new_info</span> <span class="entity">old_info</span> <span class="entity">ctxt</span><span class="main">)</span>
        <span class="main">|</span> NONE <span class="main">=&gt;</span> no_tac

      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">Function.prove_termination</span> NONE <span class="main">(</span><span class="entity">tac</span> ORELSE <span class="entity">fallback_tac</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_cong</span> <span class="entity">data</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewr_cong</span> <span class="entity">thm</span> <span class="entity">cong</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> Thm.nprems_of <span class="entity">thm</span> &gt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">(</span>warning <span class="inner_quoted">"No fundef_cong rule can be derived; this will likely not work later"</span><span class="main">;</span> NONE<span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="main">(</span><span class="entity">print_info</span> <span class="inner_quoted">"Porting fundef_cong rule for "</span><span class="main">;</span>
             SOME <span class="main">(</span>Local_Defs.fold <span class="entity">lthy</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span> <span class="entity">cong</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">congs'</span> <span class="main">=</span>
          map2 <span class="main">(</span>Option.mapPartial o <span class="entity">rewr_cong</span><span class="main">)</span> <span class="main">(</span>fst <span class="entity">data</span><span class="main">)</span> <span class="main">(</span>map <span class="main">#</span>cong <span class="entity">infos</span><span class="main">)</span>
          |&gt; <span class="entity">cat_options</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_congs</span> <span class="entity">phi</span> <span class="main">=</span>
          fold <span class="entity">Function_Context_Tree.add_function_cong</span> <span class="main">(</span>map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">congs'</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data'</span> <span class="main">=</span>
          apsnd <span class="main">(</span><span class="entity">map_const_info</span> I I I I I I <span class="main">(</span>K <span class="main">(</span>SOME <span class="entity">congs'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">data</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">data'</span><span class="main">,</span> Local_Theory.declaration <span class="main">{</span>pervasive <span class="main">=</span> false<span class="main">,</span> syntax <span class="main">=</span> false<span class="main">}</span> <span class="entity">add_congs</span> <span class="entity">lthy</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_fun</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">specs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">eq</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">eq</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">eqs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">Function.add_function</span> <span class="entity">bindings</span> <span class="entity">specs</span> <span class="entity">fun_config</span> <span class="entity">pat_completeness_auto</span> <span class="entity">lthy</span>
          |-&gt; <span class="entity">prove_termination</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simps</span> <span class="main">=</span> the <span class="main">(</span><span class="main">#</span>simps <span class="entity">info</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span> <span class="main">=</span>
          <span class="comment1">(* [simp del] is required because otherwise non-matching function definitions
             (e.g. divmod_nat) make the simplifier loop
             separate step because otherwise we'll get tons of warnings because the psimp rules
             are not added to the simpset *)</span>
          Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">simp</span> del<span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="entity">simps</span><span class="main">)</span> <span class="entity">lthy'</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_eq</span> <span class="entity">phi</span> <span class="main">=</span>
          <span class="entity">prove_eq_fun</span> <span class="main">(</span><span class="entity">Function_Common.transform_function_data</span> <span class="entity">phi</span> <span class="entity">info</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="main">#</span>inducts <span class="entity">info</span><span class="main">)</span><span class="main">,</span> <span class="entity">prove_eq</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy''</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_def</span> <span class="entity">lthy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">defs</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="entity">define_params_nosyn</span> <span class="entity">eqs</span> <span class="entity">lthy</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_eq</span> <span class="entity">phi</span> <span class="main">=</span> <span class="entity">prove_eq_def</span> <span class="main">(</span>map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">defs</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">defs</span><span class="main">,</span> NONE<span class="main">)</span><span class="main">,</span> <span class="entity">prove_eq</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">eqs</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">lthy'</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="comment1">(* the redefinition itself doesn't have a sort constraint, but the equality prop may have
           one; hence the proof needs to happen after exiting the local theory target
           conceptually, everything happening locally would be great, but the type checker won't
           allow us to add sort constraints to TFrees after they have been declared *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">side</span><span class="main">,</span> <span class="entity">prove_eq</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">lthy'</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">lthy'</span>
          |&gt; <span class="main">(</span>snd o Local_Theory.begin_nested<span class="main">)</span>
          |&gt; <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_fun</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_fun</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">mk_def</span><span class="main">)</span>
          |-&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">simps</span><span class="main">,</span> <span class="entity">inducts</span><span class="main">)</span><span class="main">,</span> <span class="entity">prove_eq</span><span class="main">)</span> <span class="main">=&gt;</span>
                apfst <span class="main">(</span>rpair <span class="entity">prove_eq</span><span class="main">)</span> o <span class="entity">Side_Conditions.mk_side</span> <span class="entity">simps</span> <span class="entity">inducts</span><span class="main">)</span>
          ||&gt; `Local_Theory.end_nested
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">phi</span> <span class="main">=</span> Proof_Context.export_morphism <span class="entity">lthy</span> <span class="entity">lthy'</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">lthy'</span>
        |&gt; `<span class="main">(</span><span class="entity">prove_eq</span> <span class="entity">phi</span><span class="main">)</span>
        |&gt;&gt; apfst <span class="main">(</span><span class="entity">on_thms_complete</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">print_info</span> <span class="inner_quoted">"Proved equivalence for"</span><span class="main">)</span><span class="main">)</span>
        |-&gt; <span class="entity">prove_cong</span>
        |-&gt; <span class="entity">add_constants</span> <span class="entity">items</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">const_raw</span> <span class="main">(</span><span class="entity">binding</span><span class="main">,</span> <span class="entity">raw_consts</span><span class="main">)</span> <span class="entity">proof</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">proof</span> <span class="main">=</span> <span class="entity">Skip</span> <span class="keyword2"><span class="keyword">then</span></span>
        warning <span class="inner_quoted">"Skipping certificate proofs"</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Syntax.read_terms <span class="entity">lthy</span> <span class="entity">raw_consts</span> |&gt; map dest_Const |&gt; split_list

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">eqs</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">annotate_code_eqs</span> <span class="entity">lthy</span> <span class="entity">name</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tab</span> <span class="main">=</span> <span class="entity">symtab_of_sccs</span> <span class="main">(</span><span class="entity">new_names</span> <span class="entity">lthy</span> <span class="entity">eqs</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> fold <span class="main">(</span><span class="entity">consts</span> <span class="entity">tab</span> <span class="entity">proof</span><span class="main">)</span> <span class="entity">eqs</span> <span class="entity">lthy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">instantiations</span><span class="main">,</span> <span class="entity">constants</span><span class="main">}</span> <span class="main">=</span> Definitions.get <span class="main">(</span>Context.Proof <span class="entity">lthy</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span>
      map <span class="main">(</span>snd o snd<span class="main">)</span> <span class="main">(</span>Symreltab.dest <span class="entity">instantiations</span><span class="main">)</span> @
        map_filter <span class="main">(</span>fst o snd o snd<span class="main">)</span> <span class="main">(</span>Symtab.dest <span class="entity">constants</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    snd <span class="main">(</span>Local_Theory.note <span class="main">(</span><span class="entity">binding</span><span class="main">,</span> <span class="entity">thms</span><span class="main">)</span> <span class="entity">lthy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(** setup **)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_flags</span> <span class="main">=</span>
  Scan.optional <span class="main">(</span>Args.parens <span class="main">(</span>Parse.reserved <span class="inner_quoted">"skip"</span> &gt;&gt; K <span class="entity">Skip</span><span class="main">)</span><span class="main">)</span> <span class="entity">Cert</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory</span>
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">declassify</span>"<span class="antiquote">}</span></span></span>
    <span class="inner_quoted">"redefines a constant after applying the dictionary construction"</span>
    <span class="main">(</span><span class="entity">parse_flags</span> -- <span class="entity">Parse_Spec.opt_thm_name</span> <span class="inner_quoted">":"</span> -- Scan.repeat1 Parse.const &gt;&gt;
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">flags</span><span class="main">,</span> <span class="entity">def_binding</span><span class="main">)</span><span class="main">,</span> <span class="entity">consts</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">const_raw</span> <span class="main">(</span><span class="entity">def_binding</span><span class="main">,</span> <span class="entity">consts</span><span class="main">)</span> <span class="entity">flags</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Termination">
<div class="head">
<h1>Theory Termination</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Termination heuristics›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:termination}›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Termination
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="Dict_Construction.html">../Dict_Construction</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  As indicated in the introduction, the newly-defined functions must be proven terminating. In
  general, we cannot reuse the original termination proof, as the following example illustrates:
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"f <span class="free">x</span> <span class="main">=</span> f <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The invocation of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory_text</span></span> <span class="raw_text"><span class="raw_text">‹<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">declassify</span></span></span></span> f›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> would fail, because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> f<span class="antiquote"><span class="antiquote">}</span></span></span></span>'s code equations
  are not terminating.

  Hence, in the general case where users have modified the code equations, we need to fall back
  to an (automated) attempt to prove termination.

  In the remainder of this section, we will illustrate the special case where the user has not
  modified the code equations, i.e., the original termination proof should ``morally'' be still
  applicable. For this, we will perform the dictionary construction manually.
›</span></span>

<span class="comment1">― ‹Some ML incantations to ensure that the dictionary types are present›</span>
<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹<span class="entity">Class_Graph.ensure_class</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">class</span> plus<span class="antiquote">}</span></span> #&gt; snd›</span>
<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹<span class="entity">Class_Graph.ensure_class</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">class</span> zero<span class="antiquote">}</span></span> #&gt; snd›</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">sum_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>plus<span class="main">,</span>zero<span class="main">}</span> list <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">sum_list</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">sum_list</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">+</span> <span class="free">sum_list</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The above function carries two distinct class constraints, which are translated into two
  dictionary parameters:
›</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">sum_list'</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">sum_list'</span> <span class="free"><span class="bound"><span class="entity">d_plus</span></span></span> <span class="free"><span class="bound"><span class="entity">d_zero</span></span></span> <span class="main">[]</span> <span class="main">=</span> Groups_zero__class_zero__field <span class="free"><span class="bound"><span class="entity">d_zero</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">sum_list'</span> <span class="free"><span class="bound"><span class="entity">d_plus</span></span></span> <span class="free"><span class="bound"><span class="entity">d_zero</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> Groups_plus__class_plus__field <span class="free"><span class="bound"><span class="entity">d_plus</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free">sum_list'</span> <span class="free"><span class="bound"><span class="entity">d_plus</span></span></span> <span class="free"><span class="bound"><span class="entity">d_zero</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Now, we need to carry out the termination proof of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list'<span class="antiquote"><span class="antiquote">}</span></span></span></span>. The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory_text</span></span> <span class="raw_text"><span class="keyword1"><span class="command"><span class="raw_text"><span class="keyword1"><span class="command">function</span></span></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  package analyzes the function definition and discovers one recursive call. In pseudo-notation:

  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">text</span></span> [display] <span class="raw_text"><span class="raw_text">‹(d_plus, d_zero, x # xs) ↝ (d_plus, d_zero, xs)›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>

  The result of this analysis is captured in the inductive predicate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list'_rel<span class="antiquote"><span class="antiquote">}</span></span></span></span>. Its
  introduction rules look as follows:
›</span></span>

<span class="keyword1"><span class="command">thm</span></span> sum_list'_rel.intros
<span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">thm</span> sum_list'_rel.intros<span class="antiquote">}</span></span>›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Compare this to the relation for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list<span class="antiquote"><span class="antiquote">}</span></span></span></span>:›</span></span>

<span class="keyword1"><span class="command">thm</span></span> sum_list_rel.intros
<span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">thm</span> sum_list_rel.intros<span class="antiquote">}</span></span>›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Except for the additional (unchanging) dictionary arguments, these relations are more or less
  equivalent to each other. There is an important difference, though: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list_rel<span class="antiquote"><span class="antiquote">}</span></span></span></span> has
  sort constraints, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list'_rel<span class="antiquote"><span class="antiquote">}</span></span></span></span> does not. (This will become important later on.)
›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">show_sorts</span><span class="main">]</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">sum_list_rel</span>
<span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">‹<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>plus<span class="main">,</span>zero<span class="main">}</span> list <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>plus<span class="main">,</span>zero<span class="main">}</span> list <span class="main">⇒</span> bool›</span><span class="antiquote">}</span></span>›</span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">sum_list'_rel</span>
<span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">‹<span class="tfree">'a</span><span class="main">::</span>type Groups_plus__dict <span class="main">×</span> <span class="tfree">'a</span><span class="main">::</span>type Groups_zero__dict <span class="main">×</span> <span class="tfree">'a</span><span class="main">::</span>type list <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>type Groups_plus__dict <span class="main">×</span> <span class="tfree">'a</span><span class="main">::</span>type Groups_zero__dict <span class="main">×</span> <span class="tfree">'a</span><span class="main">::</span>type list <span class="main">⇒</span> bool›</span><span class="antiquote">}</span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Let us know discuss the rough concept of the termination proof for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list'<span class="antiquote"><span class="antiquote">}</span></span></span></span>. The goal is
  to show that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list'_rel<span class="antiquote"><span class="antiquote">}</span></span></span></span> is well-founded. Usually, this is proved by specifying a
  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹measure function›</span></span> that
  <span class="antiquoted"><span class="antiquoted">▸</span></span> maps the arguments to natural numbers
  <span class="antiquoted"><span class="antiquoted">▸</span></span> decreases for each recursive call.
›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Here, however, we want to instead show that each recursive call in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list'<span class="antiquote"><span class="antiquote">}</span></span></span></span> has a
  corresponding recursive call in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list<span class="antiquote"><span class="antiquote">}</span></span></span></span>. In other words, we want to show that the
  existing proof of well-foundedness of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list_rel<span class="antiquote"><span class="antiquote">}</span></span></span></span> can be lifted to a proof of
  well-foundedness of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list'_rel<span class="antiquote"><span class="antiquote">}</span></span></span></span>. This is what the theorem
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source=true] wfP_simulate_simple<span class="antiquote"><span class="antiquote">}</span></span></span></span> states:

  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [display=true] wfP_simulate_simple<span class="antiquote"><span class="antiquote">}</span></span></span></span>

  Given any well-founded relation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>r›</span></span></span></span> and a function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>g›</span></span></span></span> that maps function arguments from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>r'›</span></span></span></span> to
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>r›</span></span></span></span>, we can deduce that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>r'›</span></span></span></span> is also well-founded.

  For our example, we need to provide a function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>g›</span></span></span></span> of type
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">‹<span class="tfree"><span class="tfree">'b</span></span> Groups_plus__dict <span class="main"><span class="main">×</span></span> <span class="tfree"><span class="tfree">'b</span></span> Groups_zero__dict <span class="main"><span class="main">×</span></span> <span class="tfree"><span class="tfree">'b</span></span> list <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span> list›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Because the dictionary parameters are not changing, they can safely be dropped by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>g›</span></span></span></span>.
  However, because of the sort constraint in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list_rel<span class="antiquote"><span class="antiquote">}</span></span></span></span>, the term <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"snd <span class="main"><span class="main">∘</span></span> snd"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  is not a well-typed instantiation for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>g›</span></span></span></span>.

  Instead (this is where the heuristic comes in), we assume that the original function
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list<span class="antiquote"><span class="antiquote">}</span></span></span></span> is parametric, i.e., termination does not depend on the elements of the list
  passed to it, but only on the structure of the list. Additionally, we assume that all involved
  type classes have at least one instantiation.

  With this in mind, we can use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"map <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span><span class="main"><span class="main">.</span></span> undefined<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">∘</span></span> snd <span class="main"><span class="main">∘</span></span> snd"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>g›</span></span></span></span>:
›</span></span>

<span class="keyword1"><span class="command">thm</span></span> wfP_simulate_simple<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span>
  r <span class="main"><span class="main">=</span></span> <span class="quoted">sum_list_rel</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span>
  r' <span class="main"><span class="main">=</span></span> <span class="quoted">sum_list'_rel</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span>
  g <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> undefined<span class="main">)</span> <span class="main">∘</span> snd <span class="main">∘</span> snd"</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Finally, we can prove the termination of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sum_list'<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">termination</span></span> <span class="quoted">sum_list'</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"wfP sum_list'_rel"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> wfP_simulate_simple<span class="main">)</span>
    <span class="comment1">― ‹We first need to obtain the well-foundedness theorem for <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> sum_list_rel<span class="antiquote">}</span></span> from the ML
        guts of the <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">theory_text</span> <span class="raw_text"><span class="keyword1"><span class="command">function</span></span></span><span class="antiquote">}</span></span> package.›</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"wfP sum_list_rel"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> accp_wfPI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹resolve_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">Function.get_info</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">sum_list</span><span class="antiquote">}</span></span> |&gt; <span class="main">#</span>totality |&gt; the<span class="main">]</span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> Groups_plus__dict <span class="main">×</span> <span class="tfree">'b</span> Groups_zero__dict <span class="main">×</span> <span class="tfree">'b</span> list <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span><span class="main">{</span>plus<span class="main">,</span>zero<span class="main">}</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> undefined<span class="main">)</span> <span class="main">∘</span> snd <span class="main">∘</span> snd"</span></span>

    <span class="comment1">― ‹Prove the simulation of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> sum_list'_rel<span class="antiquote">}</span></span> by <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> sum_list_rel<span class="antiquote">}</span></span> by rule induction.›</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sum_list_rel <span class="main">(</span><span class="skolem">g</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"sum_list'_rel <span class="skolem">x</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
      <span class="keyword1"><span class="command">using</span></span> that
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sum_list'_rel.induct<span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">d_plus</span> <span class="skolem">d_zero</span> <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
          <span class="comment1">― ‹Unfold the constituent parts of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="skolem">g</span></span><span class="antiquote">}</span></span>:›</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> g_def comp_apply snd_conv list.map<span class="main">)</span>
          <span class="comment1">― ‹Use the corresponding introduction rule of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> sum_list_rel<span class="antiquote">}</span></span> and hope for the best:›</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum_list_rel.intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="comment1">― ‹This is the goal that the <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">theory_text</span> <span class="raw_text"><span class="keyword1"><span class="command">function</span></span></span><span class="antiquote">}</span></span> package expects.›</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> sum_list'_dom <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> wfP_implies_dom<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This can be automated with a special tactic:›</span></span>

<span class="keyword1"><span class="command">experiment</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">termination</span></span> <span class="quoted">sum_list'</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹
    <span class="entity">Transfer_Termination.termination_tac</span>
      <span class="main">(</span><span class="entity">Function.get_info</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">sum_list'</span><span class="antiquote">}</span></span><span class="main">)</span>
      <span class="main">(</span><span class="entity">Function.get_info</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">sum_list</span><span class="antiquote">}</span></span><span class="main">)</span>
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
      <span class="inner_numeral">1</span>›</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A similar technique can be used for making functions defined in locales executable when, for some
  reason, the definition of a ``defs'' locale is not feasible.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> foo <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">f</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">0</span> <span class="main">=</span> <span class="free">A</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span><span class="free">f</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

<span class="comment1">― ‹We carry out this proof in the locale for simplicity; a real implementation would probably
    have to set up a local theory properly.›</span>
<span class="keyword1"><span class="command">lemma</span></span> f_total<span class="main">:</span> <span class="quoted"><span class="quoted">"wfP f_rel"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> accp_wfPI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹resolve_tac <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">Function.get_info</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">f</span><span class="antiquote">}</span></span> |&gt; <span class="main">#</span>totality |&gt; the<span class="main">]</span> <span class="inner_numeral">1</span>›</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">― ‹The dummy interpretation serves the same purpose as the assumption that class constraints have
    at least one instantiation.›</span>
<span class="keyword1"><span class="command">interpretation</span></span> dummy<span class="main">:</span> foo <span class="quoted"><span class="main">1</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">f'</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">f'</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">0</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">f'</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span><span class="free">f'</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">termination</span></span> <span class="quoted">f'</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wfP_implies_dom<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wfP_simulate_simple<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"snd"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> dummy.f_total<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x y
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> f'_rel.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> snd_conv<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> dummy.f_rel.intros<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Automatic:›</span></span>

<span class="keyword1"><span class="command">experiment</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">termination</span></span> <span class="quoted">f'</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹
    <span class="entity">Transfer_Termination.termination_tac</span>
      <span class="main">(</span><span class="entity">Function.get_info</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">f'</span><span class="antiquote">}</span></span><span class="main">)</span>
      <span class="main">(</span><span class="entity">Function.get_info</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">dummy.f</span><span class="antiquote">}</span></span><span class="main">)</span>
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
      <span class="inner_numeral">1</span>›</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Test_Dict_Construction">
<div class="head">
<h1>Theory Test_Dict_Construction</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Test cases for dictionary construction›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Test_Dict_Construction
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Dict_Construction.html">Dict_Construction</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/ListVector.html">HOL-Library.ListVector</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Code equations with different number of explicit arguments›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"fold <span class="free">f</span> <span class="main">[]</span> <span class="main">=</span> id"</span></span> <span class="quoted"><span class="quoted">"fold <span class="free">f</span> <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> fold <span class="free">f</span> <span class="free">xs</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"fold <span class="free">f</span> <span class="main">[</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">]</span> <span class="free">u</span> <span class="main">≡</span> <span class="free">f</span> <span class="free">y</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span> <span class="free">u</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">declassify</span></span> valid<span class="main">:</span> <span class="quoted">fold</span>
  <span class="keyword1"><span class="command">thm</span></span> valid
  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"List_fold <span class="main">=</span> fold"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> valid<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Complex class hierarchies›</span></span>

<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹<span class="entity">Class_Graph.ensure_class</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">class</span> zero<span class="antiquote">}</span></span> #&gt; snd›</span>
<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹<span class="entity">Class_Graph.ensure_class</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">class</span> plus<span class="antiquote">}</span></span> #&gt; snd›</span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹<span class="entity">Class_Graph.ensure_class</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">class</span> comm_monoid_add<span class="antiquote">}</span></span> #&gt; snd›</span>
  <span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹<span class="entity">Class_Graph.ensure_class</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">class</span> ring<span class="antiquote">}</span></span> #&gt; snd›</span>

  <span class="keyword1"><span class="command">typ</span></span> <span class="quoted"><span class="quoted">"nat Rings_ring__dict"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Check that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Class_Graph›</span></span></span></span> does not leak out of locales›</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹<span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">assert</span><span class="antiquote">}</span></span></span></span> <span class="main">(</span>is_none <span class="main">(</span><span class="entity">Class_Graph.node</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">class</span> ring<span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span>›</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Instances with non-trivial arity›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>plus <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>plus<span class="main">,</span>zero<span class="main">}</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> f <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> natt <span class="main">=</span> Z <span class="main">|</span> S <span class="quoted">natt</span>

<span class="keyword1"><span class="command">instantiation</span></span> natt <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>zero<span class="main">,</span>plus<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">zero_natt</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">zero_natt</span> <span class="main">=</span> Z"</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">plus_natt</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">plus_natt</span> Z <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">plus_natt</span> <span class="main">(</span>S <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> S <span class="main">(</span><span class="free">plus_natt</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"natt list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> g <span class="main">[</span>Z<span class="main">,</span>S Z<span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* FIXME problem with smart_tac *)</span>
<span class="keyword1"><span class="command">declassify</span></span> valid<span class="main">:</span> <span class="quoted">h</span>
<span class="keyword1"><span class="command">thm</span></span> valid
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"Test__Dict__Construction_h <span class="main">=</span> h"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> valid<span class="main">)</span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹<span class="entity">Dict_Construction.the_info</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> plus_natt_inst.plus_natt<span class="antiquote">}</span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Check that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> declassify<span class="antiquote"><span class="antiquote">}</span></span></span></span> does not leak out of locales›</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
  can <span class="main">(</span><span class="entity">Dict_Construction.the_info</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span><span class="main">)</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> plus_natt_inst.plus_natt<span class="antiquote">}</span></span>
  |&gt; not |&gt; <span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">assert</span><span class="antiquote">}</span></span></span></span>
›</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">attribute</span></span> fundef_cong<span class="antiquote"><span class="antiquote">}</span></span></span></span>] rules›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> seq <span class="main">=</span> Cons <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> seq"</span></span> <span class="main">|</span> Nil

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declassify</span></span> <span class="quoted">map_seq</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Check presence of derived [<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">attribute</span></span> fundef_cong<span class="antiquote"><span class="antiquote">}</span></span></span></span>] rule›</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
  <span class="entity">Dict_Construction.the_info</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> map_seq<span class="antiquote">}</span></span>
  |&gt; <span class="main">#</span>fun_info
  |&gt; the
  |&gt; <span class="main">#</span>fs
  |&gt; the_single
  |&gt; dest_Const
  |&gt; fst
  |&gt; <span class="entity">Dict_Construction.cong_of_const</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
  |&gt; the
›</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Mutual recursion›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">odd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">even</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">odd</span> <span class="main">0</span> <span class="main">⟷</span> False"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">even</span> <span class="main">0</span> <span class="main">⟷</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">odd</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">even</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">even</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">odd</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declassify</span></span> valid<span class="main">:</span> <span class="quoted">odd</span> <span class="quoted">even</span>
<span class="keyword1"><span class="command">thm</span></span> valid

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> bin_tree <span class="main">=</span> Leaf <span class="main">|</span> Node <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bin_tree"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> bin_tree"</span></span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declassify</span></span> valid<span class="main">:</span> <span class="quoted">map_bin_tree</span> <span class="quoted">rel_bin_tree</span>
<span class="keyword1"><span class="command">thm</span></span> valid

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'v</span> env <span class="main">=</span> Env <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> list"</span></span>
<span class="keyword1"><span class="command">datatype</span></span> v <span class="main">=</span> Closure <span class="quoted"><span class="quoted">"v env"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> is_measure_trivial<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"size_env size"</span></span><span class="main">,</span> <span class="operator">measure_function</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* FIXME order is important! *)</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">test_v</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"v <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">test_w</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"v env <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">test_v</span> <span class="main">(</span>Closure <span class="free"><span class="bound"><span class="entity">env</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">test_w</span> <span class="free"><span class="bound"><span class="entity">env</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">test_w</span> <span class="main">(</span>Env <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">⟷</span> list_all <span class="free">test_v</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">test_v1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"v <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>one<span class="main">,</span>monoid_add<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">test_w1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"v env <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">test_v1</span> <span class="main">(</span>Closure <span class="free"><span class="bound"><span class="entity">env</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> <span class="free">test_w1</span> <span class="free"><span class="bound"><span class="entity">env</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">test_w1</span> <span class="main">(</span>Env <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">=</span> sum_list <span class="main">(</span>map <span class="free">test_v1</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declassify</span></span> valid<span class="main">:</span> <span class="quoted">test_w</span> <span class="quoted">test_v</span>
<span class="keyword1"><span class="command">thm</span></span> valid

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* FIXME derive fundef_cong rule for sum_list *)</span>
<span class="keyword1"><span class="command">declassify</span></span> valid<span class="main">:</span> <span class="quoted">test_w1</span> <span class="quoted">test_v1</span>
<span class="keyword1"><span class="command">thm</span></span> valid

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Non-trivial code dependencies; code equations where the head is not fully general›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">≡</span> <span class="main">0</span> <span class="main">::</span> nat"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> contrived<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"c <span class="main">=</span> d <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> c_def d_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declassify</span></span> valid<span class="main">:</span> <span class="quoted">c</span>
<span class="keyword1"><span class="command">thm</span></span> valid
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"Test__Dict__Construction_c <span class="main">=</span> c"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> valid<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Pattern matching on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">0</span></span><span class="main"><span class="main">::</span></span>nat"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">j</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"j <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"j <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> j <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> j_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">k</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">0</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">k</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> f_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"k <span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declassify</span></span> valid<span class="main">:</span> <span class="quoted">j</span> <span class="quoted">k</span>
<span class="keyword1"><span class="command">thm</span></span> valid
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"Test__Dict__Construction_j <span class="main">=</span> j"</span></span>
  <span class="quoted"><span class="quoted">"Test__Dict__Construction_k <span class="main">=</span> k"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> valid<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Complex termination arguments›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">fac</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">fac</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≤</span> <span class="main">1</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">*</span> <span class="free">fac</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declassify</span></span> valid<span class="main">:</span> <span class="quoted">fac</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Combination of various things›</span></span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declassify</span></span> valid<span class="main">:</span> <span class="quoted">sum_list</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Interaction with the code generator›</span></span>

<span class="keyword1"><span class="command">declassify</span></span> <span class="quoted">h</span>
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">Test__Dict__Construction_h</span></span> <span class="keyword2"><span class="keyword">in</span></span> SML


<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Test_Side_Conditions">
<div class="head">
<h1>Theory Test_Side_Conditions</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Contrived side conditions›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Test_Side_Conditions
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Dict_Construction.html">Dict_Construction</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_alt_total</span> <span class="entity">ctxt</span> <span class="entity">term</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">assert</span><span class="antiquote">}</span></span></span></span> <span class="main">(</span><span class="entity">Side_Conditions.is_total</span> <span class="entity">ctxt</span> <span class="entity">term</span><span class="main">)</span>
›</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">head</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">head</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹snd o <span class="entity">Side_Conditions.mk_side</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> head.simps<span class="antiquote">}</span></span></span> NONE›</span>

<span class="keyword1"><span class="command">lemma</span></span> head_side_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"head_side <span class="free">xs</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> head_side.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> head_side.cases<span class="main">)</span>

<span class="keyword1"><span class="command">declaration</span></span> <span class="quoted">‹K <span class="main">(</span><span class="entity">Side_Conditions.set_alt</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">head</span><span class="antiquote">}</span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> head_side_eq<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">map</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">map</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">map</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free">map</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹snd o <span class="entity">Side_Conditions.mk_side</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> map.simps<span class="antiquote">}</span></span></span> <span class="main">(</span>SOME <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> map.induct<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">thm</span></span> map_side.intros

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹<span class="entity">assert_alt_total</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">map</span><span class="antiquote">}</span></span>›</span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Functions that use partial functions always in their domain are processed correctly.›</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">tail</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">tail</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹snd o <span class="entity">Side_Conditions.mk_side</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> tail.simps<span class="antiquote">}</span></span></span> NONE›</span>

  <span class="keyword1"><span class="command">lemma</span></span> tail_side_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"tail_side <span class="free">xs</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> tail_side.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> tail_side.cases<span class="main">)</span>

  <span class="keyword1"><span class="command">declaration</span></span> <span class="quoted">‹K <span class="main">(</span><span class="entity">Side_Conditions.set_alt</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">tail</span><span class="antiquote">}</span></span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> tail_side_eq<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>

  <span class="keyword1"><span class="command">function</span></span> <span class="entity">map'</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map'</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>head <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free">map'</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>tail <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">termination</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>size <span class="main">∘</span> snd<span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> f xs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹snd o <span class="entity">Side_Conditions.mk_side</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> map'.simps<span class="antiquote">}</span></span></span> <span class="main">(</span>SOME <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> map'.induct<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>
  <span class="keyword1"><span class="command">thm</span></span> map'_side.intros

  <span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹<span class="entity">assert_alt_total</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">map'</span><span class="antiquote">}</span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="free">ys</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map <span class="free">f</span> <span class="free">xs</span> <span class="main">=</span> map <span class="free">g</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>1<span class="main">)</span>
<span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_head</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">map_head</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> map head <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">declare</span></span> map_cong<span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span>

  <span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹snd o <span class="entity">Side_Conditions.mk_side</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> map_head_def<span class="antiquote">}</span></span></span> NONE›</span>
  <span class="keyword1"><span class="command">thm</span></span> map_head_side.intros

  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"map_head_side <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set <span class="free">xs</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_head_side.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> map_head_side.cases<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_head'</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_head'</span> <span class="free"><span class="bound"><span class="entity">xss</span></span></span> <span class="main">=</span> map <span class="main">(</span>map head<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xss</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹snd o <span class="entity">Side_Conditions.mk_side</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> map_head'_def<span class="antiquote">}</span></span></span> NONE›</span>
  <span class="keyword1"><span class="command">thm</span></span> map_head'_side.intros

  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"map_head'_side <span class="free">xss</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">xs</span> <span class="main">∈</span> set <span class="free">xss</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set <span class="bound">xs</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_head'_side.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> map_head'_side.cases<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹snd o <span class="entity">Side_Conditions.mk_side</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> map_head_def<span class="antiquote">}</span></span></span> NONE›</span>
  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">map_head_side</span>
  <span class="keyword1"><span class="command">thm</span></span> map_head_side.intros

  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> map_head_side <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> map_head_side.cases<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">head_known</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">head_known</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> head <span class="main">(</span><span class="numeral">3</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹snd o <span class="entity">Side_Conditions.mk_side</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> head_known_def<span class="antiquote">}</span></span></span> NONE›</span>
<span class="keyword1"><span class="command">thm</span></span> head_known_side.intros

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹<span class="entity">assert_alt_total</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">head_known</span><span class="antiquote">}</span></span>›</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">odd</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">even</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">odd</span> <span class="main">0</span> <span class="main">⟷</span> False"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">even</span> <span class="main">0</span> <span class="main">⟷</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">odd</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">even</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">even</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">odd</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>

<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹snd o <span class="entity">Side_Conditions.mk_side</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> odd.simps even.simps<span class="antiquote">}</span></span></span> <span class="main">(</span>SOME <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> odd_even.induct<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">thm</span></span> odd_side_even_side.intros

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹<span class="entity">assert_alt_total</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">odd</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹<span class="entity">assert_alt_total</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">even</span><span class="antiquote">}</span></span>›</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">odd_known</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">odd_known</span> <span class="main">=</span> odd <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹snd o <span class="entity">Side_Conditions.mk_side</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> odd_known_def<span class="antiquote">}</span></span></span> NONE›</span>
<span class="keyword1"><span class="command">thm</span></span> odd_known_side.intros

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹<span class="entity">assert_alt_total</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">odd_known</span><span class="antiquote">}</span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Test_Lazy_Case">
<div class="head">
<h1>Theory Test_Lazy_Case</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Interaction with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Lazy_Case›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Test_Lazy_Case
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Dict_Construction.html">Dict_Construction</a>
  <a href="../Lazy_Case/Lazy_Case.html">Lazy_Case.Lazy_Case</a>
  <a href="../Show/Show_Instances.html">Show.Show_Instances</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> tree <span class="main">=</span> Node <span class="main">|</span> Fork <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree list"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_tree<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_tree <span class="free">f</span> <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">t</span> <span class="keyword1">of</span> Node <span class="main">⇒</span> Node <span class="main">|</span> Fork <span class="bound">x</span> <span class="bound">ts</span> <span class="main">⇒</span> Fork <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>map <span class="main">(</span>map_tree <span class="free">f</span><span class="main">)</span> <span class="bound">ts</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* FIXME proper qualified path *)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Dictionary construction of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> map_tree<span class="antiquote"><span class="antiquote">}</span></span></span></span> requires the [<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">attribute</span></span> fundef_cong<span class="antiquote"><span class="antiquote">}</span></span></span></span>] rule of
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Test_Lazy_Case.tree.case_lazy<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">declassify</span></span> valid<span class="main">:</span> <span class="quoted">map_tree</span>
<span class="keyword1"><span class="command">thm</span></span> valid

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"Test__Lazy__Case_tree_map__tree <span class="main">=</span> map_tree"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> valid<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">i</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit <span class="main">×</span> <span class="main">(</span>bool list <span class="main">×</span> string <span class="main">×</span> nat option<span class="main">)</span> list<span class="main">)</span> option <span class="main">⇒</span> string"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">=</span> show"</span></span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This currently requires <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../Lazy_Case/Lazy_Case.html"></a><a href="../Lazy_Case/Lazy_Case.html">Lazy_Case.Lazy_Case</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> because of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> divmod_nat<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="comment1">(* FIXME get rid of Lazy_Case dependency *)</span>
<span class="keyword1"><span class="command">declassify</span></span> valid<span class="main">:</span> <span class="quoted">i</span>
<span class="keyword1"><span class="command">thm</span></span> valid

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"Test__Lazy__Case_i <span class="main">=</span> i"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> valid<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>