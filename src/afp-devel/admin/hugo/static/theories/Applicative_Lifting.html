<div id="Applicative">
<div class="head">
<h1>Theory Applicative</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Lifting with applicative functors›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"applicative"</span> <span class="main">::</span> thy_goal <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"print_applicative"</span> <span class="main">::</span> diag
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Equality restricted to a set›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eq_on</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">eq_on</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rel_fun_eq_onI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟹</span> <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> rel_fun <span class="main">(</span>eq_on <span class="free">A</span><span class="main">)</span> <span class="free">R</span> <span class="free">f</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> rel_fun_map_fun2<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_fun <span class="main">(</span>eq_on <span class="main">(</span>range <span class="free">h</span><span class="main">)</span><span class="main">)</span> <span class="free">A</span> <span class="free">f</span> <span class="free">g</span> <span class="main">⟹</span> rel_fun <span class="main">(</span>BNF_Def.Grp UNIV <span class="free">h</span><span class="main">)</span><span class="main">¯¯</span> <span class="free">A</span> <span class="free">f</span> <span class="main">(</span>map_fun <span class="free">h</span> id <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def Grp_def eq_onp_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rel_fun_refl_eq_onp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">z</span><span class="main">.</span> <span class="bound">z</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">`</span> <span class="free">X</span> <span class="main">⟹</span> <span class="free">A</span> <span class="bound">z</span> <span class="bound">z</span><span class="main">)</span> <span class="main">⟹</span> rel_fun <span class="main">(</span>eq_on <span class="free">X</span><span class="main">)</span> <span class="free">A</span> <span class="free">f</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def eq_onp_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eq_onE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> eq_on <span class="free">X</span> <span class="free">a</span> <span class="free">b</span><span class="main">;</span> <span class="main">⟦</span> <span class="free">b</span> <span class="main">∈</span> <span class="free">X</span><span class="main">;</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">thesis</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">thesis</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> Domainp_eq_on <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Domainp <span class="main">(</span>eq_on <span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Proof automation›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> arg1_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">f</span> <span class="free">x</span> <span class="free">z</span> <span class="main">=</span> <span class="free">f</span> <span class="free">y</span> <span class="free">z</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> UNIV_E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> UNIV <span class="main">⟹</span> <span class="free">P</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">named_theorems</span></span> combinator_unfold
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">named_theorems</span></span> combinator_repr

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">K</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">W</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">abs_def</span><span class="main">,</span> <span class="operator">combinator_unfold</span><span class="main">]</span> <span class="main">=</span> B_def C_def I_def K_def S_def T_def W_def
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">combinator_repr</span><span class="main">]</span> <span class="main">=</span> <span class="dynamic"><span class="dynamic">combinator_unfold</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cpair</span> <span class="main">≡</span> Pair"</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cuncurry</span> <span class="main">≡</span> case_prod"</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> uncurry_pair<span class="main">:</span> <span class="quoted"><span class="quoted">"cuncurry <span class="free">f</span> <span class="main">(</span>cpair <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> cpair_def cuncurry_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">"applicative.ML"</span>

<span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹<span class="entity">Applicative.setup_combinators</span>
 <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"B"</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> B_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"C"</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> C_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"I"</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> I_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"K"</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> K_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"S"</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> S_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"T"</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> T_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"W"</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> W_def<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">]</span>›</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">attribute_setup</span></span> combinator_eq <span class="main">=</span>
  <span class="quoted">‹Scan.lift <span class="main">(</span>Scan.option <span class="main">(</span>Args.$$$ <span class="inner_quoted">"weak"</span> |--
    Scan.optional <span class="main">(</span>Args.colon |-- Scan.repeat1 Args.name<span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> &gt;&gt;
    <span class="entity">Applicative.combinator_rule_attrib</span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">combinator_eq</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"B <span class="main">≡</span> S <span class="main">(</span>K S<span class="main">)</span> K"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">combinator_unfold</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">combinator_eq</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"C <span class="main">≡</span> S <span class="main">(</span>S <span class="main">(</span>K <span class="main">(</span>S <span class="main">(</span>K S<span class="main">)</span> K<span class="main">)</span><span class="main">)</span> S<span class="main">)</span> <span class="main">(</span>K K<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">combinator_unfold</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">combinator_eq</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"I <span class="main">≡</span> W K"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">combinator_unfold</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">combinator_eq</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"I <span class="main">≡</span> C K <span class="main">()</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">combinator_unfold</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">combinator_eq</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"S <span class="main">≡</span> B <span class="main">(</span>B W<span class="main">)</span> <span class="main">(</span>B B C<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">combinator_unfold</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">combinator_eq</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"T <span class="main">≡</span> C I"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">combinator_unfold</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">combinator_eq</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"W <span class="main">≡</span> S S <span class="main">(</span>S K<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">combinator_unfold</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">combinator_eq</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">weak</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> C<span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"C <span class="main">≡</span> C <span class="main">(</span>B B <span class="main">(</span>B B <span class="main">(</span>B W <span class="main">(</span>C <span class="main">(</span>B C <span class="main">(</span>B <span class="main">(</span>B B<span class="main">)</span> <span class="main">(</span>C B <span class="main">(</span>cuncurry <span class="main">(</span>K I<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>cuncurry K<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> cpair"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">combinator_unfold</span></span> uncurry_pair <span class="keyword1"><span class="command">.</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* context *)</span>


<span class="keyword1"><span class="command">method_setup</span></span> applicative_unfold <span class="main">=</span>
  <span class="quoted">‹<span class="entity">Applicative.parse_opt_afun</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">opt_af</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
    <span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span><span class="entity">Applicative.unfold_wrapper_tac</span> <span class="entity">ctxt</span> <span class="entity">opt_af</span><span class="main">)</span><span class="main">)</span>›</span>
  <span class="quoted">"unfold into an applicative expression"</span>

<span class="keyword1"><span class="command">method_setup</span></span> applicative_fold <span class="main">=</span>
  <span class="quoted">‹<span class="entity">Applicative.parse_opt_afun</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">opt_af</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
    <span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span><span class="entity">Applicative.fold_wrapper_tac</span> <span class="entity">ctxt</span> <span class="entity">opt_af</span><span class="main">)</span><span class="main">)</span>›</span>
  <span class="quoted">"fold an applicative expression"</span>

<span class="keyword1"><span class="command">method_setup</span></span> applicative_nf <span class="main">=</span>
  <span class="quoted">‹<span class="entity">Applicative.parse_opt_afun</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">opt_af</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
    <span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span><span class="entity">Applicative.normalize_wrapper_tac</span> <span class="entity">ctxt</span> <span class="entity">opt_af</span><span class="main">)</span><span class="main">)</span>›</span>
  <span class="quoted">"prove an equation that has been lifted to an applicative functor, using normal forms"</span>

<span class="keyword1"><span class="command">method_setup</span></span> applicative_lifting <span class="main">=</span>
  <span class="quoted">‹<span class="entity">Applicative.parse_opt_afun</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">opt_af</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
    <span class="entity">SIMPLE_METHOD'</span> <span class="main">(</span><span class="entity">Applicative.lifting_wrapper_tac</span> <span class="entity">ctxt</span> <span class="entity">opt_af</span><span class="main">)</span><span class="main">)</span>›</span>
  <span class="quoted">"prove an equation that has been lifted to an applicative functor"</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹<span class="entity">Outer_Syntax.local_theory_to_proof</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">applicative</span>"<span class="antiquote">}</span></span></span>
  <span class="inner_quoted">"register applicative functors"</span>
  <span class="main">(</span>Parse.binding --
    Scan.optional <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">(</span>"<span class="antiquote">}</span></span></span> |-- Parse.list Parse.short_ident --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">)</span>"<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> --
    <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">for</span>"<span class="antiquote">}</span></span></span> |-- Parse.reserved <span class="inner_quoted">"pure"</span> |-- <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">:</span>"<span class="antiquote">}</span></span></span> |-- Parse.term<span class="main">)</span> --
    <span class="main">(</span>Parse.reserved <span class="inner_quoted">"ap"</span> |-- <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">:</span>"<span class="antiquote">}</span></span></span> |-- Parse.term<span class="main">)</span> --
    Scan.option <span class="main">(</span>Parse.reserved <span class="inner_quoted">"rel"</span> |-- <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">:</span>"<span class="antiquote">}</span></span></span> |-- Parse.term<span class="main">)</span> --
    Scan.option <span class="main">(</span>Parse.reserved <span class="inner_quoted">"set"</span> |-- <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">:</span>"<span class="antiquote">}</span></span></span> |-- Parse.term<span class="main">)</span> &gt;&gt;
    <span class="entity">Applicative.applicative_cmd</span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹<span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">print_applicative</span>"<span class="antiquote">}</span></span></span>
  <span class="inner_quoted">"print registered applicative functors"</span>
  <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">Toplevel.keep</span> <span class="main">(</span><span class="entity">Applicative.print_afuns</span> o <span class="entity">Toplevel.context_of</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">attribute_setup</span></span> applicative_unfold <span class="main">=</span>
  <span class="quoted">‹Scan.lift <span class="main">(</span>Scan.option Parse.name &gt;&gt; <span class="entity">Applicative.add_unfold_attrib</span><span class="main">)</span>›</span>
  <span class="quoted">"register rules for unfolding into applicative expressions"</span>

<span class="keyword1"><span class="command">attribute_setup</span></span> applicative_lifted <span class="main">=</span>
  <span class="quoted">‹Scan.lift <span class="main">(</span>Parse.name &gt;&gt; <span class="entity">Applicative.forward_lift_attrib</span><span class="main">)</span>›</span>
  <span class="quoted">"lift an equation to an applicative functor"</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Overloaded applicative operators›</span></span>

<span class="keyword1"><span class="command">consts</span></span>
  pure <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
  ap <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span>"</span></span>

<span class="keyword1"><span class="command">bundle</span></span> applicative_syntax
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">notation</span></span> ap <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⋄</span>"</span> 70<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> ap

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/applicative.ML">
<div class="head">
<h1>File ‹applicative.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">APPLICATIVE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">afun</span>
  <span class="keyword1"><span class="keyword">val</span></span> intern<span class="main">:</span> Context.generic <span class="main">-&gt;</span> xstring <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> extern<span class="main">:</span> Context.generic <span class="main">-&gt;</span> string <span class="main">-&gt;</span> xstring
  <span class="keyword1"><span class="keyword">val</span></span> afun_of_generic<span class="main">:</span> Context.generic <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">afun</span>
  <span class="keyword1"><span class="keyword">val</span></span> afun_of<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">afun</span>
  <span class="keyword1"><span class="keyword">val</span></span> afuns_of_term_generic<span class="main">:</span> Context.generic <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">afun</span> list
  <span class="keyword1"><span class="keyword">val</span></span> afuns_of_term<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">afun</span> list
  <span class="keyword1"><span class="keyword">val</span></span> afuns_of_typ_generic<span class="main">:</span> Context.generic <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> <span class="entity">afun</span> list
  <span class="keyword1"><span class="keyword">val</span></span> afuns_of_typ<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> <span class="entity">afun</span> list
  <span class="keyword1"><span class="keyword">val</span></span> name_of_afun<span class="main">:</span> <span class="entity">afun</span> <span class="main">-&gt;</span> binding
  <span class="keyword1"><span class="keyword">val</span></span> unfolds_of_afun<span class="main">:</span> <span class="entity">afun</span> <span class="main">-&gt;</span> thm list

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">afun_inst</span>
  <span class="keyword1"><span class="keyword">val</span></span> match_afun_inst<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun</span> <span class="main">-&gt;</span> term * int <span class="main">-&gt;</span> <span class="entity">afun_inst</span>
  <span class="keyword1"><span class="keyword">val</span></span> import_afun_inst<span class="main">:</span> <span class="entity">afun</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun_inst</span> * <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> inner_sort_of<span class="main">:</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> sort
  <span class="keyword1"><span class="keyword">val</span></span> mk_type<span class="main">:</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> mk_pure<span class="main">:</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> lift_term<span class="main">:</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_ap<span class="main">:</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> typ * typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_comb<span class="main">:</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_set<span class="main">:</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> dest_type<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> typ option
  <span class="keyword1"><span class="keyword">val</span></span> dest_type'<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> dest_pure<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> dest_comb<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term * term
  <span class="keyword1"><span class="keyword">val</span></span> infer_comb<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> subst_lift_term<span class="main">:</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> <span class="main">(</span>term * term<span class="main">)</span> list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> generalize_lift_terms<span class="main">:</span> <span class="entity">afun_inst</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list * <span class="entity">Proof.context</span>

  <span class="keyword1"><span class="keyword">val</span></span> afun_unfold_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> afun_fold_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> unfold_all_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> normalform_conv<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> normalize_rel_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> general_normalform_conv<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun</span> <span class="main">-&gt;</span> cterm * cterm <span class="main">-&gt;</span> thm * thm
  <span class="keyword1"><span class="keyword">val</span></span> general_normalize_rel_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> forward_lift_rule<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> unfold_wrapper_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun</span> option <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> fold_wrapper_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun</span> option <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> normalize_wrapper_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun</span> option <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic
  <span class="keyword1"><span class="keyword">val</span></span> lifting_wrapper_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">afun</span> option <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic

  <span class="keyword1"><span class="keyword">val</span></span> setup_combinators<span class="main">:</span> <span class="main">(</span>string * thm<span class="main">)</span> list <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory
  <span class="keyword1"><span class="keyword">val</span></span> combinator_rule_attrib<span class="main">:</span> string list option <span class="main">-&gt;</span> attribute
  <span class="keyword1"><span class="keyword">val</span></span> parse_opt_afun<span class="main">:</span> <span class="entity">afun</span> option context_parser
  <span class="keyword1"><span class="keyword">val</span></span> applicative_cmd<span class="main">:</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span>binding * string list<span class="main">)</span> * string<span class="main">)</span> * string<span class="main">)</span> * string option<span class="main">)</span> * string option<span class="main">)</span> <span class="main">-&gt;</span>
    local_theory <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
  <span class="keyword1"><span class="keyword">val</span></span> print_afuns<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> add_unfold_attrib<span class="main">:</span> xstring option <span class="main">-&gt;</span> attribute
  <span class="keyword1"><span class="keyword">val</span></span> forward_lift_attrib<span class="main">:</span> xstring <span class="main">-&gt;</span> attribute
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Applicative</span> <span class="main">:</span> <span class="entity">APPLICATIVE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword3"><span class="keyword">open</span></span> Ctr_Sugar_Util

<span class="comment1">(** General utilities **)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fold_options</span> <span class="entity">xs</span> <span class="main">=</span> fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="entity">x'</span> <span class="main">=&gt;</span> cons <span class="entity">x'</span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span> I<span class="main">)</span><span class="main">)</span> <span class="entity">xs</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">the_pair</span> <span class="main">[</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">]</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">the_pair</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> General.Size<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_comb2</span> <span class="main">(</span><span class="entity">f</span> $ <span class="entity">x</span> $ <span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">strip_comb2</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"strip_comb2"</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_comb_pattern</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> take <span class="entity">n</span> <span class="main">(</span>binder_types <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">maxidx</span> <span class="main">=</span> maxidx_of_term <span class="entity">t</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span>Name.uu<span class="main">,</span> <span class="entity">maxidx</span> + <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">Ts</span> ~~ <span class="main">(</span><span class="inner_numeral">1</span> upto <span class="entity">n</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> Term.betapplys <span class="main">(</span><span class="entity">t</span><span class="main">,</span> map Var <span class="entity">vars</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_comb_pattern</span> <span class="entity">ctxt</span> <span class="entity">tn</span> <span class="entity">u</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">pat</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_comb_pattern</span> <span class="entity">tn</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">envs</span> <span class="main">=</span> Pattern.match <span class="entity">thy</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">(</span>Vartab.empty<span class="main">,</span> Vartab.empty<span class="main">)</span>
      <span class="keyword3"><span class="keyword">handle</span></span> Pattern.MATCH <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"match_comb_pattern"</span><span class="main">,</span> <span class="main">[</span><span class="entity">u</span><span class="main">,</span> <span class="entity">pat</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">envs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_comb_pattern</span> <span class="entity">ctxt</span> <span class="entity">tn</span> <span class="entity">u</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">env</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">match_comb_pattern</span> <span class="entity">ctxt</span> <span class="entity">tn</span> <span class="entity">u</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> map <span class="main">(</span>the o Envir.lookup1 <span class="entity">env</span><span class="main">)</span> <span class="entity">vars</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_term_types</span> <span class="entity">tyenv</span> <span class="entity">t</span> <span class="main">=</span> Term_Subst.map_types_same <span class="main">(</span>Envir.norm_type_same <span class="entity">tyenv</span><span class="main">)</span> <span class="entity">t</span>
  <span class="keyword3"><span class="keyword">handle</span></span> Same.SAME <span class="main">=&gt;</span> <span class="entity">t</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_TFrees_of</span> <span class="main">=</span> <span class="entity">mk_TFrees'</span> oo replicate<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_Free</span> <span class="entity">name</span> <span class="entity">typ</span> <span class="entity">ctxt</span> <span class="main">=</span> yield_singleton Variable.variant_fixes <span class="entity">name</span> <span class="entity">ctxt</span>
  |&gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">name'</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="entity">name'</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(*tuples with explicit sentinel*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tuple'</span> <span class="entity">ts</span> <span class="main">=</span> fold_rev <span class="main">(</span>curry <span class="entity">HOLogic.mk_prod</span><span class="main">)</span> <span class="entity">ts</span> <span class="entity">HOLogic.unit</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_tuple'</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Unity<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">strip_tuple'</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pair<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">t1</span> $ <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t1</span> :: <span class="entity">strip_tuple'</span> <span class="entity">t2</span>
  <span class="main">|</span> <span class="entity">strip_tuple'</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"strip_tuple'"</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eq_on</span> <span class="entity">S</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">SA</span><span class="main">,</span> <span class="entity">ST</span><span class="main">)</span> <span class="main">=</span> `<span class="entity">HOLogic.dest_setT</span> <span class="main">(</span>fastype_of <span class="entity">S</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> eq_on<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">ST</span> --&gt; <span class="entity">BNF_Util.mk_pred2T</span> <span class="entity">SA</span> <span class="entity">SA</span><span class="main">)</span> $ <span class="entity">S</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(* Polymorphic terms and term groups *)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">poly_type</span> <span class="main">=</span> typ list * typ<span class="main">;</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">poly_term</span> <span class="main">=</span> typ list * term<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">instantiate_poly_type</span> <span class="main">(</span><span class="entity">tvars</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">insts</span> <span class="main">=</span> typ_subst_atomic <span class="main">(</span><span class="entity">tvars</span> ~~ <span class="entity">insts</span><span class="main">)</span> <span class="entity">T</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">instantiate_poly_term</span> <span class="main">(</span><span class="entity">tvars</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="entity">insts</span> <span class="main">=</span> subst_atomic_types <span class="main">(</span><span class="entity">tvars</span> ~~ <span class="entity">insts</span><span class="main">)</span> <span class="entity">t</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_poly_type</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">tvars</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">U</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyenv</span> <span class="main">=</span> Sign.typ_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> Vartab.empty
      <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TYPE <span class="main">(</span><span class="inner_quoted">"dest_poly_type"</span><span class="main">,</span> <span class="main">[</span><span class="entity">U</span><span class="main">,</span> <span class="entity">T</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> map <span class="main">(</span>Type.lookup <span class="entity">tyenv</span> o dest_TVar<span class="main">)</span> <span class="entity">tvars</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">poly_type_to_term</span> <span class="main">(</span><span class="entity">tvars</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">tvars</span><span class="main">,</span> Logic.mk_type <span class="entity">T</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">poly_type_of_term</span> <span class="main">(</span><span class="entity">tvars</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">tvars</span><span class="main">,</span> Logic.dest_type <span class="entity">t</span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(*
  Schematic variables are treated uniformly in packed terms, thus forming an ad hoc context
  of type variables. Otherwise, morphisms are allowed to rename schematic variables
  non-consistently in separate terms, and occasionally will do so.
*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pack_poly_term</span> <span class="main">(</span><span class="entity">tvars</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.mk_prod</span> <span class="main">(</span><span class="entity">mk_tuple'</span> <span class="main">(</span>map Logic.mk_type <span class="entity">tvars</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unpack_poly_term</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tvars</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.dest_prod</span> <span class="entity">t</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>map Logic.dest_type <span class="main">(</span><span class="entity">strip_tuple'</span> <span class="entity">tvars</span><span class="main">)</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pack_poly_terms</span> <span class="main">=</span> <span class="entity">mk_tuple'</span> o map <span class="entity">pack_poly_term</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unpack_poly_terms</span> <span class="main">=</span> map <span class="entity">unpack_poly_term</span> o <span class="entity">strip_tuple'</span><span class="main">;</span>

<span class="comment1">(*match and instantiate schematic type variables which are not "quantified" in the packed term*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_poly_terms_type</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pt</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">(</span><span class="entity">U</span><span class="main">,</span> <span class="entity">maxidx</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pt'</span> <span class="main">=</span> Logic.incr_indexes <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">maxidx</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">pt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tvars</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> <span class="entity">poly_type_of_term</span> <span class="main">(</span>nth <span class="main">(</span><span class="entity">unpack_poly_terms</span> <span class="entity">pt'</span><span class="main">)</span> <span class="entity">i</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyenv</span> <span class="main">=</span> Sign.typ_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> Vartab.empty
      <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TYPE <span class="main">(</span><span class="inner_quoted">"match_poly_terms"</span><span class="main">,</span> <span class="main">[</span><span class="entity">U</span><span class="main">,</span> <span class="entity">T</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyenv'</span> <span class="main">=</span> fold Vartab.delete_safe <span class="main">(</span>map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> o dest_TVar<span class="main">)</span> <span class="entity">tvars</span><span class="main">)</span> <span class="entity">tyenv</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pt''</span> <span class="main">=</span> Envir.subst_term_types <span class="entity">tyenv'</span> <span class="entity">pt'</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">unpack_poly_terms</span> <span class="entity">pt''</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_poly_terms</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pt</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">maxidx</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">match_poly_terms_type</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pt</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">,</span> <span class="entity">maxidx</span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(*fix schematic type variables which are not "quantified", as well as schematic term variables*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">import_poly_terms</span> <span class="entity">pt</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">insert_paramTs</span> <span class="main">(</span><span class="entity">tvars</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> fold_types <span class="main">(</span>fold_atyps
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> TVar <span class="entity">v</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">tvars</span> <span class="main">(</span>TVar <span class="entity">v</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> I <span class="keyword2"><span class="keyword">else</span></span> insert <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">v</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> I<span class="main">)</span><span class="main">)</span> <span class="entity">t</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">paramTs</span> <span class="main">=</span> rev <span class="main">(</span>fold <span class="entity">insert_paramTs</span> <span class="main">(</span><span class="entity">unpack_poly_terms</span> <span class="entity">pt</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tfrees</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.invent_types <span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">paramTs</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">instT</span> <span class="main">=</span> <span class="entity">paramTs</span> ~~ map TFree <span class="entity">tfrees</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span>Term_Subst.instantiateT <span class="entity">instT</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>rev <span class="main">(</span>Term.add_vars <span class="entity">pt</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">frees</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="main">(</span>map <span class="main">(</span>Name.clean o <span class="main">#</span><span class="inner_numeral">1</span> o <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">params</span><span class="main">)</span> <span class="entity">ctxt'</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> <span class="entity">params</span> ~~ map Free <span class="main">(</span><span class="entity">frees</span> ~~ map <span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">params</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pt'</span> <span class="main">=</span> Term_Subst.instantiate <span class="main">(</span><span class="entity">instT</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="entity">pt</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">unpack_poly_terms</span> <span class="entity">pt'</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(** Internal representation **)</span>

<span class="comment1">(* Applicative functors *)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">rel_thms</span> <span class="main">=</span> <span class="main">{</span>
  pure_transfer<span class="main">:</span> thm<span class="main">,</span>
  ap_rel_fun<span class="main">:</span> thm
<span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_rel_thms</span> <span class="entity">f</span> <span class="main">{</span><span class="entity">pure_transfer</span><span class="main">,</span> <span class="entity">ap_rel_fun</span><span class="main">}</span> <span class="main">=</span>
  <span class="main">{</span>pure_transfer <span class="main">=</span> <span class="entity">f</span> <span class="entity">pure_transfer</span><span class="main">,</span> ap_rel_fun <span class="main">=</span> <span class="entity">f</span> <span class="entity">ap_rel_fun</span><span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">afun_thms</span> <span class="main">=</span> <span class="main">{</span>
  hom<span class="main">:</span> thm<span class="main">,</span>
  ichng<span class="main">:</span> thm<span class="main">,</span>
  reds<span class="main">:</span> thm Symtab.table<span class="main">,</span>
  rel_thms<span class="main">:</span> <span class="entity">rel_thms</span> option<span class="main">,</span>
  rel_intros<span class="main">:</span> thm list<span class="main">,</span>
  pure_comp_conv<span class="main">:</span> thm
<span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_afun_thms</span> <span class="entity">f</span> <span class="main">{</span><span class="entity">hom</span><span class="main">,</span> <span class="entity">ichng</span><span class="main">,</span> <span class="entity">reds</span><span class="main">,</span> <span class="entity">rel_thms</span><span class="main">,</span> <span class="entity">rel_intros</span><span class="main">,</span> <span class="entity">pure_comp_conv</span><span class="main">}</span> <span class="main">=</span>
  <span class="main">{</span>hom <span class="main">=</span> <span class="entity">f</span> <span class="entity">hom</span><span class="main">,</span> ichng <span class="main">=</span> <span class="entity">f</span> <span class="entity">ichng</span><span class="main">,</span> reds <span class="main">=</span> Symtab.map <span class="main">(</span>K <span class="entity">f</span><span class="main">)</span> <span class="entity">reds</span><span class="main">,</span>
    rel_thms <span class="main">=</span> Option.map <span class="main">(</span><span class="entity">map_rel_thms</span> <span class="entity">f</span><span class="main">)</span> <span class="entity">rel_thms</span><span class="main">,</span> rel_intros <span class="main">=</span> map <span class="entity">f</span> <span class="entity">rel_intros</span><span class="main">,</span>
    pure_comp_conv <span class="main">=</span> <span class="entity">f</span> <span class="entity">pure_comp_conv</span><span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">afun</span> <span class="main">=</span> <span class="entity">AFun</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">{</span>
  name<span class="main">:</span> binding<span class="main">,</span>
  terms<span class="main">:</span> term<span class="main">,</span>
  rel<span class="main">:</span> term option<span class="main">,</span>
  thms<span class="main">:</span> afun_thms<span class="main">,</span>
  unfolds<span class="main">:</span> thm Item_Net.T
<span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rep_afun</span> <span class="main">(</span><span class="entity">AFun</span> <span class="entity">af</span><span class="main">)</span> <span class="main">=</span> <span class="entity">af</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name_of_afun</span> <span class="main">=</span> <span class="main">#</span>name o <span class="entity">rep_afun</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">terms_of_afun</span> <span class="main">=</span> <span class="main">#</span>terms o <span class="entity">rep_afun</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rel_of_afun</span> <span class="main">=</span> <span class="main">#</span>rel o <span class="entity">rep_afun</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms_of_afun</span> <span class="main">=</span> <span class="main">#</span>thms o <span class="entity">rep_afun</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unfolds_of_afun</span> <span class="main">=</span> Item_Net.content o <span class="main">#</span>unfolds o <span class="entity">rep_afun</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">red_of_afun</span> <span class="main">=</span> Symtab.lookup o <span class="main">#</span>reds o <span class="entity">thms_of_afun</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">has_red_afun</span> <span class="main">=</span> is_some oo <span class="entity">red_of_afun</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_afun</span> <span class="entity">name</span> <span class="entity">terms</span> <span class="entity">rel</span> <span class="entity">thms</span> <span class="main">=</span>
  <span class="entity">AFun</span> <span class="main">{</span>name <span class="main">=</span> <span class="entity">name</span><span class="main">,</span> terms <span class="main">=</span> <span class="entity">terms</span><span class="main">,</span> rel <span class="main">=</span> <span class="entity">rel</span><span class="main">,</span> thms <span class="main">=</span> <span class="entity">thms</span><span class="main">,</span> unfolds <span class="main">=</span> Thm.full_rules<span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_afun</span> <span class="entity">f1</span> <span class="entity">f2</span> <span class="entity">f3</span> <span class="entity">f4</span> <span class="entity">f5</span> <span class="main">(</span><span class="entity">AFun</span> <span class="main">{</span><span class="entity">name</span><span class="main">,</span> <span class="entity">terms</span><span class="main">,</span> <span class="entity">rel</span><span class="main">,</span> <span class="entity">thms</span><span class="main">,</span> <span class="entity">unfolds</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">AFun</span> <span class="main">{</span>name <span class="main">=</span> <span class="entity">f1</span> <span class="entity">name</span><span class="main">,</span> terms <span class="main">=</span> <span class="entity">f2</span> <span class="entity">terms</span><span class="main">,</span> rel <span class="main">=</span> <span class="entity">f3</span> <span class="entity">rel</span><span class="main">,</span> thms <span class="main">=</span> <span class="entity">f4</span> <span class="entity">thms</span><span class="main">,</span> unfolds <span class="main">=</span> <span class="entity">f5</span> <span class="entity">unfolds</span><span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_unfolds</span> <span class="entity">f</span> <span class="entity">thms</span> <span class="main">=</span> fold Item_Net.update <span class="main">(</span>map <span class="entity">f</span> <span class="main">(</span>Item_Net.content <span class="entity">thms</span><span class="main">)</span><span class="main">)</span> Thm.full_rules<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">morph_afun</span> <span class="entity">phi</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">binding</span> <span class="main">=</span> Morphism.binding <span class="entity">phi</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term</span> <span class="main">=</span> Morphism.term <span class="entity">phi</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> Morphism.thm <span class="entity">phi</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">map_afun</span> <span class="entity">binding</span> <span class="entity">term</span> <span class="main">(</span>Option.map <span class="entity">term</span><span class="main">)</span> <span class="main">(</span><span class="entity">map_afun_thms</span> <span class="entity">thm</span><span class="main">)</span> <span class="main">(</span><span class="entity">map_unfolds</span> <span class="entity">thm</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transfer_afun</span> <span class="main">=</span> <span class="entity">morph_afun</span> o Morphism.transfer_morphism<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_unfolds_afun</span> <span class="entity">thms</span> <span class="main">=</span> <span class="entity">map_afun</span> I I I I <span class="main">(</span>fold Item_Net.update <span class="entity">thms</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">patterns_of_afun</span> <span class="entity">af</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">[</span><span class="entity">Tt</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">pure</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ap</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">]</span> <span class="main">=</span> <span class="entity">unpack_poly_terms</span> <span class="main">(</span><span class="entity">terms_of_afun</span> <span class="entity">af</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> <span class="entity">poly_type_of_term</span> <span class="entity">Tt</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">[</span><span class="main">#</span><span class="inner_numeral">2</span> <span class="main">(</span><span class="entity">mk_comb_pattern</span> <span class="main">(</span><span class="entity">pure</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">#</span><span class="inner_numeral">2</span> <span class="main">(</span><span class="entity">mk_comb_pattern</span> <span class="main">(</span><span class="entity">ap</span><span class="main">,</span> <span class="inner_numeral">2</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> Net.encode_type <span class="entity">T</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(* Combinator rules *)</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">combinator_rule</span> <span class="main">=</span> <span class="entity">Combinator_Rule</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">{</span>
  strong_premises<span class="main">:</span> string Ord_List.T<span class="main">,</span>
  weak_premises<span class="main">:</span> bool<span class="main">,</span>
  conclusion<span class="main">:</span> string<span class="main">,</span>
  eq_thm<span class="main">:</span> thm
<span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rep_combinator_rule</span> <span class="main">(</span><span class="entity">Combinator_Rule</span> <span class="entity">rule</span><span class="main">)</span> <span class="main">=</span> <span class="entity">rule</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conclusion_of_rule</span> <span class="main">=</span> <span class="main">#</span>conclusion o <span class="entity">rep_combinator_rule</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm_of_rule</span> <span class="main">=</span> <span class="main">#</span>eq_thm o <span class="entity">rep_combinator_rule</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_combinator_rule</span> <span class="main">(</span><span class="entity">rule1</span><span class="main">,</span> <span class="entity">rule2</span><span class="main">)</span> <span class="main">=</span>
  pointer_eq <span class="main">(</span><span class="entity">rule1</span><span class="main">,</span> <span class="entity">rule2</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span> Thm.eq_thm <span class="main">(</span><span class="entity">thm_of_rule</span> <span class="entity">rule1</span><span class="main">,</span> <span class="entity">thm_of_rule</span> <span class="entity">rule2</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_applicable_rule</span> <span class="entity">rule</span> <span class="entity">have_weak</span> <span class="entity">have_premises</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">strong_premises</span><span class="main">,</span> <span class="entity">weak_premises</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">rep_combinator_rule</span> <span class="entity">rule</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">have_weak</span> <span class="keyword1"><span class="keyword">orelse</span></span> not <span class="entity">weak_premises</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">have_premises</span> <span class="entity">strong_premises</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_combinator_rule</span> <span class="entity">f1</span> <span class="entity">f2</span> <span class="entity">f3</span> <span class="entity">f4</span>
  <span class="main">(</span><span class="entity">Combinator_Rule</span> <span class="main">{</span><span class="entity">strong_premises</span><span class="main">,</span> <span class="entity">weak_premises</span><span class="main">,</span> <span class="entity">conclusion</span><span class="main">,</span> <span class="entity">eq_thm</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">Combinator_Rule</span> <span class="main">{</span>strong_premises <span class="main">=</span> <span class="entity">f1</span> <span class="entity">strong_premises</span><span class="main">,</span> weak_premises <span class="main">=</span> <span class="entity">f2</span> <span class="entity">weak_premises</span><span class="main">,</span>
      conclusion <span class="main">=</span> <span class="entity">f3</span> <span class="entity">conclusion</span><span class="main">,</span> eq_thm <span class="main">=</span> <span class="entity">f4</span> <span class="entity">eq_thm</span><span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transfer_combinator_rule</span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">map_combinator_rule</span> I I I <span class="main">(</span>Thm.transfer <span class="entity">thy</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_combinator_rule</span> <span class="entity">comb_names</span> <span class="entity">weak_premises</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Logic.dest_equals <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conclusion</span> <span class="main">=</span> the <span class="main">(</span>Symtab.lookup <span class="entity">comb_names</span> <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> <span class="main">(</span>dest_Const <span class="entity">lhs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">premises</span> <span class="main">=</span> Ord_List.make fast_string_ord
      <span class="main">(</span><span class="entity">fold_options</span> <span class="main">(</span>map <span class="main">(</span>Symtab.lookup <span class="entity">comb_names</span> o <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span>Term.add_consts <span class="entity">rhs</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">weak_premises'</span> <span class="main">=</span> Ord_List.make fast_string_ord <span class="main">(</span>these <span class="entity">weak_premises</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">strong_premises</span> <span class="main">=</span> Ord_List.subtract fast_string_ord <span class="entity">weak_premises'</span> <span class="entity">premises</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">Combinator_Rule</span> <span class="main">{</span>strong_premises <span class="main">=</span> <span class="entity">strong_premises</span><span class="main">,</span> weak_premises <span class="main">=</span> is_some <span class="entity">weak_premises</span><span class="main">,</span>
    conclusion <span class="main">=</span> <span class="entity">conclusion</span><span class="main">,</span> eq_thm <span class="main">=</span> <span class="entity">thm</span><span class="main">}</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(* Generic data *)</span>

<span class="comment1">(*FIXME: needs tests, especially around theory merging*)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge_afuns</span> <span class="main">_</span> <span class="main">(</span><span class="entity">af1</span><span class="main">,</span> <span class="entity">af2</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> pointer_eq <span class="main">(</span><span class="entity">af1</span><span class="main">,</span> <span class="entity">af2</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Change_Table.SAME
  <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">map_afun</span> I I I I <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thms1</span> <span class="main">=&gt;</span> Item_Net.merge <span class="main">(</span><span class="entity">thms1</span><span class="main">,</span> <span class="main">#</span>unfolds <span class="main">(</span><span class="entity">rep_afun</span> <span class="entity">af2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">af1</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Generic_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">{</span>
    combinators<span class="main">:</span> thm Symtab.table * <span class="entity">combinator_rule</span> list<span class="main">,</span>
    afuns<span class="main">:</span> <span class="entity">afun</span> Name_Space.table<span class="main">,</span>
    patterns<span class="main">:</span> <span class="main">(</span>string * term list<span class="main">)</span> Item_Net.T
  <span class="main">}</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> <span class="main">{</span>
    combinators <span class="main">=</span> <span class="main">(</span>Symtab.empty<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
    afuns <span class="main">=</span> Name_Space.empty_table <span class="inner_quoted">"applicative functor"</span><span class="main">,</span>
    patterns <span class="main">=</span> Item_Net.init <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span> o apply2 <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="main">#</span><span class="inner_numeral">2</span>
  <span class="main">}</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="main">(</span><span class="main">{</span>combinators <span class="main">=</span> <span class="main">(</span><span class="entity">cd1</span><span class="main">,</span> <span class="entity">cr1</span><span class="main">)</span><span class="main">,</span> afuns <span class="main">=</span> <span class="entity">a1</span><span class="main">,</span> patterns <span class="main">=</span> <span class="entity">p1</span><span class="main">}</span><span class="main">,</span>
             <span class="main">{</span>combinators <span class="main">=</span> <span class="main">(</span><span class="entity">cd2</span><span class="main">,</span> <span class="entity">cr2</span><span class="main">)</span><span class="main">,</span> afuns <span class="main">=</span> <span class="entity">a2</span><span class="main">,</span> patterns <span class="main">=</span> <span class="entity">p2</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">{</span>combinators <span class="main">=</span> <span class="main">(</span>Symtab.merge <span class="main">(</span>K true<span class="main">)</span> <span class="main">(</span><span class="entity">cd1</span><span class="main">,</span> <span class="entity">cd2</span><span class="main">)</span><span class="main">,</span> Library.merge <span class="entity">eq_combinator_rule</span> <span class="main">(</span><span class="entity">cr1</span><span class="main">,</span> <span class="entity">cr2</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
      afuns <span class="main">=</span> Name_Space.join_tables <span class="entity">merge_afuns</span> <span class="main">(</span><span class="entity">a1</span><span class="main">,</span> <span class="entity">a2</span><span class="main">)</span><span class="main">,</span>
      patterns <span class="main">=</span> Item_Net.merge <span class="main">(</span><span class="entity">p1</span><span class="main">,</span> <span class="entity">p2</span><span class="main">)</span><span class="main">}</span><span class="main">;</span>
<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_combinators</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Context.theory_of <span class="entity">context</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>combinators <span class="main">=</span> <span class="main">(</span><span class="entity">defs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">context</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>Symtab.map <span class="main">(</span>K <span class="main">(</span>Thm.transfer <span class="entity">thy</span><span class="main">)</span><span class="main">)</span> <span class="entity">defs</span><span class="main">,</span> map <span class="main">(</span><span class="entity">transfer_combinator_rule</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">rules</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_afun_table</span> <span class="main">=</span> <span class="main">#</span>afuns o Data.get<span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_afun_space</span> <span class="main">=</span> Name_Space.space_of_table o <span class="entity">get_afun_table</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_patterns</span> <span class="main">=</span> <span class="main">#</span>patterns o Data.get<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_data</span> <span class="entity">f1</span> <span class="entity">f2</span> <span class="entity">f3</span> <span class="main">{</span><span class="entity">combinators</span><span class="main">,</span> <span class="entity">afuns</span><span class="main">,</span> <span class="entity">patterns</span><span class="main">}</span> <span class="main">=</span>
  <span class="main">{</span>combinators <span class="main">=</span> <span class="entity">f1</span> <span class="entity">combinators</span><span class="main">,</span> afuns <span class="main">=</span> <span class="entity">f2</span> <span class="entity">afuns</span><span class="main">,</span> patterns <span class="main">=</span> <span class="entity">f3</span> <span class="entity">patterns</span><span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intern</span> <span class="main">=</span> Name_Space.intern o <span class="entity">get_afun_space</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">extern</span> <span class="entity">context</span> <span class="main">=</span> Name_Space.extern <span class="main">(</span>Context.proof_of <span class="entity">context</span><span class="main">)</span> <span class="main">(</span><span class="entity">get_afun_space</span> <span class="entity">context</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">local</span></span> <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">undeclared</span> <span class="entity">name</span> <span class="main">=</span> error <span class="main">(</span><span class="inner_quoted">"Undeclared applicative functor "</span> ^ quote <span class="entity">name</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">afun_of_generic</span> <span class="entity">context</span> <span class="entity">name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Name_Space.lookup <span class="main">(</span><span class="entity">get_afun_table</span> <span class="entity">context</span><span class="main">)</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="entity">af</span> <span class="main">=&gt;</span> <span class="entity">transfer_afun</span> <span class="main">(</span>Context.theory_of <span class="entity">context</span><span class="main">)</span> <span class="entity">af</span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">undeclared</span> <span class="entity">name</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">afun_of</span> <span class="main">=</span> <span class="entity">afun_of_generic</span> o Context.Proof<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_afun</span> <span class="entity">name</span> <span class="entity">f</span> <span class="entity">context</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Name_Space.defined <span class="main">(</span><span class="entity">get_afun_table</span> <span class="entity">context</span><span class="main">)</span> <span class="entity">name</span>
  <span class="keyword2"><span class="keyword">then</span></span> Data.map <span class="main">(</span><span class="entity">map_data</span> I <span class="main">(</span>Name_Space.map_table_entry <span class="entity">name</span> <span class="entity">f</span><span class="main">)</span> I<span class="main">)</span> <span class="entity">context</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">undeclared</span> <span class="entity">name</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_term</span> <span class="entity">context</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">1</span> o Item_Net.retrieve_matching <span class="main">(</span><span class="entity">get_patterns</span> <span class="entity">context</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_typ</span> <span class="entity">context</span> <span class="main">=</span> <span class="entity">match_term</span> <span class="entity">context</span> o Net.encode_type<span class="main">;</span>

<span class="comment1">(*works only with terms which are combinations of pure and ap*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">afuns_of_term_generic</span> <span class="entity">context</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">afun_of_generic</span> <span class="entity">context</span><span class="main">)</span> o <span class="entity">match_term</span> <span class="entity">context</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">afuns_of_term</span> <span class="main">=</span> <span class="entity">afuns_of_term_generic</span> o Context.Proof<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">afuns_of_typ_generic</span> <span class="entity">context</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">afun_of_generic</span> <span class="entity">context</span><span class="main">)</span> o <span class="entity">match_typ</span> <span class="entity">context</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">afuns_of_typ</span> <span class="main">=</span> <span class="entity">afuns_of_typ_generic</span> o Context.Proof<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_unfolds_of_generic</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unfolds_of</span> <span class="main">=</span> map <span class="main">(</span>Thm.transfer'' <span class="entity">context</span><span class="main">)</span> o <span class="entity">unfolds_of_afun</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Name_Space.fold_table <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">af</span><span class="main">)</span> <span class="main">=&gt;</span> append <span class="main">(</span><span class="entity">unfolds_of</span> <span class="entity">af</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">get_afun_table</span> <span class="entity">context</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_unfolds_of</span> <span class="main">=</span> <span class="entity">all_unfolds_of_generic</span> o Context.Proof<span class="main">;</span>


<span class="comment1">(** Term construction and destruction **)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">afun_inst</span> <span class="main">=</span> <span class="main">{</span>
  T<span class="main">:</span> <span class="entity">poly_type</span><span class="main">,</span>
  pure<span class="main">:</span> <span class="entity">poly_term</span><span class="main">,</span>
  ap<span class="main">:</span> <span class="entity">poly_term</span><span class="main">,</span>
  set<span class="main">:</span> <span class="entity">poly_term</span>
<span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_afun_inst</span> <span class="main">[</span><span class="entity">T</span><span class="main">,</span> <span class="entity">pure</span><span class="main">,</span> <span class="entity">ap</span><span class="main">,</span> <span class="entity">set</span><span class="main">]</span> <span class="main">=</span> <span class="main">{</span>T <span class="main">=</span> <span class="entity">poly_type_of_term</span> <span class="entity">T</span><span class="main">,</span> pure <span class="main">=</span> <span class="entity">pure</span><span class="main">,</span> ap <span class="main">=</span> <span class="entity">ap</span><span class="main">,</span> set <span class="main">=</span> <span class="entity">set</span><span class="main">}</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pack_afun_inst</span> <span class="main">{</span><span class="entity">T</span><span class="main">,</span> <span class="entity">pure</span><span class="main">,</span> <span class="entity">ap</span><span class="main">,</span> <span class="entity">set</span><span class="main">}</span> <span class="main">=</span> <span class="entity">pack_poly_terms</span> <span class="main">[</span><span class="entity">poly_type_to_term</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">pure</span><span class="main">,</span> <span class="entity">ap</span><span class="main">,</span> <span class="entity">set</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_afun_inst</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="main">=</span> <span class="entity">match_poly_terms</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">terms_of_afun</span> <span class="entity">af</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span> #&gt; <span class="entity">mk_afun_inst</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">import_afun_inst_raw</span> <span class="entity">terms</span> <span class="main">=</span> <span class="entity">import_poly_terms</span> <span class="entity">terms</span> #&gt;&gt; <span class="entity">mk_afun_inst</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">import_afun_inst</span> <span class="main">=</span> <span class="entity">import_afun_inst_raw</span> o <span class="entity">terms_of_afun</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inner_sort_of</span> <span class="main">{</span>T <span class="main">=</span> <span class="main">(</span><span class="entity">tvars</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Type.sort_of_atyp <span class="main">(</span>the_single <span class="entity">tvars</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_type</span> <span class="main">{</span><span class="entity">T</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">instantiate_poly_type</span> <span class="entity">T</span> o single<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_pure</span> <span class="main">{</span><span class="entity">pure</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">instantiate_poly_term</span> <span class="entity">pure</span> o single<span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_ap</span> <span class="main">{</span><span class="entity">ap</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">(</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">instantiate_poly_term</span> <span class="entity">ap</span> <span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">]</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_set</span> <span class="main">{</span><span class="entity">set</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">instantiate_poly_term</span> <span class="entity">set</span> o single<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lift_term</span> <span class="entity">af_inst</span> <span class="entity">t</span> <span class="main">=</span> Term.betapply <span class="main">(</span><span class="entity">mk_pure</span> <span class="entity">af_inst</span> <span class="main">(</span>Term.fastype_of <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_comb</span> <span class="entity">af_inst</span> <span class="entity">funT</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> Term.betapplys <span class="main">(</span><span class="entity">mk_ap</span> <span class="entity">af_inst</span> <span class="main">(</span>dest_funT <span class="entity">funT</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_type</span> <span class="entity">ctxt</span> <span class="main">{</span><span class="entity">T</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> the_single o <span class="entity">dest_poly_type</span> <span class="entity">ctxt</span> <span class="entity">T</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dest_type'</span> <span class="main">=</span> the_default <span class="entity">HOLogic.unitT</span> ooo <span class="entity">dest_type</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_pure</span> <span class="entity">ctxt</span> <span class="main">{</span>pure <span class="main">=</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">pure</span><span class="main">)</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> the_single o <span class="entity">dest_comb_pattern</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pure</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_comb</span> <span class="entity">ctxt</span> <span class="main">{</span>ap <span class="main">=</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ap</span><span class="main">)</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">the_pair</span> o <span class="entity">dest_comb_pattern</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ap</span><span class="main">,</span> <span class="inner_numeral">2</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">infer_comb</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">funT</span> <span class="main">=</span> the_default <span class="main">(</span>dummyT --&gt; dummyT<span class="main">)</span> <span class="main">(</span><span class="entity">dest_type</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="main">(</span>fastype_of <span class="entity">t1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_comb</span> <span class="entity">af_inst</span> <span class="entity">funT</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*lift a term, except for non-combination subterms mapped by subst*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subst_lift_term</span> <span class="entity">af_inst</span> <span class="entity">subst</span> <span class="entity">tm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subst_lift</span> <span class="main">(</span><span class="entity">s</span> $ <span class="entity">t</span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">subst_lift</span> <span class="entity">s</span><span class="main">,</span> <span class="entity">subst_lift</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">(</span>NONE<span class="main">,</span> NONE<span class="main">)</span> <span class="main">=&gt;</span> NONE
        <span class="main">|</span> <span class="main">(</span>SOME <span class="entity">s'</span><span class="main">,</span> NONE<span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span><span class="entity">mk_comb</span> <span class="entity">af_inst</span> <span class="main">(</span>fastype_of <span class="entity">s</span><span class="main">)</span> <span class="main">(</span><span class="entity">s'</span><span class="main">,</span> <span class="entity">lift_term</span> <span class="entity">af_inst</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">(</span>NONE<span class="main">,</span> SOME <span class="entity">t'</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span><span class="entity">mk_comb</span> <span class="entity">af_inst</span> <span class="main">(</span>fastype_of <span class="entity">s</span><span class="main">)</span> <span class="main">(</span><span class="entity">lift_term</span> <span class="entity">af_inst</span> <span class="entity">s</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">(</span>SOME <span class="entity">s'</span><span class="main">,</span> SOME <span class="entity">t'</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span><span class="entity">mk_comb</span> <span class="entity">af_inst</span> <span class="main">(</span>fastype_of <span class="entity">s</span><span class="main">)</span> <span class="main">(</span><span class="entity">s'</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">subst_lift</span> <span class="entity">t</span> <span class="main">=</span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">subst</span> <span class="entity">t</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">subst_lift</span> <span class="entity">tm</span> <span class="keyword2"><span class="keyword">of</span></span>
      NONE <span class="main">=&gt;</span> <span class="entity">lift_term</span> <span class="entity">af_inst</span> <span class="entity">tm</span>
    <span class="main">|</span> SOME <span class="entity">tm'</span> <span class="main">=&gt;</span> <span class="entity">tm'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_lifted_vars</span> <span class="main">(</span><span class="entity">s</span> $ <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">add_lifted_vars</span> <span class="entity">s</span> #&gt; <span class="entity">add_lifted_vars</span> <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">add_lifted_vars</span> <span class="main">(</span>Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Term.add_vars <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">add_lifted_vars</span> <span class="main">_</span> <span class="main">=</span> I<span class="main">;</span>

<span class="comment1">(*lift terms, where schematic variables are generalized to the functor and then fixed*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">generalize_lift_terms</span> <span class="entity">af_inst</span> <span class="entity">ts</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> subtract <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>fold <span class="entity">add_lifted_vars</span> <span class="entity">ts</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>fold Term.add_vars <span class="entity">ts</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">var_names</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> split_list <span class="entity">vars</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">free_names</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> Variable.variant_fixes <span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">1</span> <span class="entity">var_names</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts'</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_type</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">Ts</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subst</span> <span class="main">=</span> map Var <span class="entity">vars</span> ~~ map Free <span class="main">(</span><span class="entity">free_names</span> ~~ <span class="entity">Ts'</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>map <span class="main">(</span><span class="entity">subst_lift_term</span> <span class="entity">af_inst</span> <span class="entity">subst</span><span class="main">)</span> <span class="entity">ts</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(** Reasoning with applicative functors **)</span>

<span class="comment1">(* Utilities *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">clean_name</span> <span class="main">=</span> perhaps <span class="main">(</span>perhaps_apply <span class="main">[</span>try Name.dest_skolem<span class="main">,</span> try Name.dest_internal<span class="main">]</span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(*based on term_name from Pure/term.ML*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_to_vname</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Long_Name.base_name <span class="entity">x</span>
  <span class="main">|</span> <span class="entity">term_to_vname</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">clean_name</span> <span class="entity">x</span>
  <span class="main">|</span> <span class="entity">term_to_vname</span> <span class="main">(</span>Var <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">clean_name</span> <span class="entity">x</span>
  <span class="main">|</span> <span class="entity">term_to_vname</span> <span class="main">_</span> <span class="main">=</span> <span class="inner_quoted">"x"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">afuns_of_rel</span> <span class="entity">precise</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Variable.focus NONE <span class="entity">t</span> <span class="entity">ctxt</span>
    |&gt; <span class="main">#</span><span class="inner_numeral">1</span> |&gt; <span class="main">#</span><span class="inner_numeral">2</span>
    |&gt; Logic.strip_imp_concl
    |&gt; Envir.beta_eta_contract
    |&gt; <span class="entity">HOLogic.dest_Trueprop</span>
    |&gt; <span class="entity">strip_comb2</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">precise</span>
    <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">afuns_of_term</span> <span class="entity">ctxt</span> <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">afuns_of_term</span> <span class="entity">ctxt</span> <span class="entity">rhs</span>
      <span class="main">|</span> <span class="entity">afs</span> <span class="main">=&gt;</span> <span class="entity">afs</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">afuns_of_typ</span> <span class="entity">ctxt</span> <span class="main">(</span>fastype_of <span class="entity">lhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AUTO_AFUNS</span> <span class="entity">precise</span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="entity">opt_af</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">opt_af</span> <span class="keyword2"><span class="keyword">of</span></span>
    SOME <span class="entity">af</span> <span class="main">=&gt;</span> <span class="entity">tac</span> <span class="main">[</span><span class="entity">af</span><span class="main">]</span>
  <span class="main">|</span> NONE <span class="main">=&gt;</span> SUBGOAL <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">goal</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">afuns_of_rel</span> <span class="entity">precise</span> <span class="entity">ctxt</span> <span class="entity">goal</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> no_tac
    <span class="main">|</span> <span class="entity">afs</span> <span class="main">=&gt;</span> <span class="entity">tac</span> <span class="entity">afs</span> <span class="entity">i</span><span class="main">)</span> <span class="keyword3"><span class="keyword">handle</span></span> TERM <span class="main">_</span> <span class="main">=&gt;</span> no_tac<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AUTO_AFUN</span> <span class="entity">precise</span> <span class="entity">tac</span> <span class="main">=</span> <span class="entity">AUTO_AFUNS</span> <span class="entity">precise</span> <span class="main">(</span><span class="entity">tac</span> o hd<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">binop_par_conv</span> <span class="entity">cv</span> <span class="entity">ct</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">binop</span><span class="main">,</span> <span class="entity">arg1</span><span class="main">)</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span> <span class="main">=</span> Thm.dest_comb <span class="entity">ct</span> |&gt;&gt; Thm.dest_comb<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">cv</span> <span class="main">(</span><span class="entity">arg1</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Drule.binop_cong_rule <span class="entity">binop</span> <span class="entity">th1</span> <span class="entity">th2</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">binop_par_conv_tac</span> <span class="entity">cv</span> <span class="main">=</span> CONVERSION <span class="main">(</span><span class="entity">HOLogic.Trueprop_conv</span> <span class="main">(</span><span class="entity">binop_par_conv</span> <span class="entity">cv</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fold_goal_tac</span> <span class="main">=</span> SELECT_GOAL oo Raw_Simplifier.fold_goals_tac<span class="main">;</span>


<span class="comment1">(* Unfolding of lifted constants *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">afun_unfold_tac</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="main">=</span> Raw_Simplifier.rewrite_goal_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">unfolds_of_afun</span> <span class="entity">af</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">afun_fold_tac</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="main">=</span> <span class="entity">fold_goal_tac</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">unfolds_of_afun</span> <span class="entity">af</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unfold_all_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> Raw_Simplifier.rewrite_goal_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">all_unfolds_of</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">;</span>


<span class="comment1">(* Basic conversions *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pure_conv</span> <span class="entity">ctxt</span> <span class="main">{</span>pure <span class="main">=</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">pure</span><span class="main">)</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">cv</span> <span class="entity">ct</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">var</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="entity">tyenv</span><span class="main">,</span> <span class="entity">env</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">match_comb_pattern</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pure</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg</span> <span class="main">=</span> the <span class="main">(</span>Envir.lookup1 <span class="entity">env</span> <span class="entity">var</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">cv</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">arg</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> Thm.is_reflexive <span class="entity">thm</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pure_inst</span> <span class="main">=</span> Envir.subst_term_types <span class="entity">tyenv</span> <span class="entity">pure</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> Drule.arg_cong_rule <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">pure_inst</span><span class="main">)</span> <span class="entity">thm</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ap_conv</span> <span class="entity">ctxt</span> <span class="main">{</span>ap <span class="main">=</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ap</span><span class="main">)</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">cv1</span> <span class="entity">cv2</span> <span class="entity">ct</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">var1</span><span class="main">,</span> <span class="entity">var2</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="entity">tyenv</span><span class="main">,</span> <span class="entity">env</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">match_comb_pattern</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ap</span><span class="main">,</span> <span class="inner_numeral">2</span><span class="main">)</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg1</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="main">(</span>the o Envir.lookup1 <span class="entity">env</span><span class="main">)</span> <span class="main">(</span><span class="entity">var1</span><span class="main">,</span> <span class="entity">var2</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm1</span> <span class="main">=</span> <span class="entity">cv1</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">arg1</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm2</span> <span class="main">=</span> <span class="entity">cv2</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">arg2</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> Thm.is_reflexive <span class="entity">thm1</span> <span class="keyword1"><span class="keyword">andalso</span></span> Thm.is_reflexive <span class="entity">thm2</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ap_inst</span> <span class="main">=</span> Envir.subst_term_types <span class="entity">tyenv</span> <span class="entity">ap</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> Drule.binop_cong_rule <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">ap_inst</span><span class="main">)</span> <span class="entity">thm1</span> <span class="entity">thm2</span> <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(* Normal form conversion *)</span>

<span class="comment1">(*convert a term into applicative normal form*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalform_conv</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="entity">ct</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">hom</span><span class="main">,</span> <span class="entity">ichng</span><span class="main">,</span> <span class="entity">pure_comp_conv</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">thms_of_afun</span> <span class="entity">af</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">the_red</span> <span class="main">=</span> the o <span class="entity">red_of_afun</span> <span class="entity">af</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">leaf_conv</span> <span class="main">=</span> Conv.rewr_conv <span class="main">(</span><span class="entity">mk_meta_eq</span> <span class="main">(</span><span class="entity">the_red</span> <span class="inner_quoted">"I"</span><span class="main">)</span> |&gt; Thm.symmetric<span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge_conv</span> <span class="main">=</span> Conv.rewr_conv <span class="main">(</span><span class="entity">mk_meta_eq</span> <span class="entity">hom</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">swap_conv</span> <span class="main">=</span> Conv.rewr_conv <span class="main">(</span><span class="entity">mk_meta_eq</span> <span class="entity">ichng</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rotate_conv</span> <span class="main">=</span> Conv.rewr_conv <span class="main">(</span><span class="entity">mk_meta_eq</span> <span class="main">(</span><span class="entity">the_red</span> <span class="inner_quoted">"B"</span><span class="main">)</span> |&gt; Thm.symmetric<span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pure_rotate_conv</span> <span class="main">=</span> Conv.rewr_conv <span class="main">(</span><span class="entity">mk_meta_eq</span> <span class="entity">pure_comp_conv</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">af_inst</span> <span class="main">=</span> <span class="entity">match_afun_inst</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">,</span> Thm.maxidx_of_cterm <span class="entity">ct</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">left_conv</span> <span class="entity">cv</span> <span class="main">=</span> <span class="entity">ap_conv</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">cv</span> Conv.all_conv<span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_pure_nf</span> <span class="entity">ct</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span><span class="entity">pure_rotate_conv</span> then_conv <span class="entity">left_conv</span> <span class="entity">norm_pure_nf</span><span class="main">)</span> else_conv <span class="entity">merge_conv</span><span class="main">)</span> <span class="entity">ct</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">norm_nf_pure</span> <span class="main">=</span> <span class="entity">swap_conv</span> then_conv <span class="entity">norm_pure_nf</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_nf_nf</span> <span class="entity">ct</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">rotate_conv</span> then_conv
        <span class="entity">left_conv</span> <span class="main">(</span><span class="entity">left_conv</span> <span class="entity">norm_pure_nf</span> then_conv <span class="entity">norm_nf_nf</span><span class="main">)</span><span class="main">)</span> else_conv
      <span class="entity">norm_nf_pure</span><span class="main">)</span> <span class="entity">ct</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize</span> <span class="entity">ct</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">ap_conv</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">normalize</span> <span class="entity">normalize</span> then_conv <span class="entity">norm_nf_nf</span><span class="main">)</span> else_conv
      <span class="entity">pure_conv</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> Conv.all_conv else_conv
      <span class="entity">leaf_conv</span><span class="main">)</span> <span class="entity">ct</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">normalize</span> <span class="entity">ct</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">normalize_rel_tac</span> <span class="main">=</span> <span class="entity">binop_par_conv_tac</span> o apply2 oo <span class="entity">normalform_conv</span><span class="main">;</span>


<span class="comment1">(* Bracket abstraction and generalized unlifting *)</span>

<span class="comment1">(*TODO: use proper conversions*)</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">apterm</span> <span class="main">=</span>
    <span class="entity">Pure</span> <span class="keyword2"><span class="keyword">of</span></span> term  <span class="comment1">(*includes pure application*)</span>
  <span class="main">|</span> <span class="entity">ApVar</span> <span class="keyword2"><span class="keyword">of</span></span> int * term  <span class="comment1">(*unique index, instantiated term*)</span>
  <span class="main">|</span> <span class="entity">Ap</span> <span class="keyword2"><span class="keyword">of</span></span> apterm * apterm<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apterm_vars</span> <span class="main">(</span><span class="entity">Pure</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> I
  <span class="main">|</span> <span class="entity">apterm_vars</span> <span class="main">(</span><span class="entity">ApVar</span> <span class="entity">v</span><span class="main">)</span> <span class="main">=</span> cons <span class="entity">v</span>
  <span class="main">|</span> <span class="entity">apterm_vars</span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">apterm_vars</span> <span class="entity">t1</span> #&gt; <span class="entity">apterm_vars</span> <span class="entity">t2</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">occurs_any</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Pure</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> false
  <span class="main">|</span> <span class="entity">occurs_any</span> <span class="entity">vs</span> <span class="main">(</span><span class="entity">ApVar</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">j</span> <span class="main">=&gt;</span> <span class="entity">i</span> <span class="main">=</span> <span class="entity">j</span><span class="main">)</span> <span class="entity">vs</span>
  <span class="main">|</span> <span class="entity">occurs_any</span> <span class="entity">vs</span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">occurs_any</span> <span class="entity">vs</span> <span class="entity">t1</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">occurs_any</span> <span class="entity">vs</span> <span class="entity">t2</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_of_apterm</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tm_of</span> <span class="main">(</span><span class="entity">Pure</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t</span>
      <span class="main">|</span> <span class="entity">tm_of</span> <span class="main">(</span><span class="entity">ApVar</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t</span>
      <span class="main">|</span> <span class="entity">tm_of</span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">infer_comb</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">tm_of</span> <span class="entity">t1</span><span class="main">,</span> <span class="entity">tm_of</span> <span class="entity">t2</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">tm_of</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apterm_of_term</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">t</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">aptm_of</span> <span class="entity">t</span> <span class="entity">i</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> try <span class="main">(</span><span class="entity">dest_comb</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">i</span> |&gt; <span class="entity">aptm_of</span> <span class="entity">t1</span> ||&gt;&gt; <span class="entity">aptm_of</span> <span class="entity">t2</span> |&gt;&gt; <span class="entity">Ap</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> can <span class="main">(</span><span class="entity">dest_pure</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">t</span>
          <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">Pure</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">ApVar</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">i</span> + <span class="inner_numeral">1</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">aptm_of</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*find a common variable sequence for two applicative terms, depending on available combinators*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">consolidate</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">common_inst</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span> <span class="entity">insts</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Termtab.lookup <span class="entity">insts</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">k</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">k</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">j</span><span class="main">,</span> <span class="entity">insts</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">j</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">j</span> + <span class="inner_numeral">1</span><span class="main">,</span> Termtab.update <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">j</span><span class="main">)</span> <span class="entity">insts</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> Termtab.empty<span class="main">)</span>
      |&gt; fold_map <span class="entity">common_inst</span> <span class="main">(</span><span class="entity">apterm_vars</span> <span class="entity">t1</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      ||&gt;&gt; fold_map <span class="entity">common_inst</span> <span class="main">(</span><span class="entity">apterm_vars</span> <span class="entity">t2</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge_adjacent</span> <span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">merge_adjacent</span> <span class="main">(</span><span class="main">(</span><span class="entity">is</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">is</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">merge_adjacent</span> <span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">merge_adjacent</span> <span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="entity">i</span><span class="main">]</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span> <span class="entity">xs</span>
      <span class="main">|</span> <span class="entity">merge_adjacent</span> <span class="main">(</span><span class="main">(</span><span class="entity">is</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">i'</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span><span class="main">,</span> <span class="entity">d'</span><span class="main">)</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d</span> <span class="main">=</span> <span class="entity">d'</span>
          <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">merge_adjacent</span> <span class="main">(</span><span class="main">(</span><span class="entity">i'</span>::<span class="entity">is</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span> <span class="entity">xs</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">is</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span> :: <span class="entity">merge_adjacent</span> <span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="entity">i'</span><span class="main">]</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span><span class="main">,</span> <span class="entity">d'</span><span class="main">)</span> <span class="entity">xs</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">align</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> NONE
      <span class="main">|</span> <span class="entity">align</span> <span class="main">(</span><span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">i'</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span><span class="main">,</span> <span class="entity">d'</span><span class="main">)</span>::<span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d</span> <span class="main">=</span> <span class="entity">d'</span>
          <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">i</span> @ <span class="entity">i'</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> Option.map <span class="main">(</span>apfst <span class="main">(</span>cons <span class="main">(</span><span class="main">(</span><span class="entity">i'</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span><span class="main">,</span> <span class="entity">d'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">align</span> <span class="main">(</span><span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span> <span class="entity">xs</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ys</span>
      <span class="main">|</span> <span class="entity">merge</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="entity">xs</span>
      <span class="main">|</span> <span class="entity">merge</span> <span class="main">(</span><span class="main">(</span><span class="entity">xs</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">is1</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span><span class="main">,</span> <span class="entity">d1</span><span class="main">)</span>::<span class="entity">xs'</span><span class="main">)</span><span class="main">,</span> <span class="entity">ys</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">is2</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">,</span> <span class="entity">d2</span><span class="main">)</span>::<span class="entity">ys'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d1</span> <span class="main">=</span> <span class="entity">d2</span>
          <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">is1</span> @ <span class="entity">is2</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span><span class="main">,</span> <span class="entity">d1</span><span class="main">)</span> :: <span class="entity">merge</span> <span class="main">(</span><span class="entity">xs'</span><span class="main">,</span> <span class="entity">ys'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">align</span> <span class="main">(</span><span class="main">(</span><span class="entity">is2</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">,</span> <span class="entity">d2</span><span class="main">)</span> <span class="entity">xs</span><span class="main">,</span> <span class="entity">align</span> <span class="main">(</span><span class="main">(</span><span class="entity">is1</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span><span class="main">,</span> <span class="entity">d1</span><span class="main">)</span> <span class="entity">ys</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">(</span>SOME <span class="main">(</span><span class="entity">zs</span><span class="main">,</span> <span class="entity">xs''</span><span class="main">)</span><span class="main">,</span> NONE<span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">zs</span> @ <span class="entity">merge</span> <span class="main">(</span><span class="entity">xs''</span><span class="main">,</span> <span class="entity">ys'</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>NONE<span class="main">,</span> SOME <span class="main">(</span><span class="entity">zs</span><span class="main">,</span> <span class="entity">ys''</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">zs</span> @ <span class="entity">merge</span> <span class="main">(</span><span class="entity">xs'</span><span class="main">,</span> <span class="entity">ys''</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">is1</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span><span class="main">,</span> <span class="entity">d1</span><span class="main">)</span> :: <span class="main">(</span><span class="main">(</span><span class="entity">is2</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">,</span> <span class="entity">d2</span><span class="main">)</span> :: <span class="entity">merge</span> <span class="main">(</span><span class="entity">xs'</span><span class="main">,</span> <span class="entity">ys'</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unbalanced</span> <span class="entity">vs</span> <span class="main">=</span> error <span class="main">(</span><span class="inner_quoted">"Unbalanced opaque terms "</span> ^
      commas_quote <span class="main">(</span>map <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span> o <span class="main">#</span><span class="inner_numeral">2</span> o <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">vs</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mismatch</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> error <span class="main">(</span><span class="inner_quoted">"Mismatched opaque terms "</span> ^
      quote <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">t1</span><span class="main">)</span> ^ <span class="inner_quoted">" and "</span> ^ quote <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">t2</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">same</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">same</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span> <span class="main">=</span> <span class="entity">unbalanced</span> <span class="entity">ys</span>
      <span class="main">|</span> <span class="entity">same</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="entity">unbalanced</span> <span class="entity">xs</span>
      <span class="main">|</span> <span class="entity">same</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">i1</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span><span class="main">,</span> <span class="entity">d1</span><span class="main">)</span>::<span class="entity">xs</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">i2</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">,</span> <span class="entity">d2</span><span class="main">)</span>::<span class="entity">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d1</span> <span class="main">=</span> <span class="entity">d2</span>
          <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">i1</span> @ <span class="entity">i2</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span><span class="main">,</span> <span class="entity">d1</span><span class="main">)</span> :: <span class="entity">same</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">mismatch</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">vars</span>
    |&gt; <span class="entity">has_red_afun</span> <span class="entity">af</span> <span class="inner_quoted">"C"</span> ? apply2 <span class="main">(</span>sort <span class="main">(</span>int_ord o apply2 <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span><span class="main">)</span>
    |&gt; apply2 <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">has_red_afun</span> <span class="entity">af</span> <span class="inner_quoted">"W"</span>
        <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">merge_adjacent</span> <span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> Term.dummy<span class="main">)</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> map <span class="main">(</span>apfst <span class="main">(</span>apfst single<span class="main">)</span><span class="main">)</span><span class="main">)</span>
    |&gt; <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">has_red_afun</span> <span class="entity">af</span> <span class="inner_quoted">"K"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">merge</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">same</span><span class="main">)</span>
    |&gt; map <span class="main">#</span><span class="inner_numeral">1</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ap_cong</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">thm1</span> <span class="entity">thm2</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">funT</span> <span class="main">=</span> the_default <span class="main">(</span>dummyT --&gt; dummyT<span class="main">)</span>
      <span class="main">(</span><span class="entity">dest_type</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="main">(</span>Thm.typ_of_cterm <span class="main">(</span>Thm.lhs_of <span class="entity">thm1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ap_inst</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">mk_ap</span> <span class="entity">af_inst</span> <span class="main">(</span>dest_funT <span class="entity">funT</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Drule.binop_cong_rule <span class="entity">ap_inst</span> <span class="entity">thm1</span> <span class="entity">thm2</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewr_subst_ap</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">rewr</span> <span class="entity">thm1</span> <span class="entity">thm2</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rule1</span> <span class="main">=</span> <span class="entity">ap_cong</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">thm1</span> <span class="entity">thm2</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rule2</span> <span class="main">=</span> Conv.rewr_conv <span class="entity">rewr</span> <span class="main">(</span>Thm.rhs_of <span class="entity">rule1</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Thm.transitive <span class="entity">rule1</span> <span class="entity">rule2</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge_pures</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">merge_thm</span> <span class="entity">tt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="main">(</span><span class="entity">Pure</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> SOME <span class="main">(</span>Thm.reflexive <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">merge</span> <span class="main">(</span><span class="entity">ApVar</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> NONE
      <span class="main">|</span> <span class="entity">merge</span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">tt1</span><span class="main">,</span> <span class="entity">tt2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">merge</span> <span class="entity">tt1</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> NONE
        <span class="main">|</span> SOME <span class="entity">thm1</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">merge</span> <span class="entity">tt2</span> <span class="keyword2"><span class="keyword">of</span></span>
            NONE <span class="main">=&gt;</span> NONE
          <span class="main">|</span> SOME <span class="entity">thm2</span> <span class="main">=&gt;</span> SOME <span class="main">(</span><span class="entity">rewr_subst_ap</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">merge_thm</span> <span class="entity">thm1</span> <span class="entity">thm2</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">merge</span> <span class="entity">tt</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">exception</span></span> <span class="entity">ASSERT</span> <span class="keyword2"><span class="keyword">of</span></span> string<span class="main">;</span>

<span class="comment1">(*abstract over a variable (opaque subterm)*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eliminate</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">af</span><span class="main">,</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">tt</span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">v_tm</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">hom</span><span class="main">,</span> <span class="entity">ichng</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">thms_of_afun</span> <span class="entity">af</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">the_red</span> <span class="main">=</span> the o <span class="entity">red_of_afun</span> <span class="entity">af</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hom_conv</span> <span class="main">=</span> <span class="entity">mk_meta_eq</span> <span class="entity">hom</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ichng_conv</span> <span class="main">=</span> <span class="entity">mk_meta_eq</span> <span class="entity">ichng</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_combI</span> <span class="main">=</span> Thm.symmetric o <span class="entity">mk_meta_eq</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id_conv</span> <span class="main">=</span> <span class="entity">mk_combI</span> <span class="main">(</span><span class="entity">the_red</span> <span class="inner_quoted">"I"</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comp_conv</span> <span class="main">=</span> <span class="entity">mk_combI</span> <span class="main">(</span><span class="entity">the_red</span> <span class="inner_quoted">"B"</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">flip_conv</span> <span class="main">=</span> Option.map <span class="entity">mk_combI</span> <span class="main">(</span><span class="entity">red_of_afun</span> <span class="entity">af</span> <span class="inner_quoted">"C"</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const_conv</span> <span class="main">=</span> Option.map <span class="entity">mk_combI</span> <span class="main">(</span><span class="entity">red_of_afun</span> <span class="entity">af</span> <span class="inner_quoted">"K"</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dup_conv</span> <span class="main">=</span> Option.map <span class="entity">mk_combI</span> <span class="main">(</span><span class="entity">red_of_afun</span> <span class="entity">af</span> <span class="inner_quoted">"W"</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rewr_subst_ap</span> <span class="main">=</span> <span class="entity">rewr_subst_ap</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">extract_comb</span> <span class="entity">n</span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">Pure</span> <span class="main">(</span><span class="entity">thm</span> |&gt; Thm.rhs_of |&gt; funpow <span class="entity">n</span> Thm.dest_arg1 |&gt; Thm.term_of<span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">refl_step</span> <span class="entity">tt</span> <span class="main">=</span> <span class="main">(</span><span class="entity">tt</span><span class="main">,</span> Thm.reflexive <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">term_of_apterm</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">tt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comb2_step</span> <span class="entity">def</span> <span class="main">(</span><span class="entity">tt1</span><span class="main">,</span> <span class="entity">thm1</span><span class="main">)</span> <span class="main">(</span><span class="entity">tt2</span><span class="main">,</span> <span class="entity">thm2</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="entity">rewr_subst_ap</span> <span class="entity">def</span> <span class="entity">thm1</span> <span class="entity">thm2</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">extract_comb</span> <span class="inner_numeral">3</span> <span class="entity">thm</span><span class="main">,</span> <span class="entity">tt1</span><span class="main">)</span><span class="main">,</span> <span class="entity">tt2</span><span class="main">)</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">B_step</span> <span class="main">=</span> <span class="entity">comb2_step</span> <span class="entity">comp_conv</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">swap_B_step</span> <span class="main">(</span><span class="entity">tt1</span><span class="main">,</span> <span class="entity">thm1</span><span class="main">)</span> <span class="entity">thm2</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm3</span> <span class="main">=</span> <span class="entity">rewr_subst_ap</span> <span class="entity">ichng_conv</span> <span class="entity">thm1</span> <span class="entity">thm2</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm4</span> <span class="main">=</span> Thm.transitive <span class="entity">thm3</span> <span class="main">(</span>Conv.rewr_conv <span class="entity">comp_conv</span> <span class="main">(</span>Thm.rhs_of <span class="entity">thm3</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">extract_comb</span> <span class="inner_numeral">3</span> <span class="entity">thm4</span><span class="main">,</span> <span class="entity">extract_comb</span> <span class="inner_numeral">1</span> <span class="entity">thm3</span><span class="main">)</span><span class="main">,</span> <span class="entity">tt1</span><span class="main">)</span><span class="main">,</span> <span class="entity">thm4</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">I_step</span> <span class="entity">tm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> Conv.rewr_conv <span class="entity">id_conv</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">tm</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">extract_comb</span> <span class="inner_numeral">1</span> <span class="entity">thm</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">W_step</span> <span class="entity">s1</span> <span class="entity">s2</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">tt1</span><span class="main">,</span> <span class="entity">tt2</span><span class="main">)</span><span class="main">,</span> <span class="entity">tt3</span><span class="main">)</span><span class="main">,</span> <span class="entity">thm1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">B_step</span> <span class="entity">s1</span> <span class="entity">s2</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm2</span> <span class="main">=</span> Conv.rewr_conv <span class="entity">comp_conv</span> <span class="main">(</span>Thm.rhs_of <span class="entity">thm1</span> |&gt; funpow <span class="inner_numeral">2</span> Thm.dest_arg1<span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm3</span> <span class="main">=</span> <span class="entity">merge_pures</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">hom_conv</span> <span class="entity">tt3</span> |&gt; the<span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tt4</span><span class="main">,</span> <span class="entity">thm4</span><span class="main">)</span> <span class="main">=</span> <span class="entity">swap_B_step</span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">extract_comb</span> <span class="inner_numeral">3</span> <span class="entity">thm2</span><span class="main">,</span> <span class="entity">tt1</span><span class="main">)</span><span class="main">,</span> <span class="entity">tt2</span><span class="main">)</span><span class="main">,</span> <span class="entity">thm2</span><span class="main">)</span> <span class="entity">thm3</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Thm.rhs_of <span class="entity">thm1</span> |&gt; Thm.dest_arg<span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm5</span> <span class="main">=</span> <span class="entity">rewr_subst_ap</span> <span class="main">(</span>the <span class="entity">dup_conv</span><span class="main">)</span> <span class="entity">thm4</span> <span class="main">(</span>Thm.reflexive <span class="entity">var</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm6</span> <span class="main">=</span> Thm.transitive <span class="entity">thm1</span> <span class="entity">thm5</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">extract_comb</span> <span class="inner_numeral">2</span> <span class="entity">thm6</span><span class="main">,</span> <span class="entity">tt4</span><span class="main">)</span><span class="main">,</span> <span class="entity">thm6</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">S_step</span> <span class="entity">s1</span> <span class="entity">s2</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">tt1</span><span class="main">,</span> <span class="entity">tt2</span><span class="main">)</span><span class="main">,</span> <span class="entity">tt3</span><span class="main">)</span><span class="main">,</span> <span class="entity">thm1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">comb2_step</span> <span class="main">(</span>the <span class="entity">flip_conv</span><span class="main">)</span> <span class="entity">s1</span> <span class="entity">s2</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm2</span> <span class="main">=</span> Conv.rewr_conv <span class="entity">comp_conv</span> <span class="main">(</span>Thm.rhs_of <span class="entity">thm1</span> |&gt; Thm.dest_arg1<span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Thm.rhs_of <span class="entity">thm1</span> |&gt; Thm.dest_arg<span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm3</span> <span class="main">=</span> <span class="entity">rewr_subst_ap</span> <span class="main">(</span>the <span class="entity">dup_conv</span><span class="main">)</span> <span class="entity">thm2</span> <span class="main">(</span>Thm.reflexive <span class="entity">var</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm4</span> <span class="main">=</span> Thm.transitive <span class="entity">thm1</span> <span class="entity">thm3</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tt</span> <span class="main">=</span> <span class="entity">Ap</span> <span class="main">(</span><span class="entity">extract_comb</span> <span class="inner_numeral">2</span> <span class="entity">thm4</span><span class="main">,</span> <span class="entity">Ap</span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">extract_comb</span> <span class="inner_numeral">3</span> <span class="entity">thm2</span><span class="main">,</span> <span class="entity">Ap</span> <span class="main">(</span><span class="entity">tt1</span><span class="main">,</span> <span class="entity">tt2</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">tt3</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">tt</span><span class="main">,</span> <span class="entity">thm4</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">K_step</span> <span class="entity">tt</span> <span class="entity">tm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">tm</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T_opt</span> <span class="main">=</span> Term.fastype_of <span class="entity">tm</span> |&gt; <span class="entity">dest_type</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> |&gt; Option.map <span class="main">(</span>Thm.ctyp_of <span class="entity">ctxt</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> Thm.instantiate' <span class="main">[</span><span class="entity">T_opt</span><span class="main">]</span> <span class="main">[</span>SOME <span class="entity">ct</span><span class="main">]</span>
          <span class="main">(</span>Conv.rewr_conv <span class="main">(</span>the <span class="entity">const_conv</span><span class="main">)</span> <span class="main">(</span><span class="entity">term_of_apterm</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">tt</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">extract_comb</span> <span class="inner_numeral">2</span> <span class="entity">thm</span><span class="main">,</span> <span class="entity">tt</span><span class="main">)</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unreachable</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> <span class="entity">ASSERT</span> <span class="inner_quoted">"eliminate: assertion failed"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">elim</span> <span class="main">(</span><span class="entity">Pure</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">unreachable</span> <span class="main">(</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">elim</span> <span class="main">(</span><span class="entity">ApVar</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">i</span><span class="main">)</span> <span class="entity">v</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">I_step</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">unreachable</span> <span class="main">(</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">elim</span> <span class="main">(</span><span class="entity">Ap</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">occurs_any</span> <span class="entity">v</span> <span class="entity">t1</span><span class="main">,</span> <span class="entity">occurs_any</span> <span class="entity">v</span> <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
            <span class="main">(</span>false<span class="main">,</span> false<span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">unreachable</span> <span class="main">(</span><span class="main">)</span>
          <span class="main">|</span> <span class="main">(</span>false<span class="main">,</span> true<span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">B_step</span> <span class="main">(</span><span class="entity">refl_step</span> <span class="entity">t1</span><span class="main">)</span> <span class="main">(</span><span class="entity">elim</span> <span class="entity">t2</span><span class="main">)</span>
          <span class="main">|</span> <span class="main">(</span>true<span class="main">,</span> false<span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">merge_pures</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">hom_conv</span> <span class="entity">t2</span> <span class="keyword2"><span class="keyword">of</span></span>
                SOME <span class="entity">thm</span> <span class="main">=&gt;</span> <span class="entity">swap_B_step</span> <span class="main">(</span><span class="entity">elim</span> <span class="entity">t1</span><span class="main">)</span> <span class="entity">thm</span>
              <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">comb2_step</span> <span class="main">(</span>the <span class="entity">flip_conv</span><span class="main">)</span> <span class="main">(</span><span class="entity">elim</span> <span class="entity">t1</span><span class="main">)</span> <span class="main">(</span><span class="entity">refl_step</span> <span class="entity">t2</span><span class="main">)</span><span class="main">)</span>
          <span class="main">|</span> <span class="main">(</span>true<span class="main">,</span> true<span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> is_some <span class="entity">flip_conv</span>
              <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">S_step</span> <span class="main">(</span><span class="entity">elim</span> <span class="entity">t1</span><span class="main">)</span> <span class="main">(</span><span class="entity">elim</span> <span class="entity">t2</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">W_step</span> <span class="main">(</span><span class="entity">elim</span> <span class="entity">t1</span><span class="main">)</span> <span class="main">(</span><span class="entity">elim</span> <span class="entity">t2</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">occurs_any</span> <span class="entity">v</span> <span class="entity">tt</span>
    <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">elim</span> <span class="entity">tt</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">K_step</span> <span class="entity">tt</span> <span class="entity">v_tm</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*convert a pair of terms into equal canonical forms, modulo pure terms*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">general_normalform_conv</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="entity">cts</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="main">(</span>Thm.term_of<span class="main">)</span> <span class="entity">cts</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">maxidx</span> <span class="main">=</span> Int.max <span class="main">(</span>apply2 Thm.maxidx_of_cterm <span class="entity">cts</span><span class="main">)</span><span class="main">;</span>
    <span class="comment1">(* TODO: is there a better strategy for finding the instantiated functor? *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">af_inst</span> <span class="main">=</span> <span class="entity">match_afun_inst</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">maxidx</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">apt1</span><span class="main">,</span> <span class="entity">apt2</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="inner_numeral">0</span> |&gt; <span class="entity">apterm_of_term</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">t1</span> ||&gt;&gt; <span class="entity">apterm_of_term</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">t2</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vs</span> <span class="main">=</span> <span class="entity">consolidate</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="main">(</span><span class="entity">apt1</span><span class="main">,</span> <span class="entity">apt2</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge_thm</span> <span class="main">=</span> <span class="entity">mk_meta_eq</span> <span class="main">(</span><span class="main">#</span>hom <span class="main">(</span><span class="entity">thms_of_afun</span> <span class="entity">af</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">elim_all</span> <span class="entity">tt</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> the <span class="main">(</span><span class="entity">merge_pures</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">merge_thm</span> <span class="entity">tt</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">elim_all</span> <span class="entity">tt</span> <span class="main">(</span><span class="entity">v</span>::<span class="entity">vs</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tt'</span><span class="main">,</span> <span class="entity">rule1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">eliminate</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">af</span><span class="main">,</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">tt</span> <span class="entity">v</span><span class="main">;</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rule2</span> <span class="main">=</span> <span class="entity">elim_all</span> <span class="entity">tt'</span> <span class="entity">vs</span><span class="main">;</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">vartm</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_comb</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="main">(</span>Thm.term_of <span class="main">(</span>Thm.rhs_of <span class="entity">rule1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rule3</span> <span class="main">=</span> <span class="entity">ap_cong</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">rule2</span> <span class="main">(</span>Thm.reflexive <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">vartm</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword2"><span class="keyword">in</span></span> Thm.transitive <span class="entity">rule1</span> <span class="entity">rule3</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">elim_all</span> <span class="entity">apt1</span> <span class="entity">vs</span><span class="main">,</span> <span class="entity">elim_all</span> <span class="entity">apt2</span> <span class="entity">vs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">general_normalize_rel_tac</span> <span class="main">=</span> <span class="entity">binop_par_conv_tac</span> oo <span class="entity">general_normalform_conv</span><span class="main">;</span>


<span class="comment1">(* Reduce canonical forms to base relation *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rename_params</span> <span class="entity">names</span> <span class="entity">i</span> <span class="entity">st</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">Bs</span><span class="main">,</span> <span class="entity">Bi</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span> <span class="main">=</span> Thm.dest_state <span class="main">(</span><span class="entity">st</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Bi'</span> <span class="main">=</span> Logic.list_rename_params <span class="entity">names</span> <span class="entity">Bi</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Thm.renamed_prop <span class="main">(</span>Logic.list_implies <span class="main">(</span><span class="entity">Bs</span> @ <span class="main">[</span><span class="entity">Bi'</span><span class="main">]</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span> <span class="entity">st</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*
  R' (pure f &lt;&gt; x1 &lt;&gt; ... &lt;&gt; xn) (pure g &lt;&gt; x1 &lt;&gt; ... &lt;&gt; xn)
    ===&gt; !!y1 ... yn. [| yi : setF xi ... |] ==&gt; R (f y1 ... yn) (g y1 ... yn),
  where either both R and R' are equality, or R' = relF R for relator relF of the functor.
  The premises yi : setF xi are added only in the latter case and if the set operator is available.
  Succeeds if partial progress can be made. The names of the new parameters yi are derived
  from the arguments xi.
*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">head_cong_tac</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="entity">renames</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">rel_intros</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">thms_of_afun</span> <span class="entity">af</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_name</span> <span class="entity">tm</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">renames</span> <span class="entity">tm</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">n</span> <span class="main">=&gt;</span> <span class="entity">n</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="entity">term_to_vname</span> <span class="entity">tm</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gather_vars'</span> <span class="entity">af_inst</span> <span class="entity">tm</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> try <span class="main">(</span><span class="entity">dest_comb</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">tm</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">term_name</span> <span class="entity">t2</span> :: <span class="entity">gather_vars'</span> <span class="entity">af_inst</span> <span class="entity">t1</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gather_vars</span> <span class="entity">prop</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">prop</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Trueprop<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">(</span><span class="main">_</span> $ <span class="entity">rhs</span><span class="main">)</span> <span class="main">=&gt;</span>
          rev <span class="main">(</span><span class="entity">gather_vars'</span> <span class="main">(</span><span class="entity">match_afun_inst</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="main">(</span><span class="entity">rhs</span><span class="main">,</span> maxidx_of_term <span class="entity">prop</span><span class="main">)</span><span class="main">)</span> <span class="entity">rhs</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> SUBGOAL <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">subgoal</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="main">=&gt;</span>
    <span class="main">(</span>REPEAT_DETERM <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">rel_intros</span> <span class="entity">i</span><span class="main">)</span> THEN
      REPEAT_DETERM <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">ext</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> rel_fun_eq_onI<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="entity">i</span> ORELSE
        eresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> UNIV_E<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="entity">i</span><span class="main">)</span> THEN
      PRIMITIVE <span class="main">(</span><span class="entity">rename_params</span> <span class="main">(</span><span class="entity">gather_vars</span> <span class="entity">subgoal</span><span class="main">)</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(* Forward lifting *)</span>

<span class="comment1">(*
  TODO: add limited support for premises, where used variables are not generalized in the conclusion
*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">forward_lift_rule</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> Object_Logic.rulify <span class="entity">ctxt</span> <span class="entity">thm</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">af_inst</span><span class="main">,</span> <span class="entity">ctxt_inst</span><span class="main">)</span> <span class="main">=</span> <span class="entity">import_afun_inst</span> <span class="entity">af</span> <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prop</span><span class="main">,</span> <span class="entity">ctxt_Ts</span><span class="main">)</span> <span class="main">=</span> yield_singleton Variable.importT_terms <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span> <span class="entity">ctxt_inst</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">lhs'</span><span class="main">,</span> <span class="entity">rhs'</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt_lifted</span><span class="main">)</span> <span class="main">=</span> <span class="entity">generalize_lift_terms</span> <span class="entity">af_inst</span> <span class="main">[</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">]</span> <span class="entity">ctxt_Ts</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lifted</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs'</span><span class="main">,</span> <span class="entity">rhs'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lifted'</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> yield_singleton <span class="main">(</span>Variable.import_terms true<span class="main">)</span> <span class="entity">lifted</span> <span class="entity">ctxt_lifted</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">context</span><span class="main">}</span> <span class="main">=</span> HEADGOAL <span class="main">(</span><span class="entity">general_normalize_rel_tac</span> <span class="entity">context</span> <span class="entity">af</span> THEN'
      <span class="entity">head_cong_tac</span> <span class="entity">context</span> <span class="entity">af</span> <span class="main">[</span><span class="main">]</span> THEN'
      resolve_tac <span class="entity">context</span> <span class="main">[</span><span class="entity">prems</span> MRS <span class="entity">thm</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm'</span> <span class="main">=</span> singleton <span class="main">(</span>Variable.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span>
      <span class="main">(</span>Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">lifted'</span> <span class="entity">tac</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm''</span> <span class="main">=</span> Raw_Simplifier.fold_rule <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">unfolds_of_afun</span> <span class="entity">af</span><span class="main">)</span> <span class="entity">thm'</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thm''</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">forward_lift_attrib</span> <span class="entity">name</span> <span class="main">=</span>
  Thm.rule_attribute <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">context</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thm</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">af</span> <span class="main">=</span> <span class="entity">afun_of_generic</span> <span class="entity">context</span> <span class="main">(</span><span class="entity">intern</span> <span class="entity">context</span> <span class="entity">name</span><span class="main">)</span>  <span class="comment1">(* FIXME !?!? *)</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">forward_lift_rule</span> <span class="main">(</span>Context.proof_of <span class="entity">context</span><span class="main">)</span> <span class="entity">af</span> <span class="entity">thm</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>


<span class="comment1">(* High-level tactics *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unfold_wrapper_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">AUTO_AFUNS</span> false <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">afs</span> <span class="main">=&gt;</span>
  <span class="entity">Simplifier.safe_asm_full_simp_tac</span> <span class="main">(</span><span class="entity">ctxt</span> addsimps flat <span class="main">(</span>map <span class="entity">unfolds_of_afun</span> <span class="entity">afs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fold_wrapper_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">AUTO_AFUN</span> true <span class="main">(</span><span class="entity">fold_goal_tac</span> <span class="entity">ctxt</span> o <span class="entity">unfolds_of_afun</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">WRAPPER</span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="entity">opt_af</span> <span class="main">=</span>
  REPEAT_DETERM o resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> allI<span class="antiquote">}</span></span></span><span class="main">]</span> THEN'
  <span class="entity">Subgoal.FOCUS</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">params</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">renames</span> <span class="main">=</span> map <span class="main">(</span>swap o apsnd Thm.term_of<span class="main">)</span> <span class="entity">params</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">AUTO_AFUNS</span> false <span class="main">(</span>EVERY' o map <span class="main">(</span><span class="entity">afun_unfold_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">opt_af</span> <span class="inner_numeral">1</span> THEN
      <span class="entity">AUTO_AFUN</span> true <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">af</span> <span class="main">=&gt;</span>
        <span class="entity">afun_unfold_tac</span> <span class="entity">ctxt</span> <span class="entity">af</span> THEN'
        CONVERSION Drule.beta_eta_conversion THEN'
        <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="entity">af</span> THEN'
        <span class="entity">head_cong_tac</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="entity">renames</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">opt_af</span> <span class="inner_numeral">1</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">ctxt</span> THEN'
  Raw_Simplifier.rewrite_goal_tac <span class="entity">ctxt</span> <span class="main">[</span>Drule.triv_forall_equality<span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">normalize_wrapper_tac</span> <span class="main">=</span> <span class="entity">WRAPPER</span> <span class="entity">normalize_rel_tac</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lifting_wrapper_tac</span> <span class="main">=</span> <span class="entity">WRAPPER</span> <span class="entity">general_normalize_rel_tac</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_opt_afun</span> <span class="main">=</span> Scan.peek <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">context</span> <span class="main">=&gt;</span>
  Scan.option Parse.name &gt;&gt; Option.map <span class="main">(</span><span class="entity">intern</span> <span class="entity">context</span> #&gt; <span class="entity">afun_of_generic</span> <span class="entity">context</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>


<span class="comment1">(** Declaration **)</span>

<span class="comment1">(* Combinator setup *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_combinators</span> <span class="entity">combs</span> <span class="entity">phi</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">names</span><span class="main">,</span> <span class="entity">thms</span><span class="main">)</span> <span class="main">=</span> split_list <span class="entity">combs</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms'</span> <span class="main">=</span> map <span class="main">(</span>Morphism.thm <span class="entity">phi</span><span class="main">)</span> <span class="entity">thms</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_combs</span> <span class="main">(</span><span class="entity">defs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>fold <span class="main">(</span>Symtab.insert <span class="main">(</span>K false<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">names</span> ~~ <span class="entity">thms'</span><span class="main">)</span> <span class="entity">defs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Data.map <span class="main">(</span><span class="entity">map_data</span> <span class="entity">add_combs</span> I I<span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">setup_combinators</span> <span class="main">=</span>
  Local_Theory.declaration <span class="main">{</span>syntax <span class="main">=</span> false<span class="main">,</span> pervasive <span class="main">=</span> false<span class="main">}</span> o <span class="entity">declare_combinators</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">combinator_of_red</span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Logic.dest_equals <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">lhs</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">#</span><span class="inner_numeral">1</span> <span class="main">(</span>dest_Const <span class="entity">head</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_combinator_rule</span> <span class="entity">weak_premises</span> <span class="entity">thm</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Logic.dest_equals <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ltvars</span> <span class="main">=</span> Term.add_tvars <span class="entity">lhs</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rtvars</span> <span class="main">=</span> Term.add_tvars <span class="entity">rhs</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span>not o member <span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span> <span class="entity">ltvars</span><span class="main">)</span> <span class="entity">rtvars</span>
      <span class="keyword2"><span class="keyword">then</span></span> Pretty.breaks
         <span class="main">[</span>Pretty.str <span class="inner_quoted">"Combinator equation"</span><span class="main">,</span>
          Pretty.quote <span class="main">(</span>Syntax.pretty_term <span class="main">(</span>Context.proof_of <span class="entity">context</span><span class="main">)</span> <span class="main">(</span>Thm.prop_of <span class="entity">thm</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
          Pretty.str <span class="inner_quoted">"has additional type variables on right-hand side."</span><span class="main">]</span>
        |&gt; Pretty.block |&gt; Pretty.string_of |&gt; error
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">defs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="main">#</span>combinators <span class="main">(</span>Data.get <span class="entity">context</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb_names</span> <span class="main">=</span>
      Symtab.make <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">combinator_of_red</span> <span class="entity">thm</span><span class="main">,</span> <span class="entity">name</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Symtab.dest <span class="entity">defs</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rule</span> <span class="main">=</span> <span class="entity">mk_combinator_rule</span> <span class="entity">comb_names</span> <span class="entity">weak_premises</span> <span class="entity">thm</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rule</span> <span class="main">(</span><span class="entity">defs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">defs</span><span class="main">,</span> insert <span class="entity">eq_combinator_rule</span> <span class="entity">rule</span> <span class="entity">rules</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Data.map <span class="main">(</span><span class="entity">map_data</span> <span class="entity">add_rule</span> I I<span class="main">)</span> <span class="entity">context</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">combinator_rule_attrib</span> <span class="main">=</span> Thm.declaration_attribute o <span class="entity">register_combinator_rule</span><span class="main">;</span>


<span class="comment1">(* Derivation of combinator reductions *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">combinator_closure</span> <span class="entity">rules</span> <span class="entity">have_weak</span> <span class="entity">combs</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply</span> <span class="entity">rule</span> <span class="main">(</span><span class="entity">cs</span><span class="main">,</span> <span class="entity">changed</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span>Ord_List.member fast_string_ord <span class="entity">cs</span> <span class="main">(</span><span class="entity">conclusion_of_rule</span> <span class="entity">rule</span><span class="main">)</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
        <span class="entity">is_applicable_rule</span> <span class="entity">rule</span> <span class="entity">have_weak</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">prems</span> <span class="main">=&gt;</span> Ord_List.subset fast_string_ord <span class="main">(</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">cs</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span>Ord_List.insert fast_string_ord <span class="main">(</span><span class="entity">conclusion_of_rule</span> <span class="entity">rule</span><span class="main">)</span> <span class="entity">cs</span><span class="main">,</span> true<span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">cs</span><span class="main">,</span> <span class="entity">changed</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">loop</span> <span class="entity">cs</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> fold <span class="entity">apply</span> <span class="entity">rules</span> <span class="main">(</span><span class="entity">cs</span><span class="main">,</span> false<span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">(</span><span class="entity">cs'</span><span class="main">,</span> true<span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">loop</span> <span class="entity">cs'</span>
      <span class="main">|</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> false<span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">cs</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">loop</span> <span class="entity">combs</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">derive_combinator_red</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">red_thms</span> <span class="main">(</span><span class="entity">base_thm</span><span class="main">,</span> <span class="entity">eq_thm</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_prop</span> <span class="main">=</span> Thm.prop_of <span class="entity">base_thm</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tvars</span> <span class="main">=</span> Term.add_tvars <span class="entity">base_prop</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">Ts</span><span class="main">,</span> <span class="entity">ctxt_Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_TFrees_of</span> <span class="main">(</span>length <span class="entity">tvars</span><span class="main">)</span> <span class="main">(</span><span class="entity">inner_sort_of</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_prop'</span> <span class="main">=</span> Term_Subst.instantiate <span class="main">(</span><span class="entity">tvars</span> ~~ <span class="entity">Ts</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">base_prop</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Logic.dest_equals <span class="entity">base_prop'</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">lhs'</span><span class="main">,</span> <span class="entity">rhs'</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">generalize_lift_terms</span> <span class="entity">af_inst</span> <span class="main">[</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">]</span> <span class="entity">ctxt_Ts</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lifted_prop</span> <span class="main">=</span> <span class="main">(</span><span class="entity">lhs'</span><span class="main">,</span> <span class="entity">rhs'</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_eq</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unfold_comb_conv</span> <span class="main">=</span> <span class="entity">HOLogic.Trueprop_conv</span>
      <span class="main">(</span><span class="entity">HOLogic.eq_conv</span> <span class="main">(</span>Conv.top_sweep_conv <span class="main">(</span>K <span class="main">(</span>Conv.rewr_conv <span class="entity">eq_thm</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt'</span><span class="main">)</span> Conv.all_conv<span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span> HEADGOAL <span class="main">(</span>CONVERSION <span class="entity">unfold_comb_conv</span> THEN'
      Raw_Simplifier.rewrite_goal_tac <span class="entity">ctxt'</span> <span class="entity">red_thms</span> THEN'
      resolve_tac <span class="entity">ctxt'</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> refl<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> singleton <span class="main">(</span>Variable.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">lifted_prop</span> <span class="main">(</span>K <span class="entity">tac</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(*derive all instantiations with pure terms which can be simplified by homomorphism*)</span>
<span class="comment1">(*FIXME: more of a workaround than a sensible solution*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">weak_red_closure</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">af_inst</span><span class="main">,</span> <span class="entity">merge_thm</span><span class="main">)</span> <span class="entity">strong_red</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Thm.prop_of <span class="entity">strong_red</span> |&gt; Logic.dest_equals<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> rev <span class="main">(</span>Term.add_vars <span class="entity">lhs</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">closure</span> <span class="main">[</span><span class="main">]</span> <span class="entity">prev</span> <span class="entity">thms</span> <span class="main">=</span> <span class="main">(</span><span class="entity">prev</span>::<span class="entity">thms</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">closure</span> <span class="main">(</span><span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">af_T</span><span class="main">)</span>::<span class="entity">vs</span><span class="main">)</span> <span class="entity">prev</span> <span class="entity">thms</span> <span class="main">=</span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> try <span class="main">(</span><span class="entity">dest_type</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">af_T</span> <span class="keyword2"><span class="keyword">of</span></span>
            NONE <span class="main">=&gt;</span> <span class="entity">closure</span> <span class="entity">vs</span> <span class="entity">prev</span> <span class="entity">thms</span>
          <span class="main">|</span> SOME <span class="entity">T_opt</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">T_opt</span> <span class="keyword2"><span class="keyword">of</span></span>
                  NONE <span class="main">=&gt;</span> yield_singleton Variable.invent_types <span class="main">(</span><span class="entity">inner_sort_of</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">ctxt</span>
                    |&gt;&gt; TFree
                <span class="main">|</span> SOME <span class="entity">T</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">v'</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_Free</span> <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> <span class="entity">v</span><span class="main">)</span> <span class="entity">T</span> <span class="entity">ctxt'</span><span class="main">;</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pure_v</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt''</span> <span class="main">(</span><span class="entity">lift_term</span> <span class="entity">af_inst</span> <span class="entity">v'</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">next</span> <span class="main">=</span> Drule.instantiate_normalize <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">af_T</span><span class="main">)</span><span class="main">,</span> <span class="entity">pure_v</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">prev</span><span class="main">;</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">next'</span> <span class="main">=</span> Raw_Simplifier.rewrite_rule <span class="entity">ctxt''</span> <span class="main">[</span><span class="entity">merge_thm</span><span class="main">]</span> <span class="entity">next</span><span class="main">;</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">next''</span> <span class="main">=</span> singleton <span class="main">(</span>Variable.export <span class="entity">ctxt''</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">next'</span><span class="main">;</span>
            <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">closure</span> <span class="entity">vs</span> <span class="entity">next''</span> <span class="main">(</span><span class="entity">prev</span>::<span class="entity">thms</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>
   <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">closure</span> <span class="entity">vars</span> <span class="entity">strong_red</span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">combinator_red_closure</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">comb_defs</span><span class="main">,</span> <span class="entity">rules</span><span class="main">)</span> <span class="main">(</span><span class="entity">af_inst</span><span class="main">,</span> <span class="entity">merge_thm</span><span class="main">)</span> <span class="entity">weak_reds</span> <span class="entity">combs</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">have_weak</span> <span class="main">=</span> not <span class="main">(</span>null <span class="entity">weak_reds</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">red_thms0</span> <span class="main">=</span> Symtab.fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> <span class="main">=&gt;</span> cons <span class="main">(</span><span class="entity">mk_meta_eq</span> <span class="entity">thm</span><span class="main">)</span><span class="main">)</span> <span class="entity">combs</span> <span class="entity">weak_reds</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">red_thms</span> <span class="main">=</span> flat <span class="main">(</span>map <span class="main">(</span><span class="entity">weak_red_closure</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">af_inst</span><span class="main">,</span> <span class="entity">merge_thm</span><span class="main">)</span><span class="main">)</span> <span class="entity">red_thms0</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply</span> <span class="entity">rule</span> <span class="main">(</span><span class="main">(</span><span class="entity">cs</span><span class="main">,</span> <span class="entity">rs</span><span class="main">)</span><span class="main">,</span> <span class="entity">changed</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span>Symtab.defined <span class="entity">cs</span> <span class="main">(</span><span class="entity">conclusion_of_rule</span> <span class="entity">rule</span><span class="main">)</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
        <span class="entity">is_applicable_rule</span> <span class="entity">rule</span> <span class="entity">have_weak</span> <span class="main">(</span>forall <span class="main">(</span>Symtab.defined <span class="entity">cs</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conclusion</span> <span class="main">=</span> <span class="entity">conclusion_of_rule</span> <span class="entity">rule</span><span class="main">;</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def</span> <span class="main">=</span> the <span class="main">(</span>Symtab.lookup <span class="entity">comb_defs</span> <span class="entity">conclusion</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_red_thm</span> <span class="main">=</span> <span class="entity">derive_combinator_red</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="entity">rs</span> <span class="main">(</span><span class="entity">def</span><span class="main">,</span> <span class="entity">thm_of_rule</span> <span class="entity">rule</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_red_thms</span> <span class="main">=</span> <span class="entity">weak_red_closure</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">af_inst</span><span class="main">,</span> <span class="entity">merge_thm</span><span class="main">)</span> <span class="main">(</span><span class="entity">mk_meta_eq</span> <span class="entity">new_red_thm</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">(</span>Symtab.update <span class="main">(</span><span class="entity">conclusion</span><span class="main">,</span> <span class="entity">new_red_thm</span><span class="main">)</span> <span class="entity">cs</span><span class="main">,</span> <span class="entity">new_red_thms</span> @ <span class="entity">rs</span><span class="main">)</span><span class="main">,</span> true<span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">cs</span><span class="main">,</span> <span class="entity">rs</span><span class="main">)</span><span class="main">,</span> <span class="entity">changed</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">loop</span> <span class="entity">xs</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> fold <span class="entity">apply</span> <span class="entity">rules</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> false<span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">(</span><span class="entity">xs'</span><span class="main">,</span> true<span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">loop</span> <span class="entity">xs'</span>
      <span class="main">|</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> false<span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">xs</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">#</span><span class="inner_numeral">1</span> <span class="main">(</span><span class="entity">loop</span> <span class="main">(</span><span class="entity">combs</span><span class="main">,</span> <span class="entity">red_thms</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(* Preparation of AFun data *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_terms</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">raw_pure</span><span class="main">,</span> <span class="entity">raw_ap</span><span class="main">,</span> <span class="entity">raw_rel</span><span class="main">,</span> <span class="entity">raw_set</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">show_typ</span> <span class="main">=</span> quote o Syntax.string_of_typ <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">show_term</span> <span class="main">=</span> quote o Syntax.string_of_term <span class="entity">ctxt</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">closed_poly_term</span> <span class="entity">t</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">poly_t</span> <span class="main">=</span> singleton <span class="main">(</span>Variable.polymorphic <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">t</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">case</span></span> Term.add_vars <span class="main">(</span>singleton
          <span class="main">(</span>Variable.export_terms <span class="main">(</span>Proof_Context.augment <span class="entity">t</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">t</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>Term.hidden_polymorphism <span class="entity">poly_t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">poly_t</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Hidden type variables in term "</span> ^ <span class="entity">show_term</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Locally free variables in term "</span> ^ <span class="entity">show_term</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pure</span> <span class="main">=</span> <span class="entity">closed_poly_term</span> <span class="entity">raw_pure</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tvar</span><span class="main">,</span> <span class="entity">T1</span><span class="main">)</span> <span class="main">=</span> fastype_of <span class="entity">pure</span> |&gt; dest_funT |&gt;&gt; dest_TVar
      <span class="keyword3"><span class="keyword">handle</span></span> TYPE <span class="main">_</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Bad type for pure: "</span> ^ <span class="entity">show_typ</span> <span class="main">(</span>fastype_of <span class="entity">pure</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">maxidx_pure</span> <span class="main">=</span> maxidx_of_term <span class="entity">pure</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ap</span> <span class="main">=</span> Logic.incr_indexes <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">maxidx_pure</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="main">(</span><span class="entity">closed_poly_term</span> <span class="entity">raw_ap</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bad_ap</span> <span class="main">_</span> <span class="main">=</span> error <span class="main">(</span><span class="inner_quoted">"Bad type for ap: "</span> ^ <span class="entity">show_typ</span> <span class="main">(</span>fastype_of <span class="entity">ap</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">T23</span><span class="main">,</span> <span class="main">(</span><span class="entity">T2</span><span class="main">,</span> <span class="entity">T3</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> fastype_of <span class="entity">ap</span> |&gt; dest_funT ||&gt; dest_funT
      <span class="keyword3"><span class="keyword">handle</span></span> TYPE <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">bad_ap</span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">maxidx_common</span> <span class="main">=</span> Term.maxidx_term <span class="entity">ap</span> <span class="entity">maxidx_pure</span><span class="main">;</span>

    <span class="comment1">(*unify type variables, while keeping the live variables separate*)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">no_unifier</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> <span class="main">=</span> error <span class="main">(</span><span class="inner_quoted">"Unable to infer common functor type from "</span> ^
      commas <span class="main">(</span>map <span class="entity">show_typ</span> <span class="main">[</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unify_ap_type</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">tyenv</span><span class="main">,</span> <span class="entity">maxidx</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argT</span> <span class="main">=</span> TVar <span class="main">(</span><span class="main">(</span>Name.aT<span class="main">,</span> <span class="entity">maxidx</span> + <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T1'</span> <span class="main">=</span> Term_Subst.instantiateT <span class="main">[</span><span class="main">(</span><span class="entity">tvar</span><span class="main">,</span> <span class="entity">argT</span><span class="main">)</span><span class="main">]</span> <span class="entity">T1</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tyenv'</span><span class="main">,</span> <span class="entity">maxidx'</span><span class="main">)</span> <span class="main">=</span> Sign.typ_unify <span class="entity">thy</span> <span class="main">(</span><span class="entity">T1'</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">(</span><span class="entity">tyenv</span><span class="main">,</span> <span class="entity">maxidx</span> + <span class="inner_numeral">1</span><span class="main">)</span>
          <span class="keyword3"><span class="keyword">handle</span></span> Type.TUNIFY <span class="main">=&gt;</span> <span class="entity">no_unifier</span> <span class="main">(</span><span class="entity">T1'</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">argT</span><span class="main">,</span> <span class="main">(</span><span class="entity">tyenv'</span><span class="main">,</span> <span class="entity">maxidx'</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ap_args</span><span class="main">,</span> <span class="main">(</span><span class="entity">ap_env</span><span class="main">,</span> <span class="entity">maxidx_env</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      fold_map <span class="entity">unify_ap_type</span> <span class="main">[</span><span class="entity">T2</span><span class="main">,</span> <span class="entity">T3</span><span class="main">,</span> <span class="entity">T23</span><span class="main">]</span> <span class="main">(</span>Vartab.empty<span class="main">,</span> <span class="entity">maxidx_common</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">[</span><span class="entity">T2_arg</span><span class="main">,</span> <span class="entity">T3_arg</span><span class="main">,</span> <span class="entity">T23_arg</span><span class="main">]</span> <span class="main">=</span> map <span class="main">(</span>Envir.norm_type <span class="entity">ap_env</span><span class="main">)</span> <span class="entity">ap_args</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tvar2</span><span class="main">,</span> <span class="entity">tvar3</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>dest_TVar <span class="entity">T2_arg</span><span class="main">,</span> dest_TVar <span class="entity">T3_arg</span><span class="main">)</span> <span class="keyword3"><span class="keyword">handle</span></span> TYPE <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">bad_ap</span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">T23_arg</span> <span class="main">=</span> <span class="entity">T2_arg</span> --&gt; <span class="entity">T3_arg</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">bad_ap</span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> foldl1 <span class="main">(</span>Sign.inter_sort <span class="entity">thy</span><span class="main">)</span> <span class="main">(</span>map <span class="main">#</span><span class="inner_numeral">2</span> <span class="main">[</span><span class="entity">tvar</span><span class="main">,</span> <span class="entity">tvar2</span><span class="main">,</span> <span class="entity">tvar3</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Sign.of_sort <span class="entity">thy</span> <span class="main">(</span>Term.aT <span class="entity">sort</span> --&gt; Term.aT <span class="entity">sort</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
      error <span class="main">(</span><span class="inner_quoted">"Sort constraint "</span> ^ quote <span class="main">(</span>Syntax.string_of_sort <span class="entity">ctxt</span> <span class="entity">sort</span><span class="main">)</span> ^
        <span class="inner_quoted">" not closed under function types"</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_sort</span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span> <span class="main">(</span><span class="entity">tyenv</span><span class="main">,</span> <span class="entity">maxidx</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span>Vartab.update_new <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="main">(</span><span class="entity">S</span><span class="main">,</span> TVar <span class="main">(</span><span class="main">(</span>Name.aT<span class="main">,</span> <span class="entity">maxidx</span> + <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">tyenv</span><span class="main">,</span> <span class="entity">maxidx</span> + <span class="inner_numeral">1</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">common_env</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> fold <span class="entity">update_sort</span> <span class="main">[</span><span class="entity">tvar</span><span class="main">,</span> <span class="entity">tvar2</span><span class="main">,</span> <span class="entity">tvar3</span><span class="main">]</span> <span class="main">(</span><span class="entity">ap_env</span><span class="main">,</span> <span class="entity">maxidx_env</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tvar'</span> <span class="main">=</span> Envir.norm_type <span class="entity">common_env</span> <span class="main">(</span>TVar <span class="entity">tvar</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pure'</span> <span class="main">=</span> <span class="entity">norm_term_types</span> <span class="entity">common_env</span> <span class="entity">pure</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tvar2'</span><span class="main">,</span> <span class="entity">tvar3'</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="main">(</span>Envir.norm_type <span class="entity">common_env</span><span class="main">)</span> <span class="main">(</span><span class="entity">T2_arg</span><span class="main">,</span> <span class="entity">T3_arg</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ap'</span> <span class="main">=</span> <span class="entity">norm_term_types</span> <span class="entity">common_env</span> <span class="entity">ap</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bad_set</span> <span class="entity">set</span> <span class="main">=</span> error <span class="main">(</span><span class="inner_quoted">"Bad type for set: "</span> ^ <span class="entity">show_typ</span> <span class="main">(</span>fastype_of <span class="entity">set</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_set</span> <span class="entity">set</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyenv</span> <span class="main">=</span> Sign.typ_match <span class="entity">thy</span> <span class="main">(</span>domain_type <span class="main">(</span>fastype_of <span class="entity">set</span><span class="main">)</span><span class="main">,</span> range_type <span class="main">(</span>fastype_of <span class="entity">pure'</span><span class="main">)</span><span class="main">)</span>
          Vartab.empty
          <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> <span class="entity">bad_set</span> <span class="entity">set</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set'</span> <span class="main">=</span> Envir.subst_term_types <span class="entity">tyenv</span> <span class="entity">set</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set_tvar</span> <span class="main">=</span> fastype_of <span class="entity">set'</span> |&gt; range_type |&gt; <span class="entity">HOLogic.dest_setT</span> |&gt; dest_TVar
          <span class="keyword3"><span class="keyword">handle</span></span> TYPE <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">bad_set</span> <span class="entity">set</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Term.eq_tvar <span class="main">(</span>dest_TVar <span class="entity">tvar'</span><span class="main">,</span> <span class="entity">set_tvar</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">bad_set</span> <span class="entity">set</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">tvar'</span><span class="main">]</span><span class="main">,</span> <span class="entity">set'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_set</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="entity">tvar'</span><span class="main">]</span><span class="main">,</span> Abs <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="entity">tvar'</span><span class="main">,</span> <span class="entity">HOLogic.mk_UNIV</span> <span class="entity">tvar'</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> SOME <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">mk_set</span> <span class="main">(</span><span class="entity">closed_poly_term</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">terms</span> <span class="main">=</span> Term_Subst.zero_var_indexes <span class="main">(</span><span class="entity">pack_poly_terms</span>
      <span class="main">[</span><span class="entity">poly_type_to_term</span> <span class="main">(</span><span class="main">[</span><span class="entity">tvar'</span><span class="main">]</span><span class="main">,</span> range_type <span class="main">(</span>fastype_of <span class="entity">pure'</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="main">[</span><span class="entity">tvar'</span><span class="main">]</span><span class="main">,</span> <span class="entity">pure'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="entity">tvar2'</span><span class="main">,</span> <span class="entity">tvar3'</span><span class="main">]</span><span class="main">,</span> <span class="entity">ap'</span><span class="main">)</span><span class="main">,</span> <span class="entity">set</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>

    <span class="comment1">(*TODO: also infer the relator type?*)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bad_rel</span> <span class="entity">rel</span> <span class="main">=</span> error <span class="main">(</span><span class="inner_quoted">"Bad type for rel: "</span> ^ <span class="entity">show_typ</span> <span class="main">(</span>fastype_of <span class="entity">rel</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rel</span> <span class="entity">rel</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">T1_af</span><span class="main">,</span> <span class="entity">T2_af</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> fastype_of <span class="entity">rel</span>
          |&gt; dest_funT
          |&gt;&gt; <span class="entity">BNF_Util.dest_pred2T</span>
          ||&gt; <span class="entity">BNF_Util.dest_pred2T</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="main">(</span>dest_TVar <span class="entity">T1</span><span class="main">;</span> dest_TVar <span class="entity">T2</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">T1</span> <span class="main">=</span> <span class="entity">T2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">bad_rel</span> <span class="entity">rel</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">af_inst</span> <span class="main">=</span> <span class="entity">mk_afun_inst</span> <span class="main">(</span><span class="entity">match_poly_terms_type</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">terms</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span> <span class="main">(</span><span class="entity">T1_af</span><span class="main">,</span> maxidx_of_term <span class="entity">rel</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">T1'</span><span class="main">,</span> <span class="entity">T2'</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="main">(</span><span class="entity">dest_type</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="main">(</span><span class="entity">T1_af</span><span class="main">,</span> <span class="entity">T2_af</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">(</span>is_none <span class="entity">T1'</span> <span class="keyword1"><span class="keyword">andalso</span></span> is_none <span class="entity">T2'</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="main">(</span><span class="entity">T1'</span> <span class="main">=</span> SOME <span class="entity">T1</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">T2'</span> <span class="main">=</span> SOME <span class="entity">T2</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">bad_rel</span> <span class="entity">rel</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> Term_Subst.zero_var_indexes <span class="main">(</span><span class="entity">pack_poly_terms</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">]</span><span class="main">,</span> <span class="entity">rel</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword3"><span class="keyword">handle</span></span> TYPE <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">bad_rel</span> <span class="entity">rel</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rel</span> <span class="main">=</span> Option.map <span class="main">(</span><span class="entity">mk_rel</span> o <span class="entity">closed_poly_term</span><span class="main">)</span> <span class="entity">raw_rel</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">terms</span><span class="main">,</span> <span class="entity">rel</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rel_intros</span> <span class="main">{</span><span class="entity">pure_transfer</span><span class="main">,</span> <span class="entity">ap_rel_fun</span><span class="main">}</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pure_rel_intro</span> <span class="main">=</span> <span class="entity">pure_transfer</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> rel_funD<span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">[</span><span class="entity">pure_rel_intro</span><span class="main">,</span> <span class="entity">ap_rel_fun</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_afun_thms</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">hom_thm</span><span class="main">,</span> <span class="entity">ichng_thm</span><span class="main">,</span> <span class="entity">reds</span><span class="main">,</span> <span class="entity">rel_axioms</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pure_comp_conv</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">,</span> <span class="entity">T3</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt_Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_TFrees_of</span> <span class="inner_numeral">3</span> <span class="main">(</span><span class="entity">inner_sort_of</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">g</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt_Ts</span>
          |&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"g"</span> <span class="main">(</span><span class="entity">T2</span> --&gt; <span class="entity">T3</span><span class="main">)</span>
          ||&gt;&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"f"</span> <span class="main">(</span><span class="entity">mk_type</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">)</span><span class="main">)</span>
          ||&gt;&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"x"</span> <span class="main">(</span><span class="entity">mk_type</span> <span class="entity">af_inst</span> <span class="entity">T1</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb</span> <span class="main">=</span> <span class="entity">mk_comb</span> <span class="entity">af_inst</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">comb</span> <span class="main">(</span><span class="entity">T2</span> --&gt; <span class="entity">T3</span><span class="main">)</span> <span class="main">(</span><span class="entity">lift_term</span> <span class="entity">af_inst</span> <span class="entity">g</span><span class="main">,</span> <span class="entity">comb</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">)</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">B_g</span> <span class="main">=</span> Abs <span class="main">(</span><span class="inner_quoted">"f"</span><span class="main">,</span> <span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">,</span> Abs <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="entity">T1</span><span class="main">,</span> Term.betapply <span class="main">(</span><span class="entity">g</span><span class="main">,</span> Bound <span class="inner_numeral">1</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">comb</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T3</span><span class="main">)</span>
          <span class="main">(</span><span class="entity">comb</span> <span class="main">(</span><span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">)</span> --&gt; <span class="entity">T1</span> --&gt; <span class="entity">T3</span><span class="main">)</span> <span class="main">(</span><span class="entity">lift_term</span> <span class="entity">af_inst</span> <span class="entity">B_g</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> <span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span><span class="main">;</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge_rule</span> <span class="main">=</span> <span class="entity">mk_meta_eq</span> <span class="entity">hom_thm</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">B_intro</span> <span class="main">=</span> the <span class="main">(</span>Symtab.lookup <span class="entity">reds</span> <span class="inner_quoted">"B"</span><span class="main">)</span> |&gt; <span class="entity">mk_meta_eq</span> |&gt; Thm.symmetric<span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span>
          HEADGOAL <span class="main">(</span>Raw_Simplifier.rewrite_goal_tac <span class="entity">ctxt'</span> <span class="main">[</span><span class="entity">B_intro</span><span class="main">,</span> <span class="entity">merge_rule</span><span class="main">]</span> THEN'
          resolve_tac <span class="entity">ctxt'</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> refl<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> singleton <span class="main">(</span>Variable.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">prop</span> <span class="main">(</span>K <span class="entity">tac</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_intros</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt_Ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_TFrees_of</span> <span class="inner_numeral">2</span> <span class="main">(</span><span class="entity">inner_sort_of</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T12</span> <span class="main">=</span> <span class="entity">mk_type</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">,</span> <span class="entity">x'</span><span class="main">)</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span><span class="main">,</span> <span class="entity">g</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt_Ts</span>
          |&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"x"</span> <span class="entity">T1</span>
          ||&gt;&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"y"</span> <span class="entity">T1</span>
          ||&gt;&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"x"</span> <span class="main">(</span><span class="entity">mk_type</span> <span class="entity">af_inst</span> <span class="entity">T1</span><span class="main">)</span>
          ||&gt;&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"f"</span> <span class="entity">T12</span>
          ||&gt;&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"g"</span> <span class="entity">T12</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pure_fun</span> <span class="main">=</span> <span class="entity">mk_pure</span> <span class="entity">af_inst</span> <span class="entity">T1</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pure_cong</span> <span class="main">=</span> Drule.infer_instantiate' <span class="entity">ctxt'</span>
          <span class="main">(</span>map <span class="main">(</span>SOME o Thm.cterm_of <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">[</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">pure_fun</span><span class="main">]</span><span class="main">)</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> arg_cong<span class="antiquote">}</span></span></span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ap_fun</span> <span class="main">=</span> <span class="entity">mk_ap</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ap_cong1</span> <span class="main">=</span> Drule.infer_instantiate' <span class="entity">ctxt'</span>
          <span class="main">(</span>map <span class="main">(</span>SOME o Thm.cterm_of <span class="entity">ctxt'</span><span class="main">)</span>  <span class="main">[</span><span class="entity">f</span><span class="main">,</span> <span class="entity">g</span><span class="main">,</span> <span class="entity">ap_fun</span><span class="main">,</span> <span class="entity">x'</span><span class="main">]</span><span class="main">)</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> arg1_cong<span class="antiquote">}</span></span></span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> Variable.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">pure_cong</span><span class="main">,</span> <span class="entity">ap_cong1</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rel_intros</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">rel_axioms</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> SOME <span class="entity">axioms</span> <span class="main">=&gt;</span> <span class="entity">mk_rel_intros</span> <span class="entity">axioms</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">{</span>hom <span class="main">=</span> <span class="entity">hom_thm</span><span class="main">,</span>
      ichng <span class="main">=</span> <span class="entity">ichng_thm</span><span class="main">,</span>
      reds <span class="main">=</span> <span class="entity">reds</span><span class="main">,</span>
      rel_thms <span class="main">=</span> <span class="entity">rel_axioms</span><span class="main">,</span>
      rel_intros <span class="main">=</span> <span class="entity">eq_intros</span> @ <span class="entity">rel_intros</span><span class="main">,</span>
      pure_comp_conv <span class="main">=</span> <span class="entity">pure_comp_conv</span><span class="main">}</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reuse_TFrees</span> <span class="entity">n</span> <span class="entity">S</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">have_n</span> <span class="main">=</span> Int.min <span class="main">(</span><span class="entity">n</span><span class="main">,</span> length <span class="entity">Ts</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">more_Ts</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_TFrees_of</span> <span class="main">(</span><span class="entity">n</span> - <span class="entity">have_n</span><span class="main">)</span> <span class="entity">S</span> <span class="entity">ctxt</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>take <span class="entity">have_n</span> <span class="entity">Ts</span> @ <span class="entity">more_Ts</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">Ts</span> @ <span class="entity">more_Ts</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_comb_prop</span> <span class="entity">lift_pos</span> <span class="entity">thm</span> <span class="entity">af_inst</span> <span class="entity">ctxt_Ts</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base</span> <span class="main">=</span> Thm.prop_of <span class="entity">thm</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tvars</span> <span class="main">=</span> Term.add_tvars <span class="entity">base</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">Ts</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">Ts'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">reuse_TFrees</span> <span class="main">(</span>length <span class="entity">tvars</span><span class="main">)</span> <span class="main">(</span><span class="entity">inner_sort_of</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">ctxt_Ts</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base'</span> <span class="main">=</span> Term_Subst.instantiate <span class="main">(</span><span class="entity">tvars</span> ~~ <span class="entity">Ts</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">base</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Logic.dest_equals <span class="entity">base'</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">lhs_args</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">lhs</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lift_var</span> <span class="main">=</span> Var o apsnd <span class="main">(</span><span class="entity">mk_type</span> <span class="entity">af_inst</span><span class="main">)</span> o dest_Var<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs_args'</span><span class="main">,</span> <span class="entity">subst</span><span class="main">)</span> <span class="main">=</span> fold_index <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">lift_pos</span> <span class="entity">i</span> <span class="keyword2"><span class="keyword">then</span></span> apfst <span class="main">(</span>cons <span class="entity">v</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">map_prod</span> <span class="main">(</span>cons <span class="main">(</span><span class="entity">lift_var</span> <span class="entity">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>cons <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">lift_var</span> <span class="entity">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">lhs_args</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs'</span><span class="main">,</span> <span class="entity">rhs'</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="main">(</span><span class="entity">subst_lift_term</span> <span class="entity">af_inst</span> <span class="entity">subst</span><span class="main">)</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lifted</span> <span class="main">=</span> <span class="main">(</span><span class="entity">lhs'</span><span class="main">,</span> <span class="entity">rhs'</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_eq</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>fold Logic.all <span class="entity">lhs_args'</span> <span class="entity">lifted</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">Ts'</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_homomorphism_prop</span> <span class="entity">af_inst</span> <span class="entity">ctxt_Ts</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">Ts'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">reuse_TFrees</span> <span class="inner_numeral">2</span> <span class="main">(</span><span class="entity">inner_sort_of</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">ctxt_Ts</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt'</span>
      |&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"f"</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">)</span>
      ||&gt;&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"x"</span> <span class="entity">T1</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">mk_comb</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">)</span> <span class="main">(</span><span class="entity">lift_term</span> <span class="entity">af_inst</span> <span class="entity">f</span><span class="main">,</span> <span class="entity">lift_term</span> <span class="entity">af_inst</span> <span class="entity">x</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">lift_term</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">f</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>Logic.all <span class="entity">f</span> <span class="main">(</span>Logic.all <span class="entity">x</span> <span class="entity">prop</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">Ts'</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_interchange_prop</span> <span class="entity">af_inst</span> <span class="entity">ctxt_Ts</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">Ts'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">reuse_TFrees</span> <span class="inner_numeral">2</span> <span class="main">(</span><span class="entity">inner_sort_of</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">ctxt_Ts</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt'</span>
      |&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"f"</span> <span class="main">(</span><span class="entity">mk_type</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">)</span><span class="main">)</span>
      ||&gt;&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"x"</span> <span class="entity">T1</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">mk_comb</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">)</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">lift_term</span> <span class="entity">af_inst</span> <span class="entity">x</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T_x</span> <span class="main">=</span> Abs <span class="main">(</span><span class="inner_quoted">"f"</span><span class="main">,</span> <span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">,</span> Bound <span class="inner_numeral">0</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">mk_comb</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">)</span> --&gt; <span class="entity">T2</span><span class="main">)</span> <span class="main">(</span><span class="entity">lift_term</span> <span class="entity">af_inst</span> <span class="entity">T_x</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>Logic.all <span class="entity">f</span> <span class="main">(</span>Logic.all <span class="entity">x</span> <span class="entity">prop</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">Ts'</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rel_props</span> <span class="main">(</span><span class="entity">af_inst</span><span class="main">,</span> <span class="entity">rel_inst</span><span class="main">)</span> <span class="entity">ctxt_Ts</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_af_rel</span> <span class="entity">tm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">BNF_Util.dest_pred2T</span> <span class="main">(</span>fastype_of <span class="entity">tm</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> betapply <span class="main">(</span><span class="entity">instantiate_poly_term</span> <span class="entity">rel_inst</span> <span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">]</span><span class="main">,</span> <span class="entity">tm</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">T1</span><span class="main">,</span> <span class="entity">T2</span><span class="main">,</span> <span class="entity">T3</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">Ts'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">reuse_TFrees</span> <span class="inner_numeral">3</span> <span class="main">(</span><span class="entity">inner_sort_of</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">ctxt_Ts</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pure_R</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_Free</span> <span class="inner_quoted">"R"</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T2</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="entity">ctxt'</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rel_pure</span> <span class="main">=</span> <span class="entity">BNF_Util.mk_rel_fun</span> <span class="entity">pure_R</span> <span class="main">(</span><span class="entity">mk_af_rel</span> <span class="entity">pure_R</span><span class="main">)</span> $ <span class="entity">mk_pure</span> <span class="entity">af_inst</span> <span class="entity">T1</span> $
      <span class="entity">mk_pure</span> <span class="entity">af_inst</span> <span class="entity">T2</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pure_prop</span> <span class="main">=</span> Logic.all <span class="entity">pure_R</span> <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="entity">rel_pure</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">g</span><span class="main">)</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">,</span> <span class="entity">ap_R</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt'</span>
      |&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"f"</span> <span class="main">(</span><span class="entity">mk_type</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">)</span><span class="main">)</span>
      ||&gt;&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"g"</span> <span class="main">(</span><span class="entity">mk_type</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T3</span><span class="main">)</span><span class="main">)</span>
      ||&gt;&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"x"</span> <span class="main">(</span><span class="entity">mk_type</span> <span class="entity">af_inst</span> <span class="entity">T1</span><span class="main">)</span>
      ||&gt;&gt; <span class="entity">mk_Free</span> <span class="inner_quoted">"R"</span> <span class="main">(</span><span class="entity">T2</span> --&gt; <span class="entity">T3</span> --&gt; <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fun_rel</span> <span class="main">=</span> <span class="entity">BNF_Util.mk_rel_fun</span> <span class="main">(</span><span class="entity">mk_eq_on</span> <span class="main">(</span><span class="entity">mk_set</span> <span class="entity">af_inst</span> <span class="entity">T1</span> $ <span class="entity">x</span><span class="main">)</span><span class="main">)</span> <span class="entity">ap_R</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rel_ap</span> <span class="main">=</span> Logic.mk_implies <span class="main">(</span><span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_af_rel</span> <span class="entity">fun_rel</span> $ <span class="entity">f</span> $ <span class="entity">g</span><span class="main">)</span><span class="main">,</span>
      <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_af_rel</span> <span class="entity">ap_R</span> $ <span class="entity">mk_comb</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T2</span><span class="main">)</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span> $
        <span class="entity">mk_comb</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">T1</span> --&gt; <span class="entity">T3</span><span class="main">)</span> <span class="main">(</span><span class="entity">g</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ap_prop</span> <span class="main">=</span> fold_rev Logic.all <span class="main">[</span><span class="entity">ap_R</span><span class="main">,</span> <span class="entity">f</span><span class="main">,</span> <span class="entity">g</span><span class="main">,</span> <span class="entity">x</span><span class="main">]</span> <span class="entity">rel_ap</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">pure_prop</span><span class="main">,</span> <span class="entity">ap_prop</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">Ts'</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_interchange</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">(</span><span class="entity">comb_defs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">comb_unfolds</span><span class="main">)</span> <span class="main">(</span><span class="entity">af_inst</span><span class="main">,</span> <span class="entity">merge_thm</span><span class="main">)</span> <span class="entity">reds</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T_def</span> <span class="main">=</span> the <span class="main">(</span>Symtab.lookup <span class="entity">comb_defs</span> <span class="inner_quoted">"T"</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T_red</span> <span class="main">=</span> the <span class="main">(</span>Symtab.lookup <span class="entity">reds</span> <span class="inner_quoted">"T"</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">weak_prop</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_comb_prop</span> <span class="main">[</span><span class="inner_numeral">0</span><span class="main">]</span> <span class="entity">T_def</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
      HEADGOAL <span class="main">(</span>Raw_Simplifier.rewrite_goal_tac <span class="entity">context</span> <span class="main">[</span>Thm.symmetric <span class="entity">merge_thm</span><span class="main">]</span> THEN'
      resolve_tac <span class="entity">context</span> <span class="main">[</span><span class="entity">T_red</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">weak_red</span> <span class="main">=</span> singleton <span class="main">(</span>Variable.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">weak_prop</span> <span class="entity">tac</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Raw_Simplifier.rewrite_rule <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">comb_unfolds</span><span class="main">)</span> <span class="entity">weak_red</span> RS <span class="entity">sym</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_weak_reds</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">(</span><span class="entity">comb_defs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">comb_unfolds</span><span class="main">)</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">hom_thm</span><span class="main">,</span> <span class="entity">ichng_thm</span><span class="main">,</span> <span class="entity">reds</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unfolded_reds</span> <span class="main">=</span>
      Symtab.map <span class="main">(</span>K <span class="main">(</span>Raw_Simplifier.rewrite_rule <span class="entity">ctxt</span> <span class="entity">comb_unfolds</span><span class="main">)</span><span class="main">)</span> <span class="entity">reds</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">af_thms</span> <span class="main">=</span> <span class="entity">mk_afun_thms</span> <span class="entity">ctxt</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">hom_thm</span><span class="main">,</span> <span class="entity">ichng_thm</span><span class="main">,</span> <span class="entity">unfolded_reds</span><span class="main">,</span> NONE<span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">af</span> <span class="main">=</span> <span class="entity">mk_afun</span> Binding.empty <span class="main">(</span><span class="entity">pack_afun_inst</span> <span class="entity">af_inst</span><span class="main">)</span> NONE <span class="entity">af_thms</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> HEADGOAL <span class="main">(</span><span class="entity">normalize_wrapper_tac</span> <span class="entity">context</span> <span class="main">(</span>SOME <span class="entity">af</span><span class="main">)</span> THEN'
      Raw_Simplifier.rewrite_goal_tac <span class="entity">context</span> <span class="entity">comb_unfolds</span> THEN'
      resolve_tac <span class="entity">context</span> <span class="main">[</span><span class="entity">refl</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk</span> <span class="entity">comb</span> <span class="entity">lift_pos</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def</span> <span class="main">=</span> the <span class="main">(</span>Symtab.lookup <span class="entity">comb_defs</span> <span class="entity">comb</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prop</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_comb_prop</span> <span class="entity">lift_pos</span> <span class="entity">def</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hol_thm</span> <span class="main">=</span> singleton <span class="main">(</span>Variable.export <span class="entity">ctxt'</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>Goal.prove <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">prop</span> <span class="entity">tac</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_meta_eq</span> <span class="entity">hol_thm</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">uncurry_thm</span> <span class="main">=</span> <span class="entity">mk_meta_eq</span> <span class="main">(</span><span class="entity">forward_lift_rule</span> <span class="entity">ctxt</span> <span class="entity">af</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> uncurry_pair<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">[</span><span class="entity">mk</span> <span class="inner_quoted">"C"</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">,</span> <span class="entity">mk</span> <span class="inner_quoted">"C"</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="entity">uncurry_thm</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_comb_reds</span> <span class="entity">ctxt</span> <span class="entity">combss</span> <span class="entity">af_inst</span> <span class="entity">user_combs</span> <span class="main">(</span><span class="entity">hom_thm</span><span class="main">,</span> <span class="entity">user_thms</span><span class="main">,</span> <span class="entity">ichng_thms</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">comb_defs</span><span class="main">,</span> <span class="entity">comb_rules</span><span class="main">)</span><span class="main">,</span> <span class="entity">comb_unfolds</span><span class="main">)</span> <span class="main">=</span> <span class="entity">combss</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge_thm</span> <span class="main">=</span> <span class="entity">mk_meta_eq</span> <span class="entity">hom_thm</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">user_reds</span> <span class="main">=</span> Symtab.make <span class="main">(</span><span class="entity">user_combs</span> ~~ <span class="entity">user_thms</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reds0</span> <span class="main">=</span> <span class="entity">combinator_red_closure</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">comb_defs</span><span class="main">,</span> <span class="entity">comb_rules</span><span class="main">)</span> <span class="main">(</span><span class="entity">af_inst</span><span class="main">,</span> <span class="entity">merge_thm</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">user_reds</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ichng_thm</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ichng_thms</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> singleton <span class="main">(</span>Variable.export <span class="entity">ctxt</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="entity">mk_interchange</span> <span class="entity">ctxt</span> <span class="entity">combss</span> <span class="main">(</span><span class="entity">af_inst</span><span class="main">,</span> <span class="entity">merge_thm</span><span class="main">)</span> <span class="entity">reds0</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">thm</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">weak_reds</span> <span class="main">=</span> <span class="entity">mk_weak_reds</span> <span class="entity">ctxt</span> <span class="entity">combss</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">hom_thm</span><span class="main">,</span> <span class="entity">ichng_thm</span><span class="main">,</span> <span class="entity">reds0</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reds1</span> <span class="main">=</span> <span class="entity">combinator_red_closure</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">comb_defs</span><span class="main">,</span> <span class="entity">comb_rules</span><span class="main">)</span> <span class="main">(</span><span class="entity">af_inst</span><span class="main">,</span> <span class="entity">merge_thm</span><span class="main">)</span> <span class="entity">weak_reds</span> <span class="entity">reds0</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unfold</span> <span class="main">=</span> Raw_Simplifier.rewrite_rule <span class="entity">ctxt</span> <span class="entity">comb_unfolds</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>Symtab.map <span class="main">(</span>K <span class="entity">unfold</span><span class="main">)</span> <span class="entity">reds1</span><span class="main">,</span> <span class="entity">ichng_thm</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">note_afun_thms</span> <span class="entity">af</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> <span class="entity">thms_of_afun</span> <span class="entity">af</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">named_thms</span> <span class="main">=</span>
      <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"homomorphism"</span><span class="main">,</span> <span class="main">[</span><span class="main">#</span>hom <span class="entity">thms</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"interchange"</span><span class="main">,</span> <span class="main">[</span><span class="main">#</span>ichng <span class="entity">thms</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"afun_rel_intros"</span><span class="main">,</span> <span class="main">#</span>rel_intros <span class="entity">thms</span><span class="main">)</span><span class="main">]</span> @
      map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="inner_quoted">"pure_"</span> ^ <span class="entity">name</span> ^ <span class="inner_quoted">"_conv"</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Symtab.dest <span class="main">(</span><span class="main">#</span>reds <span class="entity">thms</span><span class="main">)</span><span class="main">)</span> @
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="main">#</span>rel_thms <span class="entity">thms</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> SOME <span class="entity">rel_thms'</span> <span class="main">=&gt;</span>
          <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"pure_transfer"</span><span class="main">,</span> <span class="main">[</span><span class="main">#</span>pure_transfer <span class="entity">rel_thms'</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="inner_quoted">"ap_rel_fun_cong"</span><span class="main">,</span> <span class="main">[</span><span class="main">#</span>ap_rel_fun <span class="entity">rel_thms'</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">base_name</span> <span class="main">=</span> Binding.name_of <span class="main">(</span><span class="entity">name_of_afun</span> <span class="entity">af</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_note</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">thms</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span>Binding.qualify true <span class="entity">base_name</span> <span class="main">(</span>Binding.name <span class="entity">name</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="entity">thms</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Local_Theory.notes <span class="main">(</span>map <span class="entity">mk_note</span> <span class="entity">named_thms</span><span class="main">)</span> #&gt; <span class="main">#</span><span class="inner_numeral">2</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_afun</span> <span class="entity">af</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">decl</span> <span class="entity">phi</span> <span class="entity">context</span> <span class="main">=</span> Data.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">combinators</span><span class="main">,</span> <span class="entity">afuns</span><span class="main">,</span> <span class="entity">patterns</span><span class="main">}</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">af'</span> <span class="main">=</span> <span class="entity">morph_afun</span> <span class="entity">phi</span> <span class="entity">af</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">afuns'</span><span class="main">)</span> <span class="main">=</span> Name_Space.define <span class="entity">context</span> true <span class="main">(</span><span class="entity">name_of_afun</span> <span class="entity">af'</span><span class="main">,</span> <span class="entity">af'</span><span class="main">)</span> <span class="entity">afuns</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">patterns'</span> <span class="main">=</span> Item_Net.update <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">patterns_of_afun</span> <span class="entity">af'</span><span class="main">)</span> <span class="entity">patterns</span><span class="main">;</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="main">{</span>combinators <span class="main">=</span> <span class="entity">combinators</span><span class="main">,</span> afuns <span class="main">=</span> <span class="entity">afuns'</span><span class="main">,</span> patterns <span class="main">=</span> <span class="entity">patterns'</span><span class="main">}</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">context</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Local_Theory.declaration <span class="main">{</span>syntax <span class="main">=</span> false<span class="main">,</span> pervasive <span class="main">=</span> false<span class="main">}</span> <span class="entity">decl</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">applicative_cmd</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">flags</span><span class="main">)</span><span class="main">,</span> <span class="entity">raw_pure</span><span class="main">)</span><span class="main">,</span> <span class="entity">raw_ap</span><span class="main">)</span><span class="main">,</span> <span class="entity">raw_rel</span><span class="main">)</span><span class="main">,</span> <span class="entity">raw_set</span><span class="main">)</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb_unfolds</span> <span class="main">=</span> <span class="entity">Named_Theorems.get</span> <span class="entity">lthy</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> combinator_unfold<span class="antiquote">}</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">comb_reprs</span> <span class="main">=</span> <span class="entity">Named_Theorems.get</span> <span class="entity">lthy</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> combinator_repr<span class="antiquote">}</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">comb_defs</span><span class="main">,</span> <span class="entity">comb_rules</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_combinators</span> <span class="main">(</span>Context.Proof <span class="entity">lthy</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">name</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">if</span></span> Symtab.defined <span class="entity">comb_defs</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">then</span></span> I <span class="keyword2"><span class="keyword">else</span></span> error <span class="main">(</span><span class="inner_quoted">"Unknown combinator "</span> ^ quote <span class="entity">name</span><span class="main">)</span><span class="main">)</span>
      <span class="entity">flags</span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> has_duplicates <span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span> <span class="entity">flags</span>
      <span class="keyword2"><span class="keyword">then</span></span> warning <span class="inner_quoted">"Ignoring duplicate combinators"</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">user_combs0</span> <span class="main">=</span> Ord_List.make fast_string_ord <span class="entity">flags</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_pure'</span> <span class="main">=</span> Syntax.read_term <span class="entity">lthy</span> <span class="entity">raw_pure</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_ap'</span> <span class="main">=</span> Syntax.read_term <span class="entity">lthy</span> <span class="entity">raw_ap</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_rel'</span> <span class="main">=</span> Option.map <span class="main">(</span>Syntax.read_term <span class="entity">lthy</span><span class="main">)</span> <span class="entity">raw_rel</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_set'</span> <span class="main">=</span> Option.map <span class="main">(</span>Syntax.read_term <span class="entity">lthy</span><span class="main">)</span> <span class="entity">raw_set</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">terms</span><span class="main">,</span> <span class="entity">rel</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_terms</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">raw_pure'</span><span class="main">,</span> <span class="entity">raw_ap'</span><span class="main">,</span> <span class="entity">raw_rel'</span><span class="main">,</span> <span class="entity">raw_set'</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">derived_combs0</span> <span class="main">=</span> <span class="entity">combinator_closure</span> <span class="entity">comb_rules</span> false <span class="entity">user_combs0</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">required_combs</span> <span class="main">=</span> Ord_List.make fast_string_ord <span class="main">[</span><span class="inner_quoted">"B"</span><span class="main">,</span> <span class="inner_quoted">"I"</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">user_combs</span> <span class="main">=</span> Ord_List.union fast_string_ord <span class="entity">user_combs0</span>
      <span class="main">(</span>Ord_List.subtract fast_string_ord <span class="entity">derived_combs0</span> <span class="entity">required_combs</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">derived_combs1</span> <span class="main">=</span> <span class="entity">combinator_closure</span> <span class="entity">comb_rules</span> false <span class="entity">user_combs</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">derived_combs2</span> <span class="main">=</span> <span class="entity">combinator_closure</span> <span class="entity">comb_rules</span> true <span class="entity">derived_combs1</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_redundant</span> <span class="entity">comb</span> <span class="main">=</span> eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">derived_combs2</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">combinator_closure</span> <span class="entity">comb_rules</span> true <span class="main">(</span>Ord_List.remove fast_string_ord <span class="entity">comb</span> <span class="entity">user_combs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">redundant_combs</span> <span class="main">=</span> filter <span class="entity">is_redundant</span> <span class="entity">user_combs</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">redundant_combs</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span>
      warning <span class="main">(</span><span class="inner_quoted">"Redundant combinators: "</span> ^ commas <span class="entity">redundant_combs</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prove_interchange</span> <span class="main">=</span> not <span class="main">(</span>Ord_List.member fast_string_ord <span class="entity">derived_combs1</span> <span class="inner_quoted">"T"</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">af_inst</span><span class="main">,</span> <span class="entity">ctxt_af</span><span class="main">)</span> <span class="main">=</span> <span class="entity">import_afun_inst_raw</span> <span class="entity">terms</span> <span class="entity">lthy</span><span class="main">;</span>
    <span class="comment1">(* TODO: reuse TFrees from above *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">rel_insts</span><span class="main">,</span> <span class="entity">ctxt_inst</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">rel</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="main">(</span>NONE<span class="main">,</span> <span class="entity">ctxt_af</span><span class="main">)</span>
      <span class="main">|</span> SOME <span class="entity">r</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">rel_inst</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">import_poly_terms</span> <span class="entity">r</span> <span class="entity">ctxt_af</span> |&gt;&gt; the_single<span class="main">;</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> fastype_of <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> <span class="entity">rel_inst</span><span class="main">)</span> |&gt; range_type |&gt; domain_type<span class="main">;</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">af_inst</span> <span class="main">=</span> <span class="entity">match_poly_terms_type</span> <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">terms</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="inner_numeral">~1</span><span class="main">)</span> |&gt; <span class="entity">mk_afun_inst</span><span class="main">;</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span>SOME <span class="main">(</span><span class="entity">af_inst</span><span class="main">,</span> <span class="entity">rel_inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_propss</span> <span class="main">=</span> <span class="main">[</span>apfst single o <span class="entity">mk_homomorphism_prop</span> <span class="entity">af_inst</span><span class="main">,</span>
      fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">comb</span> <span class="main">=&gt;</span> <span class="entity">mk_comb_prop</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span>the <span class="main">(</span>Symtab.lookup <span class="entity">comb_defs</span> <span class="entity">comb</span><span class="main">)</span><span class="main">)</span> <span class="entity">af_inst</span><span class="main">)</span> <span class="entity">user_combs</span><span class="main">,</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">prove_interchange</span> <span class="keyword2"><span class="keyword">then</span></span> apfst single o <span class="entity">mk_interchange_prop</span> <span class="entity">af_inst</span> <span class="keyword2"><span class="keyword">else</span></span> pair <span class="main">[</span><span class="main">]</span><span class="main">,</span>
      <span class="keyword2"><span class="keyword">if</span></span> is_some <span class="entity">rel</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_rel_props</span> <span class="main">(</span>the <span class="entity">rel_insts</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> pair <span class="main">[</span><span class="main">]</span><span class="main">]</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">propss</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt_Ts</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> fold_map I <span class="entity">mk_propss</span> <span class="main">(</span><span class="entity">ctxt_inst</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">repr_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> Raw_Simplifier.rewrite_goals_tac <span class="entity">ctxt</span> <span class="entity">comb_reprs</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">after_qed</span> <span class="entity">thmss</span> <span class="entity">lthy'</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">[</span><span class="main">[</span><span class="entity">hom_thm</span><span class="main">]</span><span class="main">,</span> <span class="entity">user_thms</span><span class="main">,</span> <span class="entity">ichng_thms</span><span class="main">,</span> <span class="entity">rel_thms</span><span class="main">]</span> <span class="main">=</span> map <span class="main">(</span>Variable.export <span class="entity">lthy'</span> <span class="entity">ctxt_inst</span><span class="main">)</span> <span class="entity">thmss</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">reds</span><span class="main">,</span> <span class="entity">ichng_thm</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_comb_reds</span> <span class="entity">ctxt_inst</span> <span class="main">(</span><span class="main">(</span><span class="entity">comb_defs</span><span class="main">,</span> <span class="entity">comb_rules</span><span class="main">)</span><span class="main">,</span> <span class="entity">comb_unfolds</span><span class="main">)</span>
          <span class="entity">af_inst</span> <span class="entity">user_combs</span> <span class="main">(</span><span class="entity">hom_thm</span><span class="main">,</span> <span class="entity">user_thms</span><span class="main">,</span> <span class="entity">ichng_thms</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rel_axioms</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">rel_thms</span> <span class="keyword2"><span class="keyword">of</span></span>
            <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> NONE
          <span class="main">|</span> <span class="main">[</span><span class="entity">thm1</span><span class="main">,</span> <span class="entity">thm2</span><span class="main">]</span> <span class="main">=&gt;</span> SOME <span class="main">{</span>pure_transfer <span class="main">=</span> <span class="entity">thm1</span><span class="main">,</span> ap_rel_fun <span class="main">=</span> <span class="entity">thm2</span><span class="main">}</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">af_thms</span> <span class="main">=</span> <span class="entity">mk_afun_thms</span> <span class="entity">ctxt_inst</span> <span class="entity">af_inst</span> <span class="main">(</span><span class="entity">hom_thm</span><span class="main">,</span> <span class="entity">ichng_thm</span><span class="main">,</span> <span class="entity">reds</span><span class="main">,</span> <span class="entity">rel_axioms</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">af_thms</span> <span class="main">=</span> <span class="entity">map_afun_thms</span> <span class="main">(</span>singleton <span class="main">(</span>Variable.export <span class="entity">ctxt_inst</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="entity">af_thms</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">af</span> <span class="main">=</span> <span class="entity">mk_afun</span> <span class="entity">name</span> <span class="entity">terms</span> <span class="entity">rel</span> <span class="entity">af_thms</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">lthy</span>
        |&gt; <span class="entity">register_afun</span> <span class="entity">af</span>
        |&gt; <span class="entity">note_afun_thms</span> <span class="entity">af</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Proof.theorem</span> NONE <span class="entity">after_qed</span> <span class="main">(</span><span class="main">(</span>map o map<span class="main">)</span> <span class="main">(</span>rpair <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">propss</span><span class="main">)</span> <span class="entity">ctxt_Ts</span>
    |&gt; <span class="entity">Proof.refine</span> <span class="main">(</span><span class="entity">Method.Basic</span> <span class="main">(</span><span class="entity">SIMPLE_METHOD</span> o <span class="entity">repr_tac</span><span class="main">)</span><span class="main">)</span>
    |&gt; Seq.the_result <span class="inner_quoted">""</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_afuns</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_afun</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">af</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">[</span><span class="entity">pT</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">pure</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ap</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">set</span><span class="main">)</span><span class="main">]</span> <span class="main">=</span> <span class="entity">unpack_poly_terms</span> <span class="main">(</span><span class="entity">terms_of_afun</span> <span class="entity">af</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">tvar</span><span class="main">]</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> <span class="entity">poly_type_of_term</span> <span class="entity">pT</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rel</span> <span class="main">=</span> Option.map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> o the_single o <span class="entity">unpack_poly_terms</span><span class="main">)</span> <span class="main">(</span><span class="entity">rel_of_afun</span> <span class="entity">af</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">combinators</span> <span class="main">=</span> Symtab.keys <span class="main">(</span><span class="main">#</span>reds <span class="main">(</span><span class="entity">thms_of_afun</span> <span class="entity">af</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> Pretty.block <span class="main">(</span>Pretty.fbreaks <span class="main">(</span><span class="main">[</span>Pretty.block <span class="main">[</span>Pretty.str <span class="entity">name</span><span class="main">,</span> Pretty.str <span class="inner_quoted">":"</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span>
          Pretty.quote <span class="main">(</span>Syntax.pretty_typ <span class="entity">ctxt</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span> Pretty.str <span class="inner_quoted">"of"</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span>
          Syntax.pretty_typ <span class="entity">ctxt</span> <span class="entity">tvar</span><span class="main">]</span><span class="main">,</span>
        Pretty.block <span class="main">[</span>Pretty.str <span class="inner_quoted">"pure:"</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span> Pretty.quote <span class="main">(</span>Syntax.pretty_term <span class="entity">ctxt</span> <span class="entity">pure</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
        Pretty.block <span class="main">[</span>Pretty.str <span class="inner_quoted">"ap:"</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span> Pretty.quote <span class="main">(</span>Syntax.pretty_term <span class="entity">ctxt</span> <span class="entity">ap</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
        Pretty.block <span class="main">[</span>Pretty.str <span class="inner_quoted">"set:"</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span> Pretty.quote <span class="main">(</span>Syntax.pretty_term <span class="entity">ctxt</span> <span class="entity">set</span><span class="main">)</span><span class="main">]</span><span class="main">]</span> @
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">rel</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
        <span class="main">|</span> SOME <span class="entity">rel'</span> <span class="main">=&gt;</span> <span class="main">[</span>Pretty.block <span class="main">[</span>Pretty.str <span class="inner_quoted">"rel:"</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span>
            Pretty.quote <span class="main">(</span>Syntax.pretty_term <span class="entity">ctxt</span> <span class="entity">rel'</span><span class="main">)</span><span class="main">]</span><span class="main">]</span><span class="main">)</span> @
        <span class="main">[</span>Pretty.block <span class="main">(</span><span class="main">[</span>Pretty.str <span class="inner_quoted">"combinators:"</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">]</span> @
          Pretty.commas <span class="main">(</span>map Pretty.str <span class="entity">combinators</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">afuns</span> <span class="main">=</span> sort_by <span class="main">#</span><span class="inner_numeral">1</span> <span class="main">(</span>Name_Space.fold_table cons <span class="main">(</span><span class="entity">get_afun_table</span> <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> Pretty.writeln <span class="main">(</span>Pretty.big_list <span class="inner_quoted">"Registered applicative functors:"</span> <span class="main">(</span>map <span class="entity">pretty_afun</span> <span class="entity">afuns</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="comment1">(* Unfolding *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_unfold_thm</span> <span class="entity">name</span> <span class="entity">thm</span> <span class="entity">context</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Thm.prop_of <span class="entity">thm</span> |&gt; <span class="entity">HOLogic.dest_Trueprop</span> |&gt; <span class="entity">HOLogic.dest_eq</span>
      <span class="keyword3"><span class="keyword">handle</span></span> TERM <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"Not an equation"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">names</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">of</span></span>
        SOME <span class="entity">n</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">intern</span> <span class="entity">context</span> <span class="entity">n</span><span class="main">]</span>
      <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">match_typ</span> <span class="entity">context</span> <span class="main">(</span>Term.fastype_of <span class="entity">lhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="entity">ns</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span>::<span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">ns</span>
        <span class="main">|</span> <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"Unable to determine applicative functor instance"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">afun_of_generic</span> <span class="entity">context</span><span class="main">)</span> <span class="entity">names</span><span class="main">;</span>
    <span class="comment1">(*TODO: check equation*)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm'</span> <span class="main">=</span> <span class="entity">mk_meta_eq</span> <span class="entity">thm</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> <span class="entity">update_afun</span> <span class="entity">n</span> <span class="main">(</span><span class="entity">add_unfolds_afun</span> <span class="main">[</span><span class="entity">thm'</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">names</span> <span class="entity">context</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_unfold_attrib</span> <span class="entity">name</span> <span class="main">=</span> Thm.declaration_attribute <span class="main">(</span><span class="entity">add_unfold_thm</span> <span class="entity">name</span><span class="main">)</span><span class="main">;</span>

<span class="comment1">(*TODO: attribute to delete unfolds*)</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
</pre>
</div><div id="Applicative_Environment">
<div class="head">
<h1>Theory Applicative_Environment</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Common applicative functors›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Environment functor›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Environment <span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">const</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">apf</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">z</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.pure <span class="quoted">const</span>
<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">apf</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The declaration below demonstrates that applicative functors which lift the reductions
  for combinators K and W also lift C. However, the interchange law must be supplied in this case.›</span></span>

<span class="keyword1"><span class="command">applicative</span></span> env <span class="main">(</span>K<span class="main">,</span> W<span class="main">)</span>
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">const</span>
  ap<span class="main">:</span> <span class="quoted">apf</span>
  rel<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_fun <span class="main">(=)</span>"</span></span>
  set<span class="main">:</span> <span class="quoted">range</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> const_def apf_def rel_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"const <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">⋄</span> <span class="free">y</span> <span class="main">=</span> <span class="free">f</span> <span class="main">⋄</span> <span class="free">y</span> <span class="main">⋄</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Option">
<div class="head">
<h1>Theory Applicative_Option</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Option›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Option <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ap_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> option <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'b</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">ap_option</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ap_option</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> None"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">pure_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pure_option</span> <span class="main">≡</span> Some"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.pure <span class="quoted">pure_option</span>
<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_option</span>

<span class="keyword1"><span class="command">lemma</span></span> some_ap_option<span class="main">:</span> <span class="quoted"><span class="quoted">"ap_option <span class="main">(</span>Some <span class="free">f</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> map_option <span class="free">f</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_some_option<span class="main">:</span> <span class="quoted"><span class="quoted">"ap_option <span class="free">f</span> <span class="main">(</span>Some <span class="free">x</span><span class="main">)</span> <span class="main">=</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">g</span><span class="main">.</span> <span class="bound">g</span> <span class="free">x</span><span class="main">)</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_option_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_fun <span class="main">(</span>rel_option <span class="main">(</span>rel_fun <span class="free">A</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>rel_fun <span class="main">(</span>rel_option <span class="free">A</span><span class="main">)</span> <span class="main">(</span>rel_option <span class="free">B</span><span class="main">)</span><span class="main">)</span> ap_option ap_option"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> option.rel_cases <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">applicative</span></span> option <span class="main">(</span>C<span class="main">,</span> W<span class="main">)</span>
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">Some</span>
  ap<span class="main">:</span> <span class="quoted">ap_option</span>
  rel<span class="main">:</span> <span class="quoted">rel_option</span>
  set<span class="main">:</span> <span class="quoted">set_option</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">include</span></span> applicative_syntax
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">g</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> option.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> option.exhaust<span class="main"><span class="main">,</span></span> <span class="operator">case_product</span> option.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">⋄</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">y</span> <span class="main">⋄</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> option.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> option.exhaust<span class="main"><span class="main">,</span></span> <span class="operator">case_product</span> option.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">⋄</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> option.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> option.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_fun <span class="skolem">R</span> <span class="main">(</span>rel_option <span class="skolem">R</span><span class="main">)</span> pure pure"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_option <span class="main">(</span>rel_fun <span class="main">(</span>eq_on <span class="main">(</span>set_option <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">R</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_option <span class="main">(</span>eq_on <span class="main">(</span>set_option <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> option.rel_refl_strong<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_option <span class="skolem">R</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> some_ap_option ap_some_option<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_option_ap_conv<span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"map_option <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> ap_option <span class="main">(</span>pure <span class="free">f</span><span class="main">)</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> option.exhaust<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">no_adhoc_overloading</span></span> Applicative.pure <span class="quoted">pure_option</span> <span class="comment1">― ‹We do not want to print all occurrences of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> "Some"<span class="antiquote">}</span></span> as <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> "pure"<span class="antiquote">}</span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Sum">
<div class="head">
<h1>Theory Applicative_Sum</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Sum types›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Sum <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  There are several ways to define an applicative functor based on sum types. First, we can choose
  whether the left or the right type is fixed. Both cases are isomorphic, of course. Next, what
  should happen if two values of the fixed type are combined? The corresponding operator must be
  associative, or the idiom laws don't hold true.

  We focus on the cases where the right type is fixed. We define two concrete functors: One based
  on Haskell's \textsf{Either} datatype, which prefers the value of the left operand, and a generic
  one using the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> semigroup_add<span class="antiquote"><span class="antiquote">}</span></span></span></span> class. Only the former lifts the \textbf{W} combinator,
  though.
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ap_sum</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'e</span> <span class="main">⇒</span> <span class="tfree">'e</span> <span class="main">⇒</span> <span class="tfree">'e</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">+</span> <span class="tfree">'e</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'e</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">+</span> <span class="tfree">'e</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">ap_sum</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> Inl <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ap_sum</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>Inl <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> Inr <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ap_sum</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">(</span>Inl <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> Inr <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ap_sum</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">e1</span></span></span><span class="main">)</span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span> <span class="main">=</span> Inr <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">e1</span></span></span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">ap_either</span> <span class="main">≡</span> ap_sum <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">ap_plus</span> <span class="main">≡</span> ap_sum <span class="main">(</span>plus <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> semigroup_add <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">pure_sum</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pure_sum</span> <span class="main">≡</span> Inl"</span></span>
<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.pure <span class="quoted">pure_sum</span>
<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_either</span> <span class="comment1">(* ap_plus *)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_sum_id<span class="main">:</span> <span class="quoted"><span class="quoted">"ap_sum <span class="free">c</span> <span class="main">(</span>Inl id<span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_sum_ichng<span class="main">:</span> <span class="quoted"><span class="quoted">"ap_sum <span class="free">c</span> <span class="free">f</span> <span class="main">(</span>Inl <span class="free">x</span><span class="main">)</span> <span class="main">=</span> ap_sum <span class="free">c</span> <span class="main">(</span>Inl <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> semigroup<span class="main">)</span> ap_sum_comp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ap_sum <span class="free">f</span> <span class="main">(</span>ap_sum <span class="free">f</span> <span class="main">(</span>ap_sum <span class="free">f</span> <span class="main">(</span>Inl <span class="keyword1">(o)</span><span class="main">)</span> <span class="free">h</span><span class="main">)</span> <span class="free">g</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> ap_sum <span class="free">f</span> <span class="free">h</span> <span class="main">(</span>ap_sum <span class="free">f</span> <span class="free">g</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">h</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sum.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> sum.exhaust<span class="main"><span class="main">,</span></span> <span class="operator">case_product</span> sum.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> local.assoc<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> semigroup_const<span class="main">:</span> <span class="quoted"><span class="quoted">"semigroup <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">locale</span></span> either_af <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> B_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"reflp <span class="free">B</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">applicative</span></span> either <span class="main">(</span>W<span class="main">)</span>
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">Inl</span>
  ap<span class="main">:</span> <span class="quoted">ap_either</span>
  rel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">A</span><span class="main">.</span> rel_sum <span class="bound">A</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">include</span></span> applicative_syntax
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span><span class="main">)</span> <span class="main">+</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">⋄</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sum.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> sum.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword1"><span class="command">interpret</span></span> semigroup <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> semigroup_const<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'e</span><span class="main">)</span> <span class="main">+</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span><span class="main">)</span> <span class="main">+</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ap_sum_comp<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> comp_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span><span class="main">)</span> <span class="main">+</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'e</span><span class="main">)</span> <span class="main">+</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"rel_sum <span class="main">(</span>rel_fun <span class="main">(</span>eq_on UNIV<span class="main">)</span> <span class="skolem">R</span><span class="main">)</span> <span class="free">B</span> <span class="skolem">f</span> <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_sum <span class="skolem">R</span> <span class="free">B</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">g</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sum.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> sum.exhaust<span class="main"><span class="main">,</span></span> <span class="operator">case_product</span> sum.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> B_refl<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> reflpD<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_funE<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ap_sum_id<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> id_def<span class="main"><span class="main">]</span></span> ap_sum_ichng<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* locale *)</span>

<span class="keyword1"><span class="command">interpretation</span></span> either_af <span class="quoted"><span class="quoted">"<span class="main">(=)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">applicative</span></span> semigroup_sum
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">Inl</span>
  ap<span class="main">:</span> <span class="quoted">ap_plus</span>
<span class="keyword1"><span class="command">using</span></span>
  ap_sum_id<span class="main">[</span><span class="operator">simplified</span> id_def<span class="main">]</span>
  ap_sum_ichng
  add.ap_sum_comp<span class="main">[</span><span class="operator">simplified</span> comp_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">no_adhoc_overloading</span></span> Applicative.pure <span class="quoted">pure_sum</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Set">
<div class="head">
<h1>Theory Applicative_Set</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Set with Cartesian product›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Set <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ap_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'b</span> set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ap_set</span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">f</span> <span class="bound">x</span> <span class="main">|</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_set</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_set_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_fun <span class="main">(</span>rel_set <span class="main">(</span>rel_fun <span class="free">A</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>rel_fun <span class="main">(</span>rel_set <span class="free">A</span><span class="main">)</span> <span class="main">(</span>rel_set <span class="free">B</span><span class="main">)</span><span class="main">)</span> ap_set ap_set"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_set_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> rel_set_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_funE<span class="main">)</span>

<span class="keyword1"><span class="command">applicative</span></span> set <span class="main">(</span>C<span class="main">)</span>
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span>"</span></span>
  ap<span class="main">:</span> <span class="quoted">ap_set</span>
  rel<span class="main">:</span> <span class="quoted">rel_set</span>
  set<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_fun <span class="skolem">R</span> <span class="main">(</span>rel_set <span class="skolem">R</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_setI<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_set <span class="main">(</span>rel_fun <span class="main">(</span>eq_on <span class="skolem">x</span><span class="main">)</span> <span class="skolem">R</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">g</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_set <span class="main">(</span>eq_on <span class="skolem">x</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_setI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_set <span class="skolem">R</span> <span class="main">(</span>ap_set <span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>ap_set <span class="skolem">g</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">unfold</span> ap_set_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">fast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_List">
<div class="head">
<h1>Theory Applicative_List</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lists›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_List <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ap_list</span> <span class="free"><span class="bound"><span class="entity">fs</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> List.bind <span class="free"><span class="bound"><span class="entity">fs</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> List.bind <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">[</span><span class="bound">f</span> <span class="bound">x</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_list</span>

<span class="keyword1"><span class="command">lemma</span></span> Nil_ap<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ap_list <span class="main">[]</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_list_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_Nil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ap_list <span class="free">fs</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_list_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">fs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_list_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_fun <span class="main">(</span>list_all2 <span class="main">(</span>rel_fun <span class="free">A</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>rel_fun <span class="main">(</span>list_all2 <span class="free">A</span><span class="main">)</span> <span class="main">(</span>list_all2 <span class="free">B</span><span class="main">)</span><span class="main">)</span> ap_list ap_list"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> List.bind_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cons_ap_list<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">#</span> <span class="free">fs</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">xs</span> <span class="main">=</span> map <span class="free">f</span> <span class="free">xs</span> <span class="main">@</span> <span class="free">fs</span> <span class="main">⋄</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_list_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> append_ap_distrib<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">fs</span> <span class="main">@</span> <span class="free">gs</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">fs</span> <span class="main">⋄</span> <span class="free">xs</span> <span class="main">@</span> <span class="free">gs</span> <span class="main">⋄</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_list_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">fs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">applicative</span></span> list
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span>"</span></span>
  ap<span class="main">:</span> <span class="quoted">ap_list</span>
  rel<span class="main">:</span> <span class="quoted">list_all2</span>
  set<span class="main">:</span> <span class="quoted">set</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ap_list_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?B</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="var">?B</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">g</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">g</span> <span class="skolem">gs</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> g_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="var">?B</span> <span class="skolem">g</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">g</span><span class="main">]</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">f</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">f</span> <span class="skolem">fs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="var">?B</span> <span class="skolem">g</span><span class="main">]</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">#</span> <span class="skolem">fs</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">g</span><span class="main">]</span> <span class="main">⋄</span> <span class="main">(</span><span class="main">[</span><span class="skolem">f</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">@</span> <span class="main">[</span><span class="var">?B</span> <span class="skolem">g</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">fs</span> <span class="main">⋄</span> <span class="skolem">x</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cons_ap_list<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">g</span><span class="main">]</span> <span class="main">⋄</span> <span class="main">(</span><span class="main">[</span><span class="skolem">f</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">g</span><span class="main">]</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">fs</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.IH <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">g</span><span class="main">]</span> <span class="main">⋄</span> <span class="main">(</span><span class="main">(</span><span class="skolem">f</span> <span class="main">#</span> <span class="skolem">fs</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cons_ap_list<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="var">?B</span><span class="main">]</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">g</span> <span class="main">#</span> <span class="skolem">gs</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">[</span><span class="var">?B</span> <span class="skolem">g</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">@</span> <span class="main">[</span><span class="var">?B</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">gs</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cons_ap_list append_ap_distrib<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">g</span><span class="main">]</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">@</span> <span class="skolem">gs</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g_comp Cons.IH <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">g</span> <span class="main">#</span> <span class="skolem">gs</span><span class="main">)</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cons_ap_list<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">⋄</span> <span class="main">[</span><span class="skolem">x</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="skolem">x</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ap_list_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_fun <span class="skolem">R</span> <span class="main">(</span>list_all2 <span class="skolem">R</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span>rel_fun <span class="main">(</span>eq_on <span class="main">(</span>set <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">R</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">g</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span>eq_on <span class="main">(</span>set <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all2_same<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"list_all2 <span class="skolem">R</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cons_ap_list<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_ap_conv<span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"map <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="main">[</span><span class="free">f</span><span class="main">]</span> <span class="main">⋄</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_list_def List.bind_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_DNEList">
<div class="head">
<h1>Theory Applicative_DNEList</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Distinct, non-empty list›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_DNEList <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative_List.html">Applicative_List</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Dlist.html">HOL-Library.Dlist</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bind_eq_Nil_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"List.bind <span class="free">xs</span> <span class="free">f</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="free">xs</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> List.bind_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> zip_eq_Nil_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"zip <span class="free">xs</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∨</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> list.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> remdups_append1<span class="main">:</span> <span class="quoted"><span class="quoted">"remdups <span class="main">(</span>remdups <span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> remdups <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> remdups_append2<span class="main">:</span> <span class="quoted"><span class="quoted">"remdups <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> remdups <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> remdups <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> remdups_append1_drop<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> set <span class="free">ys</span> <span class="main">⟹</span> remdups <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> remdups <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> remdups_concat_map<span class="main">:</span> <span class="quoted"><span class="quoted">"remdups <span class="main">(</span>concat <span class="main">(</span>map remdups <span class="free">xss</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> remdups <span class="main">(</span>concat <span class="free">xss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xss</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> remdups_append1<span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> remdups_append2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> remdups_concat_remdups<span class="main">:</span> <span class="quoted"><span class="quoted">"remdups <span class="main">(</span>concat <span class="main">(</span>remdups <span class="free">xss</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> remdups <span class="main">(</span>concat <span class="free">xss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xss</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> remdups_append1_drop<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> remdups_append1_drop<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> remdups_append2<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> remdups_replicate<span class="main">:</span> <span class="quoted"><span class="quoted">"remdups <span class="main">(</span>replicate <span class="free">n</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">simp_all</span>


<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'a</span> dnelist <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">xs</span><span class="main">::</span><span class="tfree">'a</span> list<span class="main">.</span> distinct <span class="bound">xs</span> <span class="main">∧</span> <span class="bound">xs</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">morphisms</span></span> list_of_dnelist Abs_dnelist
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="skolem">x</span><span class="main">]</span> <span class="main">∈</span> <span class="var">?dnelist</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_dnelist

<span class="keyword1"><span class="command">lemma</span></span> dnelist_subtype_dlist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"type_definition <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> Dlist <span class="main">(</span>list_of_dnelist <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> Abs_dnelist <span class="main">(</span>list_of_dlist <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">xs</span> <span class="main">≠</span> Dlist.empty<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dlist_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_remdups_id dnelist.list_of_dnelist<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span> list_of_dnelist_inverse<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dlist_eq_iff Abs_dnelist_inverse<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lift_bnf</span></span> <span class="main">(</span>no_warn_transfer<span class="main">,</span> no_warn_wits<span class="main">)</span> <span class="tfree">'a</span> dnelist via dnelist_subtype_dlist <span class="keyword2"><span class="keyword">for</span></span> map<span class="main">:</span> map
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dlist_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> map

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">lemma</span></span> map_def<span class="main">:</span> <span class="quoted"><span class="quoted">"Applicative_DNEList.map <span class="main">=</span> map_fun id <span class="main">(</span>map_fun list_of_dnelist Abs_dnelist<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">xs</span><span class="main">.</span> remdups <span class="main">(</span>list.map <span class="bound">f</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> map_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff distinct_remdups_id list_of_dnelist<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">lemma</span></span> map_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_fun <span class="main">(=)</span> <span class="main">(</span>rel_fun <span class="main">(</span>pcr_dnelist <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span>pcr_dnelist <span class="main">(=)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">xs</span><span class="main">.</span> remdups <span class="main">(</span>map <span class="bound">f</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span> Applicative_DNEList.map"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_def rel_fun_def dnelist.pcr_cr_eq cr_dnelist_def list_of_dnelist<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span> Abs_dnelist_inverse<span class="main">)</span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">lift_definition</span></span> single <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> dnelist"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">lift_definition</span></span> insert <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> dnelist <span class="main">⇒</span> <span class="tfree">'a</span> dnelist"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="bound">xs</span> <span class="keyword1">then</span> <span class="bound">xs</span> <span class="keyword1">else</span> <span class="bound">x</span> <span class="main">#</span> <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">lift_definition</span></span> append <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dnelist <span class="main">⇒</span> <span class="tfree">'a</span> dnelist <span class="main">⇒</span> <span class="tfree">'a</span> dnelist"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> remdups <span class="main">(</span><span class="bound">xs</span> <span class="main">@</span> <span class="bound">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">lift_definition</span></span> bind <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dnelist <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> dnelist<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span> dnelist"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">xs</span> <span class="bound">f</span><span class="main">.</span> remdups <span class="main">(</span>List.bind <span class="bound">xs</span> <span class="bound">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">pure_dnelist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> dnelist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pure_dnelist</span> <span class="main">≡</span> single"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> ap_dnelist <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> dnelist <span class="main">⇒</span> <span class="tfree">'a</span> dnelist <span class="main">⇒</span> <span class="tfree">'b</span> dnelist"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> remdups <span class="main">(</span>ap_list <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_list_def<span class="main">)</span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_dnelist</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_pure_list <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ap_list <span class="main">[</span><span class="free">f</span><span class="main">]</span> <span class="free">xs</span> <span class="main">=</span> map <span class="free">f</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_list_def List.bind_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ap_pure_dlist<span class="main">:</span> <span class="quoted"><span class="quoted">"pure_dnelist <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">=</span> Applicative_DNEList.map <span class="free">f</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">applicative</span></span> dnelist <span class="main">(</span>K<span class="main">)</span>
<span class="keyword2"><span class="keyword">for</span></span> pure<span class="main">:</span> <span class="quoted">pure_dnelist</span>
    ap<span class="main">:</span> <span class="quoted">ap_dnelist</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure_dnelist <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dnelist"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"remdups <span class="main">(</span>remdups <span class="main">(</span>remdups <span class="main">(</span><span class="main">[</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> remdups <span class="main">(</span><span class="skolem">g</span> <span class="main">⋄</span> remdups <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> remdups <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> map <span class="bound">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>remdups <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> ap_list_def List.bind_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> remdups_concat_remdups<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def remdups_map_remdups remdups_concat_remdups<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span>  remdups <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> map <span class="bound">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> remdups_concat_remdups<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> remdups_map_remdups remdups_concat_remdups<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> remdups <span class="main">(</span>concat <span class="main">(</span>map remdups <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">g</span><span class="main">.</span> map <span class="bound">g</span> <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> map <span class="bound">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> list.pure_B_conv<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">g</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> remdups_concat_map
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_list_def List.bind_def o_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ap_list_def List.bind_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> remdups_concat_map<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def remdups_map_remdups<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure_dnelist <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> dnelist"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> dnelist"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">rule</span> *<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure_dnelist <span class="skolem">f</span> <span class="main">⋄</span> pure_dnelist <span class="skolem">x</span> <span class="main">=</span> pure_dnelist <span class="main">(</span><span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">⋄</span> pure_dnelist <span class="skolem">x</span> <span class="main">=</span> pure_dnelist <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">f</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> dnelist"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list.interchange<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"remdups <span class="main">(</span>remdups <span class="main">(</span><span class="main">[</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"remdups <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_map inj_on_def fun_eq_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"remdups <span class="main">(</span>remdups <span class="main">(</span><span class="main">[</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> remdups <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> map <span class="bound">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_list_def List.bind_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> remdups_id_iff_distinct<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> that
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def map_replicate_const<span class="main">)</span><span class="main">(</span><span class="operator">subst</span> remdups_concat_map<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def remdups_replicate<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure_dnelist <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">⋄</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> dnelist"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dnelist"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">rule</span> *<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">_</span></span> dnelist"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> does not have combinator C, so it cannot have W either.›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lift_definition</span></span> x <span class="main">::</span> <span class="quoted"><span class="quoted">"int dnelist"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lift_definition</span></span> y <span class="main">::</span> <span class="quoted"><span class="quoted">"int dnelist"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="numeral">5</span><span class="main">,</span><span class="numeral">7</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"pure_dnelist <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> pure_dnelist <span class="main">(</span><span class="main">(*)</span><span class="main">)</span> <span class="main">⋄</span> x <span class="main">⋄</span> y <span class="main">≠</span> pure_dnelist <span class="main">(</span><span class="main">(*)</span><span class="main">)</span> <span class="main">⋄</span> y <span class="main">⋄</span> x"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_list_def fun_eq_iff<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Monoid">
<div class="head">
<h1>Theory Applicative_Monoid</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monoid›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Monoid <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative.html">Applicative</a> 
  <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> monoid_ap <span class="main">=</span> Monoid_ap <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> zero<span class="main">)</span> <span class="entity">pure_monoid_add</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> monoid_ap"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pure_monoid_add</span> <span class="main">=</span> Monoid_ap <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> plus<span class="main">)</span> <span class="entity">ap_monoid_add</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> monoid_ap <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> monoid_ap <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> monoid_ap"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ap_monoid_add</span> <span class="main">(</span>Monoid_ap <span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">(</span>Monoid_ap <span class="free"><span class="bound"><span class="entity">a2</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> Monoid_ap <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹
  fold Sign.add_const_constraint
   <span class="main">[</span><span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> pure_monoid_add<span class="antiquote">}</span></span><span class="main">,</span> SOME <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> monoid_add<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> monoid_ap"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
    <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> ap_monoid_add<span class="antiquote">}</span></span><span class="main">,</span> SOME <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> monoid_add<span class="main">,</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> monoid_ap <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> monoid_ap <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> monoid_ap"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
›</span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.pure <span class="quoted">pure_monoid_add</span>
<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_monoid_add</span>

<span class="keyword1"><span class="command">applicative</span></span> monoid_add
  <span class="keyword2"><span class="keyword">for</span></span> pure<span class="main">:</span> <span class="quoted">pure_monoid_add</span>
      ap<span class="main">:</span> <span class="quoted">ap_monoid_add</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_monoid_add_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> g f x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">g</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> monoid_ap.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> monoid_ap.exhaust<span class="main"><span class="main">,</span></span> <span class="operator">case_product</span> monoid_ap.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_monoid_add_def add.assoc<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_monoid_add_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> f x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">f</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_monoid_add_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">applicative</span></span> comm_monoid_add <span class="main">(</span>C<span class="main">)</span>
  <span class="keyword2"><span class="keyword">for</span></span> pure<span class="main">:</span> <span class="quoted"><span class="quoted">"pure_monoid_add <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">_</span> <span class="main">::</span> comm_monoid_add<span class="main">,</span> <span class="main">_</span><span class="main">)</span> monoid_ap"</span></span>
      ap<span class="main">:</span> <span class="quoted"><span class="quoted">"ap_monoid_add <span class="main">::</span> <span class="main">(</span><span class="main">_</span> <span class="main">::</span> comm_monoid_add<span class="main">,</span> <span class="main">_</span><span class="main">)</span> monoid_ap <span class="main">⇒</span> <span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> monoid_add.homomorphism monoid_add.pure_B_conv monoid_add.interchange<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> f x y <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> monoid_ap.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> monoid_ap.exhaust<span class="main"><span class="main">,</span></span> <span class="operator">case_product</span> monoid_ap.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_monoid_add_def add_ac<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> monoid_add.pure_I_conv<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">class</span></span> idemp_monoid_add <span class="main">=</span> monoid_add <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> add_idemp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">+</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>

<span class="keyword1"><span class="command">applicative</span></span> idemp_monoid_add <span class="main">(</span>W<span class="main">)</span>
  <span class="keyword2"><span class="keyword">for</span></span> pure<span class="main">:</span> <span class="quoted"><span class="quoted">"pure_monoid_add <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">_</span> <span class="main">::</span> idemp_monoid_add<span class="main">,</span> <span class="main">_</span><span class="main">)</span> monoid_ap"</span></span>
      ap<span class="main">:</span> <span class="quoted"><span class="quoted">"ap_monoid_add <span class="main">::</span> <span class="main">(</span><span class="main">_</span> <span class="main">::</span> idemp_monoid_add<span class="main">,</span> <span class="main">_</span><span class="main">)</span> monoid_ap <span class="main">⇒</span> <span class="main">_</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> monoid_add.homomorphism monoid_add.pure_B_conv monoid_add.pure_I_conv<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> f x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> monoid_ap.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> monoid_ap.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_monoid_add_def add.assoc add_idemp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> monoid_add.interchange<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Test case›</span></span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pure_monoid_add <span class="main">(+)</span> <span class="main">⋄</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="main">(</span>nat<span class="main">,</span> int<span class="main">)</span> monoid_ap<span class="main">)</span> <span class="main">⋄</span> <span class="free">y</span> <span class="main">=</span> pure <span class="main">(+)</span> <span class="main">⋄</span> <span class="free">y</span> <span class="main">⋄</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">applicative_lifting</span> comm_monoid_add<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Filter">
<div class="head">
<h1>Theory Applicative_Filter</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, Digital Asset *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Filters›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Filter <span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../../HOL/HOL/Complex_Main.html">Complex_Main</a>
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Conditional_Parametricity.html">HOL-Library.Conditional_Parametricity</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pure_filter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> filter"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pure_filter</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> principal <span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ap_filter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> filter <span class="main">⇒</span> <span class="tfree">'a</span> filter <span class="main">⇒</span> <span class="tfree">'b</span> filter"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ap_filter</span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> filtermap <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>prod_filter <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> eq_on_UNIV<span class="main">:</span> <span class="quoted"><span class="quoted">"eq_on UNIV <span class="main">=</span> <span class="main">(=)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> filtermap_parametric<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">parametric_constant</span></span> pure_filter_parametric<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> pure_filter_def
<span class="keyword1"><span class="command">parametric_constant</span></span> ap_filter_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> ap_filter_def

<span class="keyword1"><span class="command">applicative</span></span> filter <span class="main">(</span>C<span class="main">)</span>
  <span class="comment1">― ‹K is available for not-<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">bot</span><span class="antiquote">}</span></span> filters and W isholds not available›</span>
<span class="keyword2"><span class="keyword">for</span></span> 
  pure<span class="main">:</span> <span class="quoted"><span class="quoted">"pure_filter"</span></span>
  ap<span class="main">:</span> <span class="quoted"><span class="quoted">"ap_filter"</span></span>
  rel<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_filter"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ap_filter <span class="main">(</span>pure_filter <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>pure_filter <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> pure_filter <span class="main">(</span><span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_filter_def pure_filter_def principal_prod_principal<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ap_filter <span class="main">(</span>ap_filter <span class="main">(</span>ap_filter <span class="main">(</span>pure_filter <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span>
    ap_filter <span class="skolem">g</span> <span class="main">(</span>ap_filter <span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> filter"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> filter"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_filter_def pure_filter_def filtermap_filtermap prod_filtermap1 prod_filtermap2 apfst_def case_prod_map_prod prod_filter_assoc prod_filter_principal_singleton split_beta<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ap_filter <span class="main">(</span>pure_filter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> filter"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_filter_def pure_filter_def prod_filter_principal_singleton filtermap_filtermap<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ap_filter <span class="main">(</span>ap_filter <span class="main">(</span>ap_filter <span class="main">(</span>pure_filter <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">y</span> <span class="main">=</span>
    ap_filter <span class="main">(</span>ap_filter <span class="skolem">f</span> <span class="skolem">y</span><span class="main">)</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> filter"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_filter_def pure_filter_def filtermap_filtermap prod_filter_principal_singleton2 prod_filter_principal_singleton prod_filtermap1 prod_filtermap2 prod_filter_assoc split_beta<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> prod_filter_commute<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> filtermap_filtermap prod_filtermap1 prod_filtermap2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_fun <span class="skolem">R</span> <span class="main">(</span>rel_filter <span class="skolem">R</span><span class="main">)</span> pure_filter pure_filter"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> pure_filter_parametric<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_filter <span class="skolem">R</span> <span class="main">(</span>ap_filter <span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>ap_filter <span class="skolem">g</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"rel_filter <span class="main">(</span>rel_fun <span class="main">(</span>eq_on UNIV<span class="main">)</span> <span class="skolem">R</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">g</span>"</span></span> 
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> filter"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> filter"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> that<span class="main">[</span><span class="operator">unfolded</span> eq_on_UNIV<span class="main">,</span> <span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Applicative_State">
<div class="head">
<h1>Theory Applicative_State</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Lars Hupel, TU München *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹State monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_State
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/State_Monad.html">HOL-Library.State_Monad</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">applicative</span></span> state <span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">State_Monad.return</span>
  ap<span class="main">:</span> <span class="quoted">State_Monad.ap</span>
<span class="keyword1"><span class="command">unfolding</span></span> State_Monad.return_def State_Monad.ap_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Stream">
<div class="head">
<h1>Theory Applicative_Stream</h1>
</div>
<pre class="source"><span class="comment1">(* Author:     Andreas Lochbihler, ETH Zurich
   Author:     Joshua Schneider, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Streams as an applicative functor›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Stream <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Stream.html">HOL-Library.Stream</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="main">(</span>transfer<span class="main">)</span> <span class="entity">ap_stream</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> stream <span class="main">⇒</span> <span class="tfree">'a</span> stream <span class="main">⇒</span> <span class="tfree">'b</span> stream"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"shd <span class="main">(</span><span class="free">ap_stream</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> shd <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>shd <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"stl <span class="main">(</span><span class="free">ap_stream</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">ap_stream</span> <span class="main">(</span>stl <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">(</span>stl <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.pure <span class="quoted">sconst</span>
<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_stream</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax applicative_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ap_stream_id<span class="main">:</span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_stream_homo<span class="main">:</span> <span class="quoted"><span class="quoted">"pure <span class="free">f</span> <span class="main">⋄</span> pure <span class="free">x</span> <span class="main">=</span> pure <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">coinduction</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_stream_interchange<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⋄</span> pure <span class="free">x</span> <span class="main">=</span> pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_stream_composition<span class="main">:</span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">g</span> <span class="main">⋄</span> <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">=</span> <span class="free">g</span> <span class="main">⋄</span> <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">applicative</span></span> stream <span class="main">(</span>S<span class="main">,</span> K<span class="main">)</span>
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">sconst</span>
  ap<span class="main">:</span> <span class="quoted">ap_stream</span>
  rel<span class="main">:</span> <span class="quoted">stream_all2</span>
  set<span class="main">:</span> <span class="quoted">sset</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> stream"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="bound">x</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">g</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> stream"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> stream"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">⋄</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> stream_all2 <span class="skolem">R</span><span class="main">)</span> pure pure"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"stream_all2 <span class="skolem">R</span> <span class="main">(</span>pure <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>pure <span class="skolem">y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">coinduction</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> stream"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> stream"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stream_all2 <span class="main">(</span>eq_on <span class="main">(</span>sset <span class="skolem">x</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="skolem">R</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">g</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stream_all2 <span class="main">(</span>eq_on <span class="main">(</span>sset <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stream.rel_refl_strong<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"stream_all2 <span class="skolem">R</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">rule</span> ap_stream_homo<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_applicative<span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smap <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> pure <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_stream_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> smap2_applicative<span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smap2 <span class="free">f</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> pure <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">⋄</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_stream_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Open_State">
<div class="head">
<h1>Theory Applicative_Open_State</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Open state monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Open_State <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ap_state</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">g</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">s'</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s''</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">g</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">s''</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">pure_state</span> <span class="main">≡</span> Pair"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_state</span>

<span class="keyword1"><span class="command">applicative</span></span> state
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">pure_state</span>
  ap<span class="main">:</span> <span class="quoted"><span class="quoted">"ap_state <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_state_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_PMF">
<div class="head">
<h1>Theory Applicative_PMF</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Probability mass functions›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_PMF <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Probability/Probability.html">HOL-Probability.Probability</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">pure_pmf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> pmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pure_pmf</span> <span class="main">≡</span> return_pmf"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ap_pmf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> pmf <span class="main">⇒</span> <span class="tfree">'a</span> pmf <span class="main">⇒</span> <span class="tfree">'b</span> pmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ap_pmf</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> map_pmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>pair_pmf <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_pmf</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ap_pmf_id<span class="main">:</span> <span class="quoted"><span class="quoted">"pure_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_pmf_def pair_return_pmf1 pmf.map_comp o_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_pmf_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"pure_pmf <span class="main">(∘)</span> <span class="main">⋄</span> <span class="free">u</span> <span class="main">⋄</span> <span class="free">v</span> <span class="main">⋄</span> <span class="free">w</span> <span class="main">=</span> <span class="free">u</span> <span class="main">⋄</span> <span class="main">(</span><span class="free">v</span> <span class="main">⋄</span> <span class="free">w</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_pmf_def pair_return_pmf1 pair_map_pmf1 pair_map_pmf2 pmf.map_comp o_def split_def pair_pair_pmf<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_pmf_homo<span class="main">:</span> <span class="quoted"><span class="quoted">"pure_pmf <span class="free">f</span> <span class="main">⋄</span> pure_pmf <span class="free">x</span> <span class="main">=</span> pure_pmf <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_pmf_def pair_return_pmf1<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_pmf_interchange<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">⋄</span> pure_pmf <span class="free">x</span> <span class="main">=</span> pure_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_pmf_def pair_return_pmf1 pair_return_pmf2 pmf.map_comp o_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_pmf_K<span class="main">:</span> <span class="quoted"><span class="quoted">"return_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">⋄</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_pmf_def pair_map_pmf1 pmf.map_comp pair_return_pmf1 o_def split_def map_fst_pair_pmf<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_pmf_C<span class="main">:</span> <span class="quoted"><span class="quoted">"return_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">⋄</span> <span class="free">y</span> <span class="main">=</span> <span class="free">f</span> <span class="main">⋄</span> <span class="free">y</span> <span class="main">⋄</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_pmf_def pair_map_pmf1 pmf.map_comp pair_return_pmf1 pair_pair_pmf o_def split_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> pair_commute_pmf<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pair_map_pmf2 pmf.map_comp o_def split_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> ap_pmf_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_fun <span class="main">(</span>rel_pmf <span class="main">(</span>rel_fun <span class="free">A</span> <span class="free">B</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>rel_fun <span class="main">(</span>rel_pmf <span class="free">A</span><span class="main">)</span> <span class="main">(</span>rel_pmf <span class="free">B</span><span class="main">)</span><span class="main">)</span> ap_pmf ap_pmf"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_pmf_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> pair_pmf_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">applicative</span></span> pmf <span class="main">(</span>C<span class="main">,</span> K<span class="main">)</span>
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">pure_pmf</span>
  ap<span class="main">:</span> <span class="quoted">ap_pmf</span>
  rel<span class="main">:</span> <span class="quoted">rel_pmf</span>
  set<span class="main">:</span> <span class="quoted">set_pmf</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_fun <span class="skolem">R</span> <span class="main">(</span>rel_pmf <span class="skolem">R</span><span class="main">)</span> pure_pmf pure_pmf"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">R</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> pmf"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> pmf"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_pmf <span class="main">(</span>rel_fun <span class="main">(</span>eq_on <span class="main">(</span>set_pmf <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">R</span><span class="main">)</span> <span class="skolem">f</span> <span class="skolem">g</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_pmf <span class="main">(</span>eq_on <span class="main">(</span>set_pmf <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf.rel_refl_strong<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_pmf <span class="skolem">R</span> <span class="main">(</span>ap_pmf <span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>ap_pmf <span class="skolem">g</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">rule</span> ap_pmf_comp<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> o_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span> ap_pmf_homo ap_pmf_C ap_pmf_K<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Probability_List">
<div class="head">
<h1>Theory Applicative_Probability_List</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Probability mass functions implemented as lists with duplicates›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Probability_List <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative_List.html">Applicative_List</a>
  <a href="../../HOL/HOL/Complex_Main.html">Complex_Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sum_list_concat_map<span class="main">:</span> <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span>concat <span class="main">(</span>map <span class="free">f</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> sum_list <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> sum_list <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_ap_list <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span>set <span class="free">f</span> <span class="main">×</span> set <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_list_def List.bind_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We call the implementation type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pfp›</span></span></span></span> because it is the basis for the Haskell library
  Probability by Martin Erwig and Steve Kollmansberger (Probabilistic Functional Programming).›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'a</span> pfp <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">xs</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> real<span class="main">)</span> list<span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">p</span><span class="main">)</span> <span class="main">∈</span> set <span class="bound">xs</span><span class="main">.</span> <span class="bound">p</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span> <span class="main">∧</span> sum_list <span class="main">(</span>map snd <span class="bound">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span><span class="main">]</span> <span class="main">∈</span> <span class="var">?pfp</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_pfp

<span class="keyword1"><span class="command">lift_definition</span></span> pure_pfp <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> pfp"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">[</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">)</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lift_definition</span></span> ap_pfp <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> pfp <span class="main">⇒</span> <span class="tfree">'a</span> pfp <span class="main">⇒</span> <span class="tfree">'b</span> pfp"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">fs</span> <span class="bound">xs</span><span class="main">.</span> <span class="main">[</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span> <span class="bound">p</span><span class="main">)</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">q</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">p</span> <span class="main">*</span> <span class="bound">q</span><span class="main">)</span><span class="main">]</span> <span class="main">⋄</span> <span class="bound">fs</span> <span class="main">⋄</span> <span class="bound">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">×</span> real<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> real<span class="main">)</span> list"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> xs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">xs</span><span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="bound">y</span>"</span></span> <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span>map snd <span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ys<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">ys</span><span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="bound">y</span>"</span></span> <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span>map snd <span class="skolem">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ap</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span> <span class="bound">p</span><span class="main">)</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">q</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">p</span> <span class="main">*</span> <span class="bound">q</span><span class="main">)</span><span class="main">]</span> <span class="main">⋄</span> <span class="skolem">xs</span> <span class="main">⋄</span> <span class="skolem">ys</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="skolem">b</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> set <span class="var">?ap</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword1"><span class="command">using</span></span> that xs ys
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mult_pos_pos<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sum_list <span class="main">(</span>map snd <span class="var">?ap</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> xs ys
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_list_def List.bind_def map_concat o_def split_beta sum_list_concat_map sum_list_const_mult<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_pfp</span>

<span class="keyword1"><span class="command">applicative</span></span> pfp
 <span class="keyword2"><span class="keyword">for</span></span> pure<span class="main">:</span> <span class="quoted">pure_pfp</span>
     ap<span class="main">:</span> <span class="quoted">ap_pfp</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure_pfp <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> pfp"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_list_def List.bind_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure_pfp <span class="skolem">f</span> <span class="main">⋄</span> pure_pfp <span class="skolem">x</span> <span class="main">=</span> pure_pfp <span class="main">(</span><span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure_pfp <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> pfp"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> pfp"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">⋄</span> pure_pfp <span class="skolem">x</span> <span class="main">=</span> pure_pfp <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">f</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> pfp"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Star">
<div class="head">
<h1>Theory Applicative_Star</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Ultrafilter›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Star <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Nonstandard_Analysis/StarDef.html">HOL-Nonstandard_Analysis.StarDef</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">applicative</span></span> star <span class="main">(</span>C<span class="main">,</span> K<span class="main">,</span> W<span class="main">)</span>
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">star_of</span>
  ap<span class="main">:</span> <span class="quoted">Ifun</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"star_of <span class="skolem">f</span> <span class="main">⋆</span> star_of <span class="skolem">x</span> <span class="main">=</span> star_of <span class="main">(</span><span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">x</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> Ifun_star_of<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> refl<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Vector">
<div class="head">
<h1>Theory Applicative_Vector</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Vector <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Analysis/Finite_Cartesian_Product.html">HOL-Analysis.Finite_Cartesian_Product</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pure_vec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span> <span class="main">::</span> finite<span class="main">)</span> vec"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pure_vec</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">χ</span> <span class="main"><span class="bound">_</span></span> <span class="main">.</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ap_vec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'c</span> <span class="main">::</span> finite<span class="main">)</span> vec <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> vec <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> vec"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ap_vec</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">χ</span> <span class="bound">i</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">$</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">$</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_vec</span>

<span class="keyword1"><span class="command">applicative</span></span> vec <span class="main">(</span>K<span class="main">,</span> W<span class="main">)</span>
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">pure_vec</span>
  ap<span class="main">:</span> <span class="quoted">ap_vec</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_vec_def ap_vec_def vec_nth_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> pure_vec_nth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"pure_vec <span class="free">x</span> <span class="main">$</span> <span class="free">i</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pure_vec_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_vec_nth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ap_vec <span class="free">f</span> <span class="free">x</span> <span class="main">$</span> <span class="free">i</span>  <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="main">$</span> <span class="free">i</span><span class="main">)</span> <span class="main">(</span><span class="free">x</span> <span class="main">$</span> <span class="free">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_vec_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Functor">
<div class="head">
<h1>Theory Applicative_Functor</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich
   Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Functor <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative_Environment.html">Applicative_Environment</a>
  <a href="Applicative_Option.html">Applicative_Option</a>
  <a href="Applicative_Sum.html">Applicative_Sum</a>
  <a href="Applicative_Set.html">Applicative_Set</a>
  <a href="Applicative_List.html">Applicative_List</a>
  <a href="Applicative_DNEList.html">Applicative_DNEList</a>
  <a href="Applicative_Monoid.html">Applicative_Monoid</a>
  <a href="Applicative_Filter.html">Applicative_Filter</a>
  <a href="Applicative_State.html">Applicative_State</a>
  <a href="Applicative_Stream.html">Applicative_Stream</a>
  <a href="Applicative_Open_State.html">Applicative_Open_State</a>
  <a href="Applicative_PMF.html">Applicative_PMF</a>
  <a href="Applicative_Probability_List.html">Applicative_Probability_List</a>
  <a href="Applicative_Star.html">Applicative_Star</a>
  <a href="Applicative_Vector.html">Applicative_Vector</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">print_applicative</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Environment_Algebra">
<div class="head">
<h1>Theory Applicative_Environment_Algebra</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Examples of applicative lifting›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Algebraic operations for the environment functor›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Environment_Algebra <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative_Environment.html">Applicative_Environment</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Function_Division.html">HOL-Library.Function_Division</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Link between applicative instance of the environment functor with the pointwise operations
  for the algebraic type classes ›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> plus_fun_af <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">+</span> <span class="free">g</span> <span class="main">=</span> pure <span class="main">(+)</span> <span class="main">⋄</span> <span class="free">f</span> <span class="main">⋄</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> plus_fun_def const_def apf_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> zero_fun_af <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">=</span> pure <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> zero_fun_def const_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> times_fun_af <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">*</span> <span class="free">g</span> <span class="main">=</span> pure <span class="main">(*)</span> <span class="main">⋄</span> <span class="free">f</span> <span class="main">⋄</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> times_fun_def const_def apf_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> one_fun_af <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">=</span> pure <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> one_fun_def const_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> of_nat_fun_af <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"of_nat <span class="free">n</span> <span class="main">=</span> pure <span class="main">(</span>of_nat <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> of_nat_fun const_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> inverse_fun_af <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inverse <span class="free">f</span> <span class="main">=</span> pure inverse <span class="main">⋄</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> inverse_fun_def o_def const_def apf_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> divide_fun_af <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"divide <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> pure divide <span class="main">⋄</span> <span class="free">f</span> <span class="main">⋄</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> divide_fun_def const_def apf_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Stream_Algebra">
<div class="head">
<h1>Theory Stream_Algebra</h1>
</div>
<pre class="source"><span class="comment1">(* Author:     Andreas Lochbihler, ETH Zurich
   Author:     Joshua Schneider, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Pointwise arithmetic on streams›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Stream_Algebra
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Applicative_Stream.html">Applicative_Stream</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">zero</span><span class="main">)</span> <span class="quoted">zero</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">=</span> sconst <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">one</span><span class="main">)</span> <span class="quoted">one</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">=</span> sconst <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">plus</span><span class="main">)</span> <span class="quoted">plus</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> pure <span class="main">(+)</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⋄</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> stream<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">minus</span><span class="main">)</span> <span class="quoted">minus</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> pure <span class="main">(-)</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⋄</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> stream<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">uminus</span><span class="main">)</span> <span class="quoted">uminus</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span> stream<span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"uminus <span class="main">=</span> <span class="main">(</span><span class="main">(⋄)</span> <span class="main">(</span>pure uminus<span class="main">)</span> <span class="main">::</span> <span class="tfree">'a</span> stream <span class="main">⇒</span> <span class="tfree">'a</span> stream<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">times</span><span class="main">)</span> <span class="quoted">times</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> pure <span class="main">(*)</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⋄</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> stream<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">Rings.dvd</span><span class="main">)</span> <span class="quoted">Rings.dvd</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">modulo</span><span class="main">)</span> <span class="quoted">modulo</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">div</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> pure <span class="keyword1">(div)</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⋄</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> stream<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">mod</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> pure <span class="keyword1">(mod)</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⋄</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">::</span> <span class="tfree">'a</span> stream<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">semigroup_add</span><span class="main">)</span> <span class="quoted">semigroup_add</span>
<span class="keyword1"><span class="command">using</span></span> add.assoc <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">applicative_lifting</span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">ab_semigroup_add</span><span class="main">)</span> <span class="quoted">ab_semigroup_add</span>
<span class="keyword1"><span class="command">using</span></span> add.commute <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">applicative_lifting</span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">semigroup_mult</span><span class="main">)</span> <span class="quoted">semigroup_mult</span>
<span class="keyword1"><span class="command">using</span></span> mult.assoc <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">applicative_lifting</span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">ab_semigroup_mult</span><span class="main">)</span> <span class="quoted">ab_semigroup_mult</span>
<span class="keyword1"><span class="command">using</span></span> mult.commute <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">applicative_lifting</span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">monoid_add</span><span class="main">)</span> <span class="quoted">monoid_add</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_monoid_add</span><span class="main">)</span> <span class="quoted">comm_monoid_add</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_monoid_diff</span><span class="main">)</span> <span class="quoted">comm_monoid_diff</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> diff_diff_add<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">monoid_mult</span><span class="main">)</span> <span class="quoted">monoid_mult</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_monoid_mult</span><span class="main">)</span> <span class="quoted">comm_monoid_mult</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="comment1">(*
  Lifted properties which are more complex than plain equations are not handled by the
  applicative lifting tool.
*)</span>

<span class="keyword1"><span class="command">lemma</span></span> plus_stream_shd<span class="main">:</span> <span class="quoted"><span class="quoted">"shd <span class="main">(</span><span class="free">x</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> shd <span class="free">x</span> <span class="main">+</span> shd <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> plus_stream_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> plus_stream_stl<span class="main">:</span> <span class="quoted"><span class="quoted">"stl <span class="main">(</span><span class="free">x</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> stl <span class="free">x</span> <span class="main">+</span> stl <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> plus_stream_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">cancel_semigroup_add</span><span class="main">)</span> <span class="quoted">cancel_semigroup_add</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> stream"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">+</span> <span class="skolem">b</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">+</span> <span class="skolem">c</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="skolem">b</span></span> <span class="quoted"><span class="skolem">c</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_stream <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"shd <span class="main">(</span><span class="skolem">a</span> <span class="main">+</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">=</span> shd <span class="main">(</span><span class="skolem">a</span> <span class="main">+</span> <span class="skolem">c</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"stl <span class="main">(</span><span class="skolem">a</span> <span class="main">+</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">=</span> stl <span class="main">(</span><span class="skolem">a</span> <span class="main">+</span> <span class="skolem">c</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> plus_stream_shd plus_stream_stl<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> stream"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">+</span> <span class="skolem">a</span> <span class="main">=</span> <span class="skolem">c</span> <span class="main">+</span> <span class="skolem">a</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="skolem">b</span></span> <span class="quoted"><span class="skolem">c</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Eq_stream <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"shd <span class="main">(</span><span class="skolem">b</span> <span class="main">+</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> shd <span class="main">(</span><span class="skolem">c</span> <span class="main">+</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"stl <span class="main">(</span><span class="skolem">b</span> <span class="main">+</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> stl <span class="main">(</span><span class="skolem">c</span> <span class="main">+</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> plus_stream_shd plus_stream_stl<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">cancel_ab_semigroup_add</span><span class="main">)</span> <span class="quoted">cancel_ab_semigroup_add</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> diff_diff_eq<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">cancel_comm_monoid_add</span><span class="main">)</span> <span class="quoted">cancel_comm_monoid_add</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">group_add</span><span class="main">)</span> <span class="quoted">group_add</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">ab_group_add</span><span class="main">)</span> <span class="quoted">ab_group_add</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring</span><span class="main">)</span> <span class="quoted">semiring</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ring_distribs<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">mult_zero</span><span class="main">)</span> <span class="quoted">mult_zero</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring_0</span><span class="main">)</span> <span class="quoted">semiring_0</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring_0_cancel</span><span class="main">)</span> <span class="quoted">semiring_0_cancel</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_semiring</span><span class="main">)</span> <span class="quoted">comm_semiring</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span><span class="main">(</span><span class="operator">rule</span> distrib_right<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_semiring_0</span><span class="main">)</span> <span class="quoted">comm_semiring_0</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_semiring_0_cancel</span><span class="main">)</span> <span class="quoted">comm_semiring_0_cancel</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> pure_stream_inject <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sconst <span class="free">x</span> <span class="main">=</span> sconst <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"sconst <span class="free">x</span> <span class="main">=</span> sconst <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"shd <span class="main">(</span>sconst <span class="free">x</span><span class="main">)</span> <span class="main">=</span> shd <span class="main">(</span>sconst <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">zero_neq_one</span><span class="main">)</span> <span class="quoted">zero_neq_one</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">applicative_unfold</span> stream<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring_1</span><span class="main">)</span> <span class="quoted">semiring_1</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_semiring_1</span><span class="main">)</span> <span class="quoted">comm_semiring_1</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring_1_cancel</span><span class="main">)</span> <span class="quoted">semiring_1_cancel</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_semiring_1_cancel</span><span class="main">)</span> <span class="quoted">comm_semiring_1_cancel</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">applicative_lifting</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> right_diff_distrib'<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">ring</span><span class="main">)</span> <span class="quoted">ring</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_ring</span><span class="main">)</span> <span class="quoted">comm_ring</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">ring_1</span><span class="main">)</span> <span class="quoted">ring_1</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">comm_ring_1</span><span class="main">)</span> <span class="quoted">comm_ring_1</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">numeral</span><span class="main">)</span> <span class="quoted">numeral</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">neg_numeral</span><span class="main">)</span> <span class="quoted">neg_numeral</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring_numeral</span><span class="main">)</span> <span class="quoted">semiring_numeral</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> of_nat_stream <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"of_nat <span class="free">n</span> <span class="main">=</span> sconst <span class="main">(</span>of_nat <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_stream_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> id_apply<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">+</span> pure <span class="main">(</span>of_nat <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> pure <span class="main">(</span><span class="main">1</span> <span class="main">+</span> of_nat <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">with</span></span> Suc.IH <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> id_apply<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">semiring_char_0</span><span class="main">)</span> <span class="quoted">semiring_char_0</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def of_nat_stream<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> pure_stream_numeral <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">n</span> <span class="main">=</span> pure <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> numeral.simps one_stream_def plus_stream_def ap_stream_homo<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> stream <span class="main">::</span> <span class="main">(</span><span class="quoted">ring_char_0</span><span class="main">)</span> <span class="quoted">ring_char_0</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Tree_Relabelling">
<div class="head">
<h1>Theory Tree_Relabelling</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Tree relabelling›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Tree_Relabelling <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative_State.html">Applicative_State</a>
  <a href="Applicative_Option.html">Applicative_Option</a>
  <a href="Applicative_PMF.html">Applicative_PMF</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Stream.html">HOL-Library.Stream</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">unbundle</span></span> applicative_syntax
<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.pure <span class="quoted">pure_option</span>
<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.pure <span class="quoted">State_Monad.return</span>
<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">State_Monad.ap</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Hutton and Fulger \cite{HuttonFulger2008TFP} suggested the following tree relabelling problem
  as an example for reasoning about effects. Given a binary tree with labels at the leaves, the
  relabelling assigns a unique number to every leaf.  Their correctness property states that the
  list of labels in the obtained tree is distinct.  As observed by Gibbons and Bird \cite{backwards},
  this breaks the abstraction of the state monad, because the relabeling function must be run.
  Although Hutton and Fulger are careful to reason in point-free style, they nevertheless unfold
  the implementation of the state monad operations.  Gibbons and Hinze \cite{GibbonsHinze2011ICFP}
  suggest to state the correctness in an effectful way using an exception-state monad.  Thereby, they
  lose the applicative structure and have to resort to a full monad.

  Here, we model the tree relabelling function three times. First, we state correctness in pure
  terms following Hutton and Fulger.  Second, we take Gibbons' and Bird's approach of considering
  traversals. Third, we state correctness effectfully, but only using the applicative functors.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> tree <span class="main">=</span> Leaf <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">|</span> Node <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">fold_tree</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fold_tree</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">(</span>Leaf <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">fold_tree</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">(</span><span class="free">fold_tree</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">fold_tree</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">leaves</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">leaves</span> <span class="main">=</span> fold_tree <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">1</span><span class="main">)</span> <span class="main">(+)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> leaves_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"leaves <span class="main">(</span>Leaf <span class="free">x</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"leaves <span class="main">(</span>Node <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> leaves <span class="free">l</span> <span class="main">+</span> leaves <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> leaves_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Pure correctness statement›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">labels</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">labels</span> <span class="main">=</span> fold_tree <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">)</span> append"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> labels_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"labels <span class="main">(</span>Leaf <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"labels <span class="main">(</span>Node <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> labels <span class="free">l</span> <span class="main">@</span> labels <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> labels_def<span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> labelling <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">fresh</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">show_variants</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">label_tree</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'x</span> tree<span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">label_tree</span> <span class="main">=</span> fold_tree <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">.</span> pure Leaf <span class="main">⋄</span> <span class="free">fresh</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">l</span> <span class="bound">r</span><span class="main">.</span> pure Node <span class="main">⋄</span> <span class="bound">l</span> <span class="main">⋄</span> <span class="bound">r</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> label_tree_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"label_tree <span class="main">(</span>Leaf <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure Leaf <span class="main">⋄</span> <span class="free">fresh</span>"</span></span>
  <span class="quoted"><span class="quoted">"label_tree <span class="main">(</span>Node <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> pure Node <span class="main">⋄</span> label_tree <span class="free">l</span> <span class="main">⋄</span> label_tree <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> label_tree_def<span class="main">)</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">label_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'x</span> list<span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">label_list</span> <span class="main">[]</span> <span class="main">=</span> pure <span class="main">[]</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">label_list</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> pure <span class="main">(#)</span> <span class="main">⋄</span> <span class="free">fresh</span> <span class="main">⋄</span> <span class="free">label_list</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> label_append<span class="main">:</span> <span class="quoted"><span class="quoted">"label_list <span class="main">(</span><span class="free">a</span> <span class="main">@</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> pure <span class="main">(@)</span> <span class="main">⋄</span> label_list <span class="free">a</span> <span class="main">⋄</span> label_list <span class="free">b</span>"</span></span>
  <span class="comment1">― ‹The proof lifts the defining equations of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> append<span class="antiquote">}</span></span> to the state monad.›</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> append.simps label_list.simps
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a1</span> <span class="skolem">a2</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> append.simps label_list.simps Cons.IH
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> label_tree_list<span class="main">:</span> <span class="quoted"><span class="quoted">"pure labels <span class="main">⋄</span> label_tree <span class="free">t</span> <span class="main">=</span> label_list <span class="main">(</span>labels <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Leaf <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> label_tree_simps labels_simps label_list.simps
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> Node <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> label_tree_simps labels_simps label_append Node.IH<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We directly show correctness without going via streams like Hutton and Fulger \cite{HuttonFulger2008TFP}. ›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> correctness_pure<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="main">::</span> <span class="tfree">'a</span> list<span class="main">.</span> distinct <span class="main">(</span>fst <span class="main">(</span>run_state <span class="main">(</span>label_list <span class="bound">xs</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>labels <span class="main">(</span>fst <span class="main">(</span>run_state <span class="main">(</span>label_tree <span class="free">t</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> label_tree_list<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">t</span></span><span class="main">,</span> <span class="operator">THEN</span> arg_cong<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">f</span><span class="main">.</span> run_state <span class="bound">f</span> <span class="free">s</span>"</span></span><span class="main">]</span> assms<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"labels <span class="free">t</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>label_list <span class="main">(</span>labels <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> State_Monad.ap_def split_beta<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness via monadic traversals›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Dual version of an applicative functor with effects composed in the opposite order›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'a</span> dual <span class="main">=</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">::</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">morphisms</span></span> un_B B <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_dual

<span class="keyword1"><span class="command">lift_definition</span></span> pure_dual <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> dual"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">pure</span><span class="main">.</span> <span class="bound">pure</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> ap_dual <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'af1</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'af1</span> <span class="main">⇒</span> <span class="tfree">'af3</span> <span class="main">⇒</span> <span class="tfree">'af13</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'af13</span> <span class="main">⇒</span> <span class="tfree">'af2</span> <span class="main">⇒</span> <span class="tfree">'af</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'af2</span> dual <span class="main">⇒</span> <span class="tfree">'af3</span> dual <span class="main">⇒</span> <span class="tfree">'af</span> dual"</span></span>
<span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">pure</span> <span class="bound">ap1</span> <span class="bound">ap2</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">ap2</span> <span class="main">(</span><span class="bound">ap1</span> <span class="main">(</span><span class="bound">pure</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">f</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state_rev <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state dual"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pure_state_rev</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state_rev"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pure_state_rev</span> <span class="main">=</span> pure_dual State_Monad.return"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ap_state_rev</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> state_rev <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state_rev <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> state_rev"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ap_state_rev</span> <span class="main">=</span> ap_dual State_Monad.return State_Monad.ap State_Monad.ap"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.pure <span class="quoted">pure_state_rev</span>
<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_state_rev</span>

<span class="keyword1"><span class="command">applicative</span></span> state_rev
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">pure_state_rev</span>
  ap<span class="main">:</span> <span class="quoted">ap_state_rev</span>
<span class="keyword1"><span class="command">unfolding</span></span> pure_state_rev_def ap_state_rev_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">applicative_nf</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> refl<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>


<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state_rev_rev <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state_rev dual"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pure_state_rev_rev</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state_rev_rev"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pure_state_rev_rev</span> <span class="main">=</span> pure_dual pure_state_rev"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ap_state_rev_rev</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> state_rev_rev <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state_rev_rev <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> state_rev_rev"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ap_state_rev_rev</span> <span class="main">=</span> ap_dual pure_state_rev ap_state_rev ap_state_rev"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.pure <span class="quoted">pure_state_rev_rev</span>
<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">ap_state_rev_rev</span>

<span class="keyword1"><span class="command">applicative</span></span> state_rev_rev
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">pure_state_rev_rev</span>
  ap<span class="main">:</span> <span class="quoted">ap_state_rev_rev</span>
<span class="keyword1"><span class="command">unfolding</span></span> pure_state_rev_rev_def ap_state_rev_rev_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">applicative_nf</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> refl<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ap_state_rev_B<span class="main">:</span> <span class="quoted"><span class="quoted">"B <span class="free">f</span> <span class="main">⋄</span> B <span class="free">x</span> <span class="main">=</span> B <span class="main">(</span>State_Monad.return <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">⋄</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_state_rev_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> ap_dual.abs_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_state_rev_pure_B<span class="main">:</span> <span class="quoted"><span class="quoted">"pure <span class="free">f</span> <span class="main">⋄</span> B <span class="free">x</span> <span class="main">=</span> B <span class="main">(</span>State_Monad.return <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_state_rev_def pure_state_rev_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">applicative_nf</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_state_rev_rev_B<span class="main">:</span> <span class="quoted"><span class="quoted">"B <span class="free">f</span> <span class="main">⋄</span> B <span class="free">x</span> <span class="main">=</span> B <span class="main">(</span>pure_state_rev <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">⋄</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_state_rev_rev_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> ap_dual.abs_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_state_rev_rev_pure_B<span class="main">:</span> <span class="quoted"><span class="quoted">"pure <span class="free">f</span> <span class="main">⋄</span> B <span class="free">x</span> <span class="main">=</span> B <span class="main">(</span>pure_state_rev <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ap_state_rev_rev_def pure_state_rev_rev_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">applicative_nf</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The formulation by Gibbons and Bird \cite{backwards} crucially depends on Kleisli composition,
  so we need the state monad rather than the applicative functor only.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ap_conv_bind_state<span class="main">:</span> <span class="quoted"><span class="quoted">"State_Monad.ap <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> State_Monad.bind <span class="free">f</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> State_Monad.bind <span class="free">x</span> <span class="main">(</span>State_Monad.return <span class="main">∘</span> <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> State_Monad.ap_def State_Monad.bind_def Let_def split_def o_def fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_pure_bind_state<span class="main">:</span> <span class="quoted"><span class="quoted">"pure <span class="free">x</span> <span class="main">⋄</span> State_Monad.bind <span class="free">y</span> <span class="free">f</span> <span class="main">=</span> State_Monad.bind <span class="free">y</span> <span class="main">(</span><span class="main">(⋄)</span> <span class="main">(</span>pure <span class="free">x</span><span class="main">)</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_conv_bind_state o_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">kleisli_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> state<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> state<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> state"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">∙</span>"</span> 55<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">kleisli_state</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> State_Monad.bind <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fetch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> stream<span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fetch</span> <span class="main">=</span> State_Monad.bind State_Monad.get <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> State_Monad.bind <span class="main">(</span>State_Monad.set <span class="main">(</span>stl <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> State_Monad.return <span class="main">(</span>shd <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">traverse</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> state<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span> tree<span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">traverse</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> pure Leaf <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">traverse</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> pure Node <span class="main">⋄</span> <span class="free">traverse</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⋄</span> <span class="free">traverse</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As we cannot abstract over the applicative functor in definitions, we define
  traversal on the transformed applicative function once again.›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">traverse_rev</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> state_rev<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span> tree<span class="main">)</span> state_rev"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">traverse_rev</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> pure Leaf <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">traverse_rev</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> pure Node <span class="main">⋄</span> <span class="free">traverse_rev</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⋄</span> <span class="free">traverse_rev</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">recurse</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> state<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span> tree<span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">recurse</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> un_B <span class="main">∘</span> traverse_rev <span class="main">(</span>B <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> recurse_Leaf<span class="main">:</span> <span class="quoted"><span class="quoted">"recurse <span class="free">f</span> <span class="main">(</span>Leaf <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure Leaf <span class="main">⋄</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> recurse_def traverse_rev.simps o_def ap_state_rev_pure_B
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> B_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> recurse_Node<span class="main">:</span>
  <span class="quoted"><span class="quoted">"recurse <span class="free">f</span> <span class="main">(</span>Node <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> pure <span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">l</span><span class="main">.</span> Node <span class="bound">l</span> <span class="bound">r</span><span class="main">)</span> <span class="main">⋄</span> recurse <span class="free">f</span> <span class="free">r</span> <span class="main">⋄</span> recurse <span class="free">f</span> <span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"recurse <span class="free">f</span> <span class="main">(</span>Node <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> un_B <span class="main">(</span>pure Node <span class="main">⋄</span> traverse_rev <span class="main">(</span>B <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="free">l</span> <span class="main">⋄</span> traverse_rev <span class="main">(</span>B <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> recurse_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> un_B <span class="main">(</span>B <span class="main">(</span>pure Node<span class="main">)</span> <span class="main">⋄</span> B <span class="main">(</span>recurse <span class="free">f</span> <span class="free">l</span><span class="main">)</span> <span class="main">⋄</span> B <span class="main">(</span>recurse <span class="free">f</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> un_B_inverse recurse_def pure_state_rev_def pure_dual_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> recurse <span class="free">f</span> <span class="free">r</span> <span class="main">⋄</span> <span class="main">(</span>pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> recurse <span class="free">f</span> <span class="free">l</span> <span class="main">⋄</span> pure Node<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_state_rev_B B_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> pure <span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">l</span><span class="main">.</span> Node <span class="bound">l</span> <span class="bound">r</span><span class="main">)</span> <span class="main">⋄</span> recurse <span class="free">f</span> <span class="free">r</span> <span class="main">⋄</span> recurse <span class="free">f</span> <span class="free">l</span>"</span></span>
    <span class="comment1">― ‹This step expands to 13 steps in \cite{backwards}›</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">applicative_nf</span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> traverse_pure<span class="main">:</span> <span class="quoted"><span class="quoted">"traverse pure <span class="free">t</span> <span class="main">=</span> pure <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> Leaf <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> traverse.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">simp</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> Node <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> traverse.simps Node.IH <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">simp</span> <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"B <span class="main"><span class="main">∘</span></span> B"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is an idiom morphism›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> B_pure<span class="main">:</span> <span class="quoted"><span class="quoted">"pure <span class="free">x</span> <span class="main">=</span> B <span class="main">(</span>State_Monad.return <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> pure_state_rev_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> BB_pure<span class="main">:</span> <span class="quoted"><span class="quoted">"pure <span class="free">x</span> <span class="main">=</span> B <span class="main">(</span>B <span class="main">(</span>pure <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> pure_state_rev_rev_def B_pure<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> BB_ap<span class="main">:</span> <span class="quoted"><span class="quoted">"B <span class="main">(</span>B <span class="free">f</span><span class="main">)</span> <span class="main">⋄</span> B <span class="main">(</span>B <span class="free">x</span><span class="main">)</span> <span class="main">=</span> B <span class="main">(</span>B <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"B <span class="main">(</span>B <span class="free">f</span><span class="main">)</span> <span class="main">⋄</span> B <span class="main">(</span>B <span class="free">x</span><span class="main">)</span> <span class="main">=</span> B <span class="main">(</span>B <span class="main">(</span>pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">f</span> <span class="main">⋄</span> <span class="main">(</span>pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">⋄</span> pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> B <span class="main">(</span>B <span class="var">?exp</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> ap_state_rev_rev_B B_pure ap_state_rev_B <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?exp</span> <span class="main">=</span> <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span>"</span></span> <span class="comment1">― ‹This step takes 15 steps in \cite{backwards}.›</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">applicative_nf</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">traverse_rev_rev</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> state_rev_rev<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span> tree<span class="main">)</span> state_rev_rev"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">traverse_rev_rev</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> pure Leaf <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">traverse_rev_rev</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> pure Node <span class="main">⋄</span> <span class="free">traverse_rev_rev</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⋄</span> <span class="free">traverse_rev_rev</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">recurse_rev</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> state_rev<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'b</span> tree<span class="main">)</span> state_rev"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">recurse_rev</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> un_B <span class="main">∘</span> traverse_rev_rev <span class="main">(</span>B <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> traverse_B_B<span class="main">:</span> <span class="quoted"><span class="quoted">"traverse_rev_rev <span class="main">(</span>B <span class="main">∘</span> B <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> B <span class="main">∘</span> B <span class="main">∘</span> traverse <span class="free">f</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">t</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">t</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> BB_pure BB_ap<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> traverse_recurse<span class="main">:</span> <span class="quoted"><span class="quoted">"traverse <span class="free">f</span> <span class="main">=</span> un_B <span class="main">∘</span> recurse_rev <span class="main">(</span>B <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> un_B <span class="main">∘</span> un_B <span class="main">∘</span> B <span class="main">∘</span> B <span class="main">∘</span> traverse <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def B_inverse<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> un_B <span class="main">∘</span> un_B <span class="main">∘</span> traverse_rev_rev <span class="main">(</span>B <span class="main">∘</span> B <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> traverse_B_B <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> recurse_rev_def o_assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> recurse_traverse<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∙</span> <span class="free">g</span> <span class="main">=</span> pure"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"recurse <span class="free">f</span> <span class="main">∙</span> traverse <span class="free">g</span> <span class="main">=</span> pure"</span></span>
<span class="comment1">― ‹Gibbons and Bird impose this as an additional requirement on traversals, but they write
  that they have not found a way to derive this fact from other axioms. So we prove it directly.›</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> State_Monad.bind <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> State_Monad.return <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">h</span><span class="main">.</span> State_Monad.bind <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> State_Monad.bind <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">h</span><span class="main">)</span> <span class="main">=</span> <span class="bound">h</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fold</span> State_Monad.bind_assoc<span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>recurse <span class="free">f</span> <span class="main">∙</span> traverse <span class="free">g</span><span class="main">)</span> <span class="skolem">t</span> <span class="main">=</span> pure <span class="skolem">t</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> kleisli_state_def
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">t</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Leaf <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_conv_bind_state recurse_Leaf **<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Node <span class="skolem">l</span> <span class="skolem">r</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_conv_bind_state recurse_Node<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> State_Monad.bind_assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> Node.IH<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Apply traversals to labelling›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">strip</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> stream<span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">strip</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> State_Monad.bind <span class="main">(</span>State_Monad.update <span class="main">(</span>SCons <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> State_Monad.return <span class="bound">a</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">adorn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> stream<span class="main">,</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">adorn</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> pure <span class="main">(</span>Pair <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">⋄</span> fetch"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">label</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> stream<span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> tree<span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">label</span> <span class="main">≡</span> traverse adorn"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">unlabel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> tree <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> stream<span class="main">,</span> <span class="tfree">'a</span> tree<span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">unlabel</span> <span class="main">≡</span> recurse strip"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> strip_adorn<span class="main">:</span> <span class="quoted"><span class="quoted">"strip <span class="main">∙</span> adorn <span class="main">=</span> pure"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> strip_def adorn_def fun_eq_iff fetch_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> ap_conv_bind_state<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> correctness_monadic<span class="main">:</span> <span class="quoted"><span class="quoted">"unlabel <span class="main">∙</span> label <span class="main">=</span> pure"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> recurse_traverse<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> strip_adorn<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Applicative correctness statement›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Repeating an effect›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">repeatM</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'x</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'x</span> list<span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">repeatM</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> State_Monad.return <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">repeatM</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> pure <span class="main">(#)</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⋄</span> <span class="free">repeatM</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> repeatM_plus<span class="main">:</span> <span class="quoted"><span class="quoted">"repeatM <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="free">m</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> pure append <span class="main">⋄</span> repeatM <span class="free">n</span> <span class="free">f</span> <span class="main">⋄</span> repeatM <span class="free">m</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">applicative_nf</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fail</span> <span class="main">≡</span> None"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lift_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span> option<span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lift_state</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> pure pure <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lift_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> option <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'a</span> option<span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lift_option</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> pure <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">assert</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  assert_fail<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">assert</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> fail <span class="main">=</span> fail"</span></span>
<span class="main">|</span> assert_pure<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">assert</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">(</span>pure <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> pure <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">else</span> fail<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> labelling <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">symbols</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'x</span> list option<span class="main">)</span> state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">symbols</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≡</span> lift_state <span class="main">(</span>repeatM <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free">fresh</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">disjoint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> list <span class="main">⇒</span> <span class="tfree">'x</span> list <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">disjoint</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">≡</span> set <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">∩</span> set <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dlabels</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> tree <span class="main">⇒</span> <span class="tfree">'x</span> list option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">dlabels</span> <span class="main">=</span> fold_tree <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> pure <span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">)</span>
     <span class="main">(</span><span class="main">λ</span><span class="bound">l</span> <span class="bound">r</span><span class="main">.</span> pure <span class="main">(</span>case_prod append<span class="main">)</span> <span class="main">⋄</span> <span class="main">(</span>assert <span class="main">(</span>case_prod disjoint<span class="main">)</span> <span class="main">(</span>pure Pair <span class="main">⋄</span> <span class="bound">l</span> <span class="main">⋄</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> dlabels_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"dlabels <span class="main">(</span>Leaf <span class="free">x</span><span class="main">)</span> <span class="main">=</span> pure <span class="main">[</span><span class="free">x</span><span class="main">]</span>"</span></span>
  <span class="quoted"><span class="quoted">"dlabels <span class="main">(</span>Node <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> pure <span class="main">(</span>case_prod append<span class="main">)</span> <span class="main">⋄</span> <span class="main">(</span>assert <span class="main">(</span>case_prod disjoint<span class="main">)</span> <span class="main">(</span>pure Pair <span class="main">⋄</span> dlabels <span class="free">l</span> <span class="main">⋄</span> dlabels <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dlabels_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> correctness_applicative<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> pure <span class="main">(</span>assert distinct<span class="main">)</span> <span class="main">⋄</span> symbols <span class="bound">n</span> <span class="main">=</span> symbols <span class="bound">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"State_Monad.return dlabels <span class="main">⋄</span> label_tree <span class="free">t</span> <span class="main">=</span> symbols <span class="main">(</span>leaves <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure dlabels <span class="main">⋄</span> label_tree <span class="main">(</span>Leaf <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> symbols <span class="main">(</span>leaves <span class="main">(</span>Leaf <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> label_tree_simps leaves_simps repeatM.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"pure dlabels <span class="main">⋄</span> label_tree <span class="skolem">l</span> <span class="main">=</span> symbols <span class="main">(</span>leaves <span class="skolem">l</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"pure dlabels <span class="main">⋄</span> label_tree <span class="skolem">r</span> <span class="main">=</span> symbols <span class="main">(</span>leaves <span class="skolem">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?cat</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"case_prod append"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?disj</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"case_prod disjoint"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">l</span> <span class="bound">r</span><span class="main">.</span> pure <span class="var">?cat</span> <span class="main">⋄</span> <span class="main">(</span>assert <span class="var">?disj</span> <span class="main">(</span>pure Pair <span class="main">⋄</span> <span class="bound">l</span> <span class="main">⋄</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"State_Monad.return dlabels <span class="main">⋄</span> label_tree <span class="main">(</span>Node <span class="skolem">l</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">=</span>
        pure <span class="var">?f</span> <span class="main">⋄</span> <span class="main">(</span>pure dlabels <span class="main">⋄</span> label_tree <span class="skolem">l</span><span class="main">)</span> <span class="main">⋄</span> <span class="main">(</span>pure dlabels <span class="main">⋄</span> label_tree <span class="skolem">r</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> label_tree_simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> pure <span class="var">?f</span> <span class="main">⋄</span> <span class="main">(</span>pure <span class="main">(</span>assert distinct<span class="main">)</span> <span class="main">⋄</span> symbols <span class="main">(</span>leaves <span class="skolem">l</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="main">(</span>pure <span class="main">(</span>assert distinct<span class="main">)</span> <span class="main">⋄</span> symbols <span class="main">(</span>leaves <span class="skolem">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> IH distinct <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> pure <span class="main">(</span>assert distinct<span class="main">)</span> <span class="main">⋄</span> symbols <span class="main">(</span>leaves <span class="main">(</span>Node <span class="skolem">l</span> <span class="skolem">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> leaves_simps repeatM_plus <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> symbols <span class="main">(</span>leaves <span class="main">(</span>Node <span class="skolem">l</span> <span class="skolem">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> distinct<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pure dlabels <span class="main">⋄</span> label_tree <span class="main">(</span>Node <span class="skolem">l</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">=</span> symbols <span class="main">(</span>leaves <span class="main">(</span>Node <span class="skolem">l</span> <span class="skolem">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Probabilistic tree relabelling›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">mirror</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mirror</span> <span class="main">(</span>Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">mirror</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> Node <span class="main">(</span><span class="free">mirror</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">mirror</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> dir <span class="main">=</span> Left <span class="main">|</span> Right

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> path

<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>sequential<span class="main">)</span> <span class="entity">subtree</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"dir list <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">subtree</span> <span class="main">(</span>Left <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">path</span></span></span><span class="main">)</span>  <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">subtree</span> <span class="free"><span class="bound"><span class="entity">path</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">subtree</span> <span class="main">(</span>Right <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">path</span></span></span><span class="main">)</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">subtree</span> <span class="free"><span class="bound"><span class="entity">path</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">subtree</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span>              <span class="main">(</span>Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>   <span class="main">=</span> Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">subtree</span> <span class="main">[]</span>             <span class="free"><span class="bound"><span class="entity">t</span></span></span>          <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">lexicographic_order</span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.pure <span class="quoted">pure_pmf</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> pmf"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">plabel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'b</span> tree pmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">plabel</span> <span class="main">(</span>Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>   <span class="main">=</span> pure Leaf <span class="main">⋄</span> <span class="free">p</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">plabel</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> pure Node <span class="main">⋄</span> <span class="free">plabel</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⋄</span> <span class="free">plabel</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> plabel_mirror<span class="main">:</span> <span class="quoted"><span class="quoted">"plabel <span class="main">(</span>mirror <span class="free">t</span><span class="main">)</span> <span class="main">=</span> pure mirror <span class="main">⋄</span> plabel <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Leaf <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> plabel.simps mirror.simps <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Node <span class="skolem">t1</span> <span class="skolem">t2</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> plabel.simps mirror.simps Node.IH <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> plabel_subtree<span class="main">:</span> <span class="quoted"><span class="quoted">"plabel <span class="main">(</span>subtree <span class="free">path</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> pure <span class="main">(</span>subtree <span class="free">path</span><span class="main">)</span> <span class="main">⋄</span> plabel <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">path</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> subtree.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Left<span class="main">:</span> <span class="main">(</span>1 <span class="skolem">path</span> <span class="skolem">l</span> <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> plabel.simps subtree.simps Left.IH <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> Right<span class="main">:</span> <span class="main">(</span>2 <span class="skolem">path</span> <span class="skolem">l</span> <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> plabel.simps subtree.simps Right.IH <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">uu</span> <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> plabel.simps subtree.simps <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">v</span> <span class="skolem">va</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> plabel.simps subtree.simps <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">applicative_lifting</span><span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Examples">
<div class="head">
<h1>Theory Applicative_Examples</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Examples <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative_Environment_Algebra.html">Applicative_Environment_Algebra</a>
  <a href="Stream_Algebra.html">Stream_Algebra</a>
  <a href="Tree_Relabelling.html">Tree_Relabelling</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Joinable">
<div class="head">
<h1>Theory Joinable</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Formalisation of idiomatic terms and lifting›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Immediate joinability under a relation›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Joinable
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definition and basic properties›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">joinable</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">joinable</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> joinable_simp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">∧</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> joinable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> joinableI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> joinable_simp <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> joinableD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">∧</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> joinable_simp <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> joinableE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">z</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> joinable_simp <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> refl_on_joinable<span class="main">:</span> <span class="quoted"><span class="quoted">"refl_on <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">}</span> <span class="main">(</span>joinable <span class="free">R</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> refl_onI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> joinable_simp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> refl_joinable_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span> <span class="main">=</span> refl <span class="main">(</span>joinable <span class="free">R</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> refl_onI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> joinable_simp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> refl_joinable<span class="main">:</span> <span class="quoted"><span class="quoted">"refl <span class="free">R</span> <span class="main">⟹</span> refl <span class="main">(</span>joinable <span class="free">R</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> refl_joinable_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> joinable_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"refl <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> refl_joinable <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sym_joinable<span class="main">:</span> <span class="quoted"><span class="quoted">"sym <span class="main">(</span>joinable <span class="free">R</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> symI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> joinable_simp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> joinable_sym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> sym_joinable <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> symD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> joinable_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> <span class="free">S</span> <span class="main">⟹</span> joinable <span class="free">R</span> <span class="main">⊆</span> joinable <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> subrelI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> joinable_simp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> refl_le_joinable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"refl <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> joinable <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> subrelI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹refl <span class="free">R</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> refl_onD<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> joinableI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> joinable_subst<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> R_subst<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">P</span> <span class="bound">x</span><span class="main">,</span> <span class="free">P</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> joinable<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span> <span class="free">x</span><span class="main">,</span> <span class="free">P</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> joinable <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> xz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> yz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> joinableE<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> R_subst xz <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span> <span class="free">x</span><span class="main">,</span> <span class="free">P</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> R_subst yz <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span> <span class="free">y</span><span class="main">,</span> <span class="free">P</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> joinableI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Confluence›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">confluent</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> rel <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">confluent</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">y'</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y'</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">y'</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> confluentI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">y'</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span> <span class="main">⟹</span> confluent <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> confluent_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> joinableI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> confluentD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"confluent <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">y'</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> confluent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> confluentE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"confluent <span class="free">R</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">z</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y'</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> confluent_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> joinableE<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> trans_joinable<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"trans <span class="free">R</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"confluent <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"trans <span class="main">(</span>joinable <span class="free">R</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> transI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span> xu<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> yu<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> joinableE<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> yv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> zv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> joinableE<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> yu yv <span class="quoted"><span class="quoted">‹confluent <span class="free">R</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> uw<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> vw<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> confluentE<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> xu uw <span class="quoted"><span class="quoted">‹trans <span class="free">R</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> zv vw <span class="quoted"><span class="quoted">‹trans <span class="free">R</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transE<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> joinableI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Relation to reflexive transitive symmetric closure›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> joinable_le_rtscl<span class="main">:</span> <span class="quoted"><span class="quoted">"joinable <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">R</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> subrelI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> xz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> yz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> joinableE<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> xz <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">R</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> in_rtrancl_UnI<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> yz <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">R</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> in_rtrancl_UnI rtrancl_converseI<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">R</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rtrancl_trans<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> joinable_eq_rtscl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"confluent <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"joinable <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">R</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"joinable <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">R</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> joinable_le_rtscl <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"joinable <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span> <span class="main">⊇</span> <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">R</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> subrelI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">R</span> <span class="main">∪</span> <span class="free">R</span><span class="main">¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">set</span><span class="main"><span class="main">:</span></span> rtrancl<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> base
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> joinable_refl refl_rtrancl <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">⊆</span> joinable <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> refl_le_joinable refl_rtrancl <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">∪</span> <span class="free">R</span><span class="main">¯</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> joinable_sym <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> trans_joinable trans_rtrancl <span class="quoted"><span class="quoted">‹confluent <span class="main">(</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> transD<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Predicate version›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">joinablep</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">joinablep</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">z</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="bound">z</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> joinablep_joinable<span class="main">[</span><span class="operator">pred_set_conv</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"joinablep <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> joinable <span class="free">R</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> joinablep_def joinable_simp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> reflp_joinablep<span class="main">:</span> <span class="quoted"><span class="quoted">"reflp <span class="free">P</span> <span class="main">⟹</span> reflp <span class="main">(</span>joinablep <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reflpI joinable_refl<span class="main"><span class="main">[</span></span><span class="operator">to_pred</span><span class="main"><span class="main">]</span></span> refl_onI<span class="main"><span class="main">[</span></span><span class="operator">to_pred</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> reflpD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> joinablep_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"reflp <span class="free">P</span> <span class="main">⟹</span> joinablep <span class="free">P</span> <span class="free">x</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> reflp_joinablep <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reflpD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> reflp_le_joinablep<span class="main">:</span> <span class="quoted"><span class="quoted">"reflp <span class="free">P</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">≤</span> joinablep <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> refl_le_joinable<span class="main"><span class="main">[</span></span><span class="operator">to_pred</span><span class="main"><span class="main">]</span></span> refl_onI<span class="main"><span class="main">[</span></span><span class="operator">to_pred</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> reflpD<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Beta_Eta">
<div class="head">
<h1>Theory Beta_Eta</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Combined beta and eta reduction of lambda terms›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Beta_Eta
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="../../HOL/HOL-Proofs-Lambda/Eta.html">HOL-Proofs-Lambda.Eta</a>"</span> <a href="Joinable.html">Joinable</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary lemmas›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> liftn_lift_swap<span class="main">:</span> <span class="quoted"><span class="quoted">"liftn <span class="free">n</span> <span class="main">(</span>lift <span class="free">t</span> <span class="free">k</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> lift <span class="main">(</span>liftn <span class="free">n</span> <span class="free">t</span> <span class="free">k</span><span class="main">)</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> subst_liftn<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">+</span> <span class="free">k</span> <span class="main">∧</span> <span class="free">k</span> <span class="main">≤</span> <span class="free">i</span> <span class="main">⟹</span> <span class="main">(</span>liftn <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">s</span> <span class="free">k</span><span class="main">)</span><span class="main">[</span><span class="free">t</span><span class="main">/</span><span class="free">i</span><span class="main">]</span> <span class="main">=</span> liftn <span class="free">n</span> <span class="free">s</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">s</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> subst_lift2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lift <span class="main">(</span>lift <span class="free">t</span> <span class="main">0</span><span class="main">)</span> <span class="main">0</span><span class="main">)</span><span class="main">[</span><span class="free">x</span><span class="main">/</span>Suc <span class="main">0</span><span class="main">]</span> <span class="main">=</span> lift <span class="free">t</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lift <span class="main">(</span>lift <span class="free">t</span> <span class="main">0</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> lift <span class="main">(</span>lift <span class="free">t</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> lift_lift <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> free_liftn<span class="main">:</span>
  <span class="quoted"><span class="quoted">"free <span class="main">(</span>liftn <span class="free">n</span> <span class="free">t</span> <span class="free">k</span><span class="main">)</span> <span class="free">i</span> <span class="main">=</span> <span class="main">(</span><span class="free">i</span> <span class="main">&lt;</span> <span class="free">k</span> <span class="main">∧</span> free <span class="free">t</span> <span class="free">i</span> <span class="main">∨</span> <span class="free">k</span> <span class="main">+</span> <span class="free">n</span> <span class="main">≤</span> <span class="free">i</span> <span class="main">∧</span> free <span class="free">t</span> <span class="main">(</span><span class="free">i</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_diff_le<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Reduction›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">beta_eta</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"dB <span class="main">⇒</span> dB <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub></span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">beta_eta</span> <span class="main">≡</span> sup beta eta"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">beta_eta_reds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"dB <span class="main">⇒</span> dB <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1"><span class="free">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> <span class="main">(</span>beta_eta<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> beta_into_beta_eta_reds<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub></span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> eta_into_beta_eta_reds<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>η</sub></span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> beta_reds_into_beta_eta_reds<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtranclp_mono<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> predicate2D<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eta_reds_into_beta_eta_reds<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtranclp_mono<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> predicate2D<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> beta_eta_appL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">s'</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">°</span> <span class="free">t</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">s'</span> <span class="main">°</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">set</span><span class="main"><span class="main">:</span></span> rtranclp<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtranclp.rtrancl_into_rtrancl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> beta_eta_appR<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">t'</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">°</span> <span class="free">t</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">s</span> <span class="main">°</span> <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">set</span><span class="main"><span class="main">:</span></span> rtranclp<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtranclp.rtrancl_into_rtrancl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> beta_eta_abs<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">t'</span> <span class="main">⟹</span> Abs <span class="free">t</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> Abs <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">set</span><span class="main"><span class="main">:</span></span> rtranclp<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtranclp.rtrancl_into_rtrancl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> beta_eta_lift<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">t</span> <span class="main">⟹</span> lift <span class="free">s</span> <span class="free">k</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> lift <span class="free">t</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">pred</span><span class="main"><span class="main">:</span></span> rtranclp<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> base <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lift <span class="skolem">y</span> <span class="free">k</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub></span> lift <span class="skolem">z</span> <span class="free">k</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> lift_preserves_beta eta_lift <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> step.IH <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lift <span class="free">s</span> <span class="free">k</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> lift <span class="skolem">z</span> <span class="free">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">iprover</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> confluent_beta_eta_reds<span class="main">:</span> <span class="quoted"><span class="quoted">"Joinable.confluent <span class="main">{</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">.</span> <span class="bound">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="bound">t</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> confluent_beta_eta
<span class="keyword1"><span class="command">unfolding</span></span> diamond_def commute_def square_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> confluentI<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Equivalence›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Terms are equivalent iff they can be reduced to a common term.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">term_equiv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"dB <span class="main">⇒</span> dB <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">↔</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">term_equiv</span> <span class="main">=</span> joinablep beta_eta_reds"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> term_equivI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↔</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> term_equiv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> joinableI<span class="main"><span class="main">[</span></span><span class="operator">to_pred</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> term_equivE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↔</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">u</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> term_equiv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> joinableE<span class="main"><span class="main">[</span></span><span class="operator">to_pred</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> reds_into_equiv<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">↔</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> term_equivI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> beta_into_equiv<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub></span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">↔</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reds_into_equiv<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> beta_into_beta_eta_reds<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eta_into_equiv<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>η</sub></span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">↔</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reds_into_equiv<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> eta_into_beta_eta_reds<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> beta_reds_into_equiv<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">↔</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reds_into_equiv<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> beta_reds_into_beta_eta_reds<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eta_reds_into_equiv<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">↔</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reds_into_equiv<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> eta_reds_into_beta_eta_reds<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> term_refl<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">↔</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> term_equiv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> joinablep_refl reflpI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> term_sym<span class="main">[</span><span class="operator">sym</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span> <span class="main">↔</span> <span class="free">t</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">t</span> <span class="main">↔</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> term_equiv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> joinable_sym<span class="main"><span class="main">[</span></span><span class="operator">to_pred</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> conversep_term <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"conversep <span class="main">(↔)</span> <span class="main">=</span> <span class="main">(↔)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> term_sym<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> term_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↔</span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">↔</span> <span class="free">u</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">↔</span> <span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> term_equiv_def
<span class="keyword1"><span class="command">using</span></span> trans_joinable<span class="main">[</span><span class="operator">to_pred</span><span class="main">]</span> trans_rtrancl<span class="main">[</span><span class="operator">to_pred</span><span class="main">]</span> confluent_beta_eta_reds
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> transpE<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> term_beta_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↔</span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">t</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub></span> <span class="free">u</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">↔</span> <span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> beta_into_beta_eta_reds <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> term_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> term_eta_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↔</span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">t</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>η</sub></span> <span class="free">u</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">↔</span> <span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> eta_into_beta_eta_reds <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> term_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> equiv_appL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↔</span> <span class="free">s'</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">°</span> <span class="free">t</span> <span class="main">↔</span> <span class="free">s'</span> <span class="main">°</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> term_equiv_def <span class="keyword1"><span class="command">using</span></span> beta_eta_appL
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> joinable_subst<span class="main"><span class="main">[</span></span><span class="operator">to_pred</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> equiv_appR<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">↔</span> <span class="free">t'</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">°</span> <span class="free">t</span> <span class="main">↔</span> <span class="free">s</span> <span class="main">°</span> <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> term_equiv_def <span class="keyword1"><span class="command">using</span></span> beta_eta_appR
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> joinable_subst<span class="main"><span class="main">[</span></span><span class="operator">to_pred</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> equiv_app<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↔</span> <span class="free">s'</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">↔</span> <span class="free">t'</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">°</span> <span class="free">t</span> <span class="main">↔</span> <span class="free">s'</span> <span class="main">°</span> <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> term_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> equiv_abs<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">↔</span> <span class="free">t'</span> <span class="main">⟹</span> Abs <span class="free">t</span> <span class="main">↔</span> Abs <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> term_equiv_def <span class="keyword1"><span class="command">using</span></span> beta_eta_abs
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> joinable_subst<span class="main"><span class="main">[</span></span><span class="operator">to_pred</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> equiv_lift<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↔</span> <span class="free">t</span> <span class="main">⟹</span> lift <span class="free">s</span> <span class="free">k</span> <span class="main">↔</span> lift <span class="free">t</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> term_equivI beta_eta_lift <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> term_equivE<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> equiv_liftn<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↔</span> <span class="free">t</span> <span class="main">⟹</span> liftn <span class="free">n</span> <span class="free">s</span> <span class="free">k</span> <span class="main">↔</span> liftn <span class="free">n</span> <span class="free">t</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> equiv_lift<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Our definition is equivalent to the the symmetric and transitive closure of
  the reduction relation.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> equiv_eq_rtscl_reds<span class="main">:</span> <span class="quoted"><span class="quoted">"term_equiv <span class="main">=</span> <span class="main">(</span>sup beta_eta beta_eta<span class="main">¯¯</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> term_equiv_def
<span class="keyword1"><span class="command">using</span></span> confluent_beta_eta_reds
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> joinable_eq_rtscl<span class="main"><span class="main">[</span></span><span class="operator">to_pred</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Combinators">
<div class="head">
<h1>Theory Combinators</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Combinators defined as closed lambda terms›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Combinators
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Beta_Eta.html">Beta_Eta</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> I_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ℐ</span> <span class="main">=</span> Abs <span class="main">(</span>Var <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> B_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ℬ</span> <span class="main">=</span> Abs <span class="main">(</span>Abs <span class="main">(</span>Abs <span class="main">(</span>Var <span class="numeral">2</span> <span class="main">°</span> <span class="main">(</span>Var <span class="main">1</span> <span class="main">°</span> Var <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> T_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">𝒯</span> <span class="main">=</span> Abs <span class="main">(</span>Abs <span class="main">(</span>Var <span class="main">0</span> <span class="main">°</span> Var <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="comment1">― ‹reverse application›</span>

<span class="keyword1"><span class="command">lemma</span></span> I_eval<span class="main">:</span> <span class="quoted"><span class="quoted">"ℐ <span class="main">°</span> <span class="free">x</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub></span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ℐ <span class="main">°</span> <span class="free">x</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub></span> Var <span class="main">0</span><span class="main">[</span><span class="free">x</span><span class="main">/</span><span class="main">0</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> I_def <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> I_equiv<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ℐ <span class="main">°</span> <span class="free">x</span> <span class="main">↔</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> I_eval <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> I_closed<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"liftn <span class="free">n</span> ℐ <span class="free">k</span> <span class="main">=</span> ℐ"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> I_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> B_eval1<span class="main">:</span> <span class="quoted"><span class="quoted">"ℬ <span class="main">°</span> <span class="free">g</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub></span> Abs <span class="main">(</span>Abs <span class="main">(</span>lift <span class="main">(</span>lift <span class="free">g</span> <span class="main">0</span><span class="main">)</span> <span class="main">0</span> <span class="main">°</span> <span class="main">(</span>Var <span class="main">1</span> <span class="main">°</span> Var <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ℬ <span class="main">°</span> <span class="free">g</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub></span> Abs <span class="main">(</span>Abs <span class="main">(</span>Var <span class="numeral">2</span> <span class="main">°</span> <span class="main">(</span>Var <span class="main">1</span> <span class="main">°</span> Var <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="free">g</span><span class="main">/</span><span class="main">0</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> B_def <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> numerals<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> B_eval2<span class="main">:</span> <span class="quoted"><span class="quoted">"ℬ <span class="main">°</span> <span class="free">g</span> <span class="main">°</span> <span class="free">f</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup></span> Abs <span class="main">(</span>lift <span class="free">g</span> <span class="main">0</span> <span class="main">°</span> <span class="main">(</span>lift <span class="free">f</span> <span class="main">0</span> <span class="main">°</span> Var <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ℬ <span class="main">°</span> <span class="free">g</span> <span class="main">°</span> <span class="free">f</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup></span> Abs <span class="main">(</span>Abs <span class="main">(</span>lift <span class="main">(</span>lift <span class="free">g</span> <span class="main">0</span><span class="main">)</span> <span class="main">0</span> <span class="main">°</span> <span class="main">(</span>Var <span class="main">1</span> <span class="main">°</span> Var <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">°</span> <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> B_eval1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub></span> Abs <span class="main">(</span>lift <span class="main">(</span>lift <span class="free">g</span> <span class="main">0</span><span class="main">)</span> <span class="main">0</span> <span class="main">°</span> <span class="main">(</span>Var <span class="main">1</span> <span class="main">°</span> Var <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="free">f</span><span class="main">/</span><span class="main">0</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> Abs <span class="main">(</span>lift <span class="free">g</span> <span class="main">0</span> <span class="main">°</span> <span class="main">(</span>lift <span class="free">f</span> <span class="main">0</span> <span class="main">°</span> Var <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> B_eval<span class="main">:</span> <span class="quoted"><span class="quoted">"ℬ <span class="main">°</span> <span class="free">g</span> <span class="main">°</span> <span class="free">f</span> <span class="main">°</span> <span class="free">x</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">g</span> <span class="main">°</span> <span class="main">(</span><span class="free">f</span> <span class="main">°</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ℬ <span class="main">°</span> <span class="free">g</span> <span class="main">°</span> <span class="free">f</span> <span class="main">°</span> <span class="free">x</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup></span> Abs <span class="main">(</span>lift <span class="free">g</span> <span class="main">0</span> <span class="main">°</span> <span class="main">(</span>lift <span class="free">f</span> <span class="main">0</span> <span class="main">°</span> Var <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">°</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> B_eval2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub></span> <span class="main">(</span>lift <span class="free">g</span> <span class="main">0</span> <span class="main">°</span> <span class="main">(</span>lift <span class="free">f</span> <span class="main">0</span> <span class="main">°</span> Var <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="free">x</span><span class="main">/</span><span class="main">0</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">g</span> <span class="main">°</span> <span class="main">(</span><span class="free">f</span> <span class="main">°</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> B_equiv<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ℬ <span class="main">°</span> <span class="free">g</span> <span class="main">°</span> <span class="free">f</span> <span class="main">°</span> <span class="free">x</span> <span class="main">↔</span> <span class="free">g</span> <span class="main">°</span> <span class="main">(</span><span class="free">f</span> <span class="main">°</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> B_eval <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> B_closed<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"liftn <span class="free">n</span> ℬ <span class="free">k</span> <span class="main">=</span> ℬ"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> B_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> T_eval1<span class="main">:</span> <span class="quoted"><span class="quoted">"𝒯 <span class="main">°</span> <span class="free">x</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub></span> Abs <span class="main">(</span>Var <span class="main">0</span> <span class="main">°</span> lift <span class="free">x</span> <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"𝒯 <span class="main">°</span> <span class="free">x</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub></span> Abs <span class="main">(</span>Var <span class="main">0</span> <span class="main">°</span> Var <span class="main">1</span><span class="main">)</span> <span class="main">[</span><span class="free">x</span><span class="main">/</span><span class="main">0</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> T_def <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> T_eval<span class="main">:</span> <span class="quoted"><span class="quoted">"𝒯 <span class="main">°</span> <span class="free">x</span> <span class="main">°</span> <span class="free">f</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">f</span> <span class="main">°</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"𝒯 <span class="main">°</span> <span class="free">x</span> <span class="main">°</span> <span class="free">f</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup></span> Abs <span class="main">(</span>Var <span class="main">0</span> <span class="main">°</span> lift <span class="free">x</span> <span class="main">0</span><span class="main">)</span> <span class="main">°</span> <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> T_eval1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>β</sub></span> <span class="main">(</span>Var <span class="main">0</span> <span class="main">°</span> lift <span class="free">x</span> <span class="main">0</span><span class="main">)</span> <span class="main">[</span><span class="free">f</span><span class="main">/</span><span class="main">0</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">f</span> <span class="main">°</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> T_equiv<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"𝒯 <span class="main">°</span> <span class="free">x</span> <span class="main">°</span> <span class="free">f</span> <span class="main">↔</span> <span class="free">f</span> <span class="main">°</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> T_eval <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> T_closed<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"liftn <span class="free">n</span> 𝒯 <span class="free">k</span> <span class="main">=</span> 𝒯"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> T_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Idiomatic_Terms">
<div class="head">
<h1>Theory Idiomatic_Terms</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Idiomatic terms -- Properties and operations›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Idiomatic_Terms
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Combinators.html">Combinators</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This theory proves the correctness of the normalisation algorithm for
  arbitrary applicative functors. We generalise the normal form using a framework
  for bracket abstraction algorithms. Both approaches justify lifting certain
  classes of equations. We model this as implications of term equivalences,
  where unlifting of idiomatic terms is expressed syntactically.›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Basic definitions›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> itrm <span class="main">=</span>
    Opaque <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">|</span> Pure <span class="quoted">dB</span>
  <span class="main">|</span> IAp <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1">⋄</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>"</span> 150<span class="main">)</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">opaque</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">opaque</span> <span class="main">(</span>Opaque <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">opaque</span> <span class="main">(</span>Pure <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">opaque</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">opaque</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">@</span> <span class="free">opaque</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">iorder</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> length <span class="main">(</span>opaque <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">itrm_cong</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> itrm <span class="main">⇒</span> <span class="tfree">'a</span> itrm <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> itrm <span class="main">⇒</span> <span class="tfree">'a</span> itrm <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">for</span></span> <span class="entity">R</span>
<span class="keyword2"><span class="keyword">where</span></span>
    into_itrm_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟹</span> <span class="free">itrm_cong</span> <span class="free">R</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
  <span class="main">|</span> pure_cong<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">↔</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟹</span> <span class="free">itrm_cong</span> <span class="free">R</span> <span class="main">(</span>Pure <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Pure <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
  <span class="main">|</span> ap_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">itrm_cong</span> <span class="free">R</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">f'</span></span></span> <span class="main">⟹</span> <span class="free">itrm_cong</span> <span class="free">R</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">x'</span></span></span> <span class="main">⟹</span> <span class="free">itrm_cong</span> <span class="free">R</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f'</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x'</span></span></span><span class="main">)</span>"</span></span>
  <span class="main">|</span> itrm_refl<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">itrm_cong</span> <span class="free">R</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
  <span class="main">|</span> itrm_sym<span class="main">[</span><span class="operator">sym</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">itrm_cong</span> <span class="free">R</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟹</span> <span class="free">itrm_cong</span> <span class="free">R</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
  <span class="main">|</span> itrm_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">itrm_cong</span> <span class="free">R</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟹</span> <span class="free">itrm_cong</span> <span class="free">R</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">⟹</span> <span class="free">itrm_cong</span> <span class="free">R</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ap_congL<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"itrm_cong <span class="free">R</span> <span class="free">f</span> <span class="free">f'</span> <span class="main">⟹</span> itrm_cong <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f'</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ap_cong<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_congR<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"itrm_cong <span class="free">R</span> <span class="free">x</span> <span class="free">x'</span> <span class="main">⟹</span> itrm_cong <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ap_cong<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Idiomatic terms are \emph{similar} iff they have the same structure, and all contained
  lambda terms are equivalent.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">similar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm <span class="main">⇒</span> <span class="tfree">'a</span> itrm <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">≅</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main"><span class="free">≅</span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> itrm_cong <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> pure_similarE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Pure <span class="free">x'</span> <span class="main">≅</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">y'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> Pure <span class="free">y'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x'</span> <span class="main">↔</span> <span class="free">y'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> Pure <span class="free">x'</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≅</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> x_def <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x''</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">=</span> Pure <span class="bound">x''</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span><span class="main">.</span> <span class="free">y</span> <span class="main">=</span> Pure <span class="bound">y'</span> <span class="main">∧</span> <span class="bound">x''</span> <span class="main">↔</span> <span class="bound">y'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">x''</span><span class="main">.</span> <span class="free">y</span> <span class="main">=</span> Pure <span class="bound">x''</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">=</span> Pure <span class="bound">y'</span> <span class="main">∧</span> <span class="bound">x''</span> <span class="main">↔</span> <span class="bound">y'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> pure_cong <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> term_sym<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> itrm_trans <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> term_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">with</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="free">thesis</span></span> <span class="keyword1"><span class="command">unfolding</span></span> x_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> opaque_similarE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Opaque <span class="free">x'</span> <span class="main">≅</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">y'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> Opaque <span class="free">y'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x'</span> <span class="main">=</span> <span class="free">y'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> Opaque <span class="free">x'</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≅</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> x_def <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x''</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">=</span> Opaque <span class="bound">x''</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span><span class="main">.</span> <span class="free">y</span> <span class="main">=</span> Opaque <span class="bound">y'</span> <span class="main">∧</span> <span class="bound">x''</span> <span class="main">=</span> <span class="bound">y'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">x''</span><span class="main">.</span> <span class="free">y</span> <span class="main">=</span> Opaque <span class="bound">x''</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y'</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">=</span> Opaque <span class="bound">y'</span> <span class="main">∧</span> <span class="bound">x''</span> <span class="main">=</span> <span class="bound">y'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span> <span class="operator">fast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">with</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="free">thesis</span></span> <span class="keyword1"><span class="command">unfolding</span></span> x_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ap_similarE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x1</span> <span class="main">⋄</span> <span class="free">x2</span> <span class="main">≅</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">y1</span> <span class="free">y2</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="free">y1</span> <span class="main">⋄</span> <span class="free">y2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x1</span> <span class="main">≅</span> <span class="free">y1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x2</span> <span class="main">≅</span> <span class="free">y2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x1'</span> <span class="bound">x2'</span><span class="main">.</span> <span class="free">x1</span> <span class="main">⋄</span> <span class="free">x2</span> <span class="main">=</span> <span class="bound">x1'</span> <span class="main">⋄</span> <span class="bound">x2'</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y1</span> <span class="bound">y2</span><span class="main">.</span> <span class="free">y</span> <span class="main">=</span> <span class="bound">y1</span> <span class="main">⋄</span> <span class="bound">y2</span> <span class="main">∧</span> <span class="bound">x1'</span> <span class="main">≅</span> <span class="bound">y1</span> <span class="main">∧</span> <span class="bound">x2'</span> <span class="main">≅</span> <span class="bound">y2</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">x1'</span> <span class="bound">x2'</span><span class="main">.</span> <span class="free">y</span> <span class="main">=</span> <span class="bound">x1'</span> <span class="main">⋄</span> <span class="bound">x2'</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y1</span> <span class="bound">y2</span><span class="main">.</span> <span class="free">x1</span> <span class="main">⋄</span> <span class="free">x2</span> <span class="main">=</span> <span class="bound">y1</span> <span class="main">⋄</span> <span class="bound">y2</span> <span class="main">∧</span> <span class="bound">x1'</span> <span class="main">≅</span> <span class="bound">y1</span> <span class="main">∧</span> <span class="bound">x2'</span> <span class="main">≅</span> <span class="bound">y2</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> ap_cong <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> itrm_sym<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> trans<span class="main">:</span> itrm_trans <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> itrm_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">with</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="free">thesis</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following relations define semantic equivalence of idiomatic terms.
  We consider equivalences that hold universally in all idioms, as well as arbitrary
  specialisations using additional laws.›</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">idiom_rule</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm <span class="main">⇒</span> <span class="tfree">'a</span> itrm <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    idiom_id<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">idiom_rule</span> <span class="main">(</span>Pure ℐ <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
  <span class="main">|</span> idiom_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">idiom_rule</span> <span class="main">(</span>Pure ℬ <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">⋄</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> idiom_hom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">idiom_rule</span> <span class="main">(</span>Pure <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⋄</span> Pure <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Pure <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">°</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> idiom_xchng<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">idiom_rule</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⋄</span> Pure <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>Pure <span class="main">(</span>𝒯 <span class="main">°</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">itrm_equiv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm <span class="main">⇒</span> <span class="tfree">'a</span> itrm <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">≃</span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main"><span class="free">≃</span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> itrm_cong idiom_rule <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> idiom_rule_into_equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"idiom_rule <span class="free">x</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≃</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> itrm_id <span class="main">=</span> idiom_id<span class="main">[</span><span class="operator">THEN</span> idiom_rule_into_equiv<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> itrm_comp <span class="main">=</span> idiom_comp<span class="main">[</span><span class="operator">THEN</span> idiom_rule_into_equiv<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> itrm_hom <span class="main">=</span> idiom_hom<span class="main">[</span><span class="operator">THEN</span> idiom_rule_into_equiv<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> itrm_xchng <span class="main">=</span> idiom_xchng<span class="main">[</span><span class="operator">THEN</span> idiom_rule_into_equiv<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> similar_into_equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≅</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≃</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">pred</span><span class="main"><span class="main">:</span></span> itrm_cong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ap_cong itrm_sym itrm_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> opaque_equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃</span> <span class="free">y</span> <span class="main">⟹</span> opaque <span class="free">x</span> <span class="main">=</span> opaque <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">pred</span><span class="main"><span class="main">:</span></span> itrm_cong<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>into_itrm_cong <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> iorder_equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃</span> <span class="free">y</span> <span class="main">⟹</span> iorder <span class="free">x</span> <span class="main">=</span> iorder <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> opaque_equiv<span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> special_idiom <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">extra_rule</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm <span class="main">⇒</span> <span class="tfree">'a</span> itrm <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">idiom_ext_rule</span> <span class="main">=</span> sup idiom_rule <span class="free">extra_rule</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">itrm_ext_equiv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm <span class="main">⇒</span> <span class="tfree">'a</span> itrm <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">≃<span class="hidden">⇧</span><sup>+</sup></span>"</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main"><span class="free">≃<span class="hidden">⇧</span><sup>+</sup></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> itrm_cong idiom_ext_rule <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> equiv_into_ext_equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> idiom_ext_rule_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">pred</span><span class="main"><span class="main">:</span></span> itrm_cong<span class="main">)</span>
   <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> into_itrm_cong ap_cong itrm_sym itrm_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> itrm_ext_id <span class="main">=</span> itrm_id<span class="main">[</span><span class="operator">THEN</span> equiv_into_ext_equiv<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> itrm_ext_comp <span class="main">=</span> itrm_comp<span class="main">[</span><span class="operator">THEN</span> equiv_into_ext_equiv<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> itrm_ext_hom <span class="main">=</span> itrm_hom<span class="main">[</span><span class="operator">THEN</span> equiv_into_ext_equiv<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> itrm_ext_xchng <span class="main">=</span> itrm_xchng<span class="main">[</span><span class="operator">THEN</span> equiv_into_ext_equiv<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Syntactic unlifting›</span></span>

<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹With generalisation of variables›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">unlift'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> itrm <span class="main">⇒</span> nat <span class="main">⇒</span> dB"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">unlift'</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>Opaque <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> Var <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">unlift'</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>Pure <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> liftn <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">0</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">unlift'</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="free">unlift'</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">+</span> iorder <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">°</span> <span class="free">unlift'</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">unlift</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="main">(</span>Abs<span class="main">^^</span>iorder <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>unlift' <span class="main">(</span>iorder <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> funpow_Suc_inside<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">^^</span> Suc <span class="free">n</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> funpow_Suc_right <span class="keyword1"><span class="command">unfolding</span></span> comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1"><span class="command">lemma</span></span> absn_cong<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↔</span> <span class="free">t</span> <span class="main">⟹</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="free">s</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> free_unlift<span class="main">:</span> <span class="quoted"><span class="quoted">"free <span class="main">(</span>unlift' <span class="free">n</span> <span class="free">x</span> <span class="free">i</span><span class="main">)</span> <span class="free">j</span> <span class="main">⟹</span> <span class="free">j</span> <span class="main">≥</span> <span class="free">n</span> <span class="main">∨</span> <span class="main">(</span><span class="free">j</span> <span class="main">≥</span> <span class="free">i</span> <span class="main">∧</span> <span class="free">j</span> <span class="main">&lt;</span> <span class="free">i</span> <span class="main">+</span> iorder <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Opaque <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Pure <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> free_liftn <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>IAp <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unlift_subst<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">≤</span> <span class="free">i</span> <span class="main">∧</span> <span class="free">j</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">⟹</span> <span class="main">(</span>unlift' <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">t</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">[</span><span class="free">s</span><span class="main">/</span><span class="free">j</span><span class="main">]</span> <span class="main">=</span> unlift' <span class="free">n</span> <span class="free">t</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Opaque <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Pure <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> subst_liftn <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>IAp <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">≤</span> <span class="skolem">i</span> <span class="main">+</span> iorder <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> IAp <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unlift'_equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃</span> <span class="free">y</span> <span class="main">⟹</span> unlift' <span class="free">n</span> <span class="free">x</span> <span class="free">i</span> <span class="main">↔</span> unlift' <span class="free">n</span> <span class="free">y</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quasi_keyword">pred</span><span class="main"><span class="main">:</span></span> itrm_cong<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>into_itrm_cong <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induction</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>idiom_id <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> I_equiv<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>idiom_comp <span class="skolem">g</span> <span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?G</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"unlift' <span class="skolem">n</span> <span class="skolem">g</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> iorder <span class="skolem">f</span> <span class="main">+</span> iorder <span class="skolem">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?F</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"unlift' <span class="skolem">n</span> <span class="skolem">f</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> iorder <span class="skolem">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"unlift' <span class="skolem">n</span> <span class="skolem">x</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unlift' <span class="skolem">n</span> <span class="main">(</span><span class="skolem">g</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> <span class="var">?G</span> <span class="main">°</span> <span class="main">(</span><span class="var">?F</span> <span class="main">°</span> <span class="var">?X</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.assoc<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unlift' <span class="skolem">n</span> <span class="main">(</span>Pure ℬ <span class="main">⋄</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> ℬ <span class="main">°</span> <span class="var">?G</span> <span class="main">°</span> <span class="var">?F</span> <span class="main">°</span> <span class="var">?X</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.commute add.left_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?G</span> <span class="main">°</span> <span class="main">(</span><span class="var">?F</span> <span class="main">°</span> <span class="var">?X</span><span class="main">)</span> <span class="main">↔</span> ℬ <span class="main">°</span> <span class="var">?G</span> <span class="main">°</span> <span class="var">?F</span> <span class="main">°</span> <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> B_equiv<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>idiom_hom <span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>idiom_xchng <span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?F</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"unlift' <span class="skolem">n</span> <span class="skolem">f</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"liftn <span class="skolem">n</span> <span class="skolem">x</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unlift' <span class="skolem">n</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> Pure <span class="skolem">x</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> <span class="var">?F</span> <span class="main">°</span> <span class="var">?X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unlift' <span class="skolem">n</span> <span class="main">(</span>Pure <span class="main">(</span>𝒯 <span class="main">°</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> 𝒯 <span class="main">°</span> <span class="var">?X</span> <span class="main">°</span> <span class="var">?F</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?F</span> <span class="main">°</span> <span class="var">?X</span> <span class="main">↔</span> 𝒯 <span class="main">°</span> <span class="var">?X</span> <span class="main">°</span> <span class="var">?F</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> T_equiv<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> pure_cong
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> equiv_liftn<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ap_cong <span class="skolem">f</span> <span class="skolem">f'</span> <span class="skolem">x</span> <span class="skolem">x'</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≃</span> <span class="skolem">x'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> iorder_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"iorder <span class="skolem">x</span> <span class="main">=</span> iorder <span class="skolem">x'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> iorder_equiv<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unlift' <span class="skolem">n</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> unlift' <span class="skolem">n</span> <span class="skolem">f</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> iorder <span class="skolem">x</span><span class="main">)</span> <span class="main">°</span> unlift' <span class="skolem">n</span> <span class="skolem">x</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unlift' <span class="skolem">n</span> <span class="main">(</span><span class="skolem">f'</span> <span class="main">⋄</span> <span class="skolem">x'</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> unlift' <span class="skolem">n</span> <span class="skolem">f'</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> iorder <span class="skolem">x</span><span class="main">)</span> <span class="main">°</span> unlift' <span class="skolem">n</span> <span class="skolem">x'</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> iorder_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> ap_cong.IH <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> equiv_app<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> itrm_refl
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> itrm_sym
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> term_sym <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> itrm_trans
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> term_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unlift_equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃</span> <span class="free">y</span> <span class="main">⟹</span> unlift <span class="free">x</span> <span class="main">↔</span> unlift <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unlift' <span class="main">(</span>iorder <span class="free">y</span><span class="main">)</span> <span class="free">x</span> <span class="main">0</span> <span class="main">↔</span> unlift' <span class="main">(</span>iorder <span class="free">y</span><span class="main">)</span> <span class="free">y</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> unlift'_equiv<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">≃</span> <span class="free">y</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"iorder <span class="free">x</span> <span class="main">=</span> iorder <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> iorder_equiv<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹Preserving variables›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">unlift_vars</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat itrm <span class="main">⇒</span> dB"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">unlift_vars</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>Opaque <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span> Var <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">unlift_vars</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>Pure <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> liftn <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">0</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">unlift_vars</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">unlift_vars</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">°</span> <span class="free">unlift_vars</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> all_pure_unlift_vars<span class="main">:</span> <span class="quoted"><span class="quoted">"opaque <span class="free">x</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≃</span> Pure <span class="main">(</span>unlift_vars <span class="main">0</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Opaque <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Pure <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>IAp <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> no_opaque<span class="main">:</span> <span class="quoted"><span class="quoted">"opaque <span class="skolem">x</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"opaque <span class="skolem">y</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> unlift_ap<span class="main">:</span> <span class="quoted"><span class="quoted">"unlift_vars <span class="main">0</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">⋄</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> unlift_vars <span class="main">0</span> <span class="skolem">x</span> <span class="main">°</span> unlift_vars <span class="main">0</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> no_opaque IAp.IH <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">⋄</span> <span class="skolem">y</span> <span class="main">≃</span> Pure <span class="main">(</span>unlift_vars <span class="main">0</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⋄</span> Pure <span class="main">(</span>unlift_vars <span class="main">0</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ap_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≃</span> Pure <span class="main">(</span>unlift_vars <span class="main">0</span> <span class="skolem">x</span> <span class="main">°</span> unlift_vars <span class="main">0</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> itrm_hom<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> Pure <span class="main">(</span>unlift_vars <span class="main">0</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">⋄</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> unlift_ap<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Canonical forms›</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">CF</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    pure_cf<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Pure <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∈</span> <span class="free">CF</span>"</span></span>
  <span class="main">|</span> ap_cf<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∈</span> <span class="free">CF</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⋄</span> Opaque <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∈</span> <span class="free">CF</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">CF_pure</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm <span class="main">⇒</span> dB"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">CF_pure</span> <span class="main">(</span>Opaque <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> undefined"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CF_pure</span> <span class="main">(</span>Pure <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">CF_pure</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⋄</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">CF_pure</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ap_cfD1<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">∈</span> CF <span class="main">⟹</span> <span class="free">f</span> <span class="main">∈</span> CF"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> CF.cases<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ap_cfD2<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">∈</span> CF <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x'</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> Opaque <span class="bound">x'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> CF.cases<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> opaque_not_cf<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Opaque <span class="free">x</span> <span class="main">∈</span> CF <span class="main">⟹</span> False"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> CF.cases<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cf_unlift<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CF"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CF_pure <span class="free">x</span> <span class="main">↔</span> unlift <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">set</span><span class="main"><span class="main">:</span></span> CF<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>pure_cf <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ap_cf <span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?n</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"iorder <span class="skolem">f</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unlift <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> Opaque <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="var">?n</span><span class="main">)</span> <span class="main">(</span>unlift' <span class="var">?n</span> <span class="skolem">f</span> <span class="main">1</span> <span class="main">°</span> Var <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span>Abs<span class="main">^^</span>iorder <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>Abs <span class="main">(</span>unlift' <span class="var">?n</span> <span class="skolem">f</span> <span class="main">1</span> <span class="main">°</span> Var <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> funpow_Suc_inside <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> unlift <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> free <span class="main">(</span>unlift' <span class="var">?n</span> <span class="skolem">f</span> <span class="main">1</span><span class="main">)</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> free_unlift <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Abs <span class="main">(</span>unlift' <span class="var">?n</span> <span class="skolem">f</span> <span class="main">1</span> <span class="main">°</span> Var <span class="main">0</span><span class="main">)</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>η</sub></span> <span class="main">(</span>unlift' <span class="var">?n</span> <span class="skolem">f</span> <span class="main">1</span><span class="main">)</span><span class="main">[</span>Var <span class="main">0</span><span class="main">/</span><span class="main">0</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> unlift' <span class="main">(</span>iorder <span class="skolem">f</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> unlift_subst <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def Suc_eq_plus1 le0<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> r_into_rtranclp absn_cong eta_into_equiv<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> ap_cf.IH <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> term_sym term_trans<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cf_similarI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CF"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> CF"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"opaque <span class="free">x</span> <span class="main">=</span> opaque <span class="free">y</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"CF_pure <span class="free">x</span> <span class="main">↔</span> CF_pure <span class="free">y</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≅</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>pure_cf <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"opaque <span class="skolem">y</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CF›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> Pure <span class="skolem">y'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> pure_cf.prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ap_cf <span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹opaque <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> Opaque <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> opaque <span class="skolem">y</span>›</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y1</span></span> <span class="skolem"><span class="skolem">y2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"opaque <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">y1</span> <span class="main">@</span> <span class="skolem">y2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"opaque <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">y1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="skolem">x</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">y2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">[</span><span class="skolem">x</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">y2</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y2</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">y'</span><span class="main">]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> CF›</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹opaque <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">y1</span> <span class="main">@</span> <span class="skolem">y2</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"opaque <span class="skolem">g</span> <span class="main">=</span> <span class="skolem">y1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y_split<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="skolem">g</span> <span class="main">⋄</span> Opaque <span class="skolem">y'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">∈</span> CF"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">cases</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> ap_cf.prems <span class="quoted"><span class="quoted">‹opaque <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">y1</span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"opaque <span class="skolem">f</span> <span class="main">=</span> opaque <span class="skolem">g</span>"</span></span> <span class="quoted"><span class="quoted">"CF_pure <span class="skolem">f</span> <span class="main">↔</span> CF_pure <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> ap_cf.IH <span class="quoted"><span class="quoted">‹<span class="skolem">g</span> <span class="main">∈</span> CF›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">≅</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> ap_cf.prems y_split <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y'</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ap_cong<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cf_similarD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> in_cf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CF"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> CF"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> similar<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≅</span> <span class="free">y</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CF_pure <span class="free">x</span> <span class="main">↔</span> CF_pure <span class="free">y</span> <span class="main">∧</span> opaque <span class="free">x</span> <span class="main">=</span> opaque <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> similar_into_equiv opaque_equiv cf_unlift unlift_equiv
      <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> term_trans term_sym<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Equivalent idiomatic terms in canonical form are similar. This justifies speaking of a
  normal form.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cf_unique<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> in_cf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CF"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> CF"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃</span> <span class="free">y</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≅</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> in_cf <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> cf_similarI<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> equiv <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"opaque <span class="free">x</span> <span class="main">=</span> opaque <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> opaque_equiv<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">from</span></span> equiv <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unlift <span class="free">x</span> <span class="main">↔</span> unlift <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> unlift_equiv<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"CF_pure <span class="free">x</span> <span class="main">↔</span> CF_pure <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cf_unlift<span class="main">[</span><span class="operator">OF</span> in_cf<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> cf_unlift<span class="main">[</span><span class="operator">OF</span> in_cf<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> term_sym term_trans<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Normalisation of idiomatic terms›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">norm_pn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"dB <span class="main">⇒</span> <span class="tfree">'a</span> itrm <span class="main">⇒</span> <span class="tfree">'a</span> itrm"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">norm_pn</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>Opaque <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> undefined"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">norm_pn</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>Pure <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> Pure <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">°</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">norm_pn</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">norm_pn</span> <span class="main">(</span>ℬ <span class="main">°</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">norm_nn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm <span class="main">⇒</span> <span class="tfree">'a</span> itrm <span class="main">⇒</span> <span class="tfree">'a</span> itrm"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">norm_nn</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>Opaque <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> undefined"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">norm_nn</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>Pure <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> norm_pn <span class="main">(</span>𝒯 <span class="main">°</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">norm_nn</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n'</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">norm_nn</span> <span class="main">(</span>norm_pn ℬ <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">n'</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">norm</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itrm <span class="main">⇒</span> <span class="tfree">'a</span> itrm"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">norm</span> <span class="main">(</span>Opaque <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> Pure ℐ <span class="main">⋄</span> Opaque <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">norm</span> <span class="main">(</span>Pure <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> Pure <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">norm</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> norm_nn <span class="main">(</span><span class="free">norm</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">norm</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">lemma</span></span> norm_pn_in_cf<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CF"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"norm_pn <span class="free">f</span> <span class="free">x</span> <span class="main">∈</span> CF"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> norm_nn_in_cf<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∈</span> CF"</span></span> <span class="quoted"><span class="quoted">"<span class="free">n'</span> <span class="main">∈</span> CF"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"norm_nn <span class="free">n</span> <span class="free">n'</span> <span class="main">∈</span> CF"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>1<span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n'</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> norm_pn_in_cf<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> norm_in_cf<span class="main">:</span> <span class="quoted"><span class="quoted">"norm <span class="free">x</span> <span class="main">∈</span> CF"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> norm_nn_in_cf<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> norm_pn_equiv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> CF"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"norm_pn <span class="free">f</span> <span class="free">x</span> <span class="main">≃</span> Pure <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>pure_cf <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Pure <span class="main">(</span><span class="skolem">f</span> <span class="main">°</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">≃</span> Pure <span class="skolem">f</span> <span class="main">⋄</span> Pure <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> itrm_hom<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ap_cf <span class="skolem">n</span> <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> ap_cf.IH <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"norm_pn <span class="main">(</span>ℬ <span class="main">°</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">n</span> <span class="main">≃</span> Pure <span class="main">(</span>ℬ <span class="main">°</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"norm_pn <span class="main">(</span>ℬ <span class="main">°</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">n</span> <span class="main">⋄</span> Opaque <span class="skolem">x</span> <span class="main">≃</span> Pure <span class="main">(</span>ℬ <span class="main">°</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">n</span> <span class="main">⋄</span> Opaque <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≃</span> Pure ℬ <span class="main">⋄</span> Pure <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">n</span> <span class="main">⋄</span> Opaque <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> itrm_hom<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≃</span> Pure <span class="skolem">f</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">⋄</span> Opaque <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> itrm_comp <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> norm_nn_equiv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∈</span> CF"</span></span> <span class="quoted"><span class="quoted">"<span class="free">n'</span> <span class="main">∈</span> CF"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"norm_nn <span class="free">n</span> <span class="free">n'</span> <span class="main">≃</span> <span class="free">n</span> <span class="main">⋄</span> <span class="free">n'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>1<span class="main">)</span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n'</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>pure_cf <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"norm_pn <span class="main">(</span>𝒯 <span class="main">°</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">n</span> <span class="main">≃</span> Pure <span class="main">(</span>𝒯 <span class="main">°</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> norm_pn_equiv<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≃</span> <span class="skolem">n</span> <span class="main">⋄</span> Pure <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> itrm_xchng<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ap_cf <span class="skolem">n'</span> <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"norm_nn <span class="main">(</span>norm_pn ℬ <span class="skolem">n</span><span class="main">)</span> <span class="skolem">n'</span> <span class="main">⋄</span> Opaque <span class="skolem">x</span> <span class="main">≃</span> Pure ℬ <span class="main">⋄</span> <span class="skolem">n</span> <span class="main">⋄</span> <span class="skolem">n'</span> <span class="main">⋄</span> Opaque <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">∈</span> CF›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"norm_pn ℬ <span class="skolem">n</span> <span class="main">∈</span> CF"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> norm_pn_in_cf<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> ap_cf.IH <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"norm_nn <span class="main">(</span>norm_pn ℬ <span class="skolem">n</span><span class="main">)</span> <span class="skolem">n'</span> <span class="main">≃</span> norm_pn ℬ <span class="skolem">n</span> <span class="main">⋄</span> <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≃</span> Pure ℬ <span class="main">⋄</span> <span class="skolem">n</span> <span class="main">⋄</span> <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> norm_pn_equiv <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">∈</span> CF›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"norm_nn <span class="main">(</span>norm_pn ℬ <span class="skolem">n</span><span class="main">)</span> <span class="skolem">n'</span> <span class="main">≃</span> Pure ℬ <span class="main">⋄</span> <span class="skolem">n</span> <span class="main">⋄</span> <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≃</span> <span class="skolem">n</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">n'</span> <span class="main">⋄</span> Opaque <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> itrm_comp <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> norm_equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"norm <span class="free">x</span> <span class="main">≃</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Opaque <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Pure ℐ <span class="main">⋄</span> Opaque <span class="skolem">x</span> <span class="main">≃</span> Opaque <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> itrm_id <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Pure <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>IAp <span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"norm <span class="skolem">f</span> <span class="main">∈</span> CF"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"norm <span class="skolem">x</span> <span class="main">∈</span> CF"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> norm_in_cf<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"norm_nn <span class="main">(</span>norm <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>norm <span class="skolem">x</span><span class="main">)</span> <span class="main">≃</span> norm <span class="skolem">f</span> <span class="main">⋄</span> norm <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> norm_nn_equiv<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≃</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> IAp.IH <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> normal_form<span class="main">:</span> <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">n</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≃</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∈</span> CF"</span></span>
<span class="keyword1"><span class="command">using</span></span> norm_equiv norm_in_cf <span class="keyword1"><span class="command">..</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Lifting with normal forms›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nf_unlift<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≃</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> cf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∈</span> CF"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CF_pure <span class="free">n</span> <span class="main">↔</span> unlift <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> cf <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"CF_pure <span class="free">n</span> <span class="main">↔</span> unlift <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cf_unlift<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> equiv <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unlift <span class="free">n</span> <span class="main">↔</span> unlift <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> unlift_equiv<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> nf_lifting<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> opaque<span class="main">:</span> <span class="quoted"><span class="quoted">"opaque <span class="free">x</span> <span class="main">=</span> opaque <span class="free">y</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> base_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"unlift <span class="free">x</span> <span class="main">↔</span> unlift <span class="free">y</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> nf_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≃</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> CF"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> normal_form<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n'</span></span> <span class="keyword2"><span class="keyword">where</span></span> nf_y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">≃</span> <span class="free">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">∈</span> CF"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> normal_form<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> nf_x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"CF_pure <span class="skolem">n</span> <span class="main">↔</span> unlift <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> nf_unlift<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> base_eq
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> nf_y <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unlift <span class="free">y</span> <span class="main">↔</span> CF_pure <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> nf_unlift<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> term_sym<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> pure_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"CF_pure <span class="skolem">n</span> <span class="main">↔</span> CF_pure <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">from</span></span> nf_x<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"opaque <span class="skolem">n</span> <span class="main">=</span> opaque <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> opaque_equiv<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> opaque
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> nf_y<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"opaque <span class="free">y</span> <span class="main">=</span> opaque <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> opaque_equiv<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> sym<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> opaque_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"opaque <span class="skolem">n</span> <span class="main">=</span> opaque <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">from</span></span> nf_x<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≃</span> <span class="skolem">n'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> nf_x nf_y pure_eq opaque_eq
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> similar_into_equiv cf_similarI<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> nf_y<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">≃</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Bracket abstraction, twice›</span></span>

<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹Preliminaries: Sequential application of variables›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">frees</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"dB <span class="main">⇒</span> nat set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">frees</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">i</span><span class="main">.</span> free <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="bound">i</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">var_dist</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat list <span class="main">⇒</span> dB <span class="main">⇒</span> dB"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">var_dist</span> <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">t</span><span class="main">.</span> <span class="bound">t</span> <span class="main">°</span> Var <span class="bound">i</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> var_dist_Nil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"var_dist <span class="main">[]</span> <span class="free">t</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> var_dist_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> var_dist_Cons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"var_dist <span class="main">(</span><span class="free">v</span> <span class="main">#</span> <span class="free">vs</span><span class="main">)</span> <span class="free">t</span> <span class="main">=</span> var_dist <span class="free">vs</span> <span class="main">(</span><span class="free">t</span> <span class="main">°</span> Var <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> var_dist_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> var_dist_append1<span class="main">:</span> <span class="quoted"><span class="quoted">"var_dist <span class="main">(</span><span class="free">vs</span> <span class="main">@</span> <span class="main">[</span><span class="free">v</span><span class="main">]</span><span class="main">)</span> <span class="free">t</span> <span class="main">=</span> var_dist <span class="free">vs</span> <span class="free">t</span> <span class="main">°</span> Var <span class="free">v</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> var_dist_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> var_dist_frees<span class="main">:</span> <span class="quoted"><span class="quoted">"frees <span class="main">(</span>var_dist <span class="free">vs</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> frees <span class="free">t</span> <span class="main">∪</span> set <span class="free">vs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> var_dist_subst_lt<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>set <span class="free">vs</span><span class="main">.</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="bound">v</span> <span class="main">⟹</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="free">s</span><span class="main">)</span><span class="main">[</span><span class="free">t</span><span class="main">/</span><span class="free">i</span><span class="main">]</span> <span class="main">=</span> var_dist <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">vs</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">[</span><span class="free">t</span><span class="main">/</span><span class="free">i</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> var_dist_subst_gt<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>set <span class="free">vs</span><span class="main">.</span> <span class="bound">v</span> <span class="main">&lt;</span> <span class="free">i</span> <span class="main">⟹</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="free">s</span><span class="main">)</span><span class="main">[</span><span class="free">t</span><span class="main">/</span><span class="free">i</span><span class="main">]</span> <span class="main">=</span> var_dist <span class="free">vs</span> <span class="main">(</span><span class="free">s</span><span class="main">[</span><span class="free">t</span><span class="main">/</span><span class="free">i</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">vsubst</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">vsubst</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> vsubst_subst<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Var <span class="free">u</span><span class="main">)</span><span class="main">[</span>Var <span class="free">v</span><span class="main">/</span><span class="free">w</span><span class="main">]</span> <span class="main">=</span> Var <span class="main">(</span>vsubst <span class="free">u</span> <span class="free">v</span> <span class="free">w</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> vsubst_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> vsubst_subst_lt<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">&lt;</span> <span class="free">w</span> <span class="main">⟹</span> vsubst <span class="free">u</span> <span class="free">v</span> <span class="free">w</span> <span class="main">=</span> <span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> vsubst_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> var_dist_subst_Var<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>var_dist <span class="free">vs</span> <span class="free">s</span><span class="main">)</span><span class="main">[</span>Var <span class="free">i</span><span class="main">/</span><span class="free">j</span><span class="main">]</span> <span class="main">=</span> var_dist <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> vsubst <span class="bound">v</span> <span class="free">i</span> <span class="free">j</span><span class="main">)</span> <span class="free">vs</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">[</span>Var <span class="free">i</span><span class="main">/</span><span class="free">j</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> var_dist_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">↔</span> <span class="free">t</span> <span class="main">⟹</span> var_dist <span class="free">vs</span> <span class="free">s</span> <span class="main">↔</span> var_dist <span class="free">vs</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹Preliminaries: Eta reductions with permuted variables›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> absn_subst<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span><span class="main">[</span><span class="free">t</span><span class="main">/</span><span class="free">k</span><span class="main">]</span> <span class="main">=</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">[</span>liftn <span class="free">n</span> <span class="free">t</span> <span class="main">0</span><span class="main">/</span><span class="free">k</span><span class="main">+</span><span class="free">n</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">k</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> liftn_lift_swap<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> absn_beta_equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">s</span> <span class="main">°</span> <span class="free">t</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">[</span>liftn <span class="free">n</span> <span class="free">t</span> <span class="main">0</span><span class="main">/</span><span class="free">n</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">s</span> <span class="main">°</span> <span class="free">t</span> <span class="main">=</span> Abs <span class="main">(</span><span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span> <span class="main">°</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> <span class="main">(</span><span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span><span class="main">[</span><span class="free">t</span><span class="main">/</span><span class="main">0</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> beta_into_equiv<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> beta.beta<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">[</span>liftn <span class="free">n</span> <span class="free">t</span> <span class="main">0</span><span class="main">/</span><span class="free">n</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> absn_subst<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> absn_dist_eta<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="main">(</span>rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="free">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">↔</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?dist_range</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">a</span> <span class="bound">k</span><span class="main">.</span> var_dist <span class="main">(</span>rev <span class="main">[</span><span class="bound">a</span><span class="main">..&lt;</span><span class="bound">k</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>liftn <span class="bound">k</span> <span class="free">t</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> append<span class="main">:</span> <span class="quoted"><span class="quoted">"rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>Suc <span class="skolem">n</span><span class="main">]</span> <span class="main">=</span> rev <span class="main">[</span><span class="main">1</span><span class="main">..&lt;</span>Suc <span class="skolem">n</span><span class="main">]</span> <span class="main">@</span> <span class="main">[</span><span class="main">0</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upt_rec<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> dist_last<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?dist_range</span> <span class="main">0</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> <span class="var">?dist_range</span> <span class="main">1</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">°</span> Var <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> append var_dist_append1 <span class="keyword1"><span class="command">..</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> free <span class="main">(</span><span class="var">?dist_range</span> <span class="main">1</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"frees <span class="main">(</span><span class="var">?dist_range</span> <span class="main">1</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> frees <span class="main">(</span>liftn <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="free">t</span> <span class="main">0</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span><span class="main">1</span><span class="main">..</span><span class="skolem">n</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> var_dist_frees <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∉</span> frees <span class="main">(</span><span class="var">?dist_range</span> <span class="main">1</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Abs <span class="main">(</span><span class="var">?dist_range</span> <span class="main">0</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>η</sub></span> <span class="main">(</span><span class="var">?dist_range</span> <span class="main">1</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span><span class="main">[</span>Var <span class="main">0</span><span class="main">/</span><span class="main">0</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> dist_last <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> eta<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> var_dist <span class="main">(</span>rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="skolem">n</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>liftn <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="free">t</span> <span class="main">0</span><span class="main">)</span><span class="main">[</span>Var <span class="main">0</span><span class="main">/</span><span class="main">0</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>set <span class="main">(</span>rev <span class="main">[</span><span class="main">1</span><span class="main">..&lt;</span>Suc <span class="skolem">n</span><span class="main">]</span><span class="main">)</span><span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="bound">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="skolem">n</span><span class="main">]</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>rev <span class="main">[</span><span class="main">1</span><span class="main">..&lt;</span>Suc <span class="skolem">n</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> var_dist_subst_lt<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="var">?dist_range</span> <span class="main">0</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> subst_liftn<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="main">0</span></span> <span class="quoted"><span class="skolem">n</span></span> <span class="quoted"><span class="main">0</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="quoted">"Var <span class="main">0</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Abs <span class="main">(</span><span class="var">?dist_range</span> <span class="main">0</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="main">↔</span> <span class="var">?dist_range</span> <span class="main">0</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span><span class="var">?dist_range</span> <span class="main">0</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="skolem">n</span><span class="main">)</span> <span class="main">(</span><span class="var">?dist_range</span> <span class="main">0</span> <span class="skolem">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> funpow_Suc_inside <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> absn_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> Suc.IH <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">strip_context</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> dB <span class="main">⇒</span> nat <span class="main">⇒</span> dB"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">strip_context</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>Var <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="keyword1">then</span> Var <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">else</span> Var <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">strip_context</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>Abs <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> Abs <span class="main">(</span><span class="free">strip_context</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">strip_context</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">°</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="free">strip_context</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">°</span> <span class="free">strip_context</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> strip_context_liftn<span class="main">:</span> <span class="quoted"><span class="quoted">"strip_context <span class="free">n</span> <span class="main">(</span>liftn <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="free">n</span><span class="main">)</span> <span class="free">t</span> <span class="free">k</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> liftn <span class="free">m</span> <span class="free">t</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">k</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> liftn_strip_context<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="free">t</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">k</span> <span class="main">∨</span> <span class="free">k</span> <span class="main">+</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">i</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"liftn <span class="free">n</span> <span class="main">(</span>strip_context <span class="free">n</span> <span class="free">t</span> <span class="free">k</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">k</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Abs <span class="skolem">t</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="skolem">t</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> Suc <span class="skolem">k</span> <span class="main">∨</span> Suc <span class="skolem">k</span> <span class="main">+</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">i</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="keyword3"><span class="command">assume</span></span> free<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> frees <span class="skolem">t</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> Suc <span class="skolem">k</span> <span class="main">∨</span> Suc <span class="skolem">k</span> <span class="main">+</span> <span class="free">n</span> <span class="main">≤</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> free Abs.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">-</span><span class="main">1</span> <span class="main">&lt;</span> <span class="skolem">k</span> <span class="main">∨</span> <span class="skolem">k</span> <span class="main">+</span> <span class="free">n</span> <span class="main">≤</span> <span class="skolem">i</span><span class="main">-</span><span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">arith</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">with</span></span> Abs.IH <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> absn_dist_eta_free<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="free">t</span><span class="main">.</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="main">(</span>rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span><span class="main">)</span> <span class="free">t</span><span class="main">)</span> <span class="main">↔</span> strip_context <span class="free">n</span> <span class="free">t</span> <span class="main">0</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="free">t</span> <span class="main">↔</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="var">?rhs</span> <span class="main">0</span><span class="main">)</span> <span class="main">↔</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> absn_dist_eta<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"liftn <span class="free">n</span> <span class="var">?rhs</span> <span class="main">0</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> liftn_strip_context<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">perm_vars</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat list <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">perm_vars</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">⟷</span> distinct <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">∧</span> set <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> perm_vars_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"perm_vars <span class="free">n</span> <span class="free">vs</span> <span class="main">⟹</span> distinct <span class="free">vs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> perm_vars_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> perm_vars_length<span class="main">:</span> <span class="quoted"><span class="quoted">"perm_vars <span class="free">n</span> <span class="free">vs</span> <span class="main">⟹</span> length <span class="free">vs</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> perm_vars_def <span class="keyword1"><span class="command">using</span></span> distinct_card <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">lemma</span></span> perm_vars_lt<span class="main">:</span> <span class="quoted"><span class="quoted">"perm_vars <span class="free">n</span> <span class="free">vs</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>set <span class="free">vs</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> perm_vars_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> perm_vars_nth_lt<span class="main">:</span> <span class="quoted"><span class="quoted">"perm_vars <span class="free">n</span> <span class="free">vs</span> <span class="main">⟹</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">vs</span> <span class="main">!</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> perm_vars_length perm_vars_lt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> perm_vars_inj_on_nth<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"perm_vars <span class="free">n</span> <span class="free">vs</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span>nth <span class="free">vs</span><span class="main">)</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> inj_onI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">j</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">vs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="free">vs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> perm_vars_length <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">vs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> perm_vars_distinct<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">vs</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> <span class="free">vs</span> <span class="main">!</span> <span class="skolem">j</span>"</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> nth_eq_iff_index_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">perm_vars_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat list <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">perm_vars_inv</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> the_inv_into <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">}</span> <span class="main">(</span><span class="main">(!)</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> perm_vars_inv_nth<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"perm_vars <span class="free">n</span> <span class="free">vs</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"perm_vars_inv <span class="free">n</span> <span class="free">vs</span> <span class="main">(</span><span class="free">vs</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> the_inv_into_f_f perm_vars_inj_on_nth<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dist_perm_eta<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> perm_vars<span class="main">:</span> <span class="quoted"><span class="quoted">"perm_vars <span class="free">n</span> <span class="free">vs</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">vs'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">t</span><span class="main">.</span> <span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="bound">t</span><span class="main">.</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">i</span> <span class="main">⟹</span>
    <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs'</span> <span class="main">(</span><span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="bound">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">↔</span> strip_context <span class="free">n</span> <span class="bound">t</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">vsubsts</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vsubsts</span> <span class="skolem">n</span> <span class="skolem">vs'</span> <span class="skolem">vs</span> <span class="main">=</span>
    map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span>
      <span class="keyword1">if</span> <span class="bound">v</span> <span class="main">&lt;</span> <span class="skolem">n</span> <span class="main">-</span> length <span class="skolem">vs'</span> <span class="keyword1">then</span> <span class="bound">v</span>
      <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">v</span> <span class="main">&lt;</span> <span class="skolem">n</span> <span class="keyword1">then</span> <span class="skolem">vs'</span> <span class="main">!</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> <span class="bound">v</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> length <span class="skolem">vs'</span><span class="main">)</span>
      <span class="keyword1">else</span> <span class="bound">v</span> <span class="main">-</span> length <span class="skolem">vs'</span><span class="main">)</span> <span class="skolem">vs</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">n</span> <span class="skolem">vs'</span> <span class="skolem">vs</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?app_vars</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">t</span> <span class="bound">n</span> <span class="bound">vs'</span> <span class="bound">vs</span><span class="main">.</span> var_dist <span class="bound">vs'</span> <span class="main">(</span><span class="main">(</span>Abs<span class="main">^^</span><span class="bound">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="bound">vs</span> <span class="main">(</span>liftn <span class="bound">n</span> <span class="bound">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span> <span class="main">::</span> <span class="quoted">dB</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">vs'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat list"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> partial<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">vs'</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?m</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">-</span> length <span class="skolem">vs'</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?app_vars</span> <span class="skolem">t</span> <span class="free">n</span> <span class="skolem">vs'</span> <span class="free">vs</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="var">?m</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="main">(</span><span class="skolem">vsubsts</span> <span class="free">n</span> <span class="skolem">vs'</span> <span class="free">vs</span><span class="main">)</span> <span class="main">(</span>liftn <span class="var">?m</span> <span class="skolem">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> partial <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">vs'</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">vs</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vsubsts</span> <span class="skolem">n</span> <span class="main">[]</span> <span class="skolem">vs</span> <span class="main">=</span> <span class="skolem">vs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> vsubsts_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_idI<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">v</span> <span class="skolem">vs'</span><span class="main">)</span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">n'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">=</span> <span class="skolem">n</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> Suc_n'<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">n'</span> <span class="main">=</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> n'_def <span class="keyword1"><span class="command">using</span></span> Cons.prems <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">have</span></span> vs'_length<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">vs'</span> <span class="main">≤</span> <span class="skolem">n'</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> n'_def <span class="keyword1"><span class="command">using</span></span> Cons.prems <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?m'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">n'</span> <span class="main">-</span> length <span class="skolem">vs'</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> m'_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?m'</span> <span class="main">=</span> <span class="skolem">n</span> <span class="main">-</span> length <span class="main">(</span><span class="skolem">v</span> <span class="main">#</span> <span class="skolem">vs'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> n'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?app_vars</span> <span class="skolem">t</span> <span class="skolem">n</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">#</span> <span class="skolem">vs'</span><span class="main">)</span> <span class="skolem">vs</span> <span class="main">=</span> <span class="var">?app_vars</span> <span class="skolem">t</span> <span class="main">(</span>Suc <span class="skolem">n'</span><span class="main">)</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">#</span> <span class="skolem">vs'</span><span class="main">)</span> <span class="skolem">vs</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> Suc_n' <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> var_dist <span class="skolem">vs'</span> <span class="main">(</span><span class="main">(</span>Abs<span class="main">^^</span>Suc <span class="skolem">n'</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="skolem">vs</span> <span class="main">(</span>liftn <span class="main">(</span>Suc <span class="skolem">n'</span><span class="main">)</span> <span class="skolem">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">°</span> Var <span class="skolem">v</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> var_dist_Cons <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> <span class="var">?app_vars</span> <span class="skolem">t</span> <span class="skolem">n'</span> <span class="skolem">vs'</span> <span class="main">(</span><span class="skolem">vsubsts</span> <span class="skolem">n</span> <span class="main">[</span><span class="skolem">v</span><span class="main">]</span> <span class="skolem">vs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> var_dist_cong<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span><span class="bound">vv</span><span class="main">.</span> vsubst <span class="bound">vv</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">+</span> <span class="skolem">n'</span><span class="main">)</span> <span class="skolem">n'</span><span class="main">)</span> <span class="skolem">vs</span> <span class="main">=</span> <span class="skolem">vsubsts</span> <span class="skolem">n</span> <span class="main">[</span><span class="skolem">v</span><span class="main">]</span> <span class="skolem">vs</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> Suc_n'<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> vsubsts_def vsubst_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>var_dist <span class="skolem">vs</span> <span class="main">(</span>liftn <span class="main">(</span>Suc <span class="skolem">n'</span><span class="main">)</span> <span class="skolem">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">[</span>liftn <span class="skolem">n'</span> <span class="main">(</span>Var <span class="skolem">v</span><span class="main">)</span> <span class="main">0</span><span class="main">/</span><span class="skolem">n'</span><span class="main">]</span>
                  <span class="main">=</span> var_dist <span class="main">(</span><span class="skolem">vsubsts</span> <span class="skolem">n</span> <span class="main">[</span><span class="skolem">v</span><span class="main">]</span> <span class="skolem">vs</span><span class="main">)</span> <span class="main">(</span>liftn <span class="skolem">n'</span> <span class="skolem">t</span> <span class="main">0</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> var_dist_subst_Var subst_liftn <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span>Suc <span class="skolem">n'</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="skolem">vs</span> <span class="main">(</span>liftn <span class="main">(</span>Suc <span class="skolem">n'</span><span class="main">)</span> <span class="skolem">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">°</span> Var <span class="skolem">v</span>
                  <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="skolem">n'</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="main">(</span><span class="skolem">vsubsts</span> <span class="skolem">n</span> <span class="main">[</span><span class="skolem">v</span><span class="main">]</span> <span class="skolem">vs</span><span class="main">)</span> <span class="main">(</span>liftn <span class="skolem">n'</span> <span class="skolem">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> absn_beta_equiv<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> term_trans<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="var">?m'</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="main">(</span><span class="skolem">vsubsts</span> <span class="skolem">n'</span> <span class="skolem">vs'</span> <span class="main">(</span><span class="skolem">vsubsts</span> <span class="skolem">n</span> <span class="main">[</span><span class="skolem">v</span><span class="main">]</span> <span class="skolem">vs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>liftn <span class="var">?m'</span> <span class="skolem">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> vs'_length Cons.IH <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="var">?m'</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="main">(</span><span class="skolem">vsubsts</span> <span class="skolem">n</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">#</span> <span class="skolem">vs'</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">)</span> <span class="main">(</span>liftn <span class="var">?m'</span> <span class="skolem">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vsubsts</span> <span class="skolem">n'</span> <span class="skolem">vs'</span> <span class="main">(</span><span class="skolem">vsubsts</span> <span class="main">(</span>Suc <span class="skolem">n'</span><span class="main">)</span> <span class="main">[</span><span class="skolem">v</span><span class="main">]</span> <span class="skolem">vs</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">vsubsts</span> <span class="main">(</span>Suc <span class="skolem">n'</span><span class="main">)</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">#</span> <span class="skolem">vs'</span><span class="main">)</span> <span class="skolem">vs</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> vsubsts_def
          <span class="keyword1"><span class="command">using</span></span> vs'_length <span class="main">[</span><span class="main">[</span><span class="operator">linarith_split_limit</span><span class="main"><span class="main">=</span></span>10<span class="main">]</span><span class="main">]</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Suc_n' <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> m'_conv <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> partial_appd <span class="main">=</span> this

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">vs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vs'</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">n</span> <span class="main">-</span> perm_vars_inv <span class="free">n</span> <span class="free">vs</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="bound">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span>"</span></span>

  <span class="keyword1"><span class="command">from</span></span> perm_vars <span class="keyword1"><span class="command">have</span></span> vs_length<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">vs</span> <span class="main">=</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> perm_vars_length<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> vs'_length<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">vs'</span> <span class="main">=</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> vs'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="skolem">vs'</span> <span class="main">!</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="bound">v</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="free">vs</span> <span class="main">=</span> rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="free">vs</span> <span class="main">=</span> length <span class="main">(</span>rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> vs_length <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">v'</span><span class="main">.</span> <span class="skolem">vs'</span> <span class="main">!</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="bound">v</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> <span class="bound">v'</span><span class="main">)</span> <span class="free">vs</span> <span class="main">(</span>rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">vs</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> vs_length <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">vs</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> perm_vars perm_vars_nth_lt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">n</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vs'</span> <span class="main">!</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">vs</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> perm_vars_inv <span class="free">n</span> <span class="free">vs</span> <span class="main">(</span><span class="free">vs</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> vs'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">n</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> <span class="skolem">i</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> perm_vars perm_vars_inv_nth <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">n</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span> <span class="main">!</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rev_nth<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vs'</span> <span class="main">!</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">vs</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span> <span class="main">!</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> list.rel_eq<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">using</span></span> list.rel_map
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> vs'_vs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">vsubsts</span> <span class="free">n</span> <span class="skolem">vs'</span> <span class="free">vs</span> <span class="main">=</span> rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> vsubsts_def vs'_length
    <span class="keyword1"><span class="command">using</span></span> perm_vars perm_vars_lt
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> map_ext<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> trans<span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?appd_vars</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">t</span> <span class="bound">n</span><span class="main">.</span> var_dist <span class="main">(</span>rev <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="bound">n</span><span class="main">]</span><span class="main">)</span> <span class="bound">t</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span>
    <span class="keyword3"><span class="command">assume</span></span> not_free<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="skolem">t</span><span class="main">.</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">i</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?app_vars</span> <span class="skolem">t</span> <span class="free">n</span> <span class="skolem">vs'</span> <span class="free">vs</span> <span class="main">↔</span> <span class="var">?appd_vars</span> <span class="skolem">t</span> <span class="free">n</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">t</span>
      <span class="keyword1"><span class="command">using</span></span> partial_appd<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">vs'</span></span><span class="main">]</span> vs'_length vs'_vs <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="var">?app_vars</span> <span class="skolem">t</span> <span class="free">n</span> <span class="skolem">vs'</span> <span class="free">vs</span><span class="main">)</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="var">?appd_vars</span> <span class="skolem">t</span> <span class="free">n</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> absn_cong<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> strip_context <span class="free">n</span> <span class="skolem">t</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> not_free <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> absn_dist_eta_free<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="var">?app_vars</span> <span class="skolem">t</span> <span class="free">n</span> <span class="skolem">vs'</span> <span class="free">vs</span><span class="main">)</span> <span class="main">↔</span> strip_context <span class="free">n</span> <span class="skolem">t</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> liftn_absn<span class="main">:</span> <span class="quoted"><span class="quoted">"liftn <span class="free">n</span> <span class="main">(</span><span class="main">(</span>Abs<span class="main">^^</span><span class="free">m</span><span class="main">)</span> <span class="free">t</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">m</span><span class="main">)</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="free">t</span> <span class="main">(</span><span class="free">k</span> <span class="main">+</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">k</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> liftn_var_dist_lt<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>set <span class="free">vs</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">k</span> <span class="main">⟹</span> liftn <span class="free">n</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="free">t</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> var_dist <span class="free">vs</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="free">t</span> <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> liftn_context_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">≤</span> <span class="free">k'</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="free">t</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">k</span> <span class="main">∨</span> <span class="free">k'</span> <span class="main">≤</span> <span class="bound">i</span> <span class="main">⟹</span> liftn <span class="free">n</span> <span class="free">t</span> <span class="free">k</span> <span class="main">=</span> liftn <span class="free">n</span> <span class="free">t</span> <span class="free">k'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="free">k'</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Abs <span class="skolem">t</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="skolem">t</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> Suc <span class="skolem">k</span> <span class="main">∨</span> Suc <span class="skolem">k'</span> <span class="main">≤</span> <span class="bound">i</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> frees <span class="skolem">t</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> Suc <span class="skolem">k</span> <span class="main">∨</span> Suc <span class="skolem">k'</span> <span class="main">≤</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> Abs.prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> free <span class="skolem">t</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="skolem">k</span> <span class="main">∨</span> <span class="skolem">k'</span> <span class="main">≤</span> <span class="bound">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="bound">i</span> <span class="main">∧</span> free <span class="skolem">t</span> <span class="bound">i</span> <span class="main">⟶</span> <span class="bound">i</span> <span class="main">-</span> <span class="main">1</span> <span class="main">&lt;</span> <span class="skolem">k</span> <span class="main">∨</span> <span class="skolem">k'</span> <span class="main">≤</span> <span class="bound">i</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="bound">i</span> <span class="main">∧</span> free <span class="skolem">t</span> <span class="bound">i</span> <span class="main">⟶</span> <span class="bound">i</span> <span class="main">&lt;</span> Suc <span class="skolem">k</span> <span class="main">∨</span> Suc <span class="skolem">k'</span> <span class="main">≤</span> <span class="bound">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">≠</span> <span class="main">0</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">∈</span> frees <span class="skolem">t</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">with</span></span> Abs.IH Abs.prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> liftn_liftn0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="free">t</span><span class="main">.</span> <span class="free">k</span> <span class="main">≤</span> <span class="bound">i</span> <span class="main">⟹</span> liftn <span class="free">n</span> <span class="free">t</span> <span class="free">k</span> <span class="main">=</span> liftn <span class="free">n</span> <span class="free">t</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> liftn_context_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> dist_perm_eta_equiv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> perm_vars<span class="main">:</span> <span class="quoted"><span class="quoted">"perm_vars <span class="free">n</span> <span class="free">vs</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> not_free<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="free">s</span><span class="main">.</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="free">t</span><span class="main">.</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">i</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> perm_equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="free">s</span><span class="main">)</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="free">t</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"strip_context <span class="free">n</span> <span class="free">s</span> <span class="main">0</span> <span class="main">↔</span> strip_context <span class="free">n</span> <span class="free">t</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> perm_vars <span class="keyword1"><span class="command">have</span></span> vs_lt_n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>set <span class="free">vs</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> perm_vars_lt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">vs'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    etas<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">t</span><span class="main">.</span> <span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="bound">t</span><span class="main">.</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">i</span> <span class="main">⟹</span>
          <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="skolem">vs'</span> <span class="main">(</span><span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="bound">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">↔</span> strip_context <span class="free">n</span> <span class="bound">t</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> perm_vars dist_perm_eta <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"strip_context <span class="free">n</span> <span class="free">s</span> <span class="main">0</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="skolem">vs'</span> <span class="main">(</span><span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="free">s</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> etas<span class="main">[</span><span class="operator">THEN</span> term_sym<span class="main">]</span> not_free<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="skolem">vs'</span> <span class="main">(</span><span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="free">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> absn_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> var_dist_cong<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="free">s</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="free">s</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> not_free<span class="main">(</span>1<span class="main">)</span> liftn_liftn0<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="free">s</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> vs_lt_n liftn_var_dist_lt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> liftn <span class="free">n</span> <span class="main">(</span><span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> liftn_absn <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> liftn <span class="free">n</span> <span class="main">(</span><span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> perm_equiv <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> equiv_liftn<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="free">t</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> liftn_absn <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="free">t</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> vs_lt_n liftn_var_dist_lt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="free">t</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> not_free<span class="main">(</span>2<span class="main">)</span> liftn_liftn0<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="main">(</span>liftn <span class="free">n</span> <span class="free">s</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">↔</span> <span class="main">...</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> strip_context <span class="free">n</span> <span class="free">t</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> etas not_free<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹General notion of bracket abstraction for lambda terms›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">foldr_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> option<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">foldr_option</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> foldr <span class="main">(</span><span class="main">λ</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> Option.bind <span class="bound">b</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bind_eq_SomeE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Option.bind <span class="free">x</span> <span class="free">f</span> <span class="main">=</span> Some <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">x'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> Some <span class="free">x'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">x'</span> <span class="main">=</span> Some <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span> bind_eq_Some_conv<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> foldr_option_Nil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"foldr_option <span class="free">f</span> <span class="main">[]</span> <span class="free">e</span> <span class="main">=</span> Some <span class="free">e</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> foldr_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> foldr_option_Cons_SomeE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"foldr_option <span class="free">f</span> <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="free">e</span> <span class="main">=</span> Some <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">y'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"foldr_option <span class="free">f</span> <span class="free">xs</span> <span class="free">e</span> <span class="main">=</span> Some <span class="free">y'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">x</span> <span class="free">y'</span> <span class="main">=</span> Some <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> foldr_option_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> bind_eq_SomeE<span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> bracket_abstraction <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">term_bracket</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> dB <span class="main">⇒</span> dB option"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bracket_app<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">term_bracket</span> <span class="free">i</span> <span class="free">s</span> <span class="main">=</span> Some <span class="free">s'</span> <span class="main">⟹</span> <span class="free">s'</span> <span class="main">°</span> Var <span class="free">i</span> <span class="main">↔</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bracket_frees<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">term_bracket</span> <span class="free">i</span> <span class="free">s</span> <span class="main">=</span> Some <span class="free">s'</span> <span class="main">⟹</span> frees <span class="free">s'</span> <span class="main">=</span> frees <span class="free">s</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">term_brackets</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat list <span class="main">⇒</span> dB <span class="main">⇒</span> dB option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">term_brackets</span> <span class="main">=</span> foldr_option <span class="free">term_bracket</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> term_brackets_Nil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"term_brackets <span class="main">[]</span> <span class="free">t</span> <span class="main">=</span> Some <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> term_brackets_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> term_brackets_Cons_SomeE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"term_brackets <span class="main">(</span><span class="free">v</span><span class="main">#</span><span class="free">vs</span><span class="main">)</span> <span class="free">t</span> <span class="main">=</span> Some <span class="free">t'</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">s'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"term_brackets <span class="free">vs</span> <span class="free">t</span> <span class="main">=</span> Some <span class="free">s'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">term_bracket</span> <span class="free">v</span> <span class="free">s'</span> <span class="main">=</span> Some <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> term_brackets_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> foldr_option_Cons_SomeE<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> term_brackets_ConsI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"term_brackets <span class="free">vs</span> <span class="free">t</span> <span class="main">=</span> Some <span class="free">t'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">term_bracket</span> <span class="free">v</span> <span class="free">t'</span> <span class="main">=</span> Some <span class="free">t''</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"term_brackets <span class="main">(</span><span class="free">v</span><span class="main">#</span><span class="free">vs</span><span class="main">)</span> <span class="free">t</span> <span class="main">=</span> Some <span class="free">t''</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> term_brackets_def foldr_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> term_brackets_dist<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"term_brackets <span class="free">vs</span> <span class="free">t</span> <span class="main">=</span> Some <span class="free">t'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"var_dist <span class="free">vs</span> <span class="free">t'</span> <span class="main">↔</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">t''</span><span class="main">.</span> <span class="free">t'</span> <span class="main">↔</span> <span class="bound">t''</span> <span class="main">⟶</span> var_dist <span class="free">vs</span> <span class="bound">t''</span> <span class="main">↔</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t'</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> term_sym<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">v</span> <span class="skolem">vs</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> Cons.prems <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span>
        inner<span class="main">:</span> <span class="quoted"><span class="quoted">"term_brackets <span class="skolem">vs</span> <span class="free">t</span> <span class="main">=</span> Some <span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
        step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">term_bracket</span> <span class="skolem">v</span> <span class="skolem">u</span> <span class="main">=</span> Some <span class="skolem">t'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> term_brackets_Cons_SomeE<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> step <span class="keyword1"><span class="command">have</span></span> red1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">t'</span> <span class="main">°</span> Var <span class="skolem">v</span> <span class="main">↔</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> bracket_app<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">rule</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t''</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t'</span> <span class="main">↔</span> <span class="skolem">t''</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> red1 <span class="keyword1"><span class="command">have</span></span> red<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">t''</span> <span class="main">°</span> Var <span class="skolem">v</span> <span class="main">↔</span> <span class="skolem">u</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> term_sym term_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"var_dist <span class="main">(</span><span class="skolem">v</span> <span class="main">#</span> <span class="skolem">vs</span><span class="main">)</span> <span class="skolem">t''</span> <span class="main">=</span> var_dist <span class="skolem">vs</span> <span class="main">(</span><span class="skolem">t''</span> <span class="main">°</span> Var <span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.IH<span class="main">[</span><span class="operator">OF</span> inner<span class="main">]</span> red<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"var_dist <span class="main">(</span><span class="skolem">v</span> <span class="main">#</span> <span class="skolem">vs</span><span class="main">)</span> <span class="skolem">t''</span> <span class="main">↔</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* locale bracket_abstraction *)</span>


<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹Bracket abstraction for idiomatic terms›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We consider idiomatic terms with explicitly assigned variables.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> strip_unlift_vars<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"opaque <span class="free">x</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"strip_context <span class="free">n</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> unlift_vars <span class="main">0</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> strip_context_liftn<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">0</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> unlift_vars_frees<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x</span><span class="main">)</span><span class="main">.</span> <span class="bound">i</span> <span class="main">∈</span> set <span class="main">(</span>opaque <span class="free">x</span><span class="main">)</span> <span class="main">∨</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">i</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> free_liftn<span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> itrm_abstraction <span class="main">=</span> special_idiom <span class="quoted"><span class="free">extra_rule</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">extra_rule</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat itrm <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">itrm_bracket</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat itrm <span class="main">⇒</span> nat itrm option"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> itrm_bracket_ap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">itrm_bracket</span> <span class="free">i</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">x'</span> <span class="main">⟹</span> <span class="free">x'</span> <span class="main">⋄</span> Opaque <span class="free">i</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> itrm_bracket_opaque<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">itrm_bracket</span> <span class="free">i</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">x'</span> <span class="main">⟹</span> set <span class="main">(</span>opaque <span class="free">x'</span><span class="main">)</span> <span class="main">=</span> set <span class="main">(</span>opaque <span class="free">x</span><span class="main">)</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">itrm_brackets</span> <span class="main">=</span> foldr_option <span class="free">itrm_bracket</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> itrm_brackets_Nil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"itrm_brackets <span class="main">[]</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> itrm_brackets_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> itrm_brackets_Cons_SomeE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"itrm_brackets <span class="main">(</span><span class="free">v</span><span class="main">#</span><span class="free">vs</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">x'</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">y'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"itrm_brackets <span class="free">vs</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">y'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">itrm_bracket</span> <span class="free">v</span> <span class="free">y'</span> <span class="main">=</span> Some <span class="free">x'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> itrm_brackets_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> foldr_option_Cons_SomeE<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">opaque_dist</span> <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">⋄</span> Opaque <span class="bound">i</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> opaque_dist_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> <span class="free">y</span> <span class="main">⟹</span> opaque_dist <span class="free">vs</span> <span class="free">x</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> opaque_dist <span class="free">vs</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> opaque_dist_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ap_congL<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> itrm_brackets_dist<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> defined<span class="main">:</span> <span class="quoted"><span class="quoted">"itrm_brackets <span class="free">vs</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">x'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"opaque_dist <span class="free">vs</span> <span class="free">x'</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">x''</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x''</span> <span class="main">=</span> <span class="free">x'</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x'</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> <span class="skolem">x''</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> x''_def <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">with</span></span> defined <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"opaque_dist <span class="free">vs</span> <span class="skolem">x''</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> opaque_dist_def
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x'</span></span> <span class="quoted"><span class="skolem">x''</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> itrm_brackets_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> itrm_sym<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">v</span> <span class="skolem">vs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> Cons.prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y'</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> defined'<span class="main">:</span> <span class="quoted"><span class="quoted">"itrm_brackets <span class="skolem">vs</span> <span class="free">x</span> <span class="main">=</span> Some <span class="skolem">y'</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">itrm_bracket</span> <span class="skolem">v</span> <span class="skolem">y'</span> <span class="main">=</span> Some <span class="skolem">x'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> itrm_brackets_Cons_SomeE<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span> <span class="main">⋄</span> Opaque <span class="skolem">v</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> <span class="skolem">y'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> itrm_bracket_ap<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x''</span> <span class="main">⋄</span> Opaque <span class="skolem">v</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> <span class="skolem">y'</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> Cons.prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> itrm_sym itrm_trans<span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> this<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">with</span></span> defined' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">⋄</span> Opaque <span class="bound">i</span><span class="main">)</span> <span class="skolem">vs</span> <span class="main">(</span><span class="skolem">x''</span> <span class="main">⋄</span> Opaque <span class="skolem">v</span><span class="main">)</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> <span class="free">x</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> Cons.IH <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> itrm_brackets_opaque<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"itrm_brackets <span class="free">vs</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">x'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>opaque <span class="free">x'</span><span class="main">)</span> <span class="main">=</span> set <span class="main">(</span>opaque <span class="free">x</span><span class="main">)</span> <span class="main">-</span> set <span class="free">vs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x'</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> itrm_brackets_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">v</span> <span class="skolem">vs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> itrm_brackets_Cons_SomeE <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> itrm_bracket_opaque<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> itrm_brackets_all<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> all_opaque<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>opaque <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> set <span class="free">vs</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> defined<span class="main">:</span> <span class="quoted"><span class="quoted">"itrm_brackets <span class="free">vs</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">x'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"opaque <span class="free">x'</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> defined <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>opaque <span class="free">x'</span><span class="main">)</span> <span class="main">=</span> set <span class="main">(</span>opaque <span class="free">x</span><span class="main">)</span> <span class="main">-</span> set <span class="free">vs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> itrm_brackets_opaque<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> all_opaque <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>opaque <span class="free">x'</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> itrm_brackets_all_unlift_vars<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> all_opaque<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>opaque <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> set <span class="free">vs</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> defined<span class="main">:</span> <span class="quoted"><span class="quoted">"itrm_brackets <span class="free">vs</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">x'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x'</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> Pure <span class="main">(</span>unlift_vars <span class="main">0</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> equiv_into_ext_equiv<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"opaque <span class="free">x'</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> itrm_brackets_all<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">x'</span> <span class="main">≃</span> Pure <span class="main">(</span>unlift_vars <span class="main">0</span> <span class="free">x'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> all_pure_unlift_vars<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* locale itrm_abstraction *)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Lifting with bracket abstraction›</span></span>

<span class="keyword1"><span class="command">locale</span></span> lifted_bracket <span class="main">=</span> bracket_abstraction <span class="main">+</span> itrm_abstraction <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bracket_compat<span class="main">:</span>
    <span class="quoted"><span class="quoted">"set <span class="main">(</span>opaque <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span> <span class="main">⟹</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">⟹</span>
      <span class="free">term_bracket</span> <span class="free">i</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> map_option <span class="main">(</span>unlift_vars <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="free">itrm_bracket</span> <span class="free">i</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> brackets_unlift_vars_swap<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> all_opaque<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>opaque <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> vs_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">vs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> defined<span class="main">:</span> <span class="quoted"><span class="quoted">"itrm_brackets <span class="free">vs</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">x'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"term_brackets <span class="free">vs</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> vs_bound defined <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x'</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">v</span> <span class="skolem">vs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> ivs<span class="main">:</span> <span class="quoted"><span class="quoted">"itrm_brackets <span class="skolem">vs</span> <span class="free">x</span> <span class="main">=</span> Some <span class="skolem">y'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> iv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">itrm_bracket</span> <span class="skolem">v</span> <span class="skolem">y'</span> <span class="main">=</span> Some <span class="skolem">x'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> itrm_brackets_Cons_SomeE<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Cons <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"term_brackets <span class="skolem">vs</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="skolem">y'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Some <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="skolem">x'</span><span class="main">)</span> <span class="main">=</span> map_option <span class="main">(</span>unlift_vars <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="free">itrm_bracket</span> <span class="skolem">v</span> <span class="skolem">y'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> iv <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>opaque <span class="skolem">y'</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> all_opaque ivs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> itrm_brackets_opaque<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">term_bracket</span> <span class="skolem">v</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="skolem">y'</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="skolem">x'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> bracket_compat <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> term_brackets_ConsI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> bracket_lifting<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> all_vars<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>opaque <span class="free">x</span><span class="main">)</span> <span class="main">∪</span> set <span class="main">(</span>opaque <span class="free">y</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> perm_vars<span class="main">:</span> <span class="quoted"><span class="quoted">"perm_vars <span class="free">n</span> <span class="free">vs</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> defined<span class="main">:</span> <span class="quoted"><span class="quoted">"itrm_brackets <span class="free">vs</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">x'</span>"</span></span> <span class="quoted"><span class="quoted">"itrm_brackets <span class="free">vs</span> <span class="free">y</span> <span class="main">=</span> Some <span class="free">y'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> base_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x</span><span class="main">)</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> perm_vars <span class="keyword1"><span class="command">have</span></span> set_vs<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">vs</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> perm_vars_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">have</span></span> x_swap<span class="main">:</span> <span class="quoted"><span class="quoted">"term_brackets <span class="free">vs</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> all_vars set_vs defined<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> brackets_unlift_vars_swap<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> y_swap<span class="main">:</span> <span class="quoted"><span class="quoted">"term_brackets <span class="free">vs</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">y'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> all_vars set_vs defined<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> brackets_unlift_vars_swap<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> all_vars <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>opaque <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> set <span class="free">vs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> set_vs <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> complete_x<span class="main">:</span> <span class="quoted"><span class="quoted">"opaque <span class="free">x'</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> defined<span class="main">(</span>1<span class="main">)</span> itrm_brackets_all <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> ux_frees<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x'</span><span class="main">)</span><span class="main">.</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> unlift_vars_frees <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

  <span class="keyword1"><span class="command">from</span></span> all_vars <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>opaque <span class="free">y</span><span class="main">)</span> <span class="main">⊆</span> set <span class="free">vs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> set_vs <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> complete_y<span class="main">:</span> <span class="quoted"><span class="quoted">"opaque <span class="free">y'</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> defined<span class="main">(</span>2<span class="main">)</span> itrm_brackets_all <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> uy_frees<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span>frees <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">y'</span><span class="main">)</span><span class="main">.</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> unlift_vars_frees <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> opaque_dist <span class="free">vs</span> <span class="free">x'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> defined<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> itrm_brackets_dist<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> opaque_dist <span class="free">vs</span> <span class="main">(</span>Pure <span class="main">(</span>unlift_vars <span class="main">0</span> <span class="free">x'</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> all_vars set_vs defined<span class="main">(</span>1<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> opaque_dist_cong itrm_brackets_all_unlift_vars<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> opaque_dist <span class="free">vs</span> <span class="main">(</span>Pure <span class="main">(</span>unlift_vars <span class="main">0</span> <span class="free">y'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> opaque_dist_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> pure_cong<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x'</span><span class="main">)</span><span class="main">)</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> x_swap term_brackets_dist <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> base_eq <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">↔</span> <span class="main">(</span>Abs<span class="main">^^</span><span class="free">n</span><span class="main">)</span> <span class="main">(</span>var_dist <span class="free">vs</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">y'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> y_swap term_brackets_dist<span class="main">[</span><span class="operator">THEN</span> term_sym<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"strip_context <span class="free">n</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">x'</span><span class="main">)</span> <span class="main">0</span> <span class="main">↔</span> strip_context <span class="free">n</span> <span class="main">(</span>unlift_vars <span class="free">n</span> <span class="free">y'</span><span class="main">)</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> perm_vars ux_frees uy_frees
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> dist_perm_eta_equiv<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"unlift_vars <span class="main">0</span> <span class="free">x'</span> <span class="main">↔</span> unlift_vars <span class="main">0</span> <span class="free">y'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> strip_unlift_vars complete_x complete_y <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> opaque_dist <span class="free">vs</span> <span class="free">y'</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> opaque_dist_cong<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Pure <span class="main">(</span>unlift_vars <span class="main">0</span> <span class="free">y'</span><span class="main">)</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> <span class="free">y'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> all_vars set_vs defined<span class="main">(</span>2<span class="main">)</span> itrm_brackets_all_unlift_vars<span class="main">[</span><span class="operator">THEN</span> itrm_sym<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≃<span class="hidden">⇧</span><sup>+</sup></span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> defined<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> itrm_brackets_dist<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* locale lifted_bracket *)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Abstract_AF">
<div class="head">
<h1>Theory Abstract_AF</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich
   Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹An abstract applicative functor›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Abstract_AF <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Applicative.html">Applicative</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'a</span> af <span class="main">=</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">::</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_af

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">af_pure</span> <span class="main">≡</span> Abs_af"</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> af_ap <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> af <span class="main">⇒</span> <span class="tfree">'a</span> af <span class="main">⇒</span> <span class="tfree">'b</span> af"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.pure <span class="quoted">Abs_af</span>
<span class="keyword1"><span class="command">adhoc_overloading</span></span> Applicative.ap <span class="quoted">af_ap</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> applicative_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> af_identity<span class="main">:</span> <span class="quoted"><span class="quoted">"af_pure id <span class="main">⋄</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> af_homomorphism<span class="main">:</span> <span class="quoted"><span class="quoted">"af_pure <span class="free">f</span> <span class="main">⋄</span> af_pure <span class="free">x</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> af_ap.abs_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> af_composition<span class="main">:</span> <span class="quoted"><span class="quoted">"af_pure comp <span class="main">⋄</span> <span class="free">g</span> <span class="main">⋄</span> <span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">=</span> <span class="free">g</span> <span class="main">⋄</span> <span class="main">(</span><span class="free">f</span> <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> af_interchange<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⋄</span> af_pure <span class="free">x</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">g</span><span class="main">.</span> <span class="bound">g</span> <span class="free">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lifting_forget</span></span> af.lifting

<span class="keyword1"><span class="command">hide_const</span></span> Abs_af Rep_af
<span class="keyword1"><span class="command">hide_fact</span></span> af_ap_def

<span class="keyword1"><span class="command">applicative</span></span> af
<span class="keyword2"><span class="keyword">for</span></span>
  pure<span class="main">:</span> <span class="quoted">af_pure</span>
  ap<span class="main">:</span> <span class="quoted">af_ap</span>
<span class="keyword1"><span class="command">using</span></span> af_homomorphism af_composition af_identity af_interchange
<span class="keyword1"><span class="command">unfolding</span></span> id_def comp_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
<span class="keyword1"><span class="command">.</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Applicative_Test">
<div class="head">
<h1>Theory Applicative_Test</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Joshua Schneider, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Regression tests for applicative lifting›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Applicative_Test <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Stream_Algebra.html">Stream_Algebra</a>
  <a href="Applicative_Environment.html">Applicative_Environment</a>
  <a href="Applicative_List.html">Applicative_List</a>
  <a href="Applicative_Option.html">Applicative_Option</a>
  <a href="Applicative_Set.html">Applicative_Set</a>
  <a href="Applicative_Sum.html">Applicative_Sum</a>
  <a href="Abstract_AF.html">Abstract_AF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">unbundle</span></span> applicative_syntax

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Normal form conversion›</span></span>

<span class="keyword1"><span class="command">notepad</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> af_pure <span class="bound">x</span> <span class="main">=</span> af_pure <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> af_pure <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">=</span> af_pure <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> af_pure <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">y</span> <span class="main">=</span> af_pure <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> af_pure <span class="bound">g</span> <span class="main">⋄</span> <span class="main">(</span><span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">y</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="main">⋄</span> <span class="main">(</span><span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">g</span> <span class="main">⋄</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="main">⋄</span> af_pure <span class="bound">x</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> af_pure <span class="bound">x</span> <span class="main">⋄</span> af_pure <span class="bound">y</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> af_pure <span class="bound">y</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> af_pure <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> af_pure <span class="bound">y</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> af_pure <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> af_pure <span class="bound">y</span> <span class="main">⋄</span> <span class="bound">z</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">z</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">g</span> <span class="bound">y</span><span class="main">.</span> af_pure <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="main">(</span>af_pure <span class="bound">g</span> <span class="main">⋄</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="main">(</span><span class="bound">g</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">g</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="main">(</span><span class="bound">g</span> <span class="main">⋄</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">y</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">g</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="main">(</span><span class="bound">g</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">g</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">g</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="main">(</span><span class="bound">g</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">z</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">g</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="bound">f</span> <span class="main">(</span><span class="bound">g</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">z</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">g</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">y</span> <span class="main">⋄</span> <span class="bound">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">g</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="main">(</span><span class="bound">g</span> <span class="main">⋄</span> <span class="main">(</span><span class="bound">x</span> <span class="main">⋄</span> af_pure <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">z</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">g</span> <span class="bound">x</span> <span class="bound">z</span><span class="main">.</span> <span class="bound">f</span> <span class="main">(</span><span class="bound">g</span> <span class="main">(</span><span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="bound">z</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">g</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">g</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="main">(</span><span class="bound">g</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">g</span> <span class="bound">x</span> <span class="bound">x'</span><span class="main">.</span> <span class="bound">f</span> <span class="main">(</span><span class="bound">g</span> <span class="bound">x</span> <span class="bound">x'</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">g</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">y</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="bound">f</span> <span class="bound">x</span> <span class="main">⋄</span> <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> af"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> af"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">⋄</span> <span class="main">(</span><span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> af_pure <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⋄</span> <span class="skolem">g</span> <span class="main">⋄</span> <span class="skolem">f</span> <span class="main">⋄</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">rule</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(* TODO automatic test for names of new variables *)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span> <span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span> af<span class="main">.</span> <span class="bound">f</span> <span class="main">⋄</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">applicative_nf</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Sets›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">plus</span><span class="main">)</span> <span class="quoted">plus</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> set_plus_def<span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>plus<span class="main">)</span>set<span class="main">)</span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">=</span> <span class="main">{</span>plus<span class="main">}</span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">⋄</span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">::</span> <span class="main">_</span> <span class="main">::</span> semigroup_add set<span class="main">)</span> <span class="main">+</span> <span class="free">Y</span> <span class="main">+</span> <span class="free">Z</span> <span class="main">=</span> <span class="free">X</span> <span class="main">+</span> <span class="main">(</span><span class="free">Y</span> <span class="main">+</span> <span class="free">Z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> add.assoc<span class="main"><span class="main">[</span></span><span class="operator">applicative_lifted</span> set<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">semigroup_add</span><span class="main">)</span> <span class="quoted">semigroup_add</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">X</span> <span class="skolem">Y</span> <span class="skolem">Z</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword1"><span class="command">from</span></span> add.assoc
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X</span> <span class="main">+</span> <span class="skolem">Y</span> <span class="main">+</span> <span class="skolem">Z</span> <span class="main">=</span> <span class="skolem">X</span> <span class="main">+</span> <span class="main">(</span><span class="skolem">Y</span> <span class="main">+</span> <span class="skolem">Z</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">ab_semigroup_add</span><span class="main">)</span> <span class="quoted">ab_semigroup_add</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">X</span> <span class="skolem">Y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword1"><span class="command">from</span></span> add.commute
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">X</span> <span class="main">+</span> <span class="skolem">Y</span> <span class="main">=</span> <span class="skolem">Y</span> <span class="main">+</span> <span class="skolem">X</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Sum type (a.k.a. either)›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"Inl plus <span class="main">⋄</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> nat <span class="main">+</span> <span class="tfree">'e</span> list<span class="main">)</span> <span class="main">⋄</span> <span class="free">x</span> <span class="main">=</span> Inl <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="numeral">2</span> <span class="main">*</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"rel_sum <span class="main">(≤)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> nat <span class="main">+</span> nat<span class="main">)</span> <span class="main">(</span>Inl Suc <span class="main">⋄</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> either_af <span class="quoted"><span class="quoted">"<span class="main">(≤)</span> <span class="main">::</span> nat <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">rule</span> reflpI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Streams›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>int stream<span class="main">)</span> <span class="main">*</span> sconst <span class="main">0</span> <span class="main">=</span> sconst <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>int stream<span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">z</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="main">*</span> <span class="free">y</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="free">z</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">algebra</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lift_streams</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> foldr <span class="main">(</span>smap2 Cons<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span>sconst <span class="main">[]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lift_streams_Nil<span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lift_streams <span class="main">[]</span> <span class="main">=</span> sconst <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lift_streams_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lift_streams_Cons<span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lift_streams <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> smap2 Cons <span class="free">x</span> <span class="main">(</span>lift_streams <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> lift_streams_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_unfold</span>

<span class="keyword1"><span class="command">lemma</span></span> stream_append_Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"smap2 append <span class="main">(</span>smap2 Cons <span class="free">x</span> <span class="free">ys</span><span class="main">)</span> <span class="free">zs</span> <span class="main">=</span> smap2 Cons <span class="free">x</span> <span class="main">(</span>smap2 append <span class="free">ys</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lift_streams_append<span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lift_streams <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> smap2 append <span class="main">(</span>lift_streams <span class="free">xs</span><span class="main">)</span> <span class="main">(</span>lift_streams <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="comment1">(*
    case could be proved directly if "lift_streams ([] @ ys) = lift_streams ys" is solved
    in head_cong_tac (invoke simplifier?) -- but only with applicative_nf
  *)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lift_streams <span class="free">ys</span> <span class="main">=</span> sconst append <span class="main">⋄</span> lift_streams <span class="main">[]</span> <span class="main">⋄</span> lift_streams <span class="free">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_unfold</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> stream_append_Cons  <span class="comment1">(* the actual lifted fact *)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_unfold</span> <span class="main">(</span><span class="operator">rule</span> sym<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"lift_streams <span class="main">(</span>rev <span class="free">x</span><span class="main">)</span> <span class="main">=</span> smap rev <span class="main">(</span>lift_streams <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lift_streams <span class="main">[]</span> <span class="main">=</span> smap rev <span class="main">(</span>lift_streams <span class="main">[]</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span> <span class="bound">ys</span><span class="main">.</span> rev <span class="bound">ys</span> <span class="main">@</span> <span class="main">[</span><span class="bound">y</span><span class="main">]</span> <span class="main">=</span> rev <span class="main">(</span><span class="bound">y</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span> <span class="bound">ys</span><span class="main">.</span> smap2 append <span class="main">(</span>smap rev <span class="bound">ys</span><span class="main">)</span> <span class="main">(</span>smap2 Cons <span class="bound">y</span> <span class="main">(</span>sconst <span class="main">[]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> smap rev <span class="main">(</span>smap2 Cons <span class="bound">y</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> Cons.IH <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_unfold</span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">applicative_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sconcat</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> smap concat <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"sconcat <span class="main">(</span>lift_streams <span class="main">[</span>sconst <span class="inner_quoted">''Hello ''</span><span class="main">,</span> sconst <span class="inner_quoted">''world!''</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> sconst <span class="inner_quoted">''Hello world!''</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Relators›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"rel_fun <span class="main">(=)</span> <span class="main">(≤)</span> <span class="main">(</span>const <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(⊆)</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">{}</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>map set <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_nf</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> Some <span class="free">a</span> <span class="main">⟹</span> rel_option <span class="main">(≤)</span> <span class="main">(</span>map_option <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">a</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>map_option Suc <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">applicative_lifting</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">schematic_goal</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">g</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> rel_sum <span class="var">?R</span> <span class="main">(=)</span> <span class="main">(</span>ap_either <span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>ap_either <span class="main">(</span>ap_either <span class="main">(</span>Inl <span class="bound">g</span><span class="main">)</span> <span class="bound">f</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">applicative_lifting</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> <span class="quoted"><span class="quoted">"stream_all2 <span class="var">?R</span> <span class="main">(</span><span class="var">?f</span> <span class="main">⋄</span> <span class="main">(</span>pure <span class="var">?g</span> <span class="main">⋄</span> <span class="var">?x</span> <span class="main">+</span> <span class="var">?y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="var">?x</span> <span class="main">+</span> <span class="var">?z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">applicative_lifting</span>
<span class="keyword1"><span class="command">oops</span></span>


<span class="keyword1"><span class="command">print_applicative</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>