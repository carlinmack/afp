<div id="Applicative">
<div class="head"><h1>Theory Applicative</h1>
<span class="command">theory</span> <span class="name">Applicative</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lifting with applicative functors›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">keywords</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"applicative"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>thy_goal</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"print_applicative"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>diag</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Equality restricted to a set›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eq_on</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a ⇒ 'a ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_on A = (λx y. x ∈ A ∧ x = y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_fun_eq_onI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀x. x ∈ A ⟹ R (f x) (g x)) ⟹ rel_fun (eq_on A) R f g"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proof automation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arg1_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y ⟹ f x z = f y z"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UNIV_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ UNIV ⟹ P ⟹ P"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>combinator_unfold</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>combinator_repr</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B g f x ≡ g (f x)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C f x y ≡ f y x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I x ≡ x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K x y ≡ x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S f g x ≡ (f x) (g x)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T x f ≡ f x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"W f x ≡ f x x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">,</span><span> </span><span>combinator_unfold</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>B_def</span><span> </span><span>C_def</span><span> </span><span>I_def</span><span> </span><span>K_def</span><span> </span><span>S_def</span><span> </span><span>T_def</span><span> </span><span>W_def</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>combinator_repr</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>combinator_unfold</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cpair ≡ Pair"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cuncurry ≡ case_prod"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncurry_pair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cuncurry f (cpair x y) = f x y"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cpair_def</span><span> </span><span>cuncurry_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"applicative.ML"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">local_setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Applicative.setup_combinators
 [("B", @{thm B_def}),
  ("C", @{thm C_def}),
  ("I", @{thm I_def}),
  ("K", @{thm K_def}),
  ("S", @{thm S_def}),
  ("T", @{thm T_def}),
  ("W", @{thm W_def})]›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>combinator_eq</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Scan.lift (Scan.option (Args.$$$ "weak" |--
    Scan.optional (Args.colon |-- Scan.repeat1 Args.name) []) &gt;&gt;
    Applicative.combinator_rule_attrib)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>combinator_eq</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ≡ S (K S) K"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>combinator_unfold</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>combinator_eq</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≡ S (S (K (S (K S) K)) S) (K K)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>combinator_unfold</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>combinator_eq</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≡ W K"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>combinator_unfold</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>combinator_eq</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≡ C K ()"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>combinator_unfold</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>combinator_eq</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ≡ B (B W) (B B C)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>combinator_unfold</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>combinator_eq</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"T ≡ C I"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>combinator_unfold</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>combinator_eq</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"W ≡ S S (S K)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>combinator_unfold</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>combinator_eq</span><span> </span><span>weak</span><span class="delimiter">:</span><span> </span><span>C</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"C ≡ C (B B (B B (B W (C (B C (B (B B) (C B (cuncurry (K I))))) (cuncurry K))))) cpair"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>combinator_unfold</span><span> </span><span>uncurry_pair</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>applicative_unfold</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Applicative.parse_opt_afun &gt;&gt; (fn opt_af =&gt; fn ctxt =&gt;
    SIMPLE_METHOD' (Applicative.unfold_wrapper_tac ctxt opt_af))›</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"unfold into an applicative expression"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>applicative_fold</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Applicative.parse_opt_afun &gt;&gt; (fn opt_af =&gt; fn ctxt =&gt;
    SIMPLE_METHOD' (Applicative.fold_wrapper_tac ctxt opt_af))›</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fold an applicative expression"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>applicative_nf</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Applicative.parse_opt_afun &gt;&gt; (fn opt_af =&gt; fn ctxt =&gt;
    SIMPLE_METHOD' (Applicative.normalize_wrapper_tac ctxt opt_af))›</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prove an equation that has been lifted to an applicative functor, using normal forms"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>applicative_lifting</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Applicative.parse_opt_afun &gt;&gt; (fn opt_af =&gt; fn ctxt =&gt;
    SIMPLE_METHOD' (Applicative.lifting_wrapper_tac ctxt opt_af))›</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prove an equation that has been lifted to an applicative functor"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Outer_Syntax.local_theory_to_proof @{command_keyword "applicative"}
  "register applicative functors"
  (Parse.binding --
    Scan.optional (@{keyword "("} |-- Parse.list Parse.short_ident --| @{keyword ")"}) [] --
    (@{keyword "for"} |-- Parse.reserved "pure" |-- @{keyword ":"} |-- Parse.term) --
    (Parse.reserved "ap" |-- @{keyword ":"} |-- Parse.term) --
    Scan.option (Parse.reserved "rel" |-- @{keyword ":"} |-- Parse.term) --
    Scan.option (Parse.reserved "set" |-- @{keyword ":"} |-- Parse.term) &gt;&gt;
    Applicative.applicative_cmd)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Outer_Syntax.command @{command_keyword "print_applicative"}
  "print registered applicative functors"
  (Scan.succeed (Toplevel.keep (Applicative.print_afuns o Toplevel.context_of)))›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>applicative_unfold</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Scan.lift (Scan.option Parse.name &gt;&gt; Applicative.add_unfold_attrib)›</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"register rules for unfolding into applicative expressions"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>applicative_lifted</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Scan.lift (Parse.name &gt;&gt; Applicative.forward_lift_attrib)›</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lift an equation to an applicative functor"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Overloaded applicative operators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>
</span><span>  </span><span>pure</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b"</span></span></span><span>
</span><span>  </span><span>ap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b ⇒ 'c"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">bundle</span></span><span> </span><span>applicative_syntax</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>ap</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋄"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>ap</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Environment">
<div class="head"><h1>Theory Applicative_Environment</h1>
<span class="command">theory</span> <span class="name">Applicative_Environment</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="../../HOL/HOL-Probability/Adhoc_Overloading.html"><span class="name">Adhoc_Overloading</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Common applicative functors›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Environment functor›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Environment</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Adhoc_Overloading"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"const x = (λ_. x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"apf x y = (λz. x z (y z))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>const</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>apf</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The declaration below demonstrates that applicative functors which lift the reductions
  for combinators K and W also lift C. However, the interchange law must be supplied in this case.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>env</span><span> </span><span class="delimiter">(</span><span>K</span><span class="delimiter">,</span><span> </span><span>W</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>const</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>apf</span><span>
</span><span>  </span><span>rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_fun (=)"</span></span></span><span>
</span><span>  </span><span>set</span><span class="delimiter">:</span><span> </span><span>range</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>const_def</span><span> </span><span>apf_def</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"const (λf x y. f y x) ⋄ f ⋄ x ⋄ y = f ⋄ y ⋄ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Option">
<div class="head"><h1>Theory Applicative_Option</h1>
<span class="command">theory</span> <span class="name">Applicative_Option</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="../../HOL/HOL-Probability/Adhoc_Overloading.html"><span class="name">Adhoc_Overloading</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Option›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Option</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Adhoc_Overloading"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ap_option</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) option ⇒ 'a option ⇒ 'b option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ap_option (Some f) (Some x) = Some (f x)"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_option _ _ = None"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>pure_option</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_option ≡ Some"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>pure_option</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_option</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>some_ap_option</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_option (Some f) x = map_option f x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_some_option</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_option f (Some x) = map_option (λg. g x) f"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>f</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_option_transfer</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_fun (rel_option (rel_fun A B)) (rel_fun (rel_option A) (rel_option B)) ap_option ap_option"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>option.rel_cases</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>option</span><span> </span><span class="delimiter">(</span><span>C</span><span class="delimiter">,</span><span> </span><span>W</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>Some</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_option</span><span>
</span><span>  </span><span>rel</span><span class="delimiter">:</span><span> </span><span>rel_option</span><span>
</span><span>  </span><span>set</span><span class="delimiter">:</span><span> </span><span>set_option</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">include</span></span><span> </span><span>applicative_syntax</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a option"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure (λx. x) ⋄ x = x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'c) option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure (λg f x. g (f x)) ⋄ g ⋄ f ⋄ x = g ⋄ (f ⋄ x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>option.exhaust</span><span class="delimiter">[</span><span>case_product</span><span> </span><span>option.exhaust</span><span class="delimiter">,</span><span> </span><span>case_product</span><span> </span><span>option.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'a ⇒ 'c) option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure (λf x y. f y x) ⋄ f ⋄ x ⋄ y = f ⋄ y ⋄ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>option.exhaust</span><span class="delimiter">[</span><span>case_product</span><span> </span><span>option.exhaust</span><span class="delimiter">,</span><span> </span><span>case_product</span><span> </span><span>option.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a ⇒ 'b) option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure (λf x. f x x) ⋄ f ⋄ x = f ⋄ x ⋄ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>option.exhaust</span><span class="delimiter">[</span><span>case_product</span><span> </span><span>option.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b ⇒ bool"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_fun R (rel_option R) pure pure"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'c) option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_option (rel_fun (eq_on (set_option x)) R) f g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_option (eq_on (set_option x)) x x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>option.rel_refl_strong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_option R (f ⋄ x) (g ⋄ x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>some_ap_option</span><span> </span><span>ap_some_option</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_option_ap_conv</span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_option f x = ap_option (pure f) x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>option.exhaust</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>pure_option</span><span> </span><span class="comment">― ‹We do not want to print all occurrences of @{const "Some"} as @{const "pure"}›</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Sum">
<div class="head"><h1>Theory Applicative_Sum</h1>
<span class="command">theory</span> <span class="name">Applicative_Sum</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="../../HOL/HOL-Probability/Adhoc_Overloading.html"><span class="name">Adhoc_Overloading</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sum types›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Sum</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Adhoc_Overloading"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  There are several ways to define an applicative functor based on sum types. First, we can choose
  whether the left or the right type is fixed. Both cases are isomorphic, of course. Next, what
  should happen if two values of the fixed type are combined? The corresponding operator must be
  associative, or the idiom laws don't hold true.

  We focus on the cases where the right type is fixed. We define two concrete functors: One based
  on Haskell's \textsf{Either} datatype, which prefers the value of the left operand, and a generic
  one using the @{class semigroup_add} class. Only the former lifts the \textbf{W} combinator,
  though.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ap_sum</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e ⇒ 'e ⇒ 'e) ⇒ ('a ⇒ 'b) + 'e ⇒ 'a + 'e ⇒ 'b + 'e"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ap_sum _ (Inl f) (Inl x) = Inl (f x)"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_sum _ (Inl _) (Inr e) = Inr e"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_sum _ (Inr e) (Inl _) = Inr e"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_sum c (Inr e1) (Inr e2) = Inr (c e1 e2)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_either ≡ ap_sum (λx _. x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_plus ≡ ap_sum (plus :: 'a :: semigroup_add ⇒ _)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>pure_sum</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_sum ≡ Inl"</span></span></span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>pure_sum</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_either</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ap_plus *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_sum_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_sum c (Inl id) x = x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_sum_ichng</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_sum c f (Inl x) = ap_sum c (Inl (λf. f x)) f"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>f</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>semigroup</span><span class="delimiter">)</span><span> </span><span>ap_sum_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ap_sum f (ap_sum f (ap_sum f (Inl (o)) h) g) x = ap_sum f h (ap_sum f g x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>h</span><span> </span><span>g</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sum.exhaust</span><span class="delimiter">[</span><span>case_product</span><span> </span><span>sum.exhaust</span><span class="delimiter">,</span><span> </span><span>case_product</span><span> </span><span>sum.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>semigroup_const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"semigroup (λx y. x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>either_af</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>B</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b ⇒ 'b ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>B_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reflp B"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>either</span><span> </span><span class="delimiter">(</span><span>W</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>Inl</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_either</span><span>
</span><span>  </span><span>rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λA. rel_sum A B"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">include</span></span><span> </span><span>applicative_syntax</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('c ⇒ 'c ⇒ 'd) + 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure (λf x. f x x) ⋄ f ⋄ x = f ⋄ x ⋄ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sum.exhaust</span><span class="delimiter">[</span><span>case_product</span><span> </span><span>sum.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>semigroup</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx y. x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>semigroup_const</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('d ⇒ 'e) + 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('c ⇒ 'd) + 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure (λg f x. g (f x)) ⋄ g ⋄ f ⋄ x = g ⋄ (f ⋄ x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ap_sum_comp</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>comp_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('c ⇒ 'd) + 'b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('c ⇒ 'e) + 'b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_sum (rel_fun (eq_on UNIV) R) B f g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_sum R B (f ⋄ x) (g ⋄ x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sum.exhaust</span><span class="delimiter">[</span><span>case_product</span><span> </span><span>sum.exhaust</span><span class="delimiter">,</span><span> </span><span>case_product</span><span> </span><span>sum.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>B_refl</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>reflpD</span><span class="delimiter">]</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rel_funE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ap_sum_id</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>id_def</span><span class="delimiter">]</span><span> </span><span>ap_sum_ichng</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* locale *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>either_af</span><span> </span><span class="string"><span class="delete"><span class="delete">"(=)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>semigroup_sum</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>Inl</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_plus</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span>
</span><span>  </span><span>ap_sum_id</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>id_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span>ap_sum_ichng</span><span>
</span><span>  </span><span>add.ap_sum_comp</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>comp_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>pure_sum</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Set">
<div class="head"><h1>Theory Applicative_Set</h1>
<span class="command">theory</span> <span class="name">Applicative_Set</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="../../HOL/HOL-Probability/Adhoc_Overloading.html"><span class="name">Adhoc_Overloading</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Set with Cartesian product›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Set</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Adhoc_Overloading"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ap_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) set ⇒ 'a set ⇒ 'b set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_set F X = {f x | f x. f ∈ F ∧ x ∈ X}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_set</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_set_transfer</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_fun (rel_set (rel_fun A B)) (rel_fun (rel_set A) (rel_set B)) ap_set ap_set"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_set_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>rel_set_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rel_funE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>set</span><span> </span><span class="delimiter">(</span><span>C</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. {x}"</span></span></span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_set</span><span>
</span><span>  </span><span>rel</span><span class="delimiter">:</span><span> </span><span>rel_set</span><span>
</span><span>  </span><span>set</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_fun R (rel_set R) (λx. {x}) (λx. {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rel_setI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'c) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_set (rel_fun (eq_on x) R) f g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_set (eq_on x) x x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rel_setI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_set R (ap_set f x) (ap_set g x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>ap_set_def</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_List">
<div class="head"><h1>Theory Applicative_List</h1>
<span class="command">theory</span> <span class="name">Applicative_List</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="../../HOL/HOL-Probability/Adhoc_Overloading.html"><span class="name">Adhoc_Overloading</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lists›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_List</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Adhoc_Overloading"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_list fs xs = List.bind fs (λf. List.bind xs (λx. [f x]))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_list</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nil_ap</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_list [] xs = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_list fs [] = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>fs</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_list_transfer</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_fun (list_all2 (rel_fun A B)) (rel_fun (list_all2 A) (list_all2 B)) ap_list ap_list"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_list_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>List.bind_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cons_ap_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f # fs) ⋄ xs = map f xs @ fs ⋄ xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>append_ap_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fs @ gs) ⋄ xs = fs ⋄ xs @ gs ⋄ xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>fs</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>list</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. [x]"</span></span></span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_list</span><span>
</span><span>  </span><span>rel</span><span class="delimiter">:</span><span> </span><span>list_all2</span><span>
</span><span>  </span><span>set</span><span class="delimiter">:</span><span> </span><span>set</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[λx. x] ⋄ x = x"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'c) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?B</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λg f x. g (f x)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[?B] ⋄ g ⋄ f ⋄ x = g ⋄ (f ⋄ x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>g</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>g</span><span> </span><span>gs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[?B g] ⋄ f ⋄ x = [g] ⋄ (f ⋄ x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>f</span><span> </span><span>fs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[?B g] ⋄ (f # fs) ⋄ x = [g] ⋄ ([f] ⋄ x) @ [?B g] ⋄ fs ⋄ x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cons_ap_list</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = [g] ⋄ ([f] ⋄ x) @ [g] ⋄ (fs ⋄ x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.IH</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = [g] ⋄ ((f # fs) ⋄ x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cons_ap_list</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[?B] ⋄ (g # gs) ⋄ f ⋄ x = [?B g] ⋄ f ⋄ x @ [?B] ⋄ gs ⋄ f ⋄ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cons_ap_list</span><span> </span><span>append_ap_distrib</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = [g] ⋄ (f ⋄ x) @ gs ⋄ (f ⋄ x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_comp</span><span> </span><span>Cons.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (g # gs) ⋄ (f ⋄ x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cons_ap_list</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ⋄ [x] = [λf. f x] ⋄ f"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_fun R (list_all2 R) (λx. [x]) (λx. [x])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'c) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 (rel_fun (eq_on (set x)) R) f g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 (eq_on (set x)) x x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_all2_same</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 R (f ⋄ x) (g ⋄ x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cons_ap_list</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_ap_conv</span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map f x = [f] ⋄ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_list_def</span><span> </span><span>List.bind_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_DNEList">
<div class="head"><h1>Theory Applicative_DNEList</h1>
<span class="command">theory</span> <span class="name">Applicative_DNEList</span><br/>
<span class="keyword">imports</span> <a href="Applicative_List.html"><span class="name">Applicative_List</span></a> <a href="Dlist.html"><span class="name">Dlist</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Distinct, non-empty list›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_DNEList</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative_List</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Dlist"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_eq_Nil_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"List.bind xs f = [] ⟷ (∀x∈set xs. f x = [])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>List.bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zip_eq_Nil_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"zip xs ys = [] ⟷ xs = [] ∨ ys = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list.exhaust</span><span class="delimiter">[</span><span>case_product</span><span> </span><span>list.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remdups_append1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups (remdups xs @ ys) = remdups (xs @ ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remdups_append2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups (xs @ remdups ys) = remdups (xs @ ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remdups_append1_drop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set xs ⊆ set ys ⟹ remdups (xs @ ys) = remdups ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remdups_concat_map</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups (concat (map remdups xss)) = remdups (concat xss)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xss</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>remdups_append1</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>remdups_append2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remdups_concat_remdups</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups (concat (remdups xss)) = remdups (concat xss)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xss</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>remdups_append1_drop</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>remdups_append1_drop</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>metis</span><span> </span><span>remdups_append2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remdups_replicate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups (replicate n x) = (if n = 0 then [] else [x])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="tfree">'a</span><span> </span><span>dnelist</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{xs::'a list. distinct xs ∧ xs ≠ []}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">morphisms</span></span><span> </span><span>list_of_dnelist</span><span> </span><span>Abs_dnelist</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[x] ∈ ?dnelist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_dnelist</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dnelist_subtype_dlist</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"type_definition (λx. Dlist (list_of_dnelist x)) (λx. Abs_dnelist (list_of_dlist x)) {xs. xs ≠ Dlist.empty}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dlist_eq_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>distinct_remdups_id</span><span> </span><span>dnelist.list_of_dnelist</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>list_of_dnelist_inverse</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dlist_eq_iff</span><span> </span><span>Abs_dnelist_inverse</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_bnf</span></span><span> </span><span class="delimiter">(</span><span>no_warn_transfer</span><span class="delimiter">,</span><span> </span><span>no_warn_wits</span><span class="delimiter">)</span><span> </span><span class="tfree">'a</span><span> </span><span>dnelist</span><span> </span><span>via</span><span> </span><span>dnelist_subtype_dlist</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>map</span><span class="delimiter">:</span><span> </span><span>map</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dlist_eq_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>map</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword2"><span class="keyword">qualified</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Applicative_DNEList.map = map_fun id (map_fun list_of_dnelist Abs_dnelist) (λf xs. remdups (list.map f xs))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>map_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>distinct_remdups_id</span><span> </span><span>list_of_dnelist</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">qualified</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_transfer</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_fun (=) (rel_fun (pcr_dnelist (=)) (pcr_dnelist (=))) (λf xs. remdups (map f xs)) Applicative_DNEList.map"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_def</span><span> </span><span>rel_fun_def</span><span> </span><span>dnelist.pcr_cr_eq</span><span> </span><span>cr_dnelist_def</span><span> </span><span>list_of_dnelist</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>Abs_dnelist_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">qualified</span></span><span> </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>single</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a dnelist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. [x]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword2"><span class="keyword">qualified</span></span><span> </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>insert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a dnelist ⇒ 'a dnelist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λx xs. if x ∈ set xs then xs else x # xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword2"><span class="keyword">qualified</span></span><span> </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>append</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dnelist ⇒ 'a dnelist ⇒ 'a dnelist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λxs ys. remdups (xs @ ys)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword2"><span class="keyword">qualified</span></span><span> </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>bind</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dnelist ⇒ ('a ⇒ 'b dnelist) ⇒ 'b dnelist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λxs f. remdups (List.bind xs f)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>pure_dnelist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a dnelist"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_dnelist ≡ single"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>ap_dnelist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) dnelist ⇒ 'a dnelist ⇒ 'b dnelist"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λf x. remdups (ap_list f x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_list_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_dnelist</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_pure_list</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_list [f] xs = map f xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_list_def</span><span> </span><span>List.bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_pure_dlist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_dnelist f ⋄ x = Applicative_DNEList.map f x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>dnelist</span><span> </span><span class="delimiter">(</span><span>K</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pure</span><span class="delimiter">:</span><span> </span><span>pure_dnelist</span><span>
</span><span>    </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_dnelist</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_dnelist (λx. x) ⋄ x = x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dnelist"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups (remdups (remdups ([λg f x. g (f x)] ⋄ g) ⋄ f) ⋄ x) = remdups (g ⋄ remdups (f ⋄ x))"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'c) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = remdups (concat (map (λf. map f x) (remdups (concat (map (λx. map (λf y. x (f y)) f) g)))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_list_def</span><span> </span><span>List.bind_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>remdups_concat_remdups</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>remdups_map_remdups</span><span> </span><span>remdups_concat_remdups</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… =  remdups (concat (map (λf. map f x) (concat (map (λx. map (λf y. x (f y)) f) g))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>remdups_concat_remdups</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>remdups_map_remdups</span><span> </span><span>remdups_concat_remdups</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = remdups (concat (map remdups (map (λg. map g (concat (map (λf. map f x) f))) g)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list.pure_B_conv</span><span class="delimiter">[</span><span>of</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remdups_concat_map</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_list_def</span><span> </span><span>List.bind_def</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_list_def</span><span> </span><span>List.bind_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>remdups_concat_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>remdups_map_remdups</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_dnelist (λg f x. g (f x)) ⋄ g ⋄ f ⋄ x = g ⋄ (f ⋄ x)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'c) dnelist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) dnelist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>rule</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_dnelist f ⋄ pure_dnelist x = pure_dnelist (f x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ⋄ pure_dnelist x = pure_dnelist (λf. f x) ⋄ f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) dnelist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list.interchange</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups (remdups ([λx y. x] ⋄ x) ⋄ y) = x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≠ []"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups (map (λ(x :: 'b) (y :: 'a). x) x) = map (λ(x :: 'b) (y :: 'a). x) x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>distinct_map</span><span> </span><span>inj_on_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups (remdups ([λx y. x] ⋄ x) ⋄ y) = remdups (concat (map (λf. map f y) (map (λx y. x) x)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_list_def</span><span> </span><span>List.bind_def</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>remdups_id_iff_distinct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>map_replicate_const</span><span class="delimiter">)</span><span class="delimiter">(</span><span>subst</span><span> </span><span>remdups_concat_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>remdups_replicate</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_dnelist (λx y. x) ⋄ x ⋄ y = x"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b dnelist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dnelist"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>rule</span><span> </span><span>*</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹@{typ "_ dnelist"} does not have combinator C, so it cannot have W either.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int dnelist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[2,3]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int dnelist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[5,7]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_dnelist (λf x y. f y x) ⋄ pure_dnelist ((*)) ⋄ x ⋄ y ≠ pure_dnelist ((*)) ⋄ y ⋄ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_list_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Monoid">
<div class="head"><h1>Theory Applicative_Monoid</h1>
<span class="command">theory</span> <span class="name">Applicative_Monoid</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="../../HOL/HOL-Probability/Adhoc_Overloading.html"><span class="name">Adhoc_Overloading</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Monoid›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Monoid</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Adhoc_Overloading"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>monoid_ap</span><span> </span><span class="delimiter">=</span><span> </span><span>Monoid_ap</span><span> </span><span class="tfree">'a</span><span> </span><span class="tfree">'b</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>zero</span><span class="delimiter">)</span><span> </span><span>pure_monoid_add</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b ⇒ ('a, 'b) monoid_ap"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_monoid_add = Monoid_ap 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>plus</span><span class="delimiter">)</span><span> </span><span>ap_monoid_add</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b ⇒ 'c) monoid_ap ⇒ ('a, 'b) monoid_ap ⇒ ('a, 'c) monoid_ap"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_monoid_add (Monoid_ap a1 f) (Monoid_ap a2 x) = Monoid_ap (a1 + a2) (f x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  fold Sign.add_const_constraint
   [(@{const_name pure_monoid_add}, SOME (@{typ "'b ⇒ ('a :: monoid_add, 'b) monoid_ap"})),
    (@{const_name ap_monoid_add}, SOME (@{typ "('a :: monoid_add, 'b ⇒ 'c) monoid_ap ⇒ ('a, 'b) monoid_ap ⇒ ('a, 'c) monoid_ap"}))]
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>pure_monoid_add</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_monoid_add</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>monoid_add</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pure</span><span class="delimiter">:</span><span> </span><span>pure_monoid_add</span><span>
</span><span>      </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_monoid_add</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_monoid_add_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>monoid_ap.exhaust</span><span class="delimiter">[</span><span>case_product</span><span> </span><span>monoid_ap.exhaust</span><span class="delimiter">,</span><span> </span><span>case_product</span><span> </span><span>monoid_ap.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_monoid_add_def</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_monoid_add_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>f</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_monoid_add_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>comm_monoid_add</span><span> </span><span class="delimiter">(</span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_monoid_add :: _ ⇒ (_ :: comm_monoid_add, _) monoid_ap"</span></span></span><span>
</span><span>      </span><span>ap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_monoid_add :: (_ :: comm_monoid_add, _) monoid_ap ⇒ _"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>monoid_add.homomorphism</span><span> </span><span>monoid_add.pure_B_conv</span><span> </span><span>monoid_add.interchange</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>monoid_ap.exhaust</span><span class="delimiter">[</span><span>case_product</span><span> </span><span>monoid_ap.exhaust</span><span class="delimiter">,</span><span> </span><span>case_product</span><span> </span><span>monoid_ap.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_monoid_add_def</span><span> </span><span>add_ac</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>monoid_add.pure_I_conv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>idemp_monoid_add</span><span> </span><span class="delimiter">=</span><span> </span><span>monoid_add</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>add_idemp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x + x = x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>idemp_monoid_add</span><span> </span><span class="delimiter">(</span><span>W</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_monoid_add :: _ ⇒ (_ :: idemp_monoid_add, _) monoid_ap"</span></span></span><span>
</span><span>      </span><span>ap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_monoid_add :: (_ :: idemp_monoid_add, _) monoid_ap ⇒ _"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>monoid_add.homomorphism</span><span> </span><span>monoid_add.pure_B_conv</span><span> </span><span>monoid_add.pure_I_conv</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>monoid_ap.exhaust</span><span class="delimiter">[</span><span>case_product</span><span> </span><span>monoid_ap.exhaust</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_monoid_add_def</span><span> </span><span>add.assoc</span><span> </span><span>add_idemp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>monoid_add.interchange</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Test case›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_monoid_add (+) ⋄ (x :: (nat, int) monoid_ap) ⋄ y = pure (+) ⋄ y ⋄ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>applicative_lifting</span><span> </span><span>comm_monoid_add</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Filter">
<div class="head"><h1>Theory Applicative_Filter</h1>
<span class="command">theory</span> <span class="name">Applicative_Filter</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Complex_Main.html"><span class="name">Complex_Main</span></a> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="../../HOL/HOL-Probability/Conditional_Parametricity.html"><span class="name">Conditional_Parametricity</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, Digital Asset *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Filters›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Filter</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Complex_Main</span><span>
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Conditional_Parametricity"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pure_filter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a filter"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pure_filter x = principal {x}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ap_filter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) filter ⇒ 'a filter ⇒ 'b filter"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ap_filter F X = filtermap (λ(f, x). f x) (prod_filter F X)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_on_UNIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_on UNIV = (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>filtermap_parametric</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>pure_filter_parametric</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>pure_filter_def</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>ap_filter_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>ap_filter_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>filter</span><span> </span><span class="delimiter">(</span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment">― ‹K is available for not-@{term bot} filters and W isholds not available›</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> 
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_filter"</span></span></span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_filter"</span></span></span><span>
</span><span>  </span><span>rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_filter"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_filter (pure_filter f) (pure_filter x) = pure_filter (f x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_filter_def</span><span> </span><span>pure_filter_def</span><span> </span><span>principal_prod_principal</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_filter (ap_filter (ap_filter (pure_filter (λg f x. g (f x))) g) f) x =
    ap_filter g (ap_filter f x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) filter"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'c) filter"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_filter_def</span><span> </span><span>pure_filter_def</span><span> </span><span>filtermap_filtermap</span><span> </span><span>prod_filtermap1</span><span> </span><span>prod_filtermap2</span><span> </span><span>apfst_def</span><span> </span><span>case_prod_map_prod</span><span> </span><span>prod_filter_assoc</span><span> </span><span>prod_filter_principal_singleton</span><span> </span><span>split_beta</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_filter (pure_filter (λx. x)) x = x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a filter"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_filter_def</span><span> </span><span>pure_filter_def</span><span> </span><span>prod_filter_principal_singleton</span><span> </span><span>filtermap_filtermap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_filter (ap_filter (ap_filter (pure_filter (λf x y. f y x)) f) x) y =
    ap_filter (ap_filter f y) x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'a ⇒ 'c) filter"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_filter_def</span><span> </span><span>pure_filter_def</span><span> </span><span>filtermap_filtermap</span><span> </span><span>prod_filter_principal_singleton2</span><span> </span><span>prod_filter_principal_singleton</span><span> </span><span>prod_filtermap1</span><span> </span><span>prod_filtermap2</span><span> </span><span>prod_filter_assoc</span><span> </span><span>split_beta</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>prod_filter_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>filtermap_filtermap</span><span> </span><span>prod_filtermap1</span><span> </span><span>prod_filtermap2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_fun R (rel_filter R) pure_filter pure_filter"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b ⇒ bool"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>pure_filter_parametric</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_filter R (ap_filter f x) (ap_filter g x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_filter (rel_fun (eq_on UNIV) R) f g"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) filter"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'c) filter"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>that</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>eq_on_UNIV</span><span class="delimiter">,</span><span> </span><span>transfer_rule</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Applicative_State">
<div class="head"><h1>Theory Applicative_State</h1>
<span class="command">theory</span> <span class="name">Applicative_State</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="State_Monad.html"><span class="name">State_Monad</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Lars Hupel, TU München *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹State monad›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_State</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.State_Monad"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>state</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>State_Monad.return</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>State_Monad.ap</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>State_Monad.return_def</span><span> </span><span>State_Monad.ap_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Stream">
<div class="head"><h1>Theory Applicative_Stream</h1>
<span class="command">theory</span> <span class="name">Applicative_Stream</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="../../HOL/HOL-Probability/Stream.html"><span class="name">Stream</span></a> <a href="../../HOL/HOL-Probability/Adhoc_Overloading.html"><span class="name">Adhoc_Overloading</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author:     Andreas Lochbihler, ETH Zurich
   Author:     Joshua Schneider, ETH Zurich
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Streams as an applicative functor›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Stream</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Stream"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Adhoc_Overloading"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span> </span><span>ap_stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) stream ⇒ 'a stream ⇒ 'b stream"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"shd (ap_stream f x) = shd f (shd x)"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"stl (ap_stream f x) = ap_stream (stl f) (stl x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>sconst</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_stream</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span>applicative_syntax</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_stream_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure (λx. x) ⋄ x = x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_stream_homo</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure f ⋄ pure x = pure (f x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_stream_interchange</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ⋄ pure x = pure (λf. f x) ⋄ f"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>f</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_stream_composition</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure (λg f x. g (f x)) ⋄ g ⋄ f ⋄ x = g ⋄ (f ⋄ x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">(</span><span>S</span><span class="delimiter">,</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>sconst</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_stream</span><span>
</span><span>  </span><span>rel</span><span class="delimiter">:</span><span> </span><span>stream_all2</span><span>
</span><span>  </span><span>set</span><span class="delimiter">:</span><span> </span><span>sset</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'a ⇒ 'c) stream"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure (λg f x. g x (f x)) ⋄ g ⋄ f ⋄ x = g ⋄ x ⋄ (f ⋄ x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b stream"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a stream"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure (λx y. x) ⋄ x ⋄ y = x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(R ===&gt; stream_all2 R) pure pure"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R x y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stream_all2 R (pure x) (pure y)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>coinduction</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) stream"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'c) stream"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stream_all2 (eq_on (sset x) ===&gt; R) f g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stream_all2 (eq_on (sset x)) x x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stream.rel_refl_strong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stream_all2 R (f ⋄ x) (g ⋄ x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ap_stream_homo</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>smap_applicative</span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"smap f x = pure f ⋄ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_stream_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>smap2_applicative</span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"smap2 f x y = pure f ⋄ x ⋄ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_stream_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Open_State">
<div class="head"><h1>Theory Applicative_Open_State</h1>
<span class="command">theory</span> <span class="name">Applicative_Open_State</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="../../HOL/HOL-Probability/Adhoc_Overloading.html"><span class="name">Adhoc_Overloading</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Open state monad›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Open_State</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Adhoc_Overloading"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'s</span><span class="delimiter">)</span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ 'a × 's"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_state f x = (λs. case f s of (g, s') ⇒ case x s' of (y, s'') ⇒ (g y, s''))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_state ≡ Pair"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_state</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>state</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>pure_state</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_state :: ('a ⇒ 'b, 's) state ⇒ ('a, 's) state ⇒ ('b, 's) state"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_state_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_PMF">
<div class="head"><h1>Theory Applicative_PMF</h1>
<span class="command">theory</span> <span class="name">Applicative_PMF</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="../../HOL/HOL-Probability/Probability.html"><span class="name">Probability</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Probability mass functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_PMF</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Probability.Probability"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Adhoc_Overloading"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>pure_pmf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a pmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_pmf ≡ return_pmf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ap_pmf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) pmf ⇒ 'a pmf ⇒ 'b pmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_pmf f x = map_pmf (λ(f, x). f x) (pair_pmf f x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_pmf</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_pmf_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_pmf (λx. x) ⋄ x = x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_pmf_def</span><span> </span><span>pair_return_pmf1</span><span> </span><span>pmf.map_comp</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_pmf_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_pmf (∘) ⋄ u ⋄ v ⋄ w = u ⋄ (v ⋄ w)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_pmf_def</span><span> </span><span>pair_return_pmf1</span><span> </span><span>pair_map_pmf1</span><span> </span><span>pair_map_pmf2</span><span> </span><span>pmf.map_comp</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>pair_pair_pmf</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_pmf_homo</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_pmf f ⋄ pure_pmf x = pure_pmf (f x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_pmf_def</span><span> </span><span>pair_return_pmf1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_pmf_interchange</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ⋄ pure_pmf x = pure_pmf (λf. f x) ⋄ u"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_pmf_def</span><span> </span><span>pair_return_pmf1</span><span> </span><span>pair_return_pmf2</span><span> </span><span>pmf.map_comp</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_pmf_K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"return_pmf (λx _. x) ⋄ x ⋄ y = x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_pmf_def</span><span> </span><span>pair_map_pmf1</span><span> </span><span>pmf.map_comp</span><span> </span><span>pair_return_pmf1</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>map_fst_pair_pmf</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_pmf_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"return_pmf (λf x y. f y x) ⋄ f ⋄ x ⋄ y = f ⋄ y ⋄ x"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_pmf_def</span><span> </span><span>pair_map_pmf1</span><span> </span><span>pmf.map_comp</span><span> </span><span>pair_return_pmf1</span><span> </span><span>pair_pair_pmf</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>pair_commute_pmf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pair_map_pmf2</span><span> </span><span>pmf.map_comp</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_pmf_transfer</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_fun (rel_pmf (rel_fun A B)) (rel_fun (rel_pmf A) (rel_pmf B)) ap_pmf ap_pmf"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_pmf_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>pair_pmf_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>pmf</span><span> </span><span class="delimiter">(</span><span>C</span><span class="delimiter">,</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>pure_pmf</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_pmf</span><span>
</span><span>  </span><span>rel</span><span class="delimiter">:</span><span> </span><span>rel_pmf</span><span>
</span><span>  </span><span>set</span><span class="delimiter">:</span><span> </span><span>set_pmf</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_fun R (rel_pmf R) pure_pmf pure_pmf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) pmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'c) pmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_pmf (rel_fun (eq_on (set_pmf x)) R) f g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_pmf (eq_on (set_pmf x)) x x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pmf.rel_refl_strong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_pmf R (ap_pmf f x) (ap_pmf g x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ap_pmf_comp</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>o_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>ap_pmf_homo</span><span> </span><span>ap_pmf_C</span><span> </span><span>ap_pmf_K</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Probability_List">
<div class="head"><h1>Theory Applicative_Probability_List</h1>
<span class="command">theory</span> <span class="name">Applicative_Probability_List</span><br/>
<span class="keyword">imports</span> <a href="Applicative_List.html"><span class="name">Applicative_List</span></a> <a href="../../HOL/HOL/Complex_Main.html"><span class="name">Complex_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Probability mass functions implemented as lists with duplicates›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Probability_List</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative_List</span><span>
</span><span>  </span><span>Complex_Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_list_concat_map</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (concat (map f xs)) = sum_list (map (λx. sum_list (f x)) xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_ap_list</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (f ⋄ x) = (λ(f, x). f x) ` (set f × set x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_list_def</span><span> </span><span>List.bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We call the implementation type ‹pfp› because it is the basis for the Haskell library
  Probability by Martin Erwig and Steve Kollmansberger (Probabilistic Functional Programming).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="tfree">'a</span><span> </span><span>pfp</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{xs :: ('a × real) list. (∀(_, p) ∈ set xs. p &gt; 0) ∧ sum_list (map snd xs) = 1}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[(x, 1)] ∈ ?pfp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_pfp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>pure_pfp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a pfp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. [(x, 1)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>ap_pfp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) pfp ⇒ 'a pfp ⇒ 'b pfp"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λfs xs. [λ(f, p) (x, q). (f x, p * q)] ⋄ fs ⋄ xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a ⇒ 'b) × real) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × real) list"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(x, y) ∈ set xs. 0 &lt; y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map snd xs) = 1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ys</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(x, y) ∈ set ys. 0 &lt; y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map snd ys) = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ap</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[λ(f, p) (x, q). (f x, p * q)] ⋄ xs ⋄ ys"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, b) ∈ set ?ap"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>xs</span><span> </span><span>ys</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mult_pos_pos</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map snd ?ap) = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs</span><span> </span><span>ys</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_list_def</span><span> </span><span>List.bind_def</span><span> </span><span>map_concat</span><span> </span><span>o_def</span><span> </span><span>split_beta</span><span> </span><span>sum_list_concat_map</span><span> </span><span>sum_list_const_mult</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_pfp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>pfp</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pure</span><span class="delimiter">:</span><span> </span><span>pure_pfp</span><span>
</span><span>     </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_pfp</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_pfp (λx. x) ⋄ x = x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pfp"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_list_def</span><span> </span><span>List.bind_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_pfp f ⋄ pure_pfp x = pure_pfp (f x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_pfp (λg f x. g (f x)) ⋄ g ⋄ f ⋄ x = g ⋄ (f ⋄ x)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'c) pfp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) pfp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ⋄ pure_pfp x = pure_pfp (λf. f x) ⋄ f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) pfp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Star">
<div class="head"><h1>Theory Applicative_Star</h1>
<span class="command">theory</span> <span class="name">Applicative_Star</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="StarDef.html"><span class="name">StarDef</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ultrafilter›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Star</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Nonstandard_Analysis.StarDef"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>star</span><span> </span><span class="delimiter">(</span><span>C</span><span class="delimiter">,</span><span> </span><span>K</span><span class="delimiter">,</span><span> </span><span>W</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>star_of</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>Ifun</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"star_of f ⋆ star_of x = star_of (f x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>Ifun_star_of</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">;</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Vector">
<div class="head"><h1>Theory Applicative_Vector</h1>
<span class="command">theory</span> <span class="name">Applicative_Vector</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="../../HOL/HOL-Analysis/Finite_Cartesian_Product.html"><span class="name">Finite_Cartesian_Product</span></a> <a href="../../HOL/HOL-Probability/Adhoc_Overloading.html"><span class="name">Adhoc_Overloading</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Vector</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Analysis.Finite_Cartesian_Product"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Adhoc_Overloading"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pure_vec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('a, 'b :: finite) vec"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_vec x = (χ _ . x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ap_vec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b, 'c :: finite) vec ⇒ ('a, 'c) vec ⇒ ('b, 'c) vec"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_vec f x = (χ i. (f $ i) (x $ i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_vec</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>vec</span><span> </span><span class="delimiter">(</span><span>K</span><span class="delimiter">,</span><span> </span><span>W</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>pure_vec</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_vec</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_vec_def</span><span> </span><span>ap_vec_def</span><span> </span><span>vec_nth_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_vec_nth</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_vec x $ i = x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_vec_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_vec_nth</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_vec f x $ i  = (f $ i) (x $ i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_vec_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Functor">
<div class="head"><h1>Theory Applicative_Functor</h1>
<span class="command">theory</span> <span class="name">Applicative_Functor</span><br/>
<span class="keyword">imports</span> <a href="Applicative_Environment.html"><span class="name">Applicative_Environment</span></a> <a href="Applicative_Option.html"><span class="name">Applicative_Option</span></a> <a href="Applicative_Sum.html"><span class="name">Applicative_Sum</span></a> <a href="Applicative_Set.html"><span class="name">Applicative_Set</span></a> <a href="Applicative_DNEList.html"><span class="name">Applicative_DNEList</span></a> <a href="Applicative_Monoid.html"><span class="name">Applicative_Monoid</span></a> <a href="Applicative_Filter.html"><span class="name">Applicative_Filter</span></a> <a href="Applicative_State.html"><span class="name">Applicative_State</span></a> <a href="Applicative_Stream.html"><span class="name">Applicative_Stream</span></a> <a href="Applicative_Open_State.html"><span class="name">Applicative_Open_State</span></a> <a href="Applicative_PMF.html"><span class="name">Applicative_PMF</span></a> <a href="Applicative_Probability_List.html"><span class="name">Applicative_Probability_List</span></a> <a href="Applicative_Star.html"><span class="name">Applicative_Star</span></a> <a href="Applicative_Vector.html"><span class="name">Applicative_Vector</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich
   Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Functor</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative_Environment</span><span>
</span><span>  </span><span>Applicative_Option</span><span>
</span><span>  </span><span>Applicative_Sum</span><span>
</span><span>  </span><span>Applicative_Set</span><span>
</span><span>  </span><span>Applicative_List</span><span>
</span><span>  </span><span>Applicative_DNEList</span><span>
</span><span>  </span><span>Applicative_Monoid</span><span>
</span><span>  </span><span>Applicative_Filter</span><span>
</span><span>  </span><span>Applicative_State</span><span>
</span><span>  </span><span>Applicative_Stream</span><span>
</span><span>  </span><span>Applicative_Open_State</span><span>
</span><span>  </span><span>Applicative_PMF</span><span>
</span><span>  </span><span>Applicative_Probability_List</span><span>
</span><span>  </span><span>Applicative_Star</span><span>
</span><span>  </span><span>Applicative_Vector</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">print_applicative</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Environment_Algebra">
<div class="head"><h1>Theory Applicative_Environment_Algebra</h1>
<span class="command">theory</span> <span class="name">Applicative_Environment_Algebra</span><br/>
<span class="keyword">imports</span> <a href="Applicative_Environment.html"><span class="name">Applicative_Environment</span></a> <a href="Function_Division.html"><span class="name">Function_Division</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Examples of applicative lifting›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Algebraic operations for the environment functor›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Environment_Algebra</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative_Environment</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Function_Division"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Link between applicative instance of the environment functor with the pointwise operations
  for the algebraic type classes ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>plus_fun_af</span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f + g = pure (+) ⋄ f ⋄ g"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plus_fun_def</span><span> </span><span>const_def</span><span> </span><span>apf_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_fun_af</span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 = pure 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>zero_fun_def</span><span> </span><span>const_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>times_fun_af</span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f * g = pure (*) ⋄ f ⋄ g"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>times_fun_def</span><span> </span><span>const_def</span><span> </span><span>apf_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_fun_af</span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 = pure 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>one_fun_def</span><span> </span><span>const_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_nat_fun_af</span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_nat n = pure (of_nat n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>of_nat_fun</span><span> </span><span>const_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inverse_fun_af</span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inverse f = pure inverse ⋄ f"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inverse_fun_def</span><span> </span><span>o_def</span><span> </span><span>const_def</span><span> </span><span>apf_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>divide_fun_af</span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"divide f g = pure divide ⋄ f ⋄ g"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>divide_fun_def</span><span> </span><span>const_def</span><span> </span><span>apf_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Stream_Algebra">
<div class="head"><h1>Theory Stream_Algebra</h1>
<span class="command">theory</span> <span class="name">Stream_Algebra</span><br/>
<span class="keyword">imports</span> <a href="Applicative_Stream.html"><span class="name">Applicative_Stream</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author:     Andreas Lochbihler, ETH Zurich
   Author:     Joshua Schneider, ETH Zurich
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pointwise arithmetic on streams›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Stream_Algebra</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Applicative_Stream</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>zero</span><span class="delimiter">)</span><span> </span><span>zero</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 = sconst 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>one</span><span class="delimiter">)</span><span> </span><span>one</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 = sconst 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>plus</span><span class="delimiter">)</span><span> </span><span>plus</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x + y = pure (+) ⋄ x ⋄ (y :: 'a stream)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>minus</span><span class="delimiter">)</span><span> </span><span>minus</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x - y = pure (-) ⋄ x ⋄ (y :: 'a stream)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>uminus</span><span class="delimiter">)</span><span> </span><span>uminus</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span> </span><span>stream</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"uminus = ((⋄) (pure uminus) :: 'a stream ⇒ 'a stream)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>times</span><span class="delimiter">)</span><span> </span><span>times</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x * y = pure (*) ⋄ x ⋄ (y :: 'a stream)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>Rings.dvd</span><span class="delimiter">)</span><span> </span><span>Rings.dvd</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>modulo</span><span class="delimiter">)</span><span> </span><span>modulo</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x div y = pure (div) ⋄ x ⋄ (y :: 'a stream)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x mod y = pure (mod) ⋄ x ⋄ (y :: 'a stream)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semigroup_add</span><span class="delimiter">)</span><span> </span><span>semigroup_add</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add.assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span>applicative_lifting</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ab_semigroup_add</span><span class="delimiter">)</span><span> </span><span>ab_semigroup_add</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add.commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span>applicative_lifting</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semigroup_mult</span><span class="delimiter">)</span><span> </span><span>semigroup_mult</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult.assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span>applicative_lifting</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ab_semigroup_mult</span><span class="delimiter">)</span><span> </span><span>ab_semigroup_mult</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult.commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span>applicative_lifting</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>monoid_add</span><span class="delimiter">)</span><span> </span><span>monoid_add</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_monoid_add</span><span class="delimiter">)</span><span> </span><span>comm_monoid_add</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_monoid_diff</span><span class="delimiter">)</span><span> </span><span>comm_monoid_diff</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>diff_diff_add</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>monoid_mult</span><span class="delimiter">)</span><span> </span><span>monoid_mult</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_monoid_mult</span><span class="delimiter">)</span><span> </span><span>comm_monoid_mult</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  Lifted properties which are more complex than plain equations are not handled by the
  applicative lifting tool.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>plus_stream_shd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shd (x + y) = shd x + shd y"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plus_stream_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>plus_stream_stl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stl (x + y) = stl x + stl y"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plus_stream_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>cancel_semigroup_add</span><span class="delimiter">)</span><span> </span><span>cancel_semigroup_add</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a stream"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a + b = a + c"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b = c"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Eq_stream</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"shd (a + b) = shd (a + c)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stl (a + b) = stl (a + c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>plus_stream_shd</span><span> </span><span>plus_stream_stl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a stream"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b + a = c + a"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b = c"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Eq_stream</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"shd (b + a) = shd (c + a)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stl (b + a) = stl (c + a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>plus_stream_shd</span><span> </span><span>plus_stream_stl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>cancel_ab_semigroup_add</span><span class="delimiter">)</span><span> </span><span>cancel_ab_semigroup_add</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>diff_diff_eq</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>cancel_comm_monoid_add</span><span class="delimiter">)</span><span> </span><span>cancel_comm_monoid_add</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>group_add</span><span class="delimiter">)</span><span> </span><span>group_add</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ab_group_add</span><span class="delimiter">)</span><span> </span><span>ab_group_add</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semiring</span><span class="delimiter">)</span><span> </span><span>semiring</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ring_distribs</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>mult_zero</span><span class="delimiter">)</span><span> </span><span>mult_zero</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semiring_0</span><span class="delimiter">)</span><span> </span><span>semiring_0</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semiring_0_cancel</span><span class="delimiter">)</span><span> </span><span>semiring_0_cancel</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_semiring</span><span class="delimiter">)</span><span> </span><span>comm_semiring</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span class="delimiter">(</span><span>rule</span><span> </span><span>distrib_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_semiring_0</span><span class="delimiter">)</span><span> </span><span>comm_semiring_0</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_semiring_0_cancel</span><span class="delimiter">)</span><span> </span><span>comm_semiring_0_cancel</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_stream_inject</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sconst x = sconst y ⟷ x = y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sconst x = sconst y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"shd (sconst x) = shd (sconst y)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>zero_neq_one</span><span class="delimiter">)</span><span> </span><span>zero_neq_one</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>applicative_unfold</span><span> </span><span>stream</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semiring_1</span><span class="delimiter">)</span><span> </span><span>semiring_1</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_semiring_1</span><span class="delimiter">)</span><span> </span><span>comm_semiring_1</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semiring_1_cancel</span><span class="delimiter">)</span><span> </span><span>semiring_1_cancel</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_semiring_1_cancel</span><span class="delimiter">)</span><span> </span><span>comm_semiring_1_cancel</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro_classes</span><span class="delimiter">;</span><span> </span><span>applicative_lifting</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>right_diff_distrib'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ring</span><span class="delimiter">)</span><span> </span><span>ring</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_ring</span><span class="delimiter">)</span><span> </span><span>comm_ring</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ring_1</span><span class="delimiter">)</span><span> </span><span>ring_1</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_ring_1</span><span class="delimiter">)</span><span> </span><span>comm_ring_1</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>numeral</span><span class="delimiter">)</span><span> </span><span>numeral</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>neg_numeral</span><span class="delimiter">)</span><span> </span><span>neg_numeral</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semiring_numeral</span><span class="delimiter">)</span><span> </span><span>semiring_numeral</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_nat_stream</span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_nat n = sconst (of_nat n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zero_stream_def</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>id_apply</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + pure (of_nat n) = pure (1 + of_nat n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc.IH</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>id_apply</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semiring_char_0</span><span class="delimiter">)</span><span> </span><span>semiring_char_0</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>of_nat_stream</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_stream_numeral</span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"numeral n = pure (numeral n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>numeral.simps</span><span> </span><span>one_stream_def</span><span> </span><span>plus_stream_def</span><span> </span><span>ap_stream_homo</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>stream</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ring_char_0</span><span class="delimiter">)</span><span> </span><span>ring_char_0</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Tree_Relabelling">
<div class="head"><h1>Theory Tree_Relabelling</h1>
<span class="command">theory</span> <span class="name">Tree_Relabelling</span><br/>
<span class="keyword">imports</span> <a href="Applicative_State.html"><span class="name">Applicative_State</span></a> <a href="Applicative_Option.html"><span class="name">Applicative_Option</span></a> <a href="Applicative_PMF.html"><span class="name">Applicative_PMF</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Tree relabelling›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Tree_Relabelling</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative_State</span><span>
</span><span>  </span><span>Applicative_Option</span><span>
</span><span>  </span><span>Applicative_PMF</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Stream"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">unbundle</span></span><span> </span><span>applicative_syntax</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>pure_option</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>State_Monad.return</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>State_Monad.ap</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Hutton and Fulger \cite{HuttonFulger2008TFP} suggested the following tree relabelling problem
  as an example for reasoning about effects. Given a binary tree with labels at the leaves, the
  relabelling assigns a unique number to every leaf.  Their correctness property states that the
  list of labels in the obtained tree is distinct.  As observed by Gibbons and Bird \cite{backwards},
  this breaks the abstraction of the state monad, because the relabeling function must be run.
  Although Hutton and Fulger are careful to reason in point-free style, they nevertheless unfold
  the implementation of the state monad operations.  Gibbons and Hinze \cite{GibbonsHinze2011ICFP}
  suggest to state the correctness in an effectful way using an exception-state monad.  Thereby, they
  lose the applicative structure and have to resort to a full monad.

  Here, we model the tree relabelling function three times. First, we state correctness in pure
  terms following Hutton and Fulger.  Second, we take Gibbons' and Bird's approach of considering
  traversals. Third, we state correctness effectfully, but only using the applicative functors.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>tree</span><span> </span><span class="delimiter">=</span><span> </span><span>Leaf</span><span> </span><span class="tfree">'a</span><span> </span><span class="delimiter">|</span><span> </span><span>Node</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>fold_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) ⇒ ('b ⇒ 'b ⇒ 'b) ⇒ 'a tree ⇒ 'b"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fold_tree f g (Leaf a) = f a"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fold_tree f g (Node l r) = g (fold_tree f g l) (fold_tree f g r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>leaves</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"leaves = fold_tree (λ_. 1) (+)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>leaves_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"leaves (Leaf x) = Suc 0"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"leaves (Node l r) = leaves l + leaves r"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>leaves_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pure correctness statement›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>labels</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'a list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"labels = fold_tree (λx. [x]) append"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>labels_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"labels (Leaf x) = [x]"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"labels (Node l r) = labels l @ labels r"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>labels_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>labelling</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>fresh</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'x) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>show_variants</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>label_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ ('s, 'x tree) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"label_tree = fold_tree (λ_ :: 'a. pure Leaf ⋄ fresh) (λl r. pure Node ⋄ l ⋄ r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>label_tree_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"label_tree (Leaf x) = pure Leaf ⋄ fresh"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"label_tree (Node l r) = pure Node ⋄ label_tree l ⋄ label_tree r"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>label_tree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>label_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ ('s, 'x list) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"label_list [] = pure []"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"label_list (x # xs) = pure (#) ⋄ fresh ⋄ label_list xs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>label_append</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"label_list (a @ b) = pure (@) ⋄ label_list a ⋄ label_list b"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹The proof lifts the defining equations of @{const append} to the state monad.›</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append.simps</span><span> </span><span>label_list.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a1</span><span> </span><span>a2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append.simps</span><span> </span><span>label_list.simps</span><span> </span><span>Cons.IH</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>label_tree_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure labels ⋄ label_tree t = label_list (labels t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Leaf</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>label_tree_simps</span><span> </span><span>labels_simps</span><span> </span><span>label_list.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Node</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>label_tree_simps</span><span> </span><span>labels_simps</span><span> </span><span>label_append</span><span> </span><span>Node.IH</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We directly show correctness without going via streams like Hutton and Fulger \cite{HuttonFulger2008TFP}. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctness_pure</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀xs :: 'a list. distinct (fst (run_state (label_list xs) s))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (labels (fst (run_state (label_tree t) s)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>label_tree_list</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>arg_cong</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λf. run_state f s"</span></span></span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"labels t"</span></span></span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"run_state (label_list (labels t)) s"</span></span></span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>State_Monad.ap_def</span><span> </span><span>split_beta</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness via monadic traversals›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Dual version of an applicative functor with effects composed in the opposite order›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="tfree">'a</span><span> </span><span>dual</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV :: 'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">morphisms</span></span><span> </span><span>un_B</span><span> </span><span>B</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_dual</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>pure_dual</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) ⇒ 'a ⇒ 'b dual"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λpure. pure"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>ap_dual</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a ⇒ ('a ⇒ 'b) ⇒ 'b) ⇒ 'af1) ⇒ ('af1 ⇒ 'af3 ⇒ 'af13) ⇒ ('af13 ⇒ 'af2 ⇒ 'af) ⇒ 'af2 dual ⇒ 'af3 dual ⇒ 'af dual"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λpure ap1 ap2 f x. ap2 (ap1 (pure (λx f. f x)) x) f"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'s</span><span class="delimiter">,</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>state_rev</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'a) state dual"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pure_state_rev</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('s, 'a) state_rev"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_state_rev = pure_dual State_Monad.return"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ap_state_rev</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'a ⇒ 'b) state_rev ⇒ ('s, 'a) state_rev ⇒ ('s, 'b) state_rev"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_state_rev = ap_dual State_Monad.return State_Monad.ap State_Monad.ap"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>pure_state_rev</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_state_rev</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>state_rev</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>pure_state_rev</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_state_rev</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pure_state_rev_def</span><span> </span><span>ap_state_rev_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>applicative_nf</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'s</span><span class="delimiter">,</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>state_rev_rev</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'a) state_rev dual"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pure_state_rev_rev</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('s, 'a) state_rev_rev"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure_state_rev_rev = pure_dual pure_state_rev"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ap_state_rev_rev</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'a ⇒ 'b) state_rev_rev ⇒ ('s, 'a) state_rev_rev ⇒ ('s, 'b) state_rev_rev"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ap_state_rev_rev = ap_dual pure_state_rev ap_state_rev ap_state_rev"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>pure_state_rev_rev</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>ap_state_rev_rev</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>state_rev_rev</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>pure_state_rev_rev</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>ap_state_rev_rev</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pure_state_rev_rev_def</span><span> </span><span>ap_state_rev_rev_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>applicative_nf</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_state_rev_B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B f ⋄ B x = B (State_Monad.return (λx f. f x) ⋄ x ⋄ f)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_state_rev_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>ap_dual.abs_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_state_rev_pure_B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure f ⋄ B x = B (State_Monad.return f ⋄ x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_state_rev_def</span><span> </span><span>pure_state_rev_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>applicative_nf</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_state_rev_rev_B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B f ⋄ B x = B (pure_state_rev (λx f. f x) ⋄ x ⋄ f)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_state_rev_rev_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>ap_dual.abs_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_state_rev_rev_pure_B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure f ⋄ B x = B (pure_state_rev f ⋄ x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_state_rev_rev_def</span><span> </span><span>pure_state_rev_rev_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>applicative_nf</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The formulation by Gibbons and Bird \cite{backwards} crucially depends on Kleisli composition,
  so we need the state monad rather than the applicative functor only.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_conv_bind_state</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"State_Monad.ap f x = State_Monad.bind f (λf. State_Monad.bind x (State_Monad.return ∘ f))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>State_Monad.ap_def</span><span> </span><span>State_Monad.bind_def</span><span> </span><span>Let_def</span><span> </span><span>split_def</span><span> </span><span>o_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_pure_bind_state</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure x ⋄ State_Monad.bind y f = State_Monad.bind y ((⋄) (pure x) ∘ f)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_conv_bind_state</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>kleisli_state</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ ('s, 'c) state) ⇒ ('a ⇒ ('s, 'b) state) ⇒ 'a ⇒ ('s, 'c) state"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∙"</span></span></span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"kleisli_state g f a = State_Monad.bind (f a) g"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fetch</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a stream, 'a) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fetch = State_Monad.bind State_Monad.get (λs. State_Monad.bind (State_Monad.set (stl s)) (λ_. State_Monad.return (shd s)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>traverse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ ('s, 'b) state) ⇒ 'a tree ⇒ ('s, 'b tree) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"traverse f (Leaf x) = pure Leaf ⋄ f x"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"traverse f (Node l r) = pure Node ⋄ traverse f l ⋄ traverse f r"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹As we cannot abstract over the applicative functor in definitions, we define
  traversal on the transformed applicative function once again.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>traverse_rev</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ ('s, 'b) state_rev) ⇒ 'a tree ⇒ ('s, 'b tree) state_rev"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"traverse_rev f (Leaf x) = pure Leaf ⋄ f x"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"traverse_rev f (Node l r) = pure Node ⋄ traverse_rev f l ⋄ traverse_rev f r"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>recurse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ ('s, 'b) state) ⇒ 'a tree ⇒ ('s, 'b tree) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"recurse f = un_B ∘ traverse_rev (B ∘ f)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>recurse_Leaf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"recurse f (Leaf x) = pure Leaf ⋄ f x"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>recurse_def</span><span> </span><span>traverse_rev.simps</span><span> </span><span>o_def</span><span> </span><span>ap_state_rev_pure_B</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>B_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>recurse_Node</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"recurse f (Node l r) = pure (λr l. Node l r) ⋄ recurse f r ⋄ recurse f l"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"recurse f (Node l r) = un_B (pure Node ⋄ traverse_rev (B ∘ f) l ⋄ traverse_rev (B ∘ f) r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>recurse_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = un_B (B (pure Node) ⋄ B (recurse f l) ⋄ B (recurse f r))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>un_B_inverse</span><span> </span><span>recurse_def</span><span> </span><span>pure_state_rev_def</span><span> </span><span>pure_dual_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = pure (λx f. f x) ⋄ recurse f r ⋄ (pure (λx f. f x) ⋄ recurse f l ⋄ pure Node)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_state_rev_B</span><span> </span><span>B_inverse</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = pure (λr l. Node l r) ⋄ recurse f r ⋄ recurse f l"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹This step expands to 13 steps in \cite{backwards}›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>applicative_nf</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>traverse_pure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"traverse pure t = pure t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Leaf</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>traverse.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Node</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>traverse.simps</span><span> </span><span>Node.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹@{term "B ∘ B"} is an idiom morphism›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>B_pure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure x = B (State_Monad.return x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pure_state_rev_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BB_pure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure x = B (B (pure x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pure_state_rev_rev_def</span><span> </span><span>B_pure</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BB_ap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B (B f) ⋄ B (B x) = B (B (f ⋄ x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B (B f) ⋄ B (B x) = B (B (pure (λx f. f x) ⋄ f ⋄ (pure (λx f. f x) ⋄ x ⋄ pure (λx f. f x))))"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = B (B ?exp)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ap_state_rev_rev_B</span><span> </span><span>B_pure</span><span> </span><span>ap_state_rev_B</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?exp = f ⋄ x"</span></span></span><span> </span><span class="comment">― ‹This step takes 15 steps in \cite{backwards}.›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>applicative_nf</span><span class="delimiter">)</span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>traverse_rev_rev</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ ('s, 'b) state_rev_rev) ⇒ 'a tree ⇒ ('s, 'b tree) state_rev_rev"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"traverse_rev_rev f (Leaf x) = pure Leaf ⋄ f x"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"traverse_rev_rev f (Node l r) = pure Node ⋄ traverse_rev_rev f l ⋄ traverse_rev_rev f r"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>recurse_rev</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ ('s, 'b) state_rev) ⇒ 'a tree ⇒ ('s, 'b tree) state_rev"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"recurse_rev f = un_B ∘ traverse_rev_rev (B ∘ f)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>traverse_B_B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"traverse_rev_rev (B ∘ B ∘ f) = B ∘ B ∘ traverse f"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs t = ?rhs t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>BB_pure</span><span> </span><span>BB_ap</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>traverse_recurse</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"traverse f = un_B ∘ recurse_rev (B ∘ f)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = un_B ∘ un_B ∘ B ∘ B ∘ traverse f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>B_inverse</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = un_B ∘ un_B ∘ traverse_rev_rev (B ∘ B ∘ f)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>traverse_B_B</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>recurse_rev_def</span><span> </span><span>o_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>recurse_traverse</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∙ g = pure"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"recurse f ∙ traverse g = pure"</span></span></span><span>
</span><span class="comment">― ‹Gibbons and Bird impose this as an additional requirement on traversals, but they write
  that they have not found a way to derive this fact from other axioms. So we prove it directly.›</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. State_Monad.bind (g x) f = State_Monad.return x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x h. State_Monad.bind (g x) (λx. State_Monad.bind (f x) h) = h x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fold</span><span> </span><span>State_Monad.bind_assoc</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(recurse f ∙ traverse g) t = pure t"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kleisli_state_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Leaf</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_conv_bind_state</span><span> </span><span>recurse_Leaf</span><span> </span><span>**</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>l</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_conv_bind_state</span><span> </span><span>recurse_Node</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>State_Monad.bind_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Node.IH</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Apply traversals to labelling›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>strip</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a × 'b ⇒ ('b stream, 'a) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strip = (λ(a, b). State_Monad.bind (State_Monad.update (SCons b)) (λ_. State_Monad.return a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>adorn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('b stream, 'a × 'b) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adorn a = pure (Pair a) ⋄ fetch"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>label</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ ('b stream, ('a × 'b) tree) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"label ≡ traverse adorn"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>unlabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'b) tree ⇒ ('b stream, 'a tree) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlabel ≡ recurse strip"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_adorn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strip ∙ adorn = pure"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>strip_def</span><span> </span><span>adorn_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>fetch_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>ap_conv_bind_state</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctness_monadic</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unlabel ∙ label = pure"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>recurse_traverse</span><span class="delimiter">)</span><span class="delimiter">(</span><span>rule</span><span> </span><span>strip_adorn</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Applicative correctness statement›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Repeating an effect›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>repeatM</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('s, 'x) state ⇒ ('s, 'x list) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"repeatM 0 f = State_Monad.return []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"repeatM (Suc n) f = pure (#) ⋄ f ⋄ repeatM n f"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>repeatM_plus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"repeatM (n + m) f = pure append ⋄ repeatM n f ⋄ repeatM m f"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>applicative_nf</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>fail</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fail ≡ None"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lift_state</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s, 'a) state ⇒ ('s, 'a option) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_state x = pure pure ⋄ x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lift_option</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a option ⇒ ('s, 'a option) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_option x = pure x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>assert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ bool) ⇒ 'a option ⇒ 'a option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>assert_fail</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"assert P fail = fail"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>assert_pure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"assert P (pure x) = (if P x then pure x else fail)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>labelling</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>symbols</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('s, 'x list option) state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"symbols n ≡ lift_state (repeatM n fresh)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>disjoint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'x list ⇒ 'x list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"disjoint xs ys ≡ set xs ∩ set ys = {}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dlabels</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'x tree ⇒ 'x list option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dlabels = fold_tree (λx. pure [x])
     (λl r. pure (case_prod append) ⋄ (assert (case_prod disjoint) (pure Pair ⋄ l ⋄ r)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dlabels_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dlabels (Leaf x) = pure [x]"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dlabels (Node l r) = pure (case_prod append) ⋄ (assert (case_prod disjoint) (pure Pair ⋄ dlabels l ⋄ dlabels r))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dlabels_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correctness_applicative</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀n. pure (assert distinct) ⋄ symbols n = symbols n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"State_Monad.return dlabels ⋄ label_tree t = symbols (leaves t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure dlabels ⋄ label_tree (Leaf x) = symbols (leaves (Leaf x))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>label_tree_simps</span><span> </span><span>leaves_simps</span><span> </span><span>repeatM.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>l</span><span> </span><span>r</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pure dlabels ⋄ label_tree l = symbols (leaves l)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure dlabels ⋄ label_tree r = symbols (leaves r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?cat</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"case_prod append"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?disj</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"case_prod disjoint"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λl r. pure ?cat ⋄ (assert ?disj (pure Pair ⋄ l ⋄ r))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"State_Monad.return dlabels ⋄ label_tree (Node l r) =
        pure ?f ⋄ (pure dlabels ⋄ label_tree l) ⋄ (pure dlabels ⋄ label_tree r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>label_tree_simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = pure ?f ⋄ (pure (assert distinct) ⋄ symbols (leaves l)) ⋄ (pure (assert distinct) ⋄ symbols (leaves r))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IH</span><span> </span><span>distinct</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = pure (assert distinct) ⋄ symbols (leaves (Node l r))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>leaves_simps</span><span> </span><span>repeatM_plus</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = symbols (leaves (Node l r))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>distinct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pure dlabels ⋄ label_tree (Node l r) = symbols (leaves (Node l r))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Probabilistic tree relabelling›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>mirror</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'a tree"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mirror (Leaf x) = Leaf x"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"mirror (Node l r) = Node (mirror r) (mirror l)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>dir</span><span> </span><span class="delimiter">=</span><span> </span><span>Left</span><span> </span><span class="delimiter">|</span><span> </span><span>Right</span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>path</span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span class="delimiter">(</span><span>sequential</span><span class="delimiter">)</span><span> </span><span>subtree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dir list ⇒ 'a tree ⇒ 'a tree"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"subtree (Left # path)  (Node l r) = subtree path l"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"subtree (Right # path) (Node l r) = subtree path r"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"subtree _              (Leaf x)   = Leaf x"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"subtree []             t          = t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>pure_pmf</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b pmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>plabel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'b tree pmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"plabel (Leaf x)   = pure Leaf ⋄ p x"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"plabel (Node l r) = pure Node ⋄ plabel l ⋄ plabel r"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>plabel_mirror</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"plabel (mirror t) = pure mirror ⋄ plabel t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Leaf</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plabel.simps</span><span> </span><span>mirror.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>t1</span><span> </span><span>t2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plabel.simps</span><span> </span><span>mirror.simps</span><span> </span><span>Node.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>plabel_subtree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"plabel (subtree path t) = pure (subtree path) ⋄ plabel t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>path</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subtree.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Left</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>path</span><span> </span><span>l</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plabel.simps</span><span> </span><span>subtree.simps</span><span> </span><span>Left.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Right</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>path</span><span> </span><span>l</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plabel.simps</span><span> </span><span>subtree.simps</span><span> </span><span>Right.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>uu</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plabel.simps</span><span> </span><span>subtree.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>4</span><span> </span><span>v</span><span> </span><span>va</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>plabel.simps</span><span> </span><span>subtree.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>applicative_lifting</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Examples">
<div class="head"><h1>Theory Applicative_Examples</h1>
<span class="command">theory</span> <span class="name">Applicative_Examples</span><br/>
<span class="keyword">imports</span> <a href="Applicative_Environment_Algebra.html"><span class="name">Applicative_Environment_Algebra</span></a> <a href="Stream_Algebra.html"><span class="name">Stream_Algebra</span></a> <a href="Tree_Relabelling.html"><span class="name">Tree_Relabelling</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Examples</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative_Environment_Algebra</span><span>
</span><span>  </span><span>Stream_Algebra</span><span>
</span><span>  </span><span>Tree_Relabelling</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Joinable">
<div class="head"><h1>Theory Joinable</h1>
<span class="command">theory</span> <span class="name">Joinable</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Formalisation of idiomatic terms and lifting›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Immediate joinability under a relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Joinable</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition and basic properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>joinable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'b) set ⇒ ('a × 'a) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable R = {(x, y). ∃z. (x, z) ∈ R ∧ (y, z) ∈ R}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joinable_simp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ joinable R ⟷ (∃z. (x, z) ∈ R ∧ (y, z) ∈ R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>joinable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joinableI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, z) ∈ R ⟹ (y, z) ∈ R ⟹ (x, y) ∈ joinable R"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>joinable_simp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joinableD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ joinable R ⟹ ∃z. (x, z) ∈ R ∧ (y, z) ∈ R"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>joinable_simp</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joinableE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ joinable R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, z) ∈ R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, z) ∈ R"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>joinable_simp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>refl_on_joinable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"refl_on {x. ∃y. (x, y) ∈ R} (joinable R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>refl_onI</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>joinable_simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>refl_joinable_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x. ∃y. (x, y) ∈ R) = refl (joinable R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>refl_onI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>refl_onD</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>joinable_simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>refl_joinable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"refl R ⟹ refl (joinable R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>refl_joinable_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>refl_onD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joinable_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"refl R ⟹ (x, x) ∈ joinable R"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>refl_joinable</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>refl_onD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sym_joinable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sym (joinable R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>symI</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>joinable_simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joinable_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ joinable R ⟹ (y, x) ∈ joinable R"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sym_joinable</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>symD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joinable_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ S ⟹ joinable R ⊆ joinable S"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subrelI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>joinable_simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>refl_le_joinable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"refl R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ joinable R"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subrelI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹refl R›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, y) ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>refl_onD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ joinable R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>joinableI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joinable_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. (x, y) ∈ R ⟹ (P x, P y) ∈ R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>joinable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ joinable R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(P x, P y) ∈ joinable R"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>joinable</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, z) ∈ R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>yz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, z) ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>joinableE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>R_subst</span><span> </span><span>xz</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(P x, P z) ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>R_subst</span><span> </span><span>yz</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(P y, P z) ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>joinableI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Confluence›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>confluent</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"confluent R ⟷ (∀x y y'. (x, y) ∈ R ∧ (x, y') ∈ R ⟶ (y, y') ∈ joinable R)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>confluentI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⋀x y y'. (x, y) ∈ R ⟹ (x, y') ∈ R ⟹ ∃z. (y, z) ∈ R ∧ (y', z) ∈ R) ⟹ confluent R"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>confluent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>joinableI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>confluentD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"confluent R ⟹ (x, y) ∈ R ⟹ (x,y') ∈ R ⟹ (y, y') ∈ joinable R"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>confluent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>confluentE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"confluent R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y') ∈ R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, z) ∈ R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y', z) ∈ R"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>confluent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>joinableE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_joinable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"confluent R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans (joinable R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>transI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ joinable R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, u) ∈ R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>yu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, u) ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>joinableE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, z) ∈ joinable R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>yv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, v) ∈ R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>zv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(z, v) ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>joinableE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>yu</span><span> </span><span>yv</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹confluent R›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>uw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, w) ∈ R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(v, w) ∈ R"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>confluentE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xu</span><span> </span><span>uw</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans R›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, w) ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>transE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>zv</span><span> </span><span>vw</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans R›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(z, w) ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>transE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, z) ∈ joinable R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>joinableI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Relation to reflexive transitive symmetric closure›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joinable_le_rtscl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable (R<span class="hidden">⇧</span><sup>*</sup>) ⊆ (R ∪ R¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subrelI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ joinable (R<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, z) ∈ R<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>yz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(y,z) ∈ R<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>joinableE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xz</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, z) ∈ (R ∪ R¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>in_rtrancl_UnI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>yz</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(z, y) ∈ (R ∪ R¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>in_rtrancl_UnI</span><span> </span><span>rtrancl_converseI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ (R ∪ R¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtrancl_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>joinable_eq_rtscl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"confluent (R<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable (R<span class="hidden">⇧</span><sup>*</sup>) = (R ∪ R¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable (R<span class="hidden">⇧</span><sup>*</sup>) ⊆ (R ∪ R¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>joinable_le_rtscl</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"joinable (R<span class="hidden">⇧</span><sup>*</sup>) ⊇ (R ∪ R¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subrelI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ (R ∪ R¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ joinable (R<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>rtrancl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, x) ∈ joinable (R<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>joinable_refl</span><span> </span><span>refl_rtrancl</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ joinable (R<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>refl_le_joinable</span><span> </span><span>refl_rtrancl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(y, z) ∈ R ∪ R¯›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, z) ∈ joinable (R<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>joinable_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(x, y) ∈ joinable (R<span class="hidden">⇧</span><sup>*</sup>)›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, z) ∈ joinable (R<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_joinable</span><span> </span><span>trans_rtrancl</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹confluent (R<span class="hidden">⇧</span><sup>*</sup>)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>transD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Predicate version›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>joinablep</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b ⇒ bool) ⇒ 'a ⇒ 'a ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"joinablep P x y ⟷ (∃z. P x z ∧ P y z)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joinablep_joinable</span><span class="delimiter">[</span><span>pred_set_conv</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"joinablep (λx y. (x, y) ∈ R) = (λx y. (x, y) ∈ joinable R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>joinablep_def</span><span> </span><span>joinable_simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reflp_joinablep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reflp P ⟹ reflp (joinablep P)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>reflpI</span><span> </span><span>joinable_refl</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span> </span><span>refl_onI</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>reflpD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joinablep_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reflp P ⟹ joinablep P x x"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reflp_joinablep</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reflpD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reflp_le_joinablep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reflp P ⟹ P ≤ joinablep P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>refl_le_joinable</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span> </span><span>refl_onI</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>reflpD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Beta_Eta">
<div class="head"><h1>Theory Beta_Eta</h1>
<span class="command">theory</span> <span class="name">Beta_Eta</span><br/>
<span class="keyword">imports</span> <a href="Eta.html"><span class="name">Eta</span></a> <a href="Joinable.html"><span class="name">Joinable</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Combined beta and eta reduction of lambda terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Beta_Eta</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Proofs-Lambda.Eta"</span></span></span><span> </span><span>Joinable</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary lemmas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>liftn_lift_swap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"liftn n (lift t k) k = lift (liftn n t k) k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_liftn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i ≤ n + k ∧ k ≤ i ⟹ (liftn (Suc n) s k)[t/i] = liftn n s k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>s</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span> </span><span>k</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_lift2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lift (lift t 0) 0)[x/Suc 0] = lift t 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift (lift t 0) 0 = lift (lift t 0) (Suc 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lift_lift</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_liftn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"free (liftn n t k) i = (i &lt; k ∧ free t i ∨ k + n ≤ i ∧ free t (i - n))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>k</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Suc_diff_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reduction›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>beta_eta</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dB ⇒ dB ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"beta_eta ≡ sup beta eta"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>beta_eta_reds</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dB ⇒ dB ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"→<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> t ≡ (beta_eta)<span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup> s t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>beta_into_beta_eta_reds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>β</sub> t ⟹ s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eta_into_beta_eta_reds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>η</sub> t ⟹ s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>beta_reds_into_beta_eta_reds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup> t ⟹ s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp_mono</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eta_reds_into_beta_eta_reds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> t ⟹ s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp_mono</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>beta_eta_appL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> s' ⟹ s ° t →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> s' ° t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>rtranclp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp.rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>beta_eta_appR</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> t' ⟹ s ° t →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> s ° t'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>rtranclp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp.rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>beta_eta_abs</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> t' ⟹ Abs t →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> Abs t'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>rtranclp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp.rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>beta_eta_lift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> t ⟹ lift s k →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> lift t k"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>pred</span><span class="delimiter">:</span><span> </span><span>rtranclp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift y k →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub> lift z k"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lift_preserves_beta</span><span> </span><span>eta_lift</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>step.IH</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift s k →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> lift z k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>iprover</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>confluent_beta_eta_reds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Joinable.confluent {(s, t). s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> t}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confluent_beta_eta</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diamond_def</span><span> </span><span>commute_def</span><span> </span><span>square_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>confluentI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Equivalence›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Terms are equivalent iff they can be reduced to a common term.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>term_equiv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dB ⇒ dB ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↔"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_equiv = joinablep beta_eta_reds"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_equivI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> u"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↔ t"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>term_equiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>joinableI</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_equivE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↔ t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> u"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>term_equiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>joinableE</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reds_into_equiv</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> t ⟹ s ↔ t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_equivI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>beta_into_equiv</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>β</sub> t ⟹ s ↔ t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reds_into_equiv</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>beta_into_beta_eta_reds</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eta_into_equiv</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>η</sub> t ⟹ s ↔ t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reds_into_equiv</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eta_into_beta_eta_reds</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>beta_reds_into_equiv</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup> t ⟹ s ↔ t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reds_into_equiv</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>beta_reds_into_beta_eta_reds</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eta_reds_into_equiv</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>η</sub><span class="hidden">⇧</span><sup>*</sup> t ⟹ s ↔ t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reds_into_equiv</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eta_reds_into_beta_eta_reds</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_refl</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ↔ t"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>term_equiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>joinablep_refl</span><span> </span><span>reflpI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_sym</span><span class="delimiter">[</span><span>sym</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s ↔ t) ⟹ (t ↔ s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>term_equiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>joinable_sym</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conversep_term</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"conversep (↔) = (↔)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↔ t ⟹ t ↔ u ⟹ s ↔ u"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>term_equiv_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_joinable</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span> </span><span>trans_rtrancl</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span> </span><span>confluent_beta_eta_reds</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>transpE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_beta_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↔ t ⟹ t →<span class="hidden">⇩</span><sub>β</sub> u ⟹ s ↔ u"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fast</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>beta_into_beta_eta_reds</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_eta_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↔ t ⟹ t →<span class="hidden">⇩</span><sub>η</sub> u ⟹ s ↔ u"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fast</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>eta_into_beta_eta_reds</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_appL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↔ s' ⟹ s ° t ↔ s' ° t"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>term_equiv_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>beta_eta_appL</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>iprover</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>joinable_subst</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_appR</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ↔ t' ⟹ s ° t ↔ s ° t'"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>term_equiv_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>beta_eta_appR</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>iprover</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>joinable_subst</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↔ s' ⟹ t ↔ t' ⟹ s ° t ↔ s' ° t'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_abs</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ↔ t' ⟹ Abs t ↔ Abs t'"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>term_equiv_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>beta_eta_abs</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>iprover</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>joinable_subst</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_lift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↔ t ⟹ lift s k ↔ lift t k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_equivI</span><span> </span><span>beta_eta_lift</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>term_equivE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_liftn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↔ t ⟹ liftn n s k ↔ liftn n t k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>equiv_lift</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Our definition is equivalent to the the symmetric and transitive closure of
  the reduction relation.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_eq_rtscl_reds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_equiv = (sup beta_eta beta_eta¯¯)<span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>term_equiv_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confluent_beta_eta_reds</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>joinable_eq_rtscl</span><span class="delimiter">[</span><span>to_pred</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Combinators">
<div class="head"><h1>Theory Combinators</h1>
<span class="command">theory</span> <span class="name">Combinators</span><br/>
<span class="keyword">imports</span> <a href="Beta_Eta.html"><span class="name">Beta_Eta</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Combinators defined as closed lambda terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Combinators</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Beta_Eta</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>I_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℐ = Abs (Var 0)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>B_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ = Abs (Abs (Abs (Var 2 ° (Var 1 ° Var 0))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>T_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒯 = Abs (Abs (Var 0 ° Var 1))"</span></span></span><span> </span><span class="comment">― ‹reverse application›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>I_eval</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℐ ° x →<span class="hidden">⇩</span><sub>β</sub> x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℐ ° x →<span class="hidden">⇩</span><sub>β</sub> Var 0[x/0]"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>I_equiv</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℐ ° x ↔ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I_eval</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>I_closed</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"liftn n ℐ k = ℐ"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>B_eval1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ ° g →<span class="hidden">⇩</span><sub>β</sub> Abs (Abs (lift (lift g 0) 0 ° (Var 1 ° Var 0)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ ° g →<span class="hidden">⇩</span><sub>β</sub> Abs (Abs (Var 2 ° (Var 1 ° Var 0))) [g/0]"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>B_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>numerals</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>B_eval2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ ° g ° f →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup> Abs (lift g 0 ° (lift f 0 ° Var 0))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ ° g ° f →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup> Abs (Abs (lift (lift g 0) 0 ° (Var 1 ° Var 0))) ° f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B_eval1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... →<span class="hidden">⇩</span><sub>β</sub> Abs (lift (lift g 0) 0 ° (Var 1 ° Var 0)) [f/0]"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = Abs (lift g 0 ° (lift f 0 ° Var 0))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>B_eval</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ ° g ° f ° x →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup> g ° (f ° x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ ° g ° f ° x →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup> Abs (lift g 0 ° (lift f 0 ° Var 0)) ° x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B_eval2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... →<span class="hidden">⇩</span><sub>β</sub> (lift g 0 ° (lift f 0 ° Var 0)) [x/0]"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = g ° (f ° x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>B_equiv</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ ° g ° f ° x ↔ g ° (f ° x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B_eval</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>B_closed</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"liftn n ℬ k = ℬ"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>B_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>T_eval1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒯 ° x →<span class="hidden">⇩</span><sub>β</sub> Abs (Var 0 ° lift x 0)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒯 ° x →<span class="hidden">⇩</span><sub>β</sub> Abs (Var 0 ° Var 1) [x/0]"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>T_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>T_eval</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒯 ° x ° f →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup> f ° x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒯 ° x ° f →<span class="hidden">⇩</span><sub>β</sub><span class="hidden">⇧</span><sup>*</sup> Abs (Var 0 ° lift x 0) ° f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T_eval1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... →<span class="hidden">⇩</span><sub>β</sub> (Var 0 ° lift x 0) [f/0]"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = f ° x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>T_equiv</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒯 ° x ° f ↔ f ° x"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T_eval</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>T_closed</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"liftn n 𝒯 k = 𝒯"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>T_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Idiomatic_Terms">
<div class="head"><h1>Theory Idiomatic_Terms</h1>
<span class="command">theory</span> <span class="name">Idiomatic_Terms</span><br/>
<span class="keyword">imports</span> <a href="Combinators.html"><span class="name">Combinators</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Idiomatic terms -- Properties and operations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Idiomatic_Terms</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Combinators</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This theory proves the correctness of the normalisation algorithm for
  arbitrary applicative functors. We generalise the normal form using a framework
  for bracket abstraction algorithms. Both approaches justify lifting certain
  classes of equations. We model this as implications of term equivalences,
  where unlifting of idiomatic terms is expressed syntactically.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic definitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>itrm</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>Opaque</span><span> </span><span class="tfree">'a</span><span> </span><span class="delimiter">|</span><span> </span><span>Pure</span><span> </span><span>dB</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IAp</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋄"</span></span></span><span> </span><span>150</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>opaque</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm ⇒ 'a list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"opaque (Opaque x) = [x]"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque (Pure _) = []"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque (f ⋄ x) = opaque f @ opaque x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"iorder x ≡ length (opaque x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>itrm_cong</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a itrm ⇒ 'a itrm ⇒ bool) ⇒ 'a itrm ⇒ 'a itrm ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>R</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>into_itrm_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R x y ⟹ itrm_cong R x y"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>pure_cong</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ↔ y ⟹ itrm_cong R (Pure x) (Pure y)"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ap_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_cong R f f' ⟹ itrm_cong R x x' ⟹ itrm_cong R (f ⋄ x) (f' ⋄ x')"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>itrm_refl</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_cong R x x"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>itrm_sym</span><span class="delimiter">[</span><span>sym</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_cong R x y ⟹ itrm_cong R y x"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>itrm_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_cong R x y ⟹ itrm_cong R y z ⟹ itrm_cong R x z"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_congL</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_cong R f f' ⟹ itrm_cong R (f ⋄ x) (f' ⋄ x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ap_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_congR</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_cong R x x' ⟹ itrm_cong R (f ⋄ x) (f ⋄ x')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ap_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Idiomatic terms are \emph{similar} iff they have the same structure, and all contained
  lambda terms are equivalent.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>similar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm ⇒ 'a itrm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≅"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≅ y ≡ itrm_cong (λ_ _. False) x y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_similarE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Pure x' ≅ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>y'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = Pure y'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ↔ y'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = Pure x'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≅ y"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x''. x = Pure x'' ⟶ (∃y'. y = Pure y' ∧ x'' ↔ y')) ∧
    (∀x''. y = Pure x'' ⟶ (∃y'. x = Pure y' ∧ x'' ↔ y'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>pure_cong</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>itrm_trans</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>that</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>opaque_similarE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Opaque x' ≅ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>y'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = Opaque y'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x' = y'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = Opaque x'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≅ y"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x''. x = Opaque x'' ⟶ (∃y'. y = Opaque y' ∧ x'' = y')) ∧
    (∀x''. y = Opaque x'' ⟶ (∃y'. x = Opaque y' ∧ x'' = y'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induction</span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>that</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_similarE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x1 ⋄ x2 ≅ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>y1</span><span> </span><span>y2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = y1 ⋄ y2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x1 ≅ y1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x2 ≅ y2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x1' x2'. x1 ⋄ x2 = x1' ⋄ x2' ⟶ (∃y1 y2. y = y1 ⋄ y2 ∧ x1' ≅ y1 ∧ x2' ≅ y2)) ∧
    (∀x1' x2'. y = x1' ⋄ x2' ⟶ (∃y1 y2. x1 ⋄ x2 = y1 ⋄ y2 ∧ x1' ≅ y1 ∧ x2' ≅ y2))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ap_cong</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>itrm_sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>trans</span><span class="delimiter">:</span><span> </span><span>itrm_trans</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>itrm_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>that</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following relations define semantic equivalence of idiomatic terms.
  We consider equivalences that hold universally in all idioms, as well as arbitrary
  specialisations using additional laws.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>idiom_rule</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm ⇒ 'a itrm ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>idiom_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"idiom_rule (Pure ℐ ⋄ x) x"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>idiom_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"idiom_rule (Pure ℬ ⋄ g ⋄ f ⋄ x) (g ⋄ (f ⋄ x))"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>idiom_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"idiom_rule (Pure f ⋄ Pure x) (Pure (f ° x))"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>idiom_xchng</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"idiom_rule (f ⋄ Pure x) (Pure (𝒯 ° x) ⋄ f)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>itrm_equiv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm ⇒ 'a itrm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≃"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃ y ≡ itrm_cong idiom_rule x y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idiom_rule_into_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"idiom_rule x y ⟹ x ≃ y"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>itrm_id</span><span> </span><span class="delimiter">=</span><span> </span><span>idiom_id</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>idiom_rule_into_equiv</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>itrm_comp</span><span> </span><span class="delimiter">=</span><span> </span><span>idiom_comp</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>idiom_rule_into_equiv</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>itrm_hom</span><span> </span><span class="delimiter">=</span><span> </span><span>idiom_hom</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>idiom_rule_into_equiv</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>itrm_xchng</span><span> </span><span class="delimiter">=</span><span> </span><span>idiom_xchng</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>idiom_rule_into_equiv</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>similar_into_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≅ y ⟹ x ≃ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>pred</span><span class="delimiter">:</span><span> </span><span>itrm_cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ap_cong</span><span> </span><span>itrm_sym</span><span> </span><span>itrm_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>opaque_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃ y ⟹ opaque x = opaque y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>pred</span><span class="delimiter">:</span><span> </span><span>itrm_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>into_itrm_cong</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induction</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iorder_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃ y ⟹ iorder x = iorder y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>opaque_equiv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>special_idiom</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>extra_rule</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm ⇒ 'a itrm ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"idiom_ext_rule = sup idiom_rule extra_rule"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>itrm_ext_equiv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm ⇒ 'a itrm ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≃<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃<span class="hidden">⇧</span><sup>+</sup> y ≡ itrm_cong idiom_ext_rule x y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equiv_into_ext_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃ y ⟹ x ≃<span class="hidden">⇧</span><sup>+</sup> y"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>idiom_ext_rule_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>pred</span><span class="delimiter">:</span><span> </span><span>itrm_cong</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>into_itrm_cong</span><span> </span><span>ap_cong</span><span> </span><span>itrm_sym</span><span> </span><span>itrm_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>itrm_ext_id</span><span> </span><span class="delimiter">=</span><span> </span><span>itrm_id</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equiv_into_ext_equiv</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>itrm_ext_comp</span><span> </span><span class="delimiter">=</span><span> </span><span>itrm_comp</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equiv_into_ext_equiv</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>itrm_ext_hom</span><span> </span><span class="delimiter">=</span><span> </span><span>itrm_hom</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equiv_into_ext_equiv</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>itrm_ext_xchng</span><span> </span><span class="delimiter">=</span><span> </span><span>itrm_xchng</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equiv_into_ext_equiv</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Syntactic unlifting›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹With generalisation of variables›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>unlift'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a itrm ⇒ nat ⇒ dB"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"unlift' n (Opaque _) i = Var i"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' n (Pure x) i = liftn n x 0"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' n (f ⋄ x) i = unlift' n f (i + iorder x) ° unlift' n x i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift x ≡ (Abs^^iorder x) (unlift' (iorder x) x 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>funpow_Suc_inside</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(f ^^ Suc n) x = (f ^^ n) (f x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>funpow_Suc_right</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>absn_cong</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↔ t ⟹ (Abs^^n) s ↔ (Abs^^n) t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_unlift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"free (unlift' n x i) j ⟹ j ≥ n ∨ (j ≥ i ∧ j &lt; i + iorder x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Opaque</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pure</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_liftn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>IAp</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unlift_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ i ∧ j ≤ n ⟹ (unlift' (Suc n) t (Suc i))[s/j] = unlift' n t i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Opaque</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pure</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subst_liftn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>IAp</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ i + iorder y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>IAp</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unlift'_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃ y ⟹ unlift' n x i ↔ unlift' n y i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n</span><span> </span><span>i</span><span> </span><span>pred</span><span class="delimiter">:</span><span> </span><span>itrm_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>into_itrm_cong</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induction</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>idiom_id</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I_equiv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>idiom_comp</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?G</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' n g (i + iorder f + iorder x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?F</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' n f (i + iorder x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' n x i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' n (g ⋄ (f ⋄ x)) i = ?G ° (?F ° ?X)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' n (Pure ℬ ⋄ g ⋄ f ⋄ x) i = ℬ ° ?G ° ?F ° ?X"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span> </span><span>add.left_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?G ° (?F ° ?X) ↔ ℬ ° ?G ° ?F ° ?X"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B_equiv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>idiom_hom</span><span> </span><span>f</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>idiom_xchng</span><span> </span><span>f</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?F</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' n f i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"liftn n x 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' n (f ⋄ Pure x) i = ?F ° ?X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' n (Pure (𝒯 ° x) ⋄ f) i = 𝒯 ° ?X ° ?F"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F ° ?X ↔ 𝒯 ° ?X ° ?F"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T_equiv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>pure_cong</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>equiv_liftn</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ap_cong</span><span> </span><span>f</span><span> </span><span>f'</span><span> </span><span>x</span><span> </span><span>x'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ≃ x'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>iorder_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"iorder x = iorder x'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iorder_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' n (f ⋄ x) i = unlift' n f (i + iorder x) ° unlift' n x i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' n (f' ⋄ x') i = unlift' n f' (i + iorder x) ° unlift' n x' i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iorder_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ap_cong.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>equiv_app</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>itrm_refl</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>itrm_sym</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>term_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>itrm_trans</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>term_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unlift_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃ y ⟹ unlift x ↔ unlift y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift' (iorder y) x 0 ↔ unlift' (iorder y) y 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>unlift'_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ≃ y›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"iorder x = iorder y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iorder_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preserving variables›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>unlift_vars</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat itrm ⇒ dB"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"unlift_vars n (Opaque i) = Var i"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift_vars n (Pure x) = liftn n x 0"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift_vars n (x ⋄ y) = unlift_vars n x ° unlift_vars n y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_pure_unlift_vars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque x = [] ⟹ x ≃ Pure (unlift_vars 0 x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Opaque</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pure</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>IAp</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_opaque</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque x = []"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque y = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unlift_ap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift_vars 0 (x ⋄ y) = unlift_vars 0 x ° unlift_vars 0 y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>no_opaque</span><span> </span><span>IAp.IH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋄ y ≃ Pure (unlift_vars 0 x) ⋄ Pure (unlift_vars 0 y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ap_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≃ Pure (unlift_vars 0 x ° unlift_vars 0 y)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>itrm_hom</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = Pure (unlift_vars 0 (x ⋄ y))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>unlift_ap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Canonical forms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>CF</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>pure_cf</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pure x ∈ CF"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>ap_cf</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ CF ⟹ f ⋄ Opaque x ∈ CF"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>CF_pure</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm ⇒ dB"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"CF_pure (Opaque _) = undefined"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CF_pure (Pure x) = x"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"CF_pure (x ⋄ _) = CF_pure x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_cfD1</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ⋄ x ∈ CF ⟹ f ∈ CF"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CF.cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ap_cfD2</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ⋄ x ∈ CF ⟹ ∃x'. x = Opaque x'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CF.cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>opaque_not_cf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Opaque x ∈ CF ⟹ False"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CF.cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_unlift</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ CF"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CF_pure x ↔ unlift x"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>CF</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pure_cf</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ap_cf</span><span> </span><span>f</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?n</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"iorder f + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift (f ⋄ Opaque x) = (Abs^^?n) (unlift' ?n f 1 ° Var 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Abs^^iorder f) (Abs (unlift' ?n f 1 ° Var 0))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>funpow_Suc_inside</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ unlift f"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free (unlift' ?n f 1) 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>free_unlift</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Abs (unlift' ?n f 1 ° Var 0) →<span class="hidden">⇩</span><sub>η</sub> (unlift' ?n f 1)[Var 0/0]"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = unlift' (iorder f) f 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unlift_subst</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>le0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>r_into_rtranclp</span><span> </span><span>absn_cong</span><span> </span><span>eta_into_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ap_cf.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_sym</span><span> </span><span>term_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_similarI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ CF"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ CF"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque x = opaque y"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CF_pure x ↔ CF_pure y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≅ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pure_cf</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque y = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ CF›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = Pure y'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pure_cf.prems</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ap_cf</span><span> </span><span>f</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹opaque (f ⋄ Opaque x) = opaque y›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y1</span><span> </span><span>y2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque y = y1 @ y2"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque f = y1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[x] = y2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹[x] = y2›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y2 = [y']"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ CF›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹opaque y = y1 @ y2›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque g = y1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y = g ⋄ Opaque y'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ CF"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ap_cf.prems</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹opaque f = y1›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque f = opaque g"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CF_pure f ↔ CF_pure g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ap_cf.IH</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g ∈ CF›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ≅ g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ap_cf.prems</span><span> </span><span>y_split</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = y'›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ap_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_similarD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>in_cf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ CF"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ CF"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>similar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≅ y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CF_pure x ↔ CF_pure y ∧ opaque x = opaque y"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>similar_into_equiv</span><span> </span><span>opaque_equiv</span><span> </span><span>cf_unlift</span><span> </span><span>unlift_equiv</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_trans</span><span> </span><span>term_sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Equivalent idiomatic terms in canonical form are similar. This justifies speaking of a
  normal form.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_unique</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>in_cf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ CF"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ CF"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃ y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≅ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_cf</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cf_similarI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>equiv</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque x = opaque y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>opaque_equiv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>equiv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift x ↔ unlift y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>unlift_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CF_pure x ↔ CF_pure y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_unlift</span><span class="delimiter">[</span><span>OF</span><span> </span><span>in_cf</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>cf_unlift</span><span class="delimiter">[</span><span>OF</span><span> </span><span>in_cf</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>term_sym</span><span> </span><span>term_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Normalisation of idiomatic terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>norm_pn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dB ⇒ 'a itrm ⇒ 'a itrm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"norm_pn f (Opaque x) = undefined"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_pn f (Pure x) = Pure (f ° x)"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_pn f (n ⋄ x) = norm_pn (ℬ ° f) n ⋄ x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>norm_nn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm ⇒ 'a itrm ⇒ 'a itrm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"norm_nn n (Opaque x) = undefined"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_nn n (Pure x) = norm_pn (𝒯 ° x) n"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_nn n (n' ⋄ x) = norm_nn (norm_pn ℬ n) n' ⋄ x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>norm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a itrm ⇒ 'a itrm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"norm (Opaque x) = Pure ℐ ⋄ Opaque x"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"norm (Pure x) = Pure x"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"norm (f ⋄ x) = norm_nn (norm f) (norm x)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_pn_in_cf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ CF"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_pn f x ∈ CF"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>f</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_nn_in_cf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ CF"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' ∈ CF"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_nn n n' ∈ CF"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>norm_pn_in_cf</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_in_cf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"norm x ∈ CF"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>norm_nn_in_cf</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_pn_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ CF"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_pn f x ≃ Pure f ⋄ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pure_cf</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Pure (f ° x) ≃ Pure f ⋄ Pure x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>itrm_hom</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ap_cf</span><span> </span><span>n</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ap_cf.IH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_pn (ℬ ° f) n ≃ Pure (ℬ ° f) ⋄ n"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_pn (ℬ ° f) n ⋄ Opaque x ≃ Pure (ℬ ° f) ⋄ n ⋄ Opaque x"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≃ Pure ℬ ⋄ Pure f ⋄ n ⋄ Opaque x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>itrm_hom</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≃ Pure f ⋄ (n ⋄ Opaque x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>itrm_comp</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_nn_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ CF"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' ∈ CF"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_nn n n' ≃ n ⋄ n'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>pure_cf</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_pn (𝒯 ° x) n ≃ Pure (𝒯 ° x) ⋄ n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>norm_pn_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≃ n ⋄ Pure x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>itrm_xchng</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ap_cf</span><span> </span><span>n'</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_nn (norm_pn ℬ n) n' ⋄ Opaque x ≃ Pure ℬ ⋄ n ⋄ n' ⋄ Opaque x"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n ∈ CF›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_pn ℬ n ∈ CF"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>norm_pn_in_cf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ap_cf.IH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_nn (norm_pn ℬ n) n' ≃ norm_pn ℬ n ⋄ n'"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≃ Pure ℬ ⋄ n ⋄ n'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>norm_pn_equiv</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n ∈ CF›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_nn (norm_pn ℬ n) n' ≃ Pure ℬ ⋄ n ⋄ n'"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≃ n ⋄ (n' ⋄ Opaque x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>itrm_comp</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"norm x ≃ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Opaque</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Pure ℐ ⋄ Opaque x ≃ Opaque x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>itrm_id</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pure</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>IAp</span><span> </span><span>f</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm f ∈ CF"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm x ∈ CF"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>norm_in_cf</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm_nn (norm f) (norm x) ≃ norm f ⋄ norm x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>norm_nn_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≃ f ⋄ x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IAp.IH</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_form</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≃ x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ CF"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>norm_equiv</span><span> </span><span>norm_in_cf</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lifting with normal forms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nf_unlift</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≃ x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ CF"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CF_pure n ↔ unlift x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>cf</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CF_pure n ↔ unlift n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cf_unlift</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>equiv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift n ↔ unlift x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>unlift_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>nf_lifting</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>opaque</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque x = opaque y"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>base_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift x ↔ unlift y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>nf_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≃ x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ CF"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal_form</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>nf_y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n' ≃ y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' ∈ CF"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal_form</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nf_x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CF_pure n ↔ unlift x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nf_unlift</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>base_eq</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nf_y</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift y ↔ CF_pure n'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nf_unlift</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>term_sym</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pure_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CF_pure n ↔ CF_pure n'"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nf_x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque n = opaque x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>opaque_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>opaque</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nf_y</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque y = opaque n'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>opaque_equiv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>opaque_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque n = opaque n'"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nf_x</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃ n"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≃ n'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nf_x</span><span> </span><span>nf_y</span><span> </span><span>pure_eq</span><span> </span><span>opaque_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>similar_into_equiv</span><span> </span><span>cf_similarI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nf_y</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' ≃ y"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃ y"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bracket abstraction, twice›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preliminaries: Sequential application of variables›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>frees</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dB ⇒ nat set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"frees t = {i. free t i}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>var_dist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ dB ⇒ dB"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"var_dist = fold (λi t. t ° Var i)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_dist_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"var_dist [] t = t"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>var_dist_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_dist_Cons</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"var_dist (v # vs) t = var_dist vs (t ° Var v)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>var_dist_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_dist_append1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"var_dist (vs @ [v]) t = var_dist vs t ° Var v"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>var_dist_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_dist_frees</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"frees (var_dist vs t) = frees t ∪ set vs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>vs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_dist_subst_lt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀v∈set vs. i &lt; v ⟹ (var_dist vs s)[t/i] = var_dist (map (λv. v - 1) vs) (s[t/i])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>vs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_dist_subst_gt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀v∈set vs. v &lt; i ⟹ (var_dist vs s)[t/i] = var_dist vs (s[t/i])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>vs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vsubst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ nat ⇒ nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vsubst u v w = (if u &lt; w then u else if u = w then v else u - 1)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vsubst_subst</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Var u)[Var v/w] = Var (vsubst u v w)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vsubst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vsubst_subst_lt</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u &lt; w ⟹ vsubst u v w = u"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vsubst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_dist_subst_Var</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(var_dist vs s)[Var i/j] = var_dist (map (λv. vsubst v i j) vs) (s[Var i/j])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>vs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_dist_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ↔ t ⟹ var_dist vs s ↔ var_dist vs t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>vs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preliminaries: Eta reductions with permuted variables›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>absn_subst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((Abs^^n) s)[t/k] = (Abs^^n) (s[liftn n t 0/k+n])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>liftn_lift_swap</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>absn_beta_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^Suc n) s ° t ↔ (Abs^^n) (s[liftn n t 0/n])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^Suc n) s ° t = Abs ((Abs^^n) s) ° t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ ((Abs^^n) s)[t/0]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>beta_into_equiv</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>beta.beta</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Abs^^n) (s[liftn n t 0/n])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>absn_subst</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>absn_dist_eta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^n) (var_dist (rev [0..&lt;n]) (liftn n t 0)) ↔ t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?dist_range</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λa k. var_dist (rev [a..&lt;k]) (liftn k t 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>append</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rev [0..&lt;Suc n] = rev [1..&lt;Suc n] @ [0]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>upt_rec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_last</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?dist_range 0 (Suc n) = ?dist_range 1 (Suc n) ° Var 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append</span><span> </span><span>var_dist_append1</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ free (?dist_range 1 (Suc n)) 0"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"frees (?dist_range 1 (Suc n)) = frees (liftn (Suc n) t 0) ∪ {1..n}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>var_dist_frees</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ∉ frees (?dist_range 1 (Suc n))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Abs (?dist_range 0 (Suc n)) →<span class="hidden">⇩</span><sub>η</sub> (?dist_range 1 (Suc n))[Var 0/0]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dist_last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eta</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = var_dist (rev [0..&lt;n]) ((liftn (Suc n) t 0)[Var 0/0])"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v∈set (rev [1..&lt;Suc n]). 0 &lt; v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rev [0..&lt;n] = map (λv. v - 1) (rev [1..&lt;Suc n])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>var_dist_subst_lt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ?dist_range 0 n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subst_liftn</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span> </span><span>n</span><span> </span><span>0</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"Var 0"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Abs (?dist_range 0 (Suc n)) ↔ ?dist_range 0 n"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^Suc n) (?dist_range 0 (Suc n)) ↔ (Abs^^n) (?dist_range 0 n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>funpow_Suc_inside</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>absn_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc.IH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ t"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>strip_context</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ dB ⇒ nat ⇒ dB"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"strip_context n (Var i) k = (if i &lt; k then Var i else Var (i - n))"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"strip_context n (Abs t) k = Abs (strip_context n t (Suc k))"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"strip_context n (s ° t) k = strip_context n s k ° strip_context n t k"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_context_liftn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strip_context n (liftn (m + n) t k) k = liftn m t k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>liftn_strip_context</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈frees t. i &lt; k ∨ k + n ≤ i"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"liftn n (strip_context n t k) k = t"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Abs</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈frees t. i &lt; Suc k ∨ Suc k + n ≤ i"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>free</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ frees t"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; Suc k ∨ Suc k + n ≤ i"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &gt; 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &gt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>free</span><span> </span><span>Abs.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i-1 &lt; k ∨ k + n ≤ i-1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Abs.IH</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>absn_dist_eta_free</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈frees t. n ≤ i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^n) (var_dist (rev [0..&lt;n]) t) ↔ strip_context n t 0"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs t ↔ ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs (liftn n ?rhs 0) ↔ ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>absn_dist_eta</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"liftn n ?rhs 0 = t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>liftn_strip_context</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>perm_vars</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"perm_vars n vs ⟷ distinct vs ∧ set vs = {0..&lt;n}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>perm_vars_distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"perm_vars n vs ⟹ distinct vs"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>perm_vars_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>perm_vars_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"perm_vars n vs ⟹ length vs = n"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>perm_vars_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_card</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>perm_vars_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"perm_vars n vs ⟹ ∀i∈set vs. i &lt; n"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>perm_vars_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>perm_vars_nth_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"perm_vars n vs ⟹ i &lt; n ⟹ vs ! i &lt; n"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>perm_vars_length</span><span> </span><span>perm_vars_lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>perm_vars_inj_on_nth</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"perm_vars n vs"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inj_on (nth vs) {0..&lt;n}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inj_onI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ {0..&lt;n}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ {0..&lt;n}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length vs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length vs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>perm_vars_length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct vs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>perm_vars_distinct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vs ! i = vs ! j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = j"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_eq_iff_index_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>perm_vars_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat list ⇒ nat ⇒ nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"perm_vars_inv n vs i ≡ the_inv_into {0..&lt;n} ((!) vs) i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>perm_vars_inv_nth</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"perm_vars n vs"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; n"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"perm_vars_inv n vs (vs ! i) = i"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>the_inv_into_f_f</span><span> </span><span>perm_vars_inj_on_nth</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_perm_eta</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>perm_vars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"perm_vars n vs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>vs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t. ∀i∈frees t. n ≤ i ⟹
    (Abs^^n) (var_dist vs' ((Abs^^n) (var_dist vs (liftn n t 0)))) ↔ strip_context n t 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>vsubsts</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vsubsts n vs' vs =
    map (λv.
      if v &lt; n - length vs' then v
      else if v &lt; n then vs' ! (n - v - 1) + (n - length vs')
      else v - length vs') vs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span>vs'</span><span> </span><span>vs</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?app_vars</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λt n vs' vs. var_dist vs' ((Abs^^n) (var_dist vs (liftn n t 0)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span>dB</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vs'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>partial</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length vs' ≤ n"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?m</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"n - length vs'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?app_vars t n vs' vs ↔ (Abs^^?m) (var_dist (vsubsts n vs' vs) (liftn ?m t 0))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>partial</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>vs'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>vs</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vsubsts n [] vs = vs"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vsubsts_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>map_idI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>v</span><span> </span><span>vs'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>n'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' = n - 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Suc_n'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n' = n"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n'_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vs'_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length vs' ≤ n'"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n'_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?m'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"n' - length vs'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m'_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?m' = n - length (v # vs')"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?app_vars t n (v # vs') vs = ?app_vars t (Suc n') (v # vs') vs"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Suc_n'</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ var_dist vs' ((Abs^^Suc n') (var_dist vs (liftn (Suc n') t 0)) ° Var v)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>var_dist_Cons</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ ?app_vars t n' vs' (vsubsts n [v] vs)"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>var_dist_cong</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λvv. vsubst vv (v + n') n') vs = vsubsts n [v] vs"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Suc_n'</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>vsubsts_def</span><span> </span><span>vsubst_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(var_dist vs (liftn (Suc n') t 0))[liftn n' (Var v) 0/n']
                  = var_dist (vsubsts n [v] vs) (liftn n' t 0)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>var_dist_subst_Var</span><span> </span><span>subst_liftn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^Suc n') (var_dist vs (liftn (Suc n') t 0)) ° Var v
                  ↔ (Abs^^n') (var_dist (vsubsts n [v] vs) (liftn n' t 0))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>absn_beta_equiv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>term_trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ (Abs^^?m') (var_dist (vsubsts n' vs' (vsubsts n [v] vs)) (liftn ?m' t 0))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vs'_length</span><span> </span><span>Cons.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Abs^^?m') (var_dist (vsubsts n (v # vs') vs) (liftn ?m' t 0))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vsubsts n' vs' (vsubsts (Suc n') [v] vs) = vsubsts (Suc n') (v # vs') vs"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vsubsts_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vs'_length</span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>linarith_split_limit</span><span class="delimiter">=</span><span>10</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Suc_n'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>m'_conv</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>partial_appd</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>vs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vs' = map (λi. n - perm_vars_inv n vs (n - i - 1) - 1) [0..&lt;n]"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>perm_vars</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vs_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length vs = n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>perm_vars_length</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vs'_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length vs' = n"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vs'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λv. vs' ! (n - v - 1)) vs = rev [0..&lt;n]"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length vs = length (rev [0..&lt;n])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vs_length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 (λv v'. vs' ! (n - v - 1) = v') vs (rev [0..&lt;n])"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length vs"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; n"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vs_length</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vs ! i &lt; n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>perm_vars</span><span> </span><span>perm_vars_nth_lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; n›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vs' ! (n - vs ! i - 1) = n - perm_vars_inv n vs (vs ! i) - 1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vs'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; n›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = n - i - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>perm_vars</span><span> </span><span>perm_vars_inv_nth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; n›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = rev [0..&lt;n] ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rev_nth</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vs' ! (n - vs ! i - 1) = rev [0..&lt;n] ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list.rel_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list.rel_map</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vs'_vs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vsubsts n vs' vs = rev [0..&lt;n]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vsubsts_def</span><span> </span><span>vs'_length</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>perm_vars</span><span> </span><span>perm_vars_lt</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>map_ext</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?appd_vars</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λt n. var_dist (rev [0..&lt;n]) t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>not_free</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈frees t. n ≤ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?app_vars t n vs' vs ↔ ?appd_vars t n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>partial_appd</span><span class="delimiter">[</span><span>of</span><span> </span><span>vs'</span><span class="delimiter">]</span><span> </span><span>vs'_length</span><span> </span><span>vs'_vs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^n) (?app_vars t n vs' vs) ↔ (Abs^^n) (?appd_vars t n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>absn_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ strip_context n t 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_free</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>absn_dist_eta_free</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^n) (?app_vars t n vs' vs) ↔ strip_context n t 0"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>that</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>liftn_absn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"liftn n ((Abs^^m) t) k = (Abs^^m) (liftn n t (k + m))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>m</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>liftn_var_dist_lt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀i∈set vs. i &lt; k ⟹ liftn n (var_dist vs t) k = var_dist vs (liftn n t k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>vs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>liftn_context_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≤ k' ⟹ ∀i∈frees t. i &lt; k ∨ k' ≤ i ⟹ liftn n t k = liftn n t k'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>k</span><span> </span><span>k'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Abs</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈frees t. i &lt; Suc k ∨ Suc k' ≤ i"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ frees t"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; Suc k ∨ Suc k' ≤ i"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≠ 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Abs.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. free t (Suc i) ⟶ i &lt; k ∨ k' ≤ i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. 0 &lt; i ∧ free t i ⟶ i - 1 &lt; k ∨ k' ≤ i - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. 0 &lt; i ∧ free t i ⟶ i &lt; Suc k ∨ Suc k' ≤ i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i ≠ 0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i ∈ frees t›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Abs.IH</span><span> </span><span>Abs.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>liftn_liftn0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈frees t. k ≤ i ⟹ liftn n t k = liftn n t 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>liftn_context_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dist_perm_eta_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>perm_vars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"perm_vars n vs"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>not_free</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈frees s. n ≤ i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈frees t. n ≤ i"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>perm_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^n) (var_dist vs s) ↔ (Abs^^n) (var_dist vs t)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strip_context n s 0 ↔ strip_context n t 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>perm_vars</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vs_lt_n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈set vs. i &lt; n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>perm_vars_lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>vs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>etas</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t. ∀i∈frees t. n ≤ i ⟹
          (Abs^^n) (var_dist vs' ((Abs^^n) (var_dist vs (liftn n t 0)))) ↔ strip_context n t 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>perm_vars</span><span> </span><span>dist_perm_eta</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strip_context n s 0 ↔ (Abs^^n) (var_dist vs' ((Abs^^n) (var_dist vs (liftn n s 0))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>etas</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>term_sym</span><span class="delimiter">]</span><span> </span><span>not_free</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ (Abs^^n) (var_dist vs' ((Abs^^n) (var_dist vs (liftn n t 0))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>absn_cong</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>var_dist_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^n) (var_dist vs (liftn n s 0)) = (Abs^^n) (var_dist vs (liftn n s n))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_free</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>liftn_liftn0</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Abs^^n) (liftn n (var_dist vs s) n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vs_lt_n</span><span> </span><span>liftn_var_dist_lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = liftn n ((Abs^^n) (var_dist vs s)) 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>liftn_absn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ liftn n ((Abs^^n) (var_dist vs t)) 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>perm_equiv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equiv_liftn</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Abs^^n) (liftn n (var_dist vs t) n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>liftn_absn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Abs^^n) (var_dist vs (liftn n t n))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vs_lt_n</span><span> </span><span>liftn_var_dist_lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (Abs^^n) (var_dist vs (liftn n t 0))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_free</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>liftn_liftn0</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^n) (var_dist vs (liftn n s 0)) ↔ ..."</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ strip_context n t 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>etas</span><span> </span><span>not_free</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹General notion of bracket abstraction for lambda terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>foldr_option</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b ⇒ 'b option) ⇒ 'a list ⇒ 'b ⇒ 'b option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"foldr_option f xs e = foldr (λa b. Option.bind b (f a)) xs (Some e)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_eq_SomeE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Option.bind x f = Some y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = Some x'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x' = Some y"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>iff</span><span class="delimiter">:</span><span> </span><span>bind_eq_Some_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldr_option_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"foldr_option f [] e = Some e"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>foldr_option_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldr_option_Cons_SomeE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"foldr_option f (x#xs) e = Some y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>y'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"foldr_option f xs e = Some y'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x y' = Some y"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>foldr_option_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>bind_eq_SomeE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>bracket_abstraction</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>term_bracket</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ dB ⇒ dB option"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bracket_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_bracket i s = Some s' ⟹ s' ° Var i ↔ s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bracket_frees</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_bracket i s = Some s' ⟹ frees s' = frees s - {i}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>term_brackets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list ⇒ dB ⇒ dB option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_brackets = foldr_option term_bracket"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_brackets_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_brackets [] t = Some t"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>term_brackets_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_brackets_Cons_SomeE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_brackets (v#vs) t = Some t'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>s'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_brackets vs t = Some s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_bracket v s' = Some t'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>term_brackets_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>foldr_option_Cons_SomeE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_brackets_ConsI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_brackets vs t = Some t'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_bracket v t' = Some t''"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_brackets (v#vs) t = Some t''"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>term_brackets_def</span><span> </span><span>foldr_option_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_brackets_dist</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_brackets vs t = Some t'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"var_dist vs t' ↔ t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀t''. t' ↔ t'' ⟶ var_dist vs t'' ↔ t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>vs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>term_sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>v</span><span> </span><span>vs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>inner</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_brackets vs t = Some u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_bracket v u = Some t'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>term_brackets_Cons_SomeE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>step</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>red1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t' ° Var v ↔ u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bracket_app</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>rule</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t''</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t' ↔ t''"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>red1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t'' ° Var v ↔ u"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>term_sym</span><span> </span><span>term_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"var_dist (v # vs) t'' = var_dist vs (t'' ° Var v)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inner</span><span class="delimiter">]</span><span> </span><span>red</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"var_dist (v # vs) t'' ↔ t"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* locale bracket_abstraction *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">paragraph</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bracket abstraction for idiomatic terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We consider idiomatic terms with explicitly assigned variables.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_unlift_vars</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque x = []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strip_context n (unlift_vars n x) 0 = unlift_vars 0 x"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>strip_context_liftn</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>0</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unlift_vars_frees</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈frees (unlift_vars n x). i ∈ set (opaque x) ∨ n ≤ i"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>free_liftn</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>itrm_abstraction</span><span> </span><span class="delimiter">=</span><span> </span><span>special_idiom</span><span> </span><span>extra_rule</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>extra_rule</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat itrm ⇒ _"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>itrm_bracket</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat itrm ⇒ nat itrm option"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>itrm_bracket_ap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_bracket i x = Some x' ⟹ x' ⋄ Opaque i ≃<span class="hidden">⇧</span><sup>+</sup> x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>itrm_bracket_opaque</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"itrm_bracket i x = Some x' ⟹ set (opaque x') = set (opaque x) - {i}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets = foldr_option itrm_bracket"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>itrm_brackets_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets [] x = Some x"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>itrm_brackets_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>itrm_brackets_Cons_SomeE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets (v#vs) x = Some x'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>y'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets vs x = Some y'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_bracket v y' = Some x'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>itrm_brackets_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>foldr_option_Cons_SomeE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque_dist = fold (λi y. y ⋄ Opaque i)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>opaque_dist_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃<span class="hidden">⇧</span><sup>+</sup> y ⟹ opaque_dist vs x ≃<span class="hidden">⇧</span><sup>+</sup> opaque_dist vs y"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>opaque_dist_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>vs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ap_congL</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>itrm_brackets_dist</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>defined</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets vs x = Some x'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque_dist vs x' ≃<span class="hidden">⇧</span><sup>+</sup> x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>x''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x'' = x'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ≃<span class="hidden">⇧</span><sup>+</sup> x''"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x''_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>defined</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque_dist vs x'' ≃<span class="hidden">⇧</span><sup>+</sup> x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>opaque_dist_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>vs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x'</span><span> </span><span>x''</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>itrm_brackets_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>itrm_sym</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>v</span><span> </span><span>vs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y'</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>defined'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets vs x = Some y'"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_bracket v y' = Some x'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>itrm_brackets_Cons_SomeE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ⋄ Opaque v ≃<span class="hidden">⇧</span><sup>+</sup> y'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>itrm_bracket_ap</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x'' ⋄ Opaque v ≃<span class="hidden">⇧</span><sup>+</sup> y'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>itrm_sym</span><span> </span><span>itrm_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>defined'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fold (λi y. y ⋄ Opaque i) vs (x'' ⋄ Opaque v) ≃<span class="hidden">⇧</span><sup>+</sup> x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>itrm_brackets_opaque</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets vs x = Some x'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (opaque x') = set (opaque x) - set vs"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>vs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>itrm_brackets_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>v</span><span> </span><span>vs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>itrm_brackets_Cons_SomeE</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>itrm_bracket_opaque</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>itrm_brackets_all</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>all_opaque</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (opaque x) ⊆ set vs"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>defined</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets vs x = Some x'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque x' = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>defined</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (opaque x') = set (opaque x) - set vs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>itrm_brackets_opaque</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>all_opaque</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (opaque x') = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>itrm_brackets_all_unlift_vars</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>all_opaque</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (opaque x) ⊆ set vs"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>defined</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets vs x = Some x'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ≃<span class="hidden">⇧</span><sup>+</sup> Pure (unlift_vars 0 x')"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equiv_into_ext_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque x' = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>itrm_brackets_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ≃ Pure (unlift_vars 0 x')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_pure_unlift_vars</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* locale itrm_abstraction *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lifting with bracket abstraction›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>lifted_bracket</span><span> </span><span class="delimiter">=</span><span> </span><span>bracket_abstraction</span><span> </span><span class="delimiter">+</span><span> </span><span>itrm_abstraction</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bracket_compat</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"set (opaque x) ⊆ {0..&lt;n} ⟹ i &lt; n ⟹
      term_bracket i (unlift_vars n x) = map_option (unlift_vars n) (itrm_bracket i x)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>brackets_unlift_vars_swap</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>all_opaque</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (opaque x) ⊆ {0..&lt;n}"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vs_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set vs ⊆ {0..&lt;n}"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>defined</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets vs x = Some x'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_brackets vs (unlift_vars n x) = Some (unlift_vars n x')"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vs_bound</span><span> </span><span>defined</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>vs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>v</span><span> </span><span>vs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y'</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ivs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets vs x = Some y'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>iv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_bracket v y' = Some x'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>itrm_brackets_Cons_SomeE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_brackets vs (unlift_vars n x) = Some (unlift_vars n y')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Some (unlift_vars n x') = map_option (unlift_vars n) (itrm_bracket v y')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (opaque y') ⊆ {0..&lt;n}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_opaque</span><span> </span><span>ivs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>itrm_brackets_opaque</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v &lt; n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"term_bracket v (unlift_vars n y') = Some (unlift_vars n x')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bracket_compat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>term_brackets_ConsI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>bracket_lifting</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>all_vars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (opaque x) ∪ set (opaque y) ⊆ {0..&lt;n}"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>perm_vars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"perm_vars n vs"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>defined</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets vs x = Some x'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"itrm_brackets vs y = Some y'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>base_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^n) (unlift_vars n x) ↔ (Abs^^n) (unlift_vars n y)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃<span class="hidden">⇧</span><sup>+</sup> y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>perm_vars</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set_vs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set vs = {0..&lt;n}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>perm_vars_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_swap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_brackets vs (unlift_vars n x) = Some (unlift_vars n x')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_vars</span><span> </span><span>set_vs</span><span> </span><span>defined</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>brackets_unlift_vars_swap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y_swap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"term_brackets vs (unlift_vars n y) = Some (unlift_vars n y')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_vars</span><span> </span><span>set_vs</span><span> </span><span>defined</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>brackets_unlift_vars_swap</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>all_vars</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (opaque x) ⊆ set vs"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_vs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>complete_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque x' = []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>defined</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>itrm_brackets_all</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ux_frees</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈frees (unlift_vars n x'). n ≤ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unlift_vars_frees</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>all_vars</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (opaque y) ⊆ set vs"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_vs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>complete_y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"opaque y' = []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>defined</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>itrm_brackets_all</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uy_frees</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈frees (unlift_vars n y'). n ≤ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unlift_vars_frees</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≃<span class="hidden">⇧</span><sup>+</sup> opaque_dist vs x'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>defined</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>itrm_brackets_dist</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≃<span class="hidden">⇧</span><sup>+</sup> opaque_dist vs (Pure (unlift_vars 0 x'))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_vars</span><span> </span><span>set_vs</span><span> </span><span>defined</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>opaque_dist_cong</span><span> </span><span>itrm_brackets_all_unlift_vars</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≃<span class="hidden">⇧</span><sup>+</sup> opaque_dist vs (Pure (unlift_vars 0 y'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>opaque_dist_cong</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>pure_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Abs^^n) (var_dist vs (unlift_vars n x')) ↔ (Abs^^n) (unlift_vars n x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_swap</span><span> </span><span>term_brackets_dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ (Abs^^n) (unlift_vars n y)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>base_eq</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ↔ (Abs^^n) (var_dist vs (unlift_vars n y'))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y_swap</span><span> </span><span>term_brackets_dist</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>term_sym</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strip_context n (unlift_vars n x') 0 ↔ strip_context n (unlift_vars n y') 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>perm_vars</span><span> </span><span>ux_frees</span><span> </span><span>uy_frees</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>dist_perm_eta_equiv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unlift_vars 0 x' ↔ unlift_vars 0 y'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>strip_unlift_vars</span><span> </span><span>complete_x</span><span> </span><span>complete_y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≃<span class="hidden">⇧</span><sup>+</sup> opaque_dist vs y'"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>opaque_dist_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Pure (unlift_vars 0 y') ≃<span class="hidden">⇧</span><sup>+</sup> y'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_vars</span><span> </span><span>set_vs</span><span> </span><span>defined</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>itrm_brackets_all_unlift_vars</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>itrm_sym</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≃<span class="hidden">⇧</span><sup>+</sup> y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>defined</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>itrm_brackets_dist</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* locale lifted_bracket *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Abstract_AF">
<div class="head"><h1>Theory Abstract_AF</h1>
<span class="command">theory</span> <span class="name">Abstract_AF</span><br/>
<span class="keyword">imports</span> <a href="Applicative.html"><span class="name">Applicative</span></a> <a href="../../HOL/HOL-Probability/Adhoc_Overloading.html"><span class="name">Adhoc_Overloading</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich
   Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An abstract applicative functor›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Abstract_AF</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Applicative</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Adhoc_Overloading"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="tfree">'a</span><span> </span><span>af</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV :: 'a set"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_af</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"af_pure ≡ Abs_af"</span></span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>af_ap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) af ⇒ 'a af ⇒ 'b af"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λf x. f x"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.pure</span><span> </span><span>Abs_af</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>Applicative.ap</span><span> </span><span>af_ap</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>applicative_syntax</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>af_identity</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"af_pure id ⋄ x = x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>af_homomorphism</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"af_pure f ⋄ af_pure x = af_pure (f x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>af_ap.abs_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>af_composition</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"af_pure comp ⋄ g ⋄ f ⋄ x = g ⋄ (f ⋄ x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>af_interchange</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ⋄ af_pure x = af_pure (λg. g x) ⋄ f"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lifting_forget</span></span><span> </span><span>af.lifting</span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span>Abs_af</span><span> </span><span>Rep_af</span><span>
</span><span class="keyword1"><span class="command">hide_fact</span></span><span> </span><span>af_ap_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">applicative</span></span><span> </span><span>af</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>pure</span><span class="delimiter">:</span><span> </span><span>af_pure</span><span>
</span><span>  </span><span>ap</span><span class="delimiter">:</span><span> </span><span>af_ap</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>af_homomorphism</span><span> </span><span>af_composition</span><span> </span><span>af_identity</span><span> </span><span>af_interchange</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id_def</span><span> </span><span>comp_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Applicative_Test">
<div class="head"><h1>Theory Applicative_Test</h1>
<span class="command">theory</span> <span class="name">Applicative_Test</span><br/>
<span class="keyword">imports</span> <a href="Stream_Algebra.html"><span class="name">Stream_Algebra</span></a> <a href="Applicative_Environment.html"><span class="name">Applicative_Environment</span></a> <a href="Applicative_List.html"><span class="name">Applicative_List</span></a> <a href="Applicative_Option.html"><span class="name">Applicative_Option</span></a> <a href="Applicative_Set.html"><span class="name">Applicative_Set</span></a> <a href="Applicative_Sum.html"><span class="name">Applicative_Sum</span></a> <a href="Abstract_AF.html"><span class="name">Abstract_AF</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Joshua Schneider, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Regression tests for applicative lifting›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Applicative_Test</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Stream_Algebra</span><span>
</span><span>  </span><span>Applicative_Environment</span><span>
</span><span>  </span><span>Applicative_List</span><span>
</span><span>  </span><span>Applicative_Option</span><span>
</span><span>  </span><span>Applicative_Set</span><span>
</span><span>  </span><span>Applicative_Sum</span><span>
</span><span>  </span><span>Abstract_AF</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">unbundle</span></span><span> </span><span>applicative_syntax</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Normal form conversion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notepad</span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. x = af_pure (λx. x) ⋄ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. af_pure x = af_pure x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f x. af_pure f ⋄ x = af_pure f ⋄ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f x y. af_pure f ⋄ x ⋄ y = af_pure f ⋄ x ⋄ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀g f x. af_pure g ⋄ (f ⋄ x) = af_pure (λf x. g (f x)) ⋄ f ⋄ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f x y. f ⋄ x ⋄ y = af_pure (λf x y. f x y) ⋄ f ⋄ x ⋄ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀g f x. g ⋄ (f ⋄ x) = af_pure (λg f x. g (f x)) ⋄ g ⋄ f ⋄ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f x. f ⋄ af_pure x = af_pure (λf. f x) ⋄ f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x y. af_pure x ⋄ af_pure y = af_pure (x y)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f x y. f ⋄ x ⋄ af_pure y = af_pure (λf x. f x y) ⋄ f ⋄ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f x y. af_pure f ⋄ x ⋄ af_pure y = af_pure (λx. f x y) ⋄ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f x y z. af_pure f ⋄ x ⋄ af_pure y ⋄ z = af_pure (λx z. f x y z) ⋄ x ⋄ z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f x g y. af_pure f ⋄ x ⋄ (af_pure g ⋄ y) = af_pure (λx y. f x (g y)) ⋄ x ⋄ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f g x y. f ⋄ (g ⋄ x) ⋄ y = af_pure (λf g x y. f (g x) y) ⋄ f ⋄ g ⋄ x ⋄ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f g x y z. f ⋄ (g ⋄ x ⋄ y) ⋄ z = af_pure (λf g x y z. f (g x y) z) ⋄ f ⋄ g ⋄ x ⋄ y ⋄ z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f g x y z. f ⋄ (g ⋄ (x ⋄ af_pure y)) ⋄ z = af_pure (λf g x z. f (g (x y)) z) ⋄ f ⋄ g ⋄ x ⋄ z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f g x. f ⋄ (g ⋄ x ⋄ x) = af_pure (λf g x x'. f (g x x')) ⋄ f ⋄ g ⋄ x ⋄ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀f x y. f x ⋄ y = af_pure (λf x. f x) ⋄ f x ⋄ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) af"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'c) af"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ⋄ (f ⋄ x) = af_pure (λg f x. g (f x)) ⋄ g ⋄ f ⋄ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>rule</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO automatic test for names of new variables *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f x::'a af. f ⋄ x = x"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>applicative_nf</span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>set</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>plus</span><span class="delimiter">)</span><span> </span><span>plus</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>set_plus_def</span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(X::('a::plus)set) + Y = {plus} ⋄ X ⋄ Y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(X :: _ :: semigroup_add set) + Y + Z = X + (Y + Z)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>add.assoc</span><span class="delimiter">[</span><span>applicative_lifted</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>set</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semigroup_add</span><span class="delimiter">)</span><span> </span><span>semigroup_add</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span> </span><span>Y</span><span> </span><span>Z</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>add.assoc</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X + Y + Z = X + (Y + Z)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>set</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ab_semigroup_add</span><span class="delimiter">)</span><span> </span><span>ab_semigroup_add</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span> </span><span>Y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>add.commute</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X + Y = Y + X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sum type (a.k.a. either)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Inl plus ⋄ (x :: nat + 'e list) ⋄ x = Inl (λx. 2 * x) ⋄ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_sum (≤) (≤) (x :: nat + nat) (Inl Suc ⋄ x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>either_af</span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤) :: nat ⇒ _"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reflpI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Streams›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::int stream) * sconst 0 = sconst 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::int stream) * (y + z) = x * y + x * z"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span> </span><span>algebra</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_streams xs = foldr (smap2 Cons) xs (sconst [])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_streams_Nil</span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_streams [] = sconst []"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_streams_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_streams_Cons</span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lift_streams (x # xs) = smap2 Cons x (lift_streams xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_streams_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_unfold</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stream_append_Cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"smap2 append (smap2 Cons x ys) zs = smap2 Cons x (smap2 append ys zs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_streams_append</span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lift_streams (xs @ ys) = smap2 append (lift_streams xs) (lift_streams ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
    case could be proved directly if "lift_streams ([] @ ys) = lift_streams ys" is solved
    in head_cong_tac (invoke simplifier?) -- but only with applicative_nf
  *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_streams ys = sconst append ⋄ lift_streams [] ⋄ lift_streams ys"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_unfold</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>stream_append_Cons</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the actual lifted fact *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_unfold</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_streams (rev x) = smap rev (lift_streams x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_streams [] = smap rev (lift_streams [])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y ys. rev ys @ [y] = rev (y # ys)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y ys. smap2 append (smap rev ys) (smap2 Cons y (sconst [])) = smap rev (smap2 Cons y ys)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons.IH</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_unfold</span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>applicative_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sconcat xs = smap concat xs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sconcat (lift_streams [sconst ''Hello '', sconst ''world!'']) = sconst ''Hello world!''"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Relators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_fun (=) (≤) (const (0::nat)) x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 (⊆) (map (λ_. {}) x) (map set x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_nf</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = Some a ⟹ rel_option (≤) (map_option (λ_. a) x) (map_option Suc x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>applicative_lifting</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀g f x. rel_sum ?R (=) (ap_either f x) (ap_either (ap_either (Inl g) f) x)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>applicative_lifting</span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stream_all2 ?R (?f ⋄ (pure ?g ⋄ ?x + ?y)) (?x + ?z)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>applicative_lifting</span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">print_applicative</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>