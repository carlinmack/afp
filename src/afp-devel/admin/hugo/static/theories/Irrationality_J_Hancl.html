<div id="Irrationality_J_Hancl">
<div class="head"><h1>Theory Irrationality_J_Hancl</h1>
<span class="command">theory</span> <span class="name">Irrationality_J_Hancl</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Analysis/Analysis.html"><span class="name">Analysis</span></a> <a href="Approximation.html"><span class="name">Approximation</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Irrationality_J_Hancl.thy
  Authors:  Angeliki Koutsoukou-Argyraki and Wenda Li,
            Computer Laboratory, University of Cambridge, UK.
  Email: ak2110@cam.ac.uk, wl302@cam.ac.uk  
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Irrational Rapidly Convergent Series›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Irrationality_J_Hancl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Analysis.Analysis"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Decision_Procs.Approximation"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This is the formalisation of a proof by J. Hancl, in particular of the proof of his Theorem 3 in
the paper: Irrational Rapidly Convergent Series, Rend. Sem. Mat. Univ. Padova, Vol 107 (2002).

The statement asserts the irrationality of the sum of a series consisting of rational numbers
defined using sequences that fulfill certain properties. Even though the statement
is number-theoretic, the proof uses only arguments from introductory Analysis.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We show the central result (theorem Hancl3) by proof by contradiction, by making use of some of 
 the auxiliary lemmas. To this end, assuming that the sum is a rational number, for a quantity 
 $\textrm{ALPHA}(n)$ we show that $\textrm{ALPHA}(n) \geq 1$ for all $n \in \mathbb{N}$. After that we show that we can find an 
  $n \in \mathbb{N}$ for which $\textrm{ALPHA}(n) &lt; 1$ which yields a contradiction and we thus conclude that the 
  sum of the series is a rational number. We finally give an immediate application of theorem Hancl3
 for a specific series (corollary Hancl3corollary, requiring lemma
 summable\_ln\_plus) which corresponds to Corollary 2 in the original
paper by J. Hancl. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span>floatarith.Max</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Misc›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>filterlim_sequentially_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"filterlim f F1 sequentially ⟷ filterlim (λx. f (x+k)) F1 sequentially"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>filterlim_iff</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eventually_sequentially_seg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>filterlim_realpow_sequentially_at_top</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x::real) &gt; 1 ⟹ filterlim ((^) x) at_top sequentially"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LIMSEQ_divide_realpow_zero</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>filterlim_inverse_at_top</span><span class="delimiter">,</span><span>of</span><span> </span><span>_</span><span> </span><span>1</span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>filterlim_at_top_powr_real</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>g</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'b ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"filterlim f at_top F"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(g ⤏ g') F"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g'&gt;1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"filterlim (λx. g x powr f x) at_top F"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"filterlim (λx. ((g'+1)/2) powr f x) at_top F"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>filterlim_at_top_gt</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">,</span><span>rule</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Z</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Z&gt;(1::real)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> x in F. ln Z ≤ ln (((g' + 1) / 2) powr f x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>filterlim_at_top</span><span class="delimiter">,</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ln Z / ln ((g' + 1) / 2)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>eventually_elim</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g'&gt;1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>ln_powr</span><span> </span><span>divide_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> x in F. Z ≤ ((g' + 1) / 2) powr f x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>eventually_elim</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>ln_le_cancel_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Z&gt;1›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g'&gt;1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> x in F. ((g'+1)/2) powr f x ≤ g x powr f x"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> x in F. g x &gt; (g'+1)/2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_tendstoD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g'&gt;1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> x in F. f x&gt;0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>filterlim_at_top_dense</span><span class="delimiter">,</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>eventually_elim</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g'&gt;1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>powr_mono2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>filterlim_at_top_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>powrfinitesum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ≤ n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" (∏j=s..(n::nat).(a powr (2^j)))  = a powr (∑j=s..(n::nat).(2^j)) "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ≤ n›</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword2"><span class="keyword">when</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s≤n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc.prems</span><span> </span><span>add.commute</span><span> </span><span>linorder_not_le</span><span> </span><span>powr_add</span><span> </span><span>prod.nat_ivl_Suc'</span><span> </span><span>sum.cl_ivl_Suc</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword2"><span class="keyword">when</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s=Suc n"</span></span></span><span>   
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏j = s..Suc n. a powr 2 ^ j) =(a powr 2 ^(Suc n))  "</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s=Suc n›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a powr 2 ^(Suc n) ) =  a powr sum ((^) 2) {s..Suc n}   "</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" (∏j = s..Suc n. a powr 2 ^ j) = a powr sum ((^) 2) {s..Suc n}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤Suc n›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤Suc n›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>summable_ratio_test_tendsto</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a::banach"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. f n≠0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. norm (f (Suc n)) / norm (f n)) ⇢ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"summable f"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>N_dist</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀n≥N. dist (norm (f (Suc n)) / norm (f n)) c &lt; (1-c)/2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tendsto_iff</span><span> </span><span>eventually_sequentially</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>diff_gt_0_iff_gt</span><span> </span><span>zero_less_divide_iff</span><span> </span><span>zero_less_numeral</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm (f (Suc n)) / norm (f n) ≤ (1+c)/2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">when</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n≥N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_dist</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c&lt;1›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>field_simps</span><span> </span><span>dist_norm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>argo</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"norm (f (Suc n))  ≤ (1+c)/2 * norm (f n)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">when</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n≥N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>divide_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(1+c)/2 &lt; 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c&lt;1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>summable_ratio_test</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>N</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>summable_ln_plus</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat ⇒ real"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"summable f"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. f n&gt;0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"summable (λn. ln (1+f n))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>summable_comparison_test_ev</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln (1 + f n) &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ln_gt_zero</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ln (1 + f n) ≤ f n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ln_add_one_self_le_self2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> n in sequentially. norm (ln (1 + f n)) ≤ f n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>eventuallyI</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>less_imp_le</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suminf_real_offset_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. 0 ≤ f i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"summable f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i. f (i + k)) ≤ suminf f"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. ∑i&lt;n. f (i + k)) ⇢ (∑i. f (i + k))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>summable_sums</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹summable f›</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>summable_LIMSEQ</span><span> </span><span>summable_ignore_initial_segment</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. ∑i&lt;n. f i) ⇢ (∑i. f i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>summable_sums</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹summable f›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sums_def</span><span> </span><span>atLeast0LessThan</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. ∑i&lt;n + k. f i) ⇢ (∑i. f i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LIMSEQ_ignore_initial_segment</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LIMSEQ_le</span><span class="delimiter">,</span><span> </span><span>safe</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≤ n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i&lt;n. f (i + k)) = (∑i&lt;n. (f ∘ (λi. i + k)) i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑i∈(λi. i + k) ` {..&lt;n}. f i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum.reindex</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ sum f {..&lt;n + k}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>sum_mono2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i&lt;n. f (i + k)) ≤ sum f {..&lt;n + k}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span>n</span><span> </span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≤ n"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" (∑i=s..n. 2^i) &lt; (2^(n+1) :: real) "</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span>  </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword2"><span class="keyword">when</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"s=n+1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword2"><span class="keyword">when</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ≠ n+1"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span class="string"><span class="delete"><span class="delete">"(∑i=s..(n+1). 2^i ) = (∑i=s..n. 2^i ) + (2::real)^(n+1) "</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum.cl_ivl_Suc</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ≤ Suc n ›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... &lt; (2) ^ (n +1) + (2)^(n+1)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≤n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹s ≤ Suc n ›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ≤ n›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = 2^(n+2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i=s..(Suc n). 2^i )&lt; (2::real)^(Suc n+1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary lemmas and the main proof›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>showpre7</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒int "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>q</span><span> </span><span>p</span><span class="delimiter">::</span><span>int</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p&gt;0"</span></span></span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. a n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. b n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>assumerational</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(λ n. b (n+1) / a (n+1) )  sums (p/q)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q*((∏j=1..n. of_int( a j)))*(suminf (λ(j::nat). (b (j+n+1)/ a (j+n+1 )))) 
        = ((∏j=1..n. of_int( a j)))*(p -q* (∑j=1..n. b j / a j))       "</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>aa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"aa=(∏j = 1..n. real_of_int (a j))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ff</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ff=(λi. real_of_int (b (i+1)) / real_of_int (a (i+1)))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j. ff (j+n)) =  (∑n. ff n) - sum ff {..&lt;n}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>suminf_minus_initial_segment</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assumerational</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sums_summable</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = p/q - sum ff {..&lt;n}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assumerational</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sums_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = p/q - (∑j=1..n. ff (j-1))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum ff {..&lt;n} = (∑j=1..n. ff (j-1))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_bounds_lt_plus1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j. ff (j + n)) = p / q - (∑j = 1..n. ff (j - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q*(∑j. ff (j + n)) = p - q*(∑j = 1..n. ff (j - 1))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹q&gt;0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"aa*q*(∑j. ff (j + n)) = aa*(p - q*(∑j = 1..n. ff (j - 1)))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>aa_def</span><span> </span><span>ff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>show7</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>d</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒int "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>q</span><span> </span><span>p</span><span class="delimiter">::</span><span>int</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ≥1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≥ 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. a n ≥ 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. b n ≥ 1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assumerational</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(λ n. b (n+1) / a (n+1) ) sums (p/q)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q*((∏j=1..n. of_int( a j)))*( suminf (λ (j::nat). (b (j+n+1)/ a (j+n+1 )))) ≥ 1 "</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L ≥ _"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>LL</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LL=?L"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>aa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"aa=(∏j = 1..n. real_of_int (a j))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ff</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ff=(λi. real_of_int (b (i+1)) / real_of_int (a (i+1)))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"aa &gt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>aa_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>int_one_le_iff_zero_less</span><span> </span><span>prod_pos</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j. ff (j + n)) &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>suminf_pos</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"summable ff"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assumerational</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>summable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" summable (λj. ff (j + n))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>summable_iff_shift</span><span class="delimiter">[</span><span>of</span><span> </span><span>ff</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ∀i. 0 &lt; ff (i + n)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>int_one_le_iff_zero_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>aa_def</span><span> </span><span>ff_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹q≥1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L ∈ ℤ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = aa *(p -q* ( ∑j=1..n. b j / a j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>aa_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>showpre7</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>int_one_le_iff_zero_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = aa * p - q * (∑j=1..n. aa * b j / a j)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>algebra_simps</span><span> </span><span>sum_distrib_left</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = prod a {1..n} * p - q * (∑j = 1..n. b j * prod a ({1..n} - {j}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j=1..n. aa * b j / a j) = (∑j=1..n. b j * prod a ({1..n} - {j}))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>of_int_sum</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {1..n}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏i = 1..n. real_of_int (a i)) = a x * (∏i∈{1..n} - {x}. real_of_int (a i))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>prod.remove</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"aa / real_of_int (a x) = prod a ({1..n} - {x})"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>aa_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"aa * b x / a x = b x * prod a ({1..n} - {x})"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult.commute</span><span> </span><span>of_int_mult</span><span> </span><span>times_divide_eq_right</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"aa * p = (∏j = 1..n.  (a j)) *  p"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>aa_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ∈ ℤ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ints_of_int</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>LL_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ints_cases</span><span> </span><span>int_one_le_iff_zero_less</span><span> </span><span>not_less</span><span> </span><span>of_int_0_less_iff</span><span> </span><span>of_int_less_1_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>show8</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>d</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒real "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat⇒int"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>k</span><span class="delimiter">::</span><span>nat</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A &gt; 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. d n&gt; 1"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀n. a n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s&gt;0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"convergent_prod d"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assu2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n ≥ s. ( A/ (of_int (a n)) powr(1/of_int (2^n)))&gt; prodinf (λj. d(n +j))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n≥s. prodinf (λj. d(j+n)) &lt; A/(Max ((λ(j::nat). 
                  (of_int (a j)) powr(1 /of_int (2^j))) ` {s..n}))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span class="delimiter">,</span><span>rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≤ n"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>sp</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sp = (λn. prodinf (λj. d(j+n)))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ff</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ff = (λ(j::nat). (real_of_int (a j)) powr(1 /of_int (2^j)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sp i ≥ sp n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">when</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i≤n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏j. d (j + i)) = (∏ia. d (ia + (n - i) + i)) * (∏ia&lt;n - i. d (ia + i))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prodinf_split_initial_segment</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹convergent_prod d›</span></span></span><span> </span><span>convergent_prod_iff_shift</span><span class="delimiter">[</span><span>of</span><span> </span><span>d</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"j+i"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sp i = sp n * (∏j&lt;n - i. d (i + j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sp_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n≥i›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sp i&gt;1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sp n&gt;1"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sp_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>convergent_prod_iff_shift</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹convergent_prod d›</span></span></span><span> </span><span>d</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>less_1_prodinf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏j&lt;n - i. d (i + j)) ≥1"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prod_ge_1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d</span><span> </span><span>less_imp_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j≥s. A / ff j &gt; sp j"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff_def</span><span> </span><span>sp_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assu2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j. s≤j ∧ j≤n ⟶ A / ff j &gt; sp n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sp n&lt; A / Max (ff ` {s..n})"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Max_in</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n≥s›</span></span></span><span> </span><span>atLeastAtMost_iff</span><span> </span><span>empty_iff</span><span> 
</span><span>        </span><span>finite_atLeastAtMost</span><span> </span><span>finite_imageI</span><span> </span><span>imageE</span><span> </span><span>image_is_empty</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>auxiliary1_9</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>d</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒int "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>m</span><span class="delimiter">::</span><span>nat</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. d n&gt; 1"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. a n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≥ m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" m ≥ s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>auxifalse_assu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n≥m. (of_int (a (n+1))) powr(1 /of_int (2^(n+1))) &lt;
              (d (n+1))* (Max ((λ (j::nat). (of_int (a j)) powr(1 /of_int (2^j))) ` {s..n} ))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(of_int (a (n+1))) powr(1 /of_int (2^(n+1))) &lt;
    (∏j=(m+1)..(n+1). d j) * (Max ((λ (j::nat). (of_int (a j)) powr(1 /of_int (2^j))) ` {s..m}))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ff</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ff = (λ(j::nat). (real_of_int (a j)) powr(1 /of_int (2^j)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ff j &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>j</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>of_int_0_less_iff</span><span> </span><span>powr_gt_zero</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ff_asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ff (n+1) &lt; d (n+1) * Max (ff ` {s..n})"</span></span></span><span> </span><span class="keyword2"><span class="keyword">when</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n≥m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>auxifalse_assu</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n≥m›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Max( ff ` {s..n} )) ≤ (∏j=(m+1)..n. d j)* (Max (ff ` {s..m}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m≥s›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword2"><span class="keyword">when</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m=Suc n"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword2"><span class="keyword">when</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m≠Suc n"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≤ n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Max (ff ` {s..n}) ≤ prod d {m + 1..n} * Max (ff ` {s..m})"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max (ff ` {s..Suc n}) = Max (ff ` {s..n} ∪ {ff (Suc n)})"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.prems</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>atLeastAtMostSuc_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = max (Max (ff ` {s..n})) (ff (Suc n))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.prems</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>max_def</span><span> </span><span>sup_assoc</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ max (Max (ff ` {s..n})) (d (n+1) * Max (ff ` {s..n}))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>max.mono</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ff_asm</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ m ≤ Suc n›</span></span></span><span> </span><span>that</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤m›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ Max (ff ` {s..n}) * max 1 (d (n+1))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max (ff ` {s..n}) ≥0"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Max_in</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀j. 0 &lt; ff j›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m ≤ n›</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>atLeastAtMost_iff</span><span> </span><span>empty_iff</span><span> </span><span>finite_atLeastAtMost</span><span> </span><span>finite_imageI</span><span> </span><span>imageE</span><span> 
</span><span>              </span><span>image_is_empty</span><span> </span><span>less_eq_real_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max_mult_distrib_right</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_mult_distrib_right</span><span> </span><span>mult.commute</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = Max (ff ` {s..n}) * d (n+1)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n+1"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤  prod d {m + 1..n} * Max (ff ` {s..m}) * d (n+1)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>d</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n+1"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = prod d {m + 1..n+1} * Max (ff ` {s..m})"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n≥m›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>prod.nat_ivl_Suc'</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d (n+1) * Max (ff ` {s..n} ) ≤ (∏j=(m+1)..(n+1). d j)* (Max (ff ` {s..m}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m≤n›</span></span></span><span> </span><span>d</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>prod.nat_ivl_Suc'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ff_asm</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m≤n›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>show9</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>d</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒real "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat⇒int "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"A &gt; 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. d n&gt; 1"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. a n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s&gt;0"</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assu1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(( λ n. (of_int (a n)) powr(1 /of_int (2^n)))⤏ A) sequentially "</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"convergent_prod d"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n≥s. prodinf (λj. d( n+j)) 
                  &lt; A/(Max ((λ(j::nat). (of_int (a j)) powr(1 /of_int (2^j))) ` {s..n})) "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀m ≥s. ∃n≥m.  ( (of_int (a (n+1))) powr(1 /of_int (2^(n+1))) ≥
          (d (n+1))* (Max ( ( λ (j::nat). (of_int (a j)) powr(1 /of_int (2^j))) ` {s..n} )))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ff</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ff = (λ(j::nat). (real_of_int (a j)) powr(1 /of_int (2^j)))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assumptioncontra</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ¬ (∀m ≥s. ∃n≥m.  ( (ff (n+1)) ≥ (d (n+1))* (Max ( ff  ` {s..n}))))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span>  </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t≥s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ttt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"  ∀n≥t.  ( (ff (n+1)) &lt; (d (n+1))* (Max ( ff ` {s..n} ) ))"</span></span></span><span>               
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B=prodinf (λj. d(t+1+j))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B&gt;0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>B_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>less_0_prodinf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>convergent_prod_iff_shift</span><span class="delimiter">[</span><span>of</span><span> </span><span>d</span><span> </span><span class="string"><span class="delete"><span class="delete">"t+1"</span></span></span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹convergent_prod d›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d</span><span> </span><span>le_less_trans</span><span> </span><span>zero_le_one</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≤ B * Max ( ff ` {s..t})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tendsto_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>sequentially</span><span> </span><span class="string"><span class="delete"><span class="delete">"λn. (∏j=(t+1)..(n+1). d j) * Max ( ff ` {s..t})"</span></span></span><span> </span><span>_</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"λn. ff (n+1)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. ff (n + 1)) ⇢ A"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assu1</span><span class="delimiter">[</span><span>folded</span><span> </span><span>ff_def</span><span class="delimiter">]</span><span> </span><span>LIMSEQ_ignore_initial_segment</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. prod d {t + 1..n + 1}) ⇢ B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. ∏i≤n. d (t + 1 + i)) ⇢ B"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>convergent_prod_LIMSEQ</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λj. d(t+1+j))"</span></span></span><span class="delimiter">,</span><span>folded</span><span> </span><span>B_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹convergent_prod d›</span></span></span><span> </span><span>convergent_prod_iff_shift</span><span class="delimiter">[</span><span>of</span><span> </span><span>d</span><span> </span><span class="string"><span class="delete"><span class="delete">"t+1"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. ∏i∈{0..n}. d (i+(t + 1))) ⇢ B"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atLeast0AtMost</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. prod d {(t + 1)..n + (t + 1)}) ⇢ B"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>prod.shift_bounds_cl_nat_ivl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>seq_offset_neg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"t"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. prod d {t + 1..n+1}) ⇢ B"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>Lim_transform</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LIMSEQ_I</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"t+1"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. prod d {t + 1..n + 1} * Max (ff ` {s..t})) ⇢ B * Max (ff ` {s..t})"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>tendsto_eq_intros</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> n in sequentially. (ff (n+1)) &lt; (∏j=(t+1)..(n+1). d j) * (Max ( ff ` {s..t}))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eventually_sequentially</span><span> </span><span>ff_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>auxiliary1_9</span><span class="delimiter">[</span><span>OF</span><span> </span><span>d</span><span> </span><span>a</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s&gt;0›</span></span></span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t≥s›</span></span></span><span> </span><span>ttt</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ff_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> n in sequentially. (ff (n+1)) ≤ (∏j=(t+1)..(n+1). d j) * (Max ( ff ` {s..t}))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>eventually_elim</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ B * Max ( ff ` {s..t+1})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max (ff ` {s..t}) ≤ Max (ff ` {s..t + 1})"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Max_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹t≥s›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B&gt;0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≤ B * Max (ff ` {s..t + 1})"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>B_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B &lt; A / Max (ff ` {s..t + 1})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>8</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"t+1"</span></span></span><span class="delimiter">,</span><span>folded</span><span> </span><span>ff_def</span><span> </span><span>B_def</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤t›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max (ff ` {s..t+1})&gt;0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ≤ B * Max (ff ` {s..t + 1})›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B&gt;0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A&gt;1›</span></span></span><span>
</span><span>      </span><span>zero_less_mult_pos</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>B</span><span> </span><span class="string"><span class="delete"><span class="delete">"Max (ff ` {s..Suc t})"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>show10</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>d</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒real "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>a</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒int "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. d n&gt; 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. a n&gt;0"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" s&gt;0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>9</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀m ≥s. ∃n≥m.  ((of_int (a (n+1))) powr(1 /of_int (2^(n+1))) ≥
          (d (n+1))* (Max ((λ(j::nat). (of_int (a j)) powr(1 /of_int (2^j))) ` {s..n} )))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀m≥s. ∃n≥m. (((d (n+1))powr(2^(n+1))) * (∏j=1..n. of_int( a j)) * 
            (1/ (∏j=1..s-1. (of_int( a j) )))) ≤ (a (n+1)) "</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span class="delimiter">,</span><span>rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≤ m"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>9</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n≥m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>asm_9</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"( (of_int (a (n+1))) powr(1 /of_int (2^(n+1))) ≥
          (d (n+1))* (Max ( ( λ (j::nat). (of_int (a j)) powr(1 /of_int (2^j))) ` {s..n} )))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤m›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s≤n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>prod</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(∏j=1..n. real_of_int( a j)) * ( 1/ (∏j=1..s-1. (of_int( a j) )))
          = (∏j=s..n. of_int( a j))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f= (λj. real_of_int( a j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{Suc 0..n}= {Suc 0..s - Suc 0} ∪ {s..n}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n≥s›</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹s &gt;0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏j=1..n. f j) = (∏j=1..s-1. f j) * (∏j=s..n. f j)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>prod.union_disjoint</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏j=1..s-1. f j) &gt; 0 "</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>linordered_semidom_class.prod_pos</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏j=1..s-1. f j) ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>argo</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" (((d (n+1))powr(2^(n+1) )) * (∏j=1..n. of_int( a j)) * ( 1/ (∏j=1..s-1. (of_int( a j) ))))
                =(((d (n+1))powr(2^(n+1) )) * (∏j=s..n. of_int( a j)))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f= (λj. real_of_int( a j))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = (d (n+1))powr(2^(n+1))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>f_def</span><span> </span><span>c_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"... ≤ ((d (n+1))powr(2^(n+1) ) * (∏i=s..n. (Max(( λ (j::nat). ( of_int( a j) powr(1 /real_of_int (2^j)) )) ` {s..n  } ))   powr(2^i)) )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mult_left_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (d (n + 1)) powr 2 ^ (n + 1)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏j = s..n. real_of_int (a j))
    ≤ (∏i = s..n.
           Max ((λj. real_of_int (a j) powr (1 / real_of_int (2 ^ j))) `
                {s..n}) powr
           2 ^ i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prod_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ {s..n}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real_of_int (a i) = (real_of_int (a i) powr (1 / real_of_int (2 ^ i))) powr 2 ^ i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>powr_powr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>less_eq_real_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"… ≤  (Max(( λ (j::nat). ( real_of_int( a j) powr(1 /real_of_int (2^j)))) ` {s..n}))powr(2^i)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>powr_mono2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real_of_int (a i) powr (1 / real_of_int (2 ^ i))
                  ≤ Max ((λj. real_of_int (a j) powr (1 / real_of_int (2 ^ j))) ` {s..n})"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Max_ge</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real_of_int (a i) ≤ Max ((λj. real_of_int (a j) powr (1 / real_of_int (2 ^ j))) ` {s..n}) powr 2 ^ i"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ real_of_int (a i) ∧
         real_of_int (a i)
         ≤ Max ((λj. real_of_int (a j) powr (1 / real_of_int (2 ^ j))) `
                 {s..n}) powr
            2 ^ i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>i</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹real_of_int (a i) = (real_of_int (a i) powr (1 / real_of_int (2 ^ i))) powr 2 ^ i›</span></span></span><span> 
</span><span>            </span><span>powr_ge_pzero</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ((d (n+1))powr(2^(n+1) )) * (Max(( λ (j::nat). ( of_int( a j) powr 
                      (1 /of_int (2^j)) )) ` {s..n  } )) powr (∑i=s..n. 2^i ) "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"((d (n+1))powr(2^(n+1) ))≥1  "</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Transcendental.log_one</span><span>  </span><span>d</span><span> </span><span>le_powr_iff</span><span> </span><span>zero_le_numeral</span><span> </span><span>zero_le_power</span><span> </span><span>zero_less_one</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏i=s..n. (Max(( λ (j::nat). ( of_int( a j) powr(1 /real_of_int (2^j)) )) ` {s..n  } ) )   powr(2^i))     = (Max(( λ (j::nat). ( of_int( a j) powr(1 /of_int (2^j)) )) ` {s..n  } )) powr (∑i=s..n. 2^i )  "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ff</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ff = Max (( λ (j::nat). ( of_int( a j) powr(1 /real_of_int (2^j)) )) ` {s..n  } )"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>ff_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤n›</span></span></span><span>  </span><span>powrfinitesum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤   ((d (n+1))powr(2^(n+1) )) * 
                (Max(( λ (j::nat).( of_int( a j) powr(1 /of_int (2^j)) )) ` {s..n  })) powr(2^(n+1))   "</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ff</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ff = Max (( λ (j::nat). ( of_int( a j) powr(1 /real_of_int (2^j)) )) ` {s..n  } )"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" sum ((^) 2) {s..n} &lt; (2::real) ^ (n + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>factt</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤n›</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ≤ ff"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S=(λ(j::nat). ( of_int( a j) powr(1 /real_of_int (2^j)) )) ` {s..n  }"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S≠{}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤n›</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈S. x≥1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ( of_int( a s) powr(1 /real_of_int (2^s)) ) ≥ 1  "</span></span></span><span>  
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ge_one_powr_ge_zero</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>int_one_le_iff_zero_less</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ( of_int( a s) powr(1 /real_of_int (2^s)) ) ∈ S"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rev_image_eqI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤n›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_ge_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span>ff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (d (n + 1)) powr 2 ^ (n + 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>fold</span><span> </span><span>ff_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mult_left_mono</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>powr_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... =  ((d (n+1)) * 
                      (Max((λj. (of_int( a j) powr(1 /of_int (2^j)))) ` {s..n}))) powr(2^(n+1))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = (λj. real_of_int (a j) powr (1 / real_of_int (2 ^ j))) ` {s..n}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d (n + 1) ≥0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n+1"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>argo</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max ss ≥0"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a s) powr (1 /  (2 ^ s)) ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a s) powr (1 /  (2 ^ s)) ∈ ss"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ss_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>rev_image_eqI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤n›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ss"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ss_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤n›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_ge_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span>ss</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>ss_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>powr_mult</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ (real_of_int (a (n + 1)) powr (1 / real_of_int (2 ^ (n + 1)))) powr 2 ^ (n + 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = (λj. real_of_int (a j) powr (1 / real_of_int (2 ^ j))) ` {s..n}"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>ss_def</span><span class="delimiter">,</span><span>rule</span><span> </span><span>powr_mono2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max ss ≥0"</span></span></span><span> </span><span class="comment">― ‹NOTE: we are repeating the same proof, so it may be a good idea to put 
                            this conclusion in an outer block so that it can be reused 
                            (without reproving).›</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a s) powr (1 /  (2 ^ s)) ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a s) powr (1 /  (2 ^ s)) ∈ ss"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ss_def</span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>rev_image_eqI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤n›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ss"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ss_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s≤n›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_ge_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span>ss</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d (n + 1) ≥0"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n+1"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>argo</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (d (n + 1)) * Max ss"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(d (n + 1)) * Max ss ≤ real_of_int (a (n + 1)) powr (1 / real_of_int (2 ^ (n + 1)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm_9</span><span class="delimiter">[</span><span>folded</span><span> </span><span>ss_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... =  (of_int (a (n+1)))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>less_eq_real_def</span><span> </span><span>pos_add_strict</span><span> </span><span>powr_powr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n≥m. d (n + 1) powr 2 ^ (n + 1) * (∏j = 1..n. real_of_int (a j)) *
                (1 / (∏j = 1..s - 1. real_of_int (a j)))
                ≤ real_of_int (a (n + 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n≥m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m≥s›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>n</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lasttoshow</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>d</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒real "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒int "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>q</span><span class="delimiter">::</span><span>int</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. d n&gt; 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀n. a n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q&gt;0"</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A &gt; 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀n. b n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>9</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀m≥s. ∃n≥m. ((of_int (a (n+1))) powr(1 /of_int (2^(n+1))) ≥
          (d (n+1))* (Max ((λ(j::nat). (of_int (a j)) powr(1 /of_int (2^j))) ` {s..n} )))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assu3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"filterlim( λ n. (d n)^(2^n)/ b n) at_top sequentially "</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> n in sequentially. (∑j. (b (n + j)) /  (a (n + j))) ≤ 2 * b n / a n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n. q*((∏j=1..n. real_of_int(a j))) * suminf (λ(j::nat). (b (j+n+1)/ a (j+n+1)))&lt;1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>as</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as=(∏j = 1..s - 1. real_of_int (a j))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n≥s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n_def1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"real_of_int q * as * 2 
      * real_of_int (b (n + 1)) / d (n + 1) powr 2 ^ (n + 1) &lt; 1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n_def2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"d (n + 1) powr 2 ^ (n + 1) * (∏j = 1..n. real_of_int (a j)) * (1 / as) 
          ≤ real_of_int (a (n + 1))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n_def3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(∑j. (b (n+1 + j)) /  (a (n+1 + j))) ≤ 2 * b (n+1) / a (n+1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(λn. real_of_int (b n) / d n ^ 2 ^ n) ⇢ 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tendsto_inverse_0_at_top</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assu3</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. real_of_int (b n) / d n powr 2 ^ n) ⇢ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d n ^ 2 ^ n = d n powr (of_nat (2 ^ n))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>powr_realpow</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tendsto_mult_right_zero</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"q * as * 2"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. q * as * 2 * b n / d n powr 2 ^ n) ⇢ 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> n in sequentially. q * as * 2 * b n / d n powr 2 ^ n &lt; 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>order_tendstoD</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> n in sequentially. q * as * 2 * b n / d n powr 2 ^ n &lt; 1 
                  ∧ (∑j. (b (n + j)) /  (a (n + j))) ≤ 2 * b n / a n"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eventually_elim</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>N_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀n≥N. q * as * 2 * b n / d n powr 2 ^ n &lt; 1 
            ∧ (∑j. (b (n + j)) /  (a (n + j))) ≤ 2 * b n / a n"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eventually_sequentially</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n≥s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n≥N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"d (n + 1) powr 2 ^ (n + 1) 
                * (∏j = 1..n. of_int (a j)) * (1 / as) ≤ real_of_int (a (n + 1))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>show10</span><span class="delimiter">[</span><span>OF</span><span> </span><span>d</span><span> </span><span>a</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s&gt;0›</span></span></span><span> </span><span>9</span><span class="delimiter">,</span><span>folded</span><span> </span><span>as_def</span><span class="delimiter">,</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"max s N"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>N_def</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n+1"</span></span></span><span class="delimiter">]</span><span> </span><span>that</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>pa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pa = (∏j = 1..n. real_of_int (a j))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>dn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dn = d (n + 1) powr 2 ^ (n + 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"dn &gt;0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as &gt; 0"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>d</span><span> </span><span>not_le</span><span> </span><span>numeral_One</span><span> </span><span>powr_gt_zero</span><span> </span><span>zero_le_numeral</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>as_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>prod_pos</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"pa&gt;0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pa_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prod_pos</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q* (∏j=1..n. real_of_int (a j)) * suminf (λ (j::nat). (b (j+n+1)/ a (j+n+1)))
              ≤q* (∏j=1..n. real_of_int (a j)) *2* (b (n+1))/(a( n+1))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>pa_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_left_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_def3</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"real_of_int q * pa"</span></span></span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹n≥s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pa&gt;0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹q&gt;0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>algebra_simps</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>KK</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"... ≤ 2*q* (∏j=1..n. real_of_int (a j)) * (b(n+1))*
      ((∏j=1..s-1. real_of_int( a j))/((d (n+1))powr(2^(n+1)) * (∏j=1..n. real_of_int ( a j))))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" dn * pa * (1 / as) ≤ real_of_int (a (n + 1))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_def2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dn_def</span><span> </span><span>pa_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>pa_def</span><span> </span><span>dn_def</span><span> </span><span>as_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pa&gt;0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹q&gt;0›</span></span></span><span> </span><span>a</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span class="delimiter">]</span><span> </span><span>b</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>divide_simps</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>KKK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (q* ((∏j=1..(s-1). real_of_int( a j)))*2
                                * (b (n+1)))/ ((d (n+1))powr(2^(n+1)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>as_def</span><span> </span><span>pa_def</span><span> </span><span>dn_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; pa›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>KKKK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"... &lt; 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_def1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>as_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>d</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒real "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒int "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A</span><span class="delimiter">::</span><span>real</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A &gt; 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. d n&gt; 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. a n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀n. b n&gt;0"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assu1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(( λ n. (of_int (a n)) powr(1 /of_int (2^n)))⤏ A) sequentially "</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assu3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"filterlim ( λ n. (d n)^(2^n)/ b n) at_top sequentially"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"convergent_prod d"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>issummable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"summable (λj. b j / a j)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>show5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> n in sequentially. (∑j. (b (n + j)) / (a (n + j))) ≤ 2 * b n / a n"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = (λj. b j / a j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c_pos</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"c j&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>j</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c_ratio_tendsto</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(λn. c (n+1) / c n ) ⇢ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>nn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nn=(λn. (2::int)^ (Suc n))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ff</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ff=(λ n. (a n / a (Suc n)) powr(1 /nn n)*(d(Suc n)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nn_pos</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"nn n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ff_pos</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ff n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span class="delimiter">]</span><span> </span><span>a</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>a</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ff_tendsto</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ff ⇢ 1/ sqrt A"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(of_int (a n)) powr(1 / (nn n)) = sqrt(of_int (a n) powr(1 /of_int (2^n)))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nn_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>powr_half_sqrt</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>powr_powr</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(( λ n. sqrt(of_int (a n) powr(1 /of_int (2^n))))⤏ sqrt A) sequentially "</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assu1</span><span> </span><span>tendsto_real_sqrt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(( λ n. (of_int (a n)) powr(1 /of_int (nn n)))⤏ sqrt A) sequentially "</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tendsto_divide</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>assu1</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>LIMSEQ_ignore_initial_segment</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. (a n / a (Suc n)) powr(1 /nn n)) ⇢ 1/sqrt A"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A&gt;1›</span></span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nn_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>powr_divide</span><span> </span><span>less_imp_le</span><span> </span><span>inverse_eq_divide</span><span> </span><span>sqrt_divide_self_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. d (Suc n))⇢ 1"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>convergent_prod_imp_LIMSEQ</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>convergent_prod_iff_shift</span><span class="delimiter">[</span><span>of</span><span> </span><span>d</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹convergent_prod d›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>tendsto_eq_intros</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. (ff n) powr nn n) ⇢ 0"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>aa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"aa=(1+1/sqrt A) / 2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eventually (λn. ff n&lt;aa) sequentially"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_tendstoD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ff_tendsto</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>aa_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A&gt;1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. aa powr nn n) ⇢ 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λy. aa ^ (nat ∘ nn) y) ⇢ 0"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tendsto_power_zero</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nn_def</span><span> </span><span>comp_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>filterlim_subseq</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>strict_monoI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>aa_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A&gt;1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>filterlim_mono_eventually</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"aa&gt;0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>aa_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A&gt;1›</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>field_simps</span><span> </span><span>pos_add_strict</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ∀<span class="hidden">⇩</span><sub>F</sub> x in sequentially. aa ^ (nat ∘ nn) x = aa powr real_of_int (nn x)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>powr_int</span><span> </span><span>order.strict_implies_order</span><span class="delimiter">[</span><span>OF</span><span> </span><span>nn_pos</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>metric_tendsto_imp_tendsto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>powr_mono2</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span>eventually_mono</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nn_pos</span><span> </span><span>ff_pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>le_cases</span><span> </span><span>not_le</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. (d (Suc n))^(nat (nn n)) * (a n / a (Suc n))) ⇢ 0"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>filterlim_mono_eventually</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> x in sequentially. ff x powr  (nn x) = d (Suc x) ^ nat (nn x) * (a x / a (Suc x))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eventuallyI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>a</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc x"</span></span></span><span class="delimiter">]</span><span> </span><span>d</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc x"</span></span></span><span class="delimiter">]</span><span> </span><span>nn_pos</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>field_simps</span><span> </span><span>powr_divide</span><span> </span><span>powr_powr</span><span> </span><span>powr_mult</span><span> </span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>powr_int</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. b (Suc n) / (d (Suc n))^(nat (nn n))) ⇢ 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tendsto_inverse_0_at_top</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assu3</span><span class="delimiter">,</span><span>THEN</span><span> </span><span>LIMSEQ_ignore_initial_segment</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>field_simps</span><span> </span><span>nat_mult_distrib</span><span> </span><span>nat_power_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. b (Suc n) * (a n / a (Suc n))) ⇢ 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>asm</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tendsto_mult</span><span class="delimiter">[</span><span>OF</span><span> </span><span>asm</span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>filterlim_mono_eventually</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>algebra_simps</span><span class="delimiter">,</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>always_eventually</span><span> 
</span><span>            </span><span>not_one_less_zero</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. (b (Suc n) / b n) * (a n / a (Suc n))) ⇢ 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>Lim_transform_bound</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eventuallyI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>a</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc x"</span></span></span><span class="delimiter">]</span><span> 
</span><span>          </span><span>b</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>b</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc x"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c_ratio_tendsto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. norm (b (Suc n) / a (Suc n)) / norm (b n / a n)) ⇢ 0"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>divide_simps</span><span> </span><span>abs_of_pos</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Lim_transform_eventually</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>summable_ratio_test_tendsto</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>a</span><span> </span><span>b</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"summable c"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_irrefl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> n in sequentially. (∑j. c (n + j)) ≤ 2 * c n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>N_ratio</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀n≥N. c (n + 1) / c n &lt; 1 / 2"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eventually (λn. c (n+1) / c n &lt; 1/2) sequentially"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c_ratio_tendsto</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>tendsto_iff</span><span class="delimiter">,</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"1/2"</span></span></span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>eventually_elim</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c_pos</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>c_pos</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eventually_sequentially</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j. c (j + n)) ≤ 2 * c n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">when</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n≥N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j&lt;m. c (j + n)) ≤ 2*c n * (1 - 1 / 2^(m+1))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c_pos</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j&lt;Suc m. c (j + n)) = c n + (∑i&lt;m. c (Suc i + n)) "</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum.lessThan_Suc_shift</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ c n + (∑i&lt;m. c (i + n) / 2)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c (Suc i + n) ≤ c (i + n) / 2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_ratio</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"i+n"</span></span></span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n≥N›</span></span></span><span> </span><span>c_pos</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"i+n"</span></span></span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>sum_mono</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = c n + (∑i&lt;m. c (i + n)) / 2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_divide_distrib</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ c n + c n * (1 - 1 / 2 ^ (m + 1))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = 2 * c n * (1 - 1 / 2 ^ (Suc m + 1))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j&lt;m. c (j + n)) ≤ 2*c n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c_pos</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>divide_le_eq_1_pos</span><span> </span><span>divide_pos_pos</span><span> </span><span>nonzero_mult_div_cancel_left</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"summable (λj. c (j + n))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹summable c›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>summable_iff_shift</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suminf_le_const</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λj. c (j+n)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2*c n"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eventually_sequentially</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> n in sequentially. (∑j. (b (n + j)) /  (a (n + j))) ≤ 2 * b n / a n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Hancl3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>d</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒real "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒int "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A &gt; 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀n. d n&gt; 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. a n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀n. b n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s&gt;0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assu1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(( λ n. (of_int (a n)) powr(1 /of_int (2^n)))⤏ A) sequentially "</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assu2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n ≥ s. (A/ (of_int (a n)) powr(1 /of_int (2^n)))&gt; prodinf (λj. d(n +j))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assu3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"filterlim (λ n. (d n)^(2^n)/ b n) at_top sequentially"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"convergent_prod d"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suminf(λ n. b n / a n ) ∉ Rats"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ (suminf(λ n. b n / a n ) ∉ Rats)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ab_sum</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"summable (λj. b j / a j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>issummable</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A&gt;1›</span></span></span><span> </span><span>d</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>assu1</span><span> </span><span>assu3</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹convergent_prod d›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span class="delimiter">::</span><span>int</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pq_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(λ n. b (n+1) / a (n+1) ) sums (p/q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suminf(λ n. b n / a n ) ∈ Rats"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suminf(λ n. b (n+1) / a (n+1)) ∈ Rats"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>suminf_minus_initial_segment</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ab_sum</span><span class="delimiter">,</span><span>of</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p'</span><span> </span><span>q'</span><span> </span><span class="delimiter">::</span><span>int</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q'≠0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pq_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(λ n. b (n+1) / a (n+1) ) sums (p'/q')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Rats_eq_int_div_int</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>summable_ignore_initial_segment</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ab_sum</span><span class="delimiter">,</span><span>of</span><span> </span><span>1</span><span class="delimiter">,</span><span>THEN</span><span> </span><span>summable_sums</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p=(if q'&lt;0 then - p' else p')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q=(if q'&lt;0 then - q' else q')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p'/q'=p/q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q&gt;0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹q'≠0›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p_def</span><span> </span><span>q_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span class="delimiter">[</span><span>of</span><span> </span><span>q</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span>pq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ALPHA</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ALPHA = (λn. (of_int q)*((∏j=1..n. of_int(a j)))*(suminf (λ (j::nat). 
                      (b (j+n+1)/a (j+n+1)))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ALPHA n ≥ 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suminf(λ n. b (n+1) / a (n+1)) &gt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>suminf_pos</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>summable_ignore_initial_segment</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ab_sum</span><span class="delimiter">,</span><span>of</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p/q &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sums_unique</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pq_def</span><span class="delimiter">,</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q≥1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p≥1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹q&gt;0›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>divide_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. 1 ≤ a n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. 1 ≤ b n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>b</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>int_one_le_iff_zero_less</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ALPHA_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>show7</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>pq_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n. ALPHA n &lt; 1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ALPHA_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lasttoshow</span><span class="delimiter">[</span><span>OF</span><span> </span><span>d</span><span> </span><span>a</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s&gt;0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹q&gt;0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A&gt;1›</span></span></span><span> </span><span>b</span><span> </span><span>_</span><span> </span><span>assu3</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> n in sequentially. (∑j. real_of_int (b (n + j)) / real_of_int (a (n + j)))
                    ≤ real_of_int (2 * b n) / real_of_int (a n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>show5</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A&gt;1›</span></span></span><span> </span><span>d</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>assu1</span><span> </span><span>assu3</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹convergent_prod d›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀m≥s. ∃n≥m. d (n + 1) * Max ((λj. real_of_int (a j) powr (1 / real_of_int (2 ^ j))) ` {s..n})
                 ≤ real_of_int (a (n + 1)) powr (1 / real_of_int (2 ^ (n + 1)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>show9</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A&gt;1›</span></span></span><span> </span><span>d</span><span> </span><span>a</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s&gt;0›</span></span></span><span> </span><span>assu1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹convergent_prod d›</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>show8</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A&gt;1›</span></span></span><span> </span><span>d</span><span> </span><span>a</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s&gt;0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹convergent_prod d›</span></span></span><span> </span><span>assu2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Hancl3corollary</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒int "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A &gt; 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. a n&gt;0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀n. b n&gt;0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assu1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((λ n. (of_int (a n)) powr(1 /of_int (2^n)))⤏ A) sequentially "</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>asscor2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n ≥6. (of_int (a n)) powr(1 /of_int (2^n ))*(1+ 4*(2/3)^n) ≤ A
                    ∧ (b n ≤2 powr((4/3)^(n-1)) )   "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"suminf(λ n. b n / a n ) ∉ Rats"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>d</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat⇒real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d= (λ n. 1+(2/3)^(n+1))"</span></span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dgt1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀n. 1 &lt; d n "</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>d_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"convergent_prod d"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>d_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>abs_convergent_prod_imp_convergent_prod</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>summable_imp_abs_convergent_prod</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>summable_ignore_initial_segment</span><span class="delimiter">[</span><span>OF</span><span> </span><span>complete_algebra_summable_geometric</span><span>
</span><span>          </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"2/3::real"</span></span></span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span>of</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n≥6. (∏j. d (n + j)) 
                    &lt; A / real_of_int (a n) powr (1 / real_of_int (2 ^ n))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>rule</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"6 ≤ n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d_sum</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"summable (λj. ln (d j))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>d_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>summable_ln_plus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>summable_ignore_initial_segment</span><span class="delimiter">[</span><span>OF</span><span> </span><span>complete_algebra_summable_geometric</span><span>
</span><span>          </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"2/3::real"</span></span></span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span>of</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j. ln (d (n + j))) &lt; ln (1+4 * (2 / 3) ^ n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>c</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c=(2 / 3) ^ n"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0&lt;c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c&lt;1/8"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c=(2 / 3)^6 * (2 / 3)  ^ (n-6)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n≥6›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>power_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ (2 / 3)^6"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>power_le_one</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... &lt; 1/8"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c&lt;1/8"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>c_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j. ln (d (n + j))) ≤ (∑j. (2 / 3) ^ (n + j + 1))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>suminf_le</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>d_def</span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>ln_add_one_self_le_self2</span><span> </span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.strict_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>0</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>summable_ignore_initial_segment</span><span class="delimiter">[</span><span>OF</span><span> </span><span>d_sum</span><span class="delimiter">,</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>summable_geometric</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>summable_ignore_initial_segment</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"2/3"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n+1"</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑j. (2 / 3)^(n+1)*(2 / 3) ^ j)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>algebra_simps</span><span> </span><span>power_add</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (2 / 3)^(n+1) * (∑j. (2 / 3) ^ j)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>suminf_mult</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>summable_geometric</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = 2 * c"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>suminf_geometric</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... &lt;  4 * c - (4 * c)<span class="hidden">⇧</span><sup>2</sup>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0&lt;c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c&lt;1/8›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sos</span><span> </span><span class="string"><span class="delete"><span class="delete">"((((A&lt;0 * A&lt;1) * R&lt;1) + ((A&lt;=0 * R&lt;1) * (R&lt;1/16 * [1]^2))))"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ ln (1 + 4 * c)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ln_one_plus_pos_lower_bound</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0&lt;c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c&lt;1/8›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (∑j. ln (d (n + j))) &lt; 1 + 4 * (2 / 3) ^ n"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Groups.mult_ac</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>add.right_neutral</span><span> </span><span>add_mono_thms_linordered_field</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> 
</span><span>          </span><span>divide_inverse</span><span> </span><span>divide_less_eq_numeral1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>divide_pos_pos</span><span> </span><span>exp_gt_zero</span><span> </span><span>less_eq_real_def</span><span>
</span><span>          </span><span>ln_exp</span><span> </span><span>ln_less_cancel_iff</span><span> </span><span>mult_zero_left</span><span> </span><span>rel_simps</span><span class="delimiter">(</span><span>27</span><span class="delimiter">)</span><span> </span><span>rel_simps</span><span class="delimiter">(</span><span>76</span><span class="delimiter">)</span><span> </span><span>zero_less_one</span><span>
</span><span>          </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp (∑j. ln (d (n + j))) = (∏j. d (n + j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>exp_suminf_prodinf_real</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀k. 0 ≤ ln (d (n + k))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dgt1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_imp_le</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"abs_convergent_prod (λna. exp (ln (d (n + na))))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>exp_ln</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dgt1</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n+j"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>abs_convergent_prod_def</span><span> </span><span>real_norm_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>abs_of_nonneg</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>convergent_prod_iff_shift</span><span class="delimiter">[</span><span>of</span><span> </span><span>d</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹convergent_prod d›</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dgt1</span><span> </span><span>less_imp_le</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏na. exp (ln (d (n + na)))) = (∏j. d (n + j))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>exp_ln</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dgt1</span><span> </span><span>le_less_trans</span><span> </span><span>zero_le_one</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏j. d (n + j))  &lt; 1 + 4 * (2 / 3) ^ n"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ A / (a n) powr (1 / of_int (2 ^ n))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a n powr (1 / real_of_int (2 ^ n)) &gt; 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asscor2</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹6≤n›</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏j. d (n + j)) &lt; A / real_of_int (a n) powr (1 / of_int (2 ^ n))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LIM n sequentially. d n ^ 2 ^ n / real_of_int (b n) :&gt; at_top"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LIM n sequentially. d n ^ 2 ^ n / 2 powr((4/3)^(n-1)) :&gt; at_top"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>n1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n1=(λn. (2::real)* (3/2)^(n-1))"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>n2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n2=(λn. ((4::real)/3)^(n-1))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LIM n sequentially. (((1+(8/9)/(n1 n)) powr (n1 n))/2) powr (n2 n) :&gt; at_top"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>filterlim_at_top_powr_real</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>g'</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"exp (8/9) / (2::real)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>e1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e1=exp (8/9) / (2::real)"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e1&gt;1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>e1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>approximation</span><span> </span><span>4</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. ((1+(8/9)/(n1 n)) powr (n1 n))/2) ⇢ e1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λn. (1+(8/9)/(n1 n)) powr (n1 n)) ⇢ exp (8/9)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>filterlim_compose</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tendsto_exp_limit_at_top</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n1_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>filterlim_tendsto_pos_mult_at_top</span><span> 
</span><span>                </span><span>filterlim_realpow_sequentially_at_top</span><span>
</span><span>                </span><span>simp</span><span class="delimiter">:</span><span>filterlim_sequentially_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. (3 / 2) ^ (x - Suc 0)"</span></span></span><span> </span><span>_</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>e1_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>tendsto_intros</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"filterlim n2 at_top sequentially"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n2_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>filterlim_sequentially_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λn. (4 / 3) ^ (n - 1)"</span></span></span><span> </span><span>_</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>filterlim_realpow_sequentially_at_top</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> n in sequentially. (((1+(8/9)/(n1 n)) powr (n1 n))/2) powr (n2 n)
        = d n ^ 2 ^ n / 2 powr((4/3)^(n-1))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eventually_sequentiallyI</span><span class="delimiter">[</span><span>of</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x≥(1::nat)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ((1 + 8 / 9 / n1 x) powr n1 x / 2) powr n2 x 
                    = (((1 + 8 / 9 / n1 x) powr n1 x) powr n2 x) / 2 powr (4 / 3) ^ (x - 1)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>n1_def</span><span> </span><span>n2_def</span><span> </span><span>powr_divide</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (1 + 8 / 9 / n1 x) powr (n1 x * n2 x) / 2 powr (4 / 3) ^ (x - 1)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>powr_powr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (1 + 8 / 9 / n1 x) powr (2 ^ x) / 2 powr (4 / 3) ^ (x - 1)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 x * n2 x = 2 ^ x"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n1_def</span><span> </span><span>n2_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>power_mult_distrib</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x≥1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span>power_Suc</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (1 + 8 / 9 / n1 x) ^ (2 ^ x) / 2 powr (4 / 3) ^ (x - 1)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>powr_realpow</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n1_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>zero_le_divide_iff</span><span> </span><span>zero_le_power</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = d x ^ 2 ^ x / 2 powr (4 / 3) ^ (x - 1)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>x1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x1=x-1"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x=x1+1"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x1_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x≥1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"8 / 9 / n1 x = (2 / 3) ^ (x + 1)"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n1_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x≥1›</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>x1_def</span><span> </span><span>*</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>divide_simps</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>d_def</span><span> 
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>**</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((1 + 8 / 9 / n1 x) powr n1 x / 2) powr n2 x 
                        = d x ^ 2 ^ x / 2 powr (4 / 3) ^ (x - 1) "</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>filterlim_cong</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀<span class="hidden">⇩</span><sub>F</sub> n in sequentially. d n ^ 2 ^ n / 2 powr((4/3)^(n-1)) 
        ≤ d n ^ 2 ^ n / real_of_int (b n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eventually_sequentiallyI</span><span class="delimiter">[</span><span>of</span><span> </span><span>6</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>divide_left_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asscor2</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀n. 1 &lt; d n›</span></span></span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>filterlim_at_top_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hancl3</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A&gt;1›</span></span></span><span> </span><span>_</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>_</span><span> </span><span>assu1</span><span class="delimiter">,</span><span>of</span><span> </span><span>d</span><span> </span><span>6</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>