<div id="While_SPMF">
<div class="head">
<h1>Theory While_SPMF</h1>
</div>
<pre class="source"><span class="comment1">(* Title: While_SPMF.thy
   Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> While_SPMF <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../MFMC_Countable/Rel_PMF_Characterisation.html">MFMC_Countable.Rel_PMF_Characterisation</a>
  <span class="quoted">"<a href="../../HOL/HOL-Types_To_Sets/Types_To_Sets.html">HOL-Types_To_Sets.Types_To_Sets</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Complete_Partial_Order2.html">HOL-Library.Complete_Partial_Order2</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This theory defines a probabilistic while combinator for discrete (sub-)probabilities and
  formalises rules for probabilistic termination similar to those by Hurd \cite{Hurd2002TPHOLs}
  and McIver and Morgan \cite{McIverMorgan2005}.
›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Miscellaneous library additions›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">map_option_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> option set<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'b</span> option set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_option_set</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> None <span class="main">=</span> <span class="main">{</span>None<span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">map_option_set</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1" id="While_SPMF-None_in_map_option_set"><span class="command">lemma</span></span> None_in_map_option_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"None <span class="main">∈</span> map_option_set <span class="free">f</span> <span class="free">x</span> <span class="main">⟷</span> None <span class="main">∈</span> Set.bind <span class="main">(</span>set_option <span class="free">x</span><span class="main">)</span> <span class="free">f</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">=</span> None"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="While_SPMF-None_in_map_option_set_None"><span class="command">lemma</span></span> None_in_map_option_set_None <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"None <span class="main">∈</span> map_option_set <span class="free">f</span> None"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="While_SPMF-None_in_map_option_set_Some"><span class="command">lemma</span></span> None_in_map_option_set_Some <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"None <span class="main">∈</span> <span class="free">f</span> <span class="free">x</span> <span class="main">⟹</span> None <span class="main">∈</span> map_option_set <span class="free">f</span> <span class="main">(</span>Some <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="While_SPMF-Some_in_map_option_set"><span class="command">lemma</span></span> Some_in_map_option_set <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Some <span class="free">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="free">x</span> <span class="main">⟹</span> Some <span class="free">y</span> <span class="main">∈</span> map_option_set <span class="free">f</span> <span class="main">(</span>Some <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="While_SPMF-map_option_set_singleton"><span class="command">lemma</span></span> map_option_set_singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"map_option_set <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="free">f</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span> <span class="free">y</span> <span class="main">=</span> <span class="main">{</span>Option.bind <span class="free">y</span> <span class="free">f</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="While_SPMF-Some_eq_bind_conv"><span class="command">lemma</span></span> Some_eq_bind_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"Some <span class="free">y</span> <span class="main">=</span> Option.bind <span class="free">x</span> <span class="free">f</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> Some <span class="bound">z</span> <span class="main">∧</span> <span class="free">f</span> <span class="bound">z</span> <span class="main">=</span> Some <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="While_SPMF-map_option_set_bind"><span class="command">lemma</span></span> map_option_set_bind<span class="main">:</span> <span class="quoted"><span class="quoted">"map_option_set <span class="free">f</span> <span class="main">(</span>Option.bind <span class="free">x</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> map_option_set <span class="main">(</span>map_option_set <span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="While_SPMF-Some_in_map_option_set_conv"><span class="command">lemma</span></span> Some_in_map_option_set_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"Some <span class="free">y</span> <span class="main">∈</span> map_option_set <span class="free">f</span> <span class="free">x</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> Some <span class="bound">z</span> <span class="main">∧</span> Some <span class="free">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">interpretation</span></span> rel_spmf_characterisation <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">rule</span> rel_pmf_measureI<span class="main">)</span>
<span class="keyword1"><span class="command">hide_fact</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> rel_pmf_measureI

<span class="keyword1" id="While_SPMF-Sup_conv_fun_lub"><span class="command">lemma</span></span> Sup_conv_fun_lub<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup <span class="main">=</span> fun_lub Sup"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_fun_def fun_eq_iff fun_lub_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">Sup</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="While_SPMF-le_conv_fun_ord"><span class="command">lemma</span></span> le_conv_fun_ord<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span> <span class="main">=</span> fun_ord <span class="main">(≤)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff fun_ord_def le_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> parallel_fixp_induct_2_1 <span class="main">=</span> parallel_fixp_induct_uc<span class="main">[</span>
  <span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"case_prod"</span></span> <span class="main">_</span> <span class="quoted"><span class="quoted">"curry"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main">,</span>
  <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">f</span> <span class="bound">g</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>curry <span class="bound">f</span><span class="main">)</span> <span class="bound">g</span>"</span></span><span class="main">,</span>
  <span class="operator">unfolded</span> case_prod_curry curry_case_prod curry_K<span class="main">,</span>
  <span class="operator">OF</span> _ _ _ _ _ _ refl refl<span class="main">]</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">P</span>

<span class="keyword1" id="While_SPMF-monotone_Pair"><span class="command">lemma</span></span> monotone_Pair<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> monotone <span class="free">ord</span> <span class="free">orda</span> <span class="free">f</span><span class="main">;</span> monotone <span class="free">ord</span> <span class="free">ordb</span> <span class="free">g</span> <span class="main">⟧</span>
  <span class="main">⟹</span> monotone <span class="free">ord</span> <span class="main">(</span>rel_prod <span class="free">orda</span> <span class="free">ordb</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">,</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_def<span class="main">)</span>

<span class="keyword1" id="While_SPMF-cont_Pair"><span class="command">lemma</span></span> cont_Pair<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> cont <span class="free">lub</span> <span class="free">ord</span> <span class="free">luba</span> <span class="free">orda</span> <span class="free">f</span><span class="main">;</span> cont <span class="free">lub</span> <span class="free">ord</span> <span class="free">lubb</span> <span class="free">ordb</span> <span class="free">g</span> <span class="main">⟧</span>
  <span class="main">⟹</span> cont <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span>prod_lub <span class="free">luba</span> <span class="free">lubb</span><span class="main">)</span> <span class="main">(</span>rel_prod <span class="free">orda</span> <span class="free">ordb</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">,</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prod_lub_def image_image <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> contD<span class="main">)</span>

<span class="keyword1" id="While_SPMF-mcont_Pair"><span class="command">lemma</span></span> mcont_Pair<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> mcont <span class="free">lub</span> <span class="free">ord</span> <span class="free">luba</span> <span class="free">orda</span> <span class="free">f</span><span class="main">;</span> mcont <span class="free">lub</span> <span class="free">ord</span> <span class="free">lubb</span> <span class="free">ordb</span> <span class="free">g</span> <span class="main">⟧</span>
  <span class="main">⟹</span> mcont <span class="free">lub</span> <span class="free">ord</span> <span class="main">(</span>prod_lub <span class="free">luba</span> <span class="free">lubb</span><span class="main">)</span> <span class="main">(</span>rel_prod <span class="free">orda</span> <span class="free">ordb</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">,</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mcontI<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monotone_Pair mcont_mono cont_Pair<span class="main">)</span>

<span class="keyword1" id="While_SPMF-mono2mono_emeasure_spmf"><span class="command">lemma</span></span> mono2mono_emeasure_spmf <span class="main">[</span><span class="operator">THEN</span> lfp.mono2mono<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> monotone_emeasure_spmf<span class="main">:</span>
  <span class="quoted"><span class="quoted">"monotone <span class="main">(</span>ord_spmf <span class="main">(=)</span><span class="main">)</span> <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monotoneI le_funI ord_spmf_eqD_emeasure<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="While_SPMF-cont_emeasure_spmf"><span class="command">lemma</span></span> cont_emeasure_spmf<span class="main">:</span> <span class="quoted"><span class="quoted">"cont lub_spmf <span class="main">(</span>ord_spmf <span class="main">(=)</span><span class="main">)</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> contI<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emeasure_lub_spmf fun_eq_iff image_comp<span class="main">)</span>

<span class="keyword1" id="While_SPMF-mcont2mcont_emeasure_spmf"><span class="command">lemma</span></span> mcont2mcont_emeasure_spmf <span class="main">[</span><span class="operator">THEN</span> lfp.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_emeasure_spmf<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lub_spmf <span class="main">(</span>ord_spmf <span class="main">(=)</span><span class="main">)</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcont_def monotone_emeasure_spmf cont_emeasure_spmf<span class="main">)</span>

<span class="keyword1" id="While_SPMF-mcont2mcont_emeasure_spmf'"><span class="command">lemma</span></span> mcont2mcont_emeasure_spmf' <span class="main">[</span><span class="operator">THEN</span> lfp.mcont2mcont<span class="main">,</span> <span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> mcont_emeasure_spmf'<span class="main">:</span> <span class="quoted"><span class="quoted">"mcont lub_spmf <span class="main">(</span>ord_spmf <span class="main">(=)</span><span class="main">)</span> Sup <span class="main">(≤)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="bound">p</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> mcont_emeasure_spmf<span class="main">[</span><span class="operator">unfolded</span> Sup_conv_fun_lub le_conv_fun_ord<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> mcont_fun_lub_apply<span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1" id="While_SPMF-mcont_bind_pmf"><span class="command">lemma</span></span> mcont_bind_pmf <span class="main">[</span><span class="operator">cont_intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> g<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> mcont <span class="free">luba</span> <span class="free">orda</span> lub_spmf <span class="main">(</span>ord_spmf <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mcont <span class="free">luba</span> <span class="free">orda</span> lub_spmf <span class="main">(</span>ord_spmf <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_pmf <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">g</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> mcont_bind_spmf<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> spmf_of_pmf <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">g</span></span><span class="main">,</span> <span class="operator">OF</span> _ assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="While_SPMF-ennreal_less_top_iff"><span class="command">lemma</span></span> ennreal_less_top_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&lt;</span> <span class="main">⊤</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">≠</span> <span class="main">(</span><span class="main">⊤</span> <span class="main">::</span> ennreal<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="While_SPMF-type_definition_Domainp"><span class="command">lemma</span></span> type_definition_Domainp<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Rep</span> <span class="free">Abs</span> <span class="free">A</span> <span class="free">T</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> type<span class="main">:</span> <span class="quoted"><span class="quoted">"type_definition <span class="free">Rep</span> <span class="free">Abs</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> T_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span><span class="main">::</span><span class="tfree">'b</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">Rep</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Domainp <span class="free">T</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> type_definition <span class="quoted"><span class="free">Rep</span></span> <span class="quoted"><span class="free">Abs</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> type<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Domainp_iff<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> T_def fun_eq_iff <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> Abs_inverse Rep<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="While_SPMF-weight_spmf_parametric"><span class="command">lemma</span></span> weight_spmf_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_spmf <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> weight_spmf weight_spmf"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def rel_spmf_weightD<span class="main">)</span>

<span class="keyword1" id="While_SPMF-lossless_spmf_parametric"><span class="command">lemma</span></span> lossless_spmf_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_spmf <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> lossless_spmf lossless_spmf"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def lossless_spmf_def rel_spmf_weightD<span class="main">)</span>

<span class="keyword1" id="While_SPMF-UNIV_parametric_pred"><span class="command">lemma</span></span> UNIV_parametric_pred<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_pred <span class="free">R</span> UNIV UNIV"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_predI<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="While_SPMF-bind_spmf_spmf_of_set"><span class="command">lemma</span></span> bind_spmf_spmf_of_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span><span class="main">.</span> <span class="main">⟦</span> finite <span class="bound">A</span><span class="main">;</span> <span class="bound">A</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟧</span> <span class="main">⟹</span> bind_spmf <span class="main">(</span>spmf_of_set <span class="bound">A</span><span class="main">)</span> <span class="main">=</span> bind_pmf <span class="main">(</span>pmf_of_set <span class="bound">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_of_set_def fun_eq_iff <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> spmf_of_pmf_pmf_of_set<span class="main">)</span>

<span class="keyword1" id="While_SPMF-set_pmf_bind_spmf"><span class="command">lemma</span></span> set_pmf_bind_spmf<span class="main">:</span> <span class="quoted"><span class="quoted">"set_pmf <span class="main">(</span>bind_spmf <span class="free">M</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> set_pmf <span class="free">M</span> <span class="main">⤜</span> map_option_set <span class="main">(</span>set_pmf <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_spmf_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_bexI<span class="main">)</span>

<span class="keyword1" id="While_SPMF-set_pmf_spmf_of_set"><span class="command">lemma</span></span> set_pmf_spmf_of_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_pmf <span class="main">(</span>spmf_of_set <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">A</span> <span class="main">∧</span> <span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span> <span class="keyword1">then</span> Some <span class="main">`</span> <span class="free">A</span> <span class="keyword1">else</span> <span class="main">{</span>None<span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_of_set_def spmf_of_pmf_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> spmf_of_pmf_pmf_of_set<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">measure_measure_spmf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> spmf <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">measure_measure_spmf</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> measure <span class="main">(</span>measure_spmf <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="While_SPMF-measure_measure_spmf_parametric"><span class="command">lemma</span></span> measure_measure_spmf_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_spmf <span class="free">A</span> <span class="main">===&gt;</span> rel_pred <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> measure_measure_spmf measure_measure_spmf"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> measure_measure_spmf_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> measure_spmf_parametric<span class="main">)</span>

<span class="keyword1" id="While_SPMF-of_nat_le_one_cancel_iff"><span class="command">lemma</span></span> of_nat_le_one_cancel_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"real <span class="free">n</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">≤</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>

<span class="keyword1" id="While_SPMF-of_int_ceiling_less_add_one"><span class="command">lemma</span></span> of_int_ceiling_less_add_one <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"of_int <span class="main">⌈</span><span class="free">r</span><span class="main">⌉</span> <span class="main">&lt;</span> <span class="free">r</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>

<span class="keyword1" id="While_SPMF-lessThan_subset_Collect"><span class="command">lemma</span></span> lessThan_subset_Collect<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{..&lt;</span><span class="free">x</span><span class="main">}</span> <span class="main">⊆</span> Collect <span class="free">P</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">y</span></span><span class="main">&lt;</span><span class="free">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessThan_def<span class="main">)</span>

<span class="keyword1" id="While_SPMF-spmf_ub_tight"><span class="command">lemma</span></span> spmf_ub_tight<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ub<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> spmf <span class="free">p</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> sum<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">∂</span>count_space UNIV<span class="main">)</span> <span class="main">=</span> weight_spmf <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"spmf <span class="free">p</span> <span class="free">x</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> spmf <span class="free">p</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"spmf <span class="free">p</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_le<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">y</span><span class="main">.</span> ennreal <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span> <span class="main">*</span> indicator <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="bound">y</span> <span class="main">∂</span>count_space UNIV<span class="main">)</span> <span class="main">≠</span> <span class="main">⊤</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> neq_top_trans<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> y<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"weight_spmf <span class="free"><span class="free"><span class="free">p</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> nn_integral_mono <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
      
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight_spmf <span class="free">p</span> <span class="main">=</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">y</span><span class="main">.</span> spmf <span class="free">p</span> <span class="bound">y</span> <span class="main">∂</span>count_space UNIV"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nn_integral_spmf space_measure_spmf measure_spmf.emeasure_eq_measure<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">y</span><span class="main">.</span> ennreal <span class="main">(</span>spmf <span class="free">p</span> <span class="bound">y</span><span class="main">)</span> <span class="main">*</span> indicator <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="bound">y</span> <span class="main">∂</span>count_space UNIV<span class="main">)</span> <span class="main">+</span>
      <span class="main">(</span><span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">y</span><span class="main">.</span> spmf <span class="free">p</span> <span class="bound">y</span> <span class="main">*</span> indicator <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="bound">y</span> <span class="main">∂</span>count_space UNIV<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> nn_integral_add<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> nn_integral_cong <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">(</span><span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">y</span><span class="main">.</span> ennreal <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span> <span class="main">*</span> indicator <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="bound">y</span> <span class="main">∂</span>count_space UNIV<span class="main">)</span> <span class="main">+</span> spmf <span class="free">p</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ub <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> add_mono nn_integral_mono<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ennreal_leI<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">&lt;</span> <span class="main">(</span><span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">y</span><span class="main">.</span> ennreal <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span> <span class="main">*</span> indicator <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="bound">y</span> <span class="main">∂</span>count_space UNIV<span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">y</span><span class="main">.</span> <span class="free">f</span> <span class="bound">y</span> <span class="main">*</span> indicator <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="bound">y</span> <span class="main">∂</span>count_space UNIV<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> * x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ennreal_less_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">y</span><span class="main">.</span> ennreal <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∂</span>count_space UNIV<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> nn_integral_add<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> nn_integral_cong <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> weight_spmf <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> sum <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> ub<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Probabilistic while loop›</span></span>

<span class="keyword1"><span class="command">locale</span></span> loop_spmf <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">guard</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">body</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">function_internals</span><span class="main">]</span><span class="main">]</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>spmf<span class="main">)</span> <span class="entity">while</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">while</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">guard</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> bind_spmf <span class="main">(</span><span class="free">body</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="free">while</span> <span class="keyword1">else</span> return_spmf <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="While_SPMF-while_fixp_induct"><span class="command">lemma</span></span> while_fixp_induct <span class="main">[</span><span class="operator">case_names</span> adm bottom step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"spmf.admissible <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="main">λ</span><span class="bound">while</span><span class="main">.</span> return_pmf None<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">while'</span><span class="main">.</span> <span class="free">P</span> <span class="bound">while'</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">guard</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="free">body</span> <span class="bound">s</span> <span class="main">⤜</span> <span class="bound">while'</span> <span class="keyword1">else</span> return_spmf <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> while"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> while.fixp_induct<span class="main">)</span>

<span class="keyword1" id="While_SPMF-while_simps"><span class="command">lemma</span></span> while_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="free">s</span> <span class="main">⟹</span> while <span class="free">s</span> <span class="main">=</span> bind_spmf <span class="main">(</span><span class="free">body</span> <span class="free">s</span><span class="main">)</span> while"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">guard</span> <span class="free">s</span> <span class="main">⟹</span> while <span class="free">s</span> <span class="main">=</span> return_spmf <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rewrite</span> while.simps<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="While_SPMF-while_spmf_parametric"><span class="command">lemma</span></span> while_spmf_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> rel_spmf <span class="free">S</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">S</span> <span class="main">===&gt;</span> rel_spmf <span class="free">S</span><span class="main">)</span> loop_spmf.while loop_spmf.while"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> loop_spmf.while_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fixp_spmf_parametric<span class="main"><span class="main">[</span></span><span class="operator">OF</span> loop_spmf.while.mono loop_spmf.while.mono<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="While_SPMF-loop_spmf_while_cong"><span class="command">lemma</span></span> loop_spmf_while_cong<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">guard</span> <span class="main">=</span> <span class="free">guard'</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">guard'</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="free">body</span> <span class="bound">s</span> <span class="main">=</span> <span class="free">body'</span> <span class="bound">s</span> <span class="main">⟧</span>
  <span class="main">⟹</span> loop_spmf.while <span class="free">guard</span> <span class="free">body</span> <span class="main">=</span> loop_spmf.while <span class="free">guard'</span> <span class="free">body'</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> loop_spmf.while_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Rules for probabilistic termination›</span></span>

<span class="keyword1"><span class="command">context</span></span> loop_spmf <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹0/1 termination laws›</span></span>

<span class="keyword1" id="While_SPMF-termination_0_1_immediate"><span class="command">lemma</span></span> termination_0_1_immediate<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">guard</span> <span class="bound">s</span> <span class="main">⟹</span> spmf <span class="main">(</span>map_spmf <span class="free">guard</span> <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> False <span class="main">≥</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> p_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">guard</span> <span class="bound">s</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>while <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">s</span><span class="main">.</span> lossless_spmf <span class="main">(</span>while <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?thesis</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">s</span></span> <span class="keyword2"><span class="keyword">where</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lossless_spmf <span class="main">(</span>while <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> True<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> while.simps <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> p<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> p_le_1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≤</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> pmf_le_1 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> order_trans<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> new_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">k</span> <span class="main">≤</span> weight_spmf <span class="main">(</span>while <span class="skolem">s</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">if</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">≤</span> <span class="main">1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> k_le<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">k</span> <span class="main">≤</span> weight_spmf <span class="main">(</span>while <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">k</span> <span class="skolem">s</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="skolem">s</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">k</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p_le_1 k <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> mult_right_mono add_mono<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> while.simps<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?M</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">s</span><span class="main">.</span> measure_spmf <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> bounded<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¦</span><span class="main">∫</span> <span class="bound">s''</span><span class="main">.</span> weight_spmf <span class="main">(</span>while <span class="bound">s''</span><span class="main">)</span> <span class="main">∂</span><span class="var">?M</span> <span class="skolem">s'</span><span class="main">¦</span> <span class="main">≤</span> <span class="main">1</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s'</span>
        <span class="keyword1"><span class="command">using</span></span> integral_nonneg_AE<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">s''</span><span class="main">.</span> weight_spmf <span class="main">(</span>while <span class="bound">s''</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?M</span> <span class="skolem">s'</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> weight_spmf_nonneg weight_spmf_le_1 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> measure_spmf.nn_integral_le_const integral_real_bounded<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≤</span> measure <span class="main">(</span><span class="var">?M</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s'</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p<span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_conv_measure_spmf measure_map_spmf vimage_def<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">k</span> <span class="main">≤</span> measure <span class="main">(</span><span class="var">?M</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s'</span><span class="main">}</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">k</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> k <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> add_mono mult_right_mono<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">∫</span> <span class="bound">s'</span><span class="main">.</span> indicator <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s'</span><span class="main">}</span> <span class="bound">s'</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">+</span>  <span class="skolem">k</span> <span class="main">∂</span><span class="var">?M</span> <span class="skolem">s</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ennreal_less_top_iff lossless lossless_weight_spmfD<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">∫</span> <span class="bound">s'</span><span class="main">.</span> indicator <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s'</span><span class="main">}</span> <span class="bound">s'</span> <span class="main">+</span> indicator <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="free">guard</span> <span class="bound">s'</span><span class="main">}</span> <span class="bound">s'</span> <span class="main">*</span> <span class="skolem">k</span> <span class="main">∂</span><span class="var">?M</span> <span class="skolem">s</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Bochner_Integration.integral_cong<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">∫</span> <span class="bound">s'</span><span class="main">.</span> indicator <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s'</span><span class="main">}</span> <span class="bound">s'</span> <span class="main">+</span> indicator <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="free">guard</span> <span class="bound">s'</span><span class="main">}</span> <span class="bound">s'</span> <span class="main">*</span> <span class="main">∫</span> <span class="bound">s''</span><span class="main">.</span> <span class="skolem">k</span> <span class="main">∂</span><span class="var">?M</span> <span class="bound">s'</span> <span class="main">∂</span><span class="var">?M</span> <span class="skolem">s</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Bochner_Integration.integral_cong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless lossless_weight_spmfD <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">∫</span> <span class="bound">s'</span><span class="main">.</span> indicator <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s'</span><span class="main">}</span> <span class="bound">s'</span> <span class="main">+</span> indicator <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="free">guard</span> <span class="bound">s'</span><span class="main">}</span> <span class="bound">s'</span> <span class="main">*</span> <span class="main">∫</span> <span class="bound">s''</span><span class="main">.</span> weight_spmf <span class="main">(</span>while <span class="bound">s''</span><span class="main">)</span> <span class="main">∂</span><span class="var">?M</span> <span class="bound">s'</span> <span class="main">∂</span><span class="var">?M</span> <span class="skolem">s</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> k bounded
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> integral_mono integrable_add measure_spmf.integrable_const_bound<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main"><span class="quoted"><span class="main"><span class="quoted"><span class="main">1</span></span></span></span></span></span><span class="main"><span class="main">]</span></span> add_mono mult_left_mono<span class="main">)</span>
          <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> weight_spmf_nonneg weight_spmf_le_1 mult_le_one k_le <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">∫</span><span class="bound">s'</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s'</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">∫</span> <span class="bound">s''</span><span class="main">.</span> weight_spmf <span class="main">(</span>while <span class="bound">s''</span><span class="main">)</span> <span class="main">∂</span><span class="var">?M</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∂</span><span class="var">?M</span> <span class="skolem">s</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Bochner_Integration.integral_cong<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">∫</span> <span class="bound">s'</span><span class="main">.</span> weight_spmf <span class="main">(</span>while <span class="bound">s'</span><span class="main">)</span> <span class="main">∂</span>measure_spmf <span class="main">(</span><span class="free">body</span> <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Bochner_Integration.integral_cong<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> while.simps weight_bind_spmf o_def<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> weight_spmf <span class="main">(</span>while <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> True
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> while.simps weight_bind_spmf o_def<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">≡</span> <span class="keyword1">INF</span> <span class="bound">s</span><span class="main">.</span> weight_spmf <span class="main">(</span>while <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">k'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">≡</span> <span class="free">p</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">k</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight_spmf <span class="main">(</span>while <span class="skolem">s</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> weight_spmf_le_1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"while <span class="skolem">s</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_spmf_def<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> k_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rewrite</span> cINF_less_iff<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bdd_belowI2 weight_spmf_nonneg<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> k_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> cINF_greatest <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> weight_spmf_nonneg<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">k</span> <span class="main">&lt;</span> <span class="main">1</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">≤</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">≤</span> weight_spmf <span class="main">(</span>while <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="keyword1"><span class="command">unfolding</span></span> k_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> cINF_lower<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bdd_belowI2 weight_spmf_nonneg<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">k'</span> <span class="main">≤</span> weight_spmf <span class="main">(</span>while <span class="bound">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> k'_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> new_bound<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span> <span class="main">≤</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> k_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> cINF_greatest<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> <span class="skolem">k'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p_pos <span class="quoted"><span class="quoted">‹<span class="skolem">k</span> <span class="main">&lt;</span> <span class="main">1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> k'_def<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">iter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">iter</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> return_spmf <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">iter</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">guard</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> bind_spmf <span class="main">(</span><span class="free">body</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">iter</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="keyword1">else</span> return_spmf <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="While_SPMF-iter_unguarded"><span class="command">lemma</span></span> iter_unguarded <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">guard</span> <span class="free">s</span> <span class="main">⟹</span> iter <span class="free">n</span> <span class="free">s</span> <span class="main">=</span> return_spmf <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  
<span class="keyword1" id="While_SPMF-iter_bind_iter"><span class="command">lemma</span></span> iter_bind_iter<span class="main">:</span> <span class="quoted"><span class="quoted">"bind_spmf <span class="main">(</span>iter <span class="free">m</span> <span class="free">s</span><span class="main">)</span> <span class="main">(</span>iter <span class="free">n</span><span class="main">)</span> <span class="main">=</span> iter <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="free">n</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="While_SPMF-iter_Suc2"><span class="command">lemma</span></span> iter_Suc2<span class="main">:</span> <span class="quoted"><span class="quoted">"iter <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> bind_spmf <span class="main">(</span>iter <span class="free">n</span> <span class="free">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">guard</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="free">body</span> <span class="bound">s</span> <span class="keyword1">else</span> return_spmf <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> iter_bind_iter<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="main">1</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> iter.simps<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> bind_spmf_cong<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong<span class="main">)</span>

<span class="keyword1" id="While_SPMF-lossless_iter"><span class="command">lemma</span></span> lossless_iter<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">guard</span> <span class="bound">s</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span>iter <span class="free">n</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="While_SPMF-iter_mono_emeasure1"><span class="command">lemma</span></span> iter_mono_emeasure1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="free">n</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">}</span> <span class="main">≤</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">}</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="free">s</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>bind_spmf <span class="main">(</span>iter <span class="free">n</span> <span class="free">s</span><span class="main">)</span> return_spmf<span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">s'</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>return_spmf <span class="bound">s'</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">}</span> <span class="main">∂</span>measure_spmf <span class="main">(</span>iter <span class="free">n</span> <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> bind_return_spmf <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf_bind o_def emeasure_bind<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> N<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure_spmf <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> space_measure_spmf Pi_def space_subprob_algebra<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">s'</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="keyword1">if</span> <span class="free">guard</span> <span class="bound">s'</span> <span class="keyword1">then</span> <span class="free">body</span> <span class="bound">s'</span> <span class="keyword1">else</span> return_spmf <span class="bound">s'</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">}</span> <span class="main">∂</span>measure_spmf <span class="main">(</span>iter <span class="free">n</span> <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nn_integral_mono<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf_return_spmf<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iter_Suc2 measure_spmf_bind o_def emeasure_bind<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> N<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure_spmf <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> space_measure_spmf Pi_def space_subprob_algebra <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> iter.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="While_SPMF-weight_while_conv_iter"><span class="command">lemma</span></span> weight_while_conv_iter<span class="main">:</span>
  <span class="quoted"><span class="quoted">"weight_spmf <span class="main">(</span>while <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>while <span class="free">s</span><span class="main">)</span><span class="main">)</span> UNIV <span class="main">≤</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> <span class="var">?f</span> <span class="bound">n</span> <span class="free">s</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> while_fixp_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> adm <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">while'</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs'</span> <span class="main">≤</span> <span class="var">?rhs'</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="skolem">s</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">have</span></span> inc<span class="main">:</span> <span class="quoted"><span class="quoted">"incseq <span class="var">?f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> incseq_SucI le_funI iter_mono_emeasure1<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

      <span class="keyword1"><span class="command">from</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs'</span> <span class="main">=</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">s'</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="skolem">while'</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span> UNIV <span class="main">∂</span>measure_spmf <span class="main">(</span><span class="free">body</span> <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf_bind o_def emeasure_bind<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> N<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure_spmf <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> space_measure_spmf Pi_def space_subprob_algebra<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">s'</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> <span class="var">?f</span> <span class="bound">n</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∂</span>measure_spmf <span class="main">(</span><span class="free">body</span> <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nn_integral_mono<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> step.IH<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">s'</span><span class="main">.</span> <span class="var">?f</span> <span class="bound">n</span> <span class="bound">s'</span> <span class="main">∂</span>measure_spmf <span class="main">(</span><span class="free">body</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> inc
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> nn_integral_monotone_convergence_SUP<span class="main">)</span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> <span class="var">?f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> True
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf_bind o_def emeasure_bind<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> N<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure_spmf <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> space_measure_spmf Pi_def space_subprob_algebra<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> <span class="var">?f</span> <span class="bound">n</span> <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> SUP_mono<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"Suc <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs'</span> <span class="main">=</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="main">0</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">}</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf_return_spmf<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">‹<span class="main">…</span> <span class="main">≤</span> <span class="var">?rhs'</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> SUP_upper<span class="main">)</span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> ennreal <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> ennreal_SUP<span class="main">)</span><span class="main">(</span><span class="operator">fold</span> measure_spmf.emeasure_eq_measure<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less measure_spmf.subprob_emeasure_le_1 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">1</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> cSUP_upper2<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bdd_aboveI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> M<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">1</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf.subprob_measure_le_1<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf.emeasure_eq_measure space_measure_spmf<span class="main">)</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">≤</span> <span class="var">?lhs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cSUP_least<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="skolem">n</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">}</span> <span class="main">≤</span> weight_spmf <span class="main">(</span>while <span class="free">s</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="skolem">n</span> <span class="free">s</span> <span class="main">≤</span> <span class="main">_</span>"</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">n</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf_return_spmf measure_return while_simps <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="skolem">s</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="skolem">s</span> <span class="main">=</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">s'</span><span class="main">.</span> <span class="var">?f</span> <span class="skolem">n</span> <span class="bound">s'</span> <span class="main">∂</span>measure_spmf <span class="main">(</span><span class="free">body</span> <span class="skolem">s</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">unfolding</span></span> measure_spmf.emeasure_eq_measure<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf_bind o_def emeasure_bind<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> N<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure_spmf <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> space_measure_spmf Pi_def space_subprob_algebra<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">s'</span><span class="main">.</span> weight_spmf <span class="main">(</span>while <span class="bound">s'</span><span class="main">)</span> <span class="main">∂</span>measure_spmf <span class="main">(</span><span class="free">body</span> <span class="skolem">s</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nn_integral_mono ennreal_leI Suc.IH<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> weight_spmf <span class="main">(</span>while <span class="skolem">s</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">unfolding</span></span> measure_spmf.emeasure_eq_measure<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> space_measure_spmf
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> while_simps measure_spmf_bind o_def emeasure_bind<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> N<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure_spmf <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> space_measure_spmf Pi_def space_subprob_algebra<span class="main">)</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf_return_spmf measure_return while_simps <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="While_SPMF-termination_0_1"><span class="command">lemma</span></span> termination_0_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">guard</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">≤</span> weight_spmf <span class="main">(</span>while <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> p_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">guard</span> <span class="bound">s</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>while <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lossless_spmf_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">}</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"weight_spmf <span class="main">(</span>while <span class="free">s</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> weight_spmf_le_1<span class="main">)</span>
  
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">≡</span> <span class="free">p</span> <span class="main">/</span> <span class="numeral">2</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> p'_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">&lt;</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p_pos <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p'_def<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">n</span><span class="main">.</span> <span class="skolem">p'</span> <span class="main">&lt;</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="skolem">s</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="keyword1"><span class="command">using</span></span> p<span class="main">[</span><span class="operator">OF</span> that<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">p'</span> <span class="main">&lt;</span> <span class="free">p</span>›</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> weight_while_conv_iter
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> le_cSUP_iff<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> measure_spmf.subprob_measure_le_1<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">N</span></span> <span class="keyword2"><span class="keyword">where</span></span> p'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">≤</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="main">(</span><span class="skolem">N</span> <span class="skolem">s</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="skolem">s</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span>
    <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">by</span></span> <span class="operator">atomize_elim</span><span class="main">(</span><span class="operator">rule</span> choice<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> order.strict_implies_order<span class="main">)</span>

  <span class="keyword1"><span class="command">interpret</span></span> fuse<span class="main">:</span> loop_spmf <span class="quoted"><span class="free">guard</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">s</span><span class="main">.</span> iter <span class="main">(</span><span class="skolem">N</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">s</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">=</span> weight_spmf <span class="main">(</span>fuse.while <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lossless_weight_spmfD<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="main">(</span><span class="operator">rule</span> fuse.termination_0_1_immediate<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_map vimage_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> p' p'_pos lossless_iter lossless<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">n</span><span class="main">.</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fuse.weight_while_conv_iter
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cSUP_least<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>fuse.iter <span class="skolem">n</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> SUP_upper2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> i<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">0</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> inc<span class="main">:</span> <span class="quoted"><span class="quoted">"incseq <span class="main">(</span><span class="main">λ</span><span class="bound">n</span> <span class="bound">s'</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> incseq_SucI le_funI iter_mono_emeasure1<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>fuse.iter <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span> <span class="main">=</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="main">(</span><span class="skolem">N</span> <span class="skolem">s</span><span class="main">)</span> <span class="skolem">s</span> <span class="main">⤜</span> fuse.iter <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">s'</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>fuse.iter <span class="skolem">n</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span> <span class="main">∂</span>measure_spmf <span class="main">(</span>iter <span class="main">(</span><span class="skolem">N</span> <span class="skolem">s</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf_bind o_def emeasure_bind<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> N<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure_spmf <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> space_measure_spmf Pi_def space_subprob_algebra<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">s'</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span><span class="main">)</span> <span class="main">∂</span>measure_spmf <span class="main">(</span>iter <span class="main">(</span><span class="skolem">N</span> <span class="skolem">s</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nn_integral_mono Suc.IH<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">s'</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span> <span class="main">∂</span>measure_spmf <span class="main">(</span>iter <span class="main">(</span><span class="skolem">N</span> <span class="skolem">s</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nn_integral_monotone_convergence_SUP<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inc<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>bind_spmf <span class="main">(</span>iter <span class="main">(</span><span class="skolem">N</span> <span class="skolem">s</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">(</span>iter <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf_bind o_def emeasure_bind<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> N<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure_spmf <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> space_measure_spmf Pi_def space_subprob_algebra<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="main">(</span><span class="skolem">N</span> <span class="skolem">s</span> <span class="main">+</span> <span class="bound">n</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iter_bind_iter<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> emeasure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> SUP_mono<span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> ennreal <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> ennreal_SUP<span class="main">)</span><span class="main">(</span><span class="operator">fold</span> measure_spmf.emeasure_eq_measure<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less measure_spmf.subprob_emeasure_le_1 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">1</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">n</span><span class="main">.</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span>iter <span class="bound">n</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> cSUP_upper2<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bdd_aboveI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> M<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">1</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf.subprob_measure_le_1<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="main">(</span>fuse.iter <span class="skolem">n</span> <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="var">?X</span> <span class="main">≤</span> <span class="main">…</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf.emeasure_eq_measure<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span>  <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">≤</span> weight_spmf <span class="main">(</span>while <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> weight_while_conv_iter <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="While_SPMF-termination_0_1_immediate_invar"><span class="command">lemma</span></span> termination_0_1_immediate_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">I</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> spmf <span class="main">(</span>map_spmf <span class="free">guard</span> <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> False <span class="main">≥</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> p_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> invar<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">s'</span> <span class="main">∈</span> set_spmf <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> <span class="free">guard</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>loop_spmf.while <span class="free">guard</span> <span class="free">body</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> lifting_syntax
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="main">(</span><span class="bound">Rep</span> <span class="main">::</span> <span class="tfree">'s'</span> <span class="main">⇒</span> <span class="tfree">'s</span><span class="main">)</span> <span class="bound">Abs</span><span class="main">.</span> type_definition <span class="bound">Rep</span> <span class="bound">Abs</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Rep</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s'</span> <span class="main">⇒</span> <span class="tfree">'s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">Abs</span></span> <span class="keyword2"><span class="keyword">where</span></span> td<span class="main">:</span> <span class="quoted"><span class="quoted">"type_definition <span class="skolem">Rep</span> <span class="skolem">Abs</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> td<span class="main">:</span> type_definition <span class="quoted"><span class="skolem">Rep</span></span> <span class="quoted"><span class="skolem">Abs</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cr</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="skolem">Rep</span> <span class="bound">y</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">cr</span>"</span></span> <span class="quoted"><span class="quoted">"right_total <span class="skolem">cr</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> td cr_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> typedef_bi_unique typedef_right_total<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_domain_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Domainp <span class="skolem">cr</span> <span class="main">=</span> <span class="free">I</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> type_definition_Domainp<span class="main">[</span><span class="operator">OF</span> td cr_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">guard'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">guard'</span> <span class="main">≡</span> <span class="main">(</span><span class="skolem">Rep</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="free">guard</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cr</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="free">guard</span> <span class="skolem">guard'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def cr_def guard'_def<span class="main">)</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">body1</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">body1</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">guard</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="free">body</span> <span class="bound">s</span> <span class="keyword1">else</span> return_pmf None"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">body1'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">body1'</span> <span class="main">≡</span> <span class="main">(</span><span class="skolem">Rep</span> <span class="main">---&gt;</span> map_spmf <span class="skolem">Abs</span><span class="main">)</span> <span class="skolem">body1</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cr</span> <span class="main">===&gt;</span> rel_spmf <span class="skolem">cr</span><span class="main">)</span> <span class="skolem">body1</span> <span class="skolem">body1'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def body1'_def body1_def cr_def spmf_rel_map td.Rep<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span> invar td.Abs_inverse <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_reflI<span class="main">)</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">s'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span> <span class="main">≡</span> <span class="skolem">Abs</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="free">s</span> <span class="skolem">s'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> s'_def cr_def I td.Abs_inverse<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">guard'</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf <span class="skolem">guard'</span> <span class="main">(</span><span class="skolem">body1'</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> False"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> body1_def p<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> p_pos
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">guard'</span> <span class="bound">s</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="skolem">body1'</span> <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless body1_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>loop_spmf.while <span class="skolem">guard'</span> <span class="skolem">body1'</span> <span class="skolem">s'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> loop_spmf.termination_0_1_immediate<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>loop_spmf.while <span class="free">guard</span> <span class="skolem">body1</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">cancel_type_definition</span><span class="main">]</span> I <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> loop_spmf_while_cong<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="While_SPMF-termination_0_1_invar"><span class="command">lemma</span></span> termination_0_1_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">I</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">≤</span> weight_spmf <span class="main">(</span>loop_spmf.while <span class="free">guard</span> <span class="free">body</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> p_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> invar<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">s'</span> <span class="main">∈</span> set_spmf <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> <span class="free">guard</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>loop_spmf.while <span class="free">guard</span> <span class="free">body</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> lifting_syntax
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="main">(</span><span class="bound">Rep</span> <span class="main">::</span> <span class="tfree">'s'</span> <span class="main">⇒</span> <span class="tfree">'s</span><span class="main">)</span> <span class="bound">Abs</span><span class="main">.</span> type_definition <span class="bound">Rep</span> <span class="bound">Abs</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Rep</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s'</span> <span class="main">⇒</span> <span class="tfree">'s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">Abs</span></span> <span class="keyword2"><span class="keyword">where</span></span> td<span class="main">:</span> <span class="quoted"><span class="quoted">"type_definition <span class="skolem">Rep</span> <span class="skolem">Abs</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> td<span class="main">:</span> type_definition <span class="quoted"><span class="skolem">Rep</span></span> <span class="quoted"><span class="skolem">Abs</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cr</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="skolem">Rep</span> <span class="bound">y</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">cr</span>"</span></span> <span class="quoted"><span class="quoted">"right_total <span class="skolem">cr</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> td cr_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> typedef_bi_unique typedef_right_total<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_domain_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Domainp <span class="skolem">cr</span> <span class="main">=</span> <span class="free">I</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> type_definition_Domainp<span class="main">[</span><span class="operator">OF</span> td cr_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">guard'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">guard'</span> <span class="main">≡</span> <span class="main">(</span><span class="skolem">Rep</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="free">guard</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cr</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="free">guard</span> <span class="skolem">guard'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def cr_def guard'_def<span class="main">)</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">body1</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">body1</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">guard</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="free">body</span> <span class="bound">s</span> <span class="keyword1">else</span> return_pmf None"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">body1'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">body1'</span> <span class="main">≡</span> <span class="main">(</span><span class="skolem">Rep</span> <span class="main">---&gt;</span> map_spmf <span class="skolem">Abs</span><span class="main">)</span> <span class="skolem">body1</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cr</span> <span class="main">===&gt;</span> rel_spmf <span class="skolem">cr</span><span class="main">)</span> <span class="skolem">body1</span> <span class="skolem">body1'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def body1'_def body1_def cr_def spmf_rel_map td.Rep<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span> invar td.Abs_inverse <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_reflI<span class="main">)</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">s'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span> <span class="main">≡</span> <span class="skolem">Abs</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="free">s</span> <span class="skolem">s'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> s'_def cr_def I td.Abs_inverse<span class="main">)</span>
    
    <span class="keyword1"><span class="command">interpret</span></span> loop_spmf <span class="quoted"><span class="skolem">guard'</span></span> <span class="quoted"><span class="skolem">body1'</span></span> <span class="keyword1"><span class="command">.</span></span>

    <span class="keyword1"><span class="command">note</span></span> UNIV_parametric_pred<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">guard'</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">≤</span> weight_spmf <span class="main">(</span>while <span class="bound">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> measure_measure_spmf_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> space_measure_spmf
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> body1_def p<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> space_measure_spmf<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> loop_spmf_while_cong<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> p_pos
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">guard'</span> <span class="bound">s</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="skolem">body1'</span> <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless body1_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>while <span class="skolem">s'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> termination_0_1<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>loop_spmf.while <span class="free">guard</span> <span class="skolem">body1</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">cancel_type_definition</span><span class="main">]</span> I <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> loop_spmf_while_cong<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Variant rule›</span></span>

<span class="keyword1"><span class="command">context</span></span> loop_spmf <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="While_SPMF-termination_variant"><span class="command">lemma</span></span> termination_variant<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">bound</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">guard</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">s</span> <span class="main">≤</span> <span class="free">bound</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">guard</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="free">f</span> <span class="bound">s'</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> True"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> p_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">guard</span> <span class="bound">s</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>while <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">≡</span> min <span class="free">p</span> <span class="main">1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≡</span> <span class="free">bound</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> p'_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="skolem">p'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> p'_le_1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">≤</span> <span class="main">1</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> step'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="skolem">s</span> <span class="main">⟹</span> <span class="skolem">p'</span> <span class="main">≤</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="free">body</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="free">f</span> <span class="bound">s'</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="skolem">s</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span>
    <span class="keyword1"><span class="command">using</span></span> p_pos step<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">s</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p'_def spmf_map vimage_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">^</span> <span class="skolem">n</span> <span class="main">≤</span> weight_spmf <span class="main">(</span>while <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">s</span> <span class="main">&lt;</span> <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="keyword1"><span class="command">using</span></span> that
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">s</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="skolem">s</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"weight_spmf <span class="main">(</span>while <span class="skolem">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> while.simps<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> p'_le_1 p_pos 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span><span class="main">(</span><span class="operator">meson</span> less_eq_real_def mult_le_one p'_pos power_le_one zero_le_power<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?M</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"measure_spmf <span class="main">(</span><span class="free">body</span> <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">^</span> Suc <span class="skolem">n</span> <span class="main">≤</span> <span class="main">(</span><span class="main">∫</span> <span class="bound">s'</span><span class="main">.</span> indicator <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="free">f</span> <span class="bound">s'</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="skolem">s</span><span class="main">}</span> <span class="bound">s'</span> <span class="main">∂</span><span class="var">?M</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">p'</span> <span class="main">^</span> <span class="skolem">n</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> step'<span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span> p'_pos <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mult_right_mono<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∫</span> <span class="bound">s'</span><span class="main">.</span> indicator <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="free">f</span> <span class="bound">s'</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="skolem">s</span><span class="main">}</span> <span class="bound">s'</span> <span class="main">*</span> <span class="skolem">p'</span> <span class="main">^</span> <span class="skolem">n</span> <span class="main">∂</span><span class="var">?M</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">(</span><span class="main">∫</span> <span class="bound">s'</span><span class="main">.</span> indicator <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="free">f</span> <span class="bound">s'</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="skolem">s</span><span class="main">}</span> <span class="bound">s'</span> <span class="main">*</span> weight_spmf <span class="main">(</span>while <span class="bound">s'</span><span class="main">)</span> <span class="main">∂</span><span class="var">?M</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> Suc.prems p'_le_1 p'_pos
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> integral_mono<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc.IH power_le_one weight_spmf_le_1 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> measure_spmf.integrable_const_bound<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">1</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">…</span> <span class="main">+</span> <span class="main">(</span><span class="main">∫</span> <span class="bound">s'</span><span class="main">.</span> indicator <span class="main">{</span><span class="bound">s'</span><span class="main">.</span> <span class="free">f</span> <span class="bound">s'</span> <span class="main">≥</span> <span class="free">f</span> <span class="skolem">s</span><span class="main">}</span> <span class="bound">s'</span> <span class="main">*</span> weight_spmf <span class="main">(</span>while <span class="bound">s'</span><span class="main">)</span> <span class="main">∂</span><span class="var">?M</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integral_nonneg_AE weight_spmf_nonneg<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">∫</span> <span class="bound">s'</span><span class="main">.</span> weight_spmf <span class="main">(</span>while <span class="bound">s'</span><span class="main">)</span> <span class="main">∂</span><span class="var">?M</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> Bochner_Integration.integral_add<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Bochner_Integration.integral_cong measure_spmf.integrable_const_bound<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">1</span></span><span class="main"><span class="main">]</span></span> weight_spmf_le_1 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> weight_spmf <span class="main">(</span>while <span class="skolem">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> while.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> weight_bind_spmf o_def<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="skolem">p'</span> <span class="main">^</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p'_pos <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> lossless
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> termination_0_1_invar<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">s</span> <span class="main">&lt;</span> <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="skolem">s</span> <span class="main">⟶</span> <span class="free">f</span> <span class="skolem">s</span> <span class="main">&lt;</span> <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="free">s</span> <span class="main">⟶</span> <span class="free">f</span> <span class="free">s</span> <span class="main">&lt;</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">s</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> n_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">guard</span> <span class="skolem">s'</span> <span class="main">⟶</span> <span class="free">f</span> <span class="skolem">s'</span> <span class="main">&lt;</span> <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s'</span> <span class="keyword1"><span class="command">using</span></span> bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">s'</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> n_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="While_SPMF-termination_variant_invar"><span class="command">lemma</span></span> termination_variant_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">bound</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">I</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">s</span> <span class="main">≤</span> <span class="free">bound</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="free">f</span> <span class="bound">s'</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> True"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> p_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">guard</span> <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> invar<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">s'</span> <span class="main">∈</span> set_spmf <span class="main">(</span><span class="free">body</span> <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> <span class="free">guard</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>loop_spmf.while <span class="free">guard</span> <span class="free">body</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> lifting_syntax
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="main">(</span><span class="bound">Rep</span> <span class="main">::</span> <span class="tfree">'s'</span> <span class="main">⇒</span> <span class="tfree">'s</span><span class="main">)</span> <span class="bound">Abs</span><span class="main">.</span> type_definition <span class="bound">Rep</span> <span class="bound">Abs</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Rep</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s'</span> <span class="main">⇒</span> <span class="tfree">'s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">Abs</span></span> <span class="keyword2"><span class="keyword">where</span></span> td<span class="main">:</span> <span class="quoted"><span class="quoted">"type_definition <span class="skolem">Rep</span> <span class="skolem">Abs</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> td<span class="main">:</span> type_definition <span class="quoted"><span class="skolem">Rep</span></span> <span class="quoted"><span class="skolem">Abs</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cr</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="skolem">Rep</span> <span class="bound">y</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">cr</span>"</span></span> <span class="quoted"><span class="quoted">"right_total <span class="skolem">cr</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> td cr_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> typedef_bi_unique typedef_right_total<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_domain_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Domainp <span class="skolem">cr</span> <span class="main">=</span> <span class="free">I</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> type_definition_Domainp<span class="main">[</span><span class="operator">OF</span> td cr_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">guard'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">guard'</span> <span class="main">≡</span> <span class="main">(</span><span class="skolem">Rep</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="free">guard</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cr</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="free">guard</span> <span class="skolem">guard'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def cr_def guard'_def<span class="main">)</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">body1</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">body1</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">guard</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="free">body</span> <span class="bound">s</span> <span class="keyword1">else</span> return_pmf None"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">body1'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">body1'</span> <span class="main">≡</span> <span class="main">(</span><span class="skolem">Rep</span> <span class="main">---&gt;</span> map_spmf <span class="skolem">Abs</span><span class="main">)</span> <span class="skolem">body1</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cr</span> <span class="main">===&gt;</span> rel_spmf <span class="skolem">cr</span><span class="main">)</span> <span class="skolem">body1</span> <span class="skolem">body1'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def body1'_def body1_def cr_def spmf_rel_map td.Rep<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span> invar td.Abs_inverse <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_reflI<span class="main">)</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">s'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span> <span class="main">≡</span> <span class="skolem">Abs</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="free">s</span> <span class="skolem">s'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> s'_def cr_def I td.Abs_inverse<span class="main">)</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">f'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f'</span> <span class="main">≡</span> <span class="main">(</span><span class="skolem">Rep</span> <span class="main">---&gt;</span> id<span class="main">)</span> <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cr</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="free">f</span> <span class="skolem">f'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def cr_def f'_def<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">guard'</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="skolem">f'</span> <span class="bound">s</span> <span class="main">≤</span> <span class="free">bound</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">bound</span></span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> bound<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">guard'</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="skolem">f'</span> <span class="bound">s'</span> <span class="main">&lt;</span> <span class="skolem">f'</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="skolem">body1'</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> True"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step body1_def<span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> this p_pos
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">guard'</span> <span class="bound">s</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="skolem">body1'</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> body1_def lossless<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>loop_spmf.while <span class="skolem">guard'</span> <span class="skolem">body1'</span> <span class="skolem">s'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> loop_spmf.termination_variant<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>loop_spmf.while <span class="free">guard</span> <span class="skolem">body1</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">cancel_type_definition</span><span class="main">]</span> I <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> loop_spmf_while_cong<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Bernoulli">
<div class="head">
<h1>Theory Bernoulli</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Bernoulli.thy
   Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Distributions built from coin flips›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹ The Bernoulli distribution›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Bernoulli <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="../../HOL/HOL-Probability/Probability.html">HOL-Probability.Probability</a>"</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bernoulli-zero_lt_num"><span class="command">lemma</span></span> zero_lt_num <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="main">(</span>numeral <span class="free">n</span> <span class="main">::</span> <span class="main">_</span> <span class="main">::</span> <span class="main">{</span>canonically_ordered_monoid_add<span class="main">,</span> semiring_char_0<span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> not_gr_zero zero_neq_numeral<span class="main">)</span>

<span class="keyword1" id="Bernoulli-ennreal_mult_numeral"><span class="command">lemma</span></span> ennreal_mult_numeral<span class="main">:</span> <span class="quoted"><span class="quoted">"ennreal <span class="free">x</span> <span class="main">*</span> numeral <span class="free">n</span> <span class="main">=</span> ennreal <span class="main">(</span><span class="free">x</span> <span class="main">*</span> numeral <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ennreal_mult''<span class="main">)</span>

<span class="keyword1" id="Bernoulli-one_plus_ennreal"><span class="command">lemma</span></span> one_plus_ennreal<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">⟹</span> <span class="main">1</span> <span class="main">+</span> ennreal <span class="free">x</span> <span class="main">=</span> ennreal <span class="main">(</span><span class="main">1</span> <span class="main">+</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define the Bernoulli distribution as a least fixpoint instead of a loop because this
  avoids the need to add a condition flag to the distribution, which we would have to project
  out at the end again.  As the direct termination proof is so simple, we do not bother to prove
  it equivalent to a while loop.
›</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>spmf<span class="main">)</span> <span class="entity">bernoulli</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"real <span class="main">⇒</span> bool spmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bernoulli</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
     <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> return_spmf <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≥</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">)</span>
     <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">&lt;</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="keyword1">then</span> <span class="free">bernoulli</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>
     <span class="keyword1">else</span> <span class="free">bernoulli</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>
   <span class="main">}</span>"</span></span>

<span class="keyword1" id="Bernoulli-pmf_bernoulli_None"><span class="command">lemma</span></span> pmf_bernoulli_None<span class="main">:</span> <span class="quoted"><span class="quoted">"pmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> None <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ereal <span class="main">(</span>pmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> None<span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">INF</span> <span class="bound">n</span><span class="main">∈</span>UNIV<span class="main">.</span> ereal <span class="main">(</span><span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> INF_greatest<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ereal <span class="main">(</span>pmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> None<span class="main">)</span> <span class="main">≤</span> ereal <span class="main">(</span><span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">n</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> Suc.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="skolem">p</span>"</span></span><span class="main">]</span> Suc.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="skolem">p</span> <span class="main">-</span> <span class="main">1</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> bernoulli.simps<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> UNIV_bool max_def <span class="dynamic"><span class="dynamic">field_simps</span></span> spmf_of_pmf_pmf_of_set<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> pmf_bind_pmf_of_set ennreal_pmf_bind nn_integral_pmf_of_set <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> spmf_of_pmf_pmf_of_set<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf_le_1<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> ereal <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> LIMSEQ_unique<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> ereal <span class="main">(</span><span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">⇢</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> LIMSEQ_INF<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span> decseq_SucI<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> ereal <span class="main">(</span><span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">⇢</span> ereal <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LIMSEQ_divide_realpow_zero<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bernoulli-lossless_bernoulli"><span class="command">lemma</span></span> lossless_bernoulli <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_iff_pmf_None pmf_bernoulli_None<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≤</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> bernoulli_True<span class="main">:</span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> True <span class="main">=</span> <span class="free">p</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?True</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> bernoulli_False<span class="main">:</span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> False <span class="main">=</span> <span class="main">1</span> <span class="main">-</span> <span class="free">p</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?False</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ennreal <span class="main">(</span>spmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">≤</span> ennreal <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">b</span> <span class="keyword1">then</span> <span class="free">p</span> <span class="keyword1">else</span> <span class="main">1</span> <span class="main">-</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">b</span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bernoulli.fixp_induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> adm bottom step<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> adm <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="dynamic"><span class="dynamic">cont_intro</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">bernoulli'</span> <span class="skolem">p</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> step.prems step.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="skolem">p</span>"</span></span><span class="main">]</span> step.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="skolem">p</span> <span class="main">-</span> <span class="main">1</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> UNIV_bool max_def divide_le_posI_ennreal ennreal_mult_numeral numeral_mult_ennreal <span class="dynamic"><span class="dynamic">field_simps</span></span> spmf_of_pmf_pmf_of_set<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> ennreal_pmf_bind nn_integral_pmf_of_set one_plus_ennreal <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> spmf_of_pmf_pmf_of_set ennreal_plus<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted">True</span><span class="main">]</span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted">False</span><span class="main">]</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> True <span class="main">+</span> spmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> False <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_False_conv_True<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?True</span></span></span> <span class="var"><span class="quoted"><span class="var">?False</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ennreal_le_iff2<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bernoulli-bernoulli_neg"><span class="command">lemma</span></span> bernoulli_neg <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bernoulli <span class="free">p</span> <span class="main">=</span> return_spmf False"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(=)</span> <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> <span class="main">(</span>return_spmf False<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bernoulli.fixp_induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> adm bottom step<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">bernoulli'</span> <span class="skolem">p</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> step.prems step.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="skolem">p</span>"</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord_spmf_return_spmf2 set_bind_spmf bind_UNION <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">from</span></span> ord_spmf_eq_leD<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted">True</span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> True <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">then</span></span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> False <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_False_conv_True<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> spmf_eqI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Bernoulli-bernoulli_pos"><span class="command">lemma</span></span> bernoulli_pos <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">≤</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bernoulli <span class="free">p</span> <span class="main">=</span> return_spmf True"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(=)</span> <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> <span class="main">(</span>return_spmf True<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bernoulli.fixp_induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> adm bottom step<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">bernoulli'</span> <span class="skolem">p</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> step.prems step.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="skolem">p</span> <span class="main">-</span> <span class="main">1</span>"</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord_spmf_return_spmf2 set_bind_spmf bind_UNION <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">from</span></span> ord_spmf_eq_leD<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted">False</span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> False <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">then</span></span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span> True <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_False_conv_True<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> spmf_eqI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> pmf_as_function <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1" id="Bernoulli-bernoulli_eq_bernoulli_pmf"><span class="command">lemma</span></span> bernoulli_eq_bernoulli_pmf<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bernoulli <span class="free">p</span> <span class="main">=</span> spmf_of_pmf <span class="main">(</span>bernoulli_pmf <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> spmf_eqI<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> max_def min_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Geometric">
<div class="head">
<h1>Theory Geometric</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Geometric.thy
   Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The geometric distribution›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Geometric <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Bernoulli.html">Bernoulli</a>
  <a href="While_SPMF.html">While_SPMF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define the geometric distribution as a least fixpoint, which is more elegant than
  as a loop. To prove probabilistic termination, we prove it equivalent to a loop and use
  the proof rules for probabilistic termination.
›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">function_internals</span><span class="main">]</span><span class="main">]</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>spmf<span class="main">)</span> <span class="entity">geometric_spmf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"real <span class="main">⇒</span> nat spmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">geometric_spmf</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">b</span> <span class="main">←</span> bernoulli <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
     <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> return_spmf <span class="main">0</span> <span class="keyword1">else</span> map_spmf <span class="main">(</span><span class="main">(+)</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="free">geometric_spmf</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Geometric-geometric_spmf_fixp_induct"><span class="command">lemma</span></span> geometric_spmf_fixp_induct <span class="main">[</span><span class="operator">case_names</span> adm bottom step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"spmf.admissible <span class="free">P</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="main">λ</span><span class="bound">geometric_spmf</span><span class="main">.</span> return_pmf None<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">geometric_spmf'</span><span class="main">.</span> <span class="free">P</span> <span class="bound">geometric_spmf'</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> bernoulli <span class="bound">p</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> return_spmf <span class="main">0</span> <span class="keyword1">else</span> map_spmf <span class="main">(</span><span class="main">(+)</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="bound">geometric_spmf'</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> geometric_spmf"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> geometric_spmf.fixp_induct<span class="main">)</span>

<span class="keyword1" id="Geometric-spmf_geometric_nonpos"><span class="command">lemma</span></span> spmf_geometric_nonpos<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≤</span> <span class="main">0</span> <span class="main">⟹</span> geometric_spmf <span class="free">p</span> <span class="main">=</span> return_pmf None"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> geometric_spmf_fixp_induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Geometric-spmf_geometric_ge_1"><span class="command">lemma</span></span> spmf_geometric_ge_1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">≤</span> <span class="free">p</span> <span class="main">⟹</span> geometric_spmf <span class="free">p</span> <span class="main">=</span> return_spmf <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> geometric_spmf.simps<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted">real</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">body</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">×</span> nat <span class="main">⇒</span> <span class="main">(</span>bool <span class="main">×</span> nat<span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">body</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">.</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">b'</span><span class="main">.</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">b'</span><span class="main">,</span> <span class="bound">x</span> <span class="main">+</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b'</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> loop_spmf <span class="quoted">fst</span> <span class="quoted"><span class="free">body</span></span> 
  <span class="keyword2"><span class="keyword">rewrites</span></span> <span class="quoted"><span class="quoted">"<span class="free">body</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">.</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">b'</span><span class="main">.</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">b'</span><span class="main">,</span> <span class="bound">x</span> <span class="main">+</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b'</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> body_def<span class="main">)</span>

<span class="keyword1" id="Geometric-geometric_spmf_conv_while"><span class="command">lemma</span></span> geometric_spmf_conv_while<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"geometric_spmf <span class="free">p</span> <span class="main">=</span> map_spmf snd <span class="main">(</span>while <span class="main">(</span>True<span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">(</span><span class="main">(+)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>geometric_spmf <span class="free">p</span><span class="main">)</span> <span class="main">=</span> map_spmf snd <span class="main">(</span>while <span class="main">(</span>True<span class="main">,</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> spmf.leq_antisym<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(=)</span> <span class="var">?lhs</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> geometric_spmf_fixp_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> adm <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">geometric'</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> step.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">x</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> while.simps<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_bind_spmf bind_map_spmf <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ord_spmf_bind_reflI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> while.simps<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf.map_comp o_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(=)</span> <span class="var">?rhs</span> <span class="var">?lhs</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(=)</span> <span class="main">(</span>map_spmf snd <span class="main">(</span>while <span class="main">(</span>False<span class="main">,</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>return_spmf <span class="skolem">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> while_fixp_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> adm <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">while'</span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> step.IH<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">x</span>"</span></span><span class="main">]</span> step.IH<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rewrite</span> geometric_spmf.simps<span class="main">)</span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_bind_spmf bind_map_spmf spmf.map_comp o_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ord_spmf_bind_reflI<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(=)</span> <span class="var">?rhs</span> <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="main">0</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> map_spmf_cong<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Geometric-lossless_geometric"><span class="command">lemma</span></span> lossless_geometric <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>geometric_spmf <span class="free">p</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">p</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">p</span> <span class="main">∧</span> <span class="free">p</span> <span class="main">&lt;</span> <span class="main">1</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?body</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">x</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">.</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">b'</span><span class="main">.</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">b'</span><span class="main">,</span> <span class="bound">x</span> <span class="main">+</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b'</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>bernoulli <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>while <span class="main">(</span>True<span class="main">,</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> termination_0_1_immediate<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span>True<span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?body</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> False"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">×</span> nat"</span></span> <span class="keyword1"><span class="command">using</span></span> True
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">s</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf.map_comp o_def spmf_map vimage_def spmf_conv_measure_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> geometric_spmf_conv_while<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_geometric_nonpos spmf_geometric_ge_1<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Geometric-spmf_geometric"><span class="command">lemma</span></span> spmf_geometric<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">&lt;</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>geometric_spmf <span class="free">p</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">^</span> <span class="free">n</span> <span class="main">*</span> <span class="free">p</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="free">n</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="free">n</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> spmf_ub_tight<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ennreal <span class="main">(</span><span class="var">?lhs</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">≤</span> ennreal <span class="main">(</span><span class="var">?rhs</span> <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> geometric_spmf_fixp_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> adm <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="dynamic"><span class="dynamic">cont_intro</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">geometric_spmf'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ennreal_spmf_bind nn_integral_measure_spmf UNIV_bool nn_integral_count_space_finite ennreal_mult spmf_map vimage_def mult.assoc spmf_conv_measure_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> mult_mono <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">n</span> <span class="main">≤</span> <span class="var">?rhs</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">.</span> ennreal <span class="main">(</span><span class="free">p</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">^</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ennreal <span class="main">(</span><span class="free">p</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">/</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> suminf_ennreal_eq sums_mult geometric_sums<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">x</span><span class="main">.</span> ennreal <span class="main">(</span><span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">^</span> <span class="bound">x</span> <span class="main">*</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> weight_spmf <span class="main">(</span>geometric_spmf <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> lossless_geometric<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> p <span class="keyword1"><span class="command">unfolding</span></span> lossless_spmf_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nn_integral_count_space_nat <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Fast_Dice_Roll">
<div class="head">
<h1>Theory Fast_Dice_Roll</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Fast_Dice_Roll.thy
   Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Arbitrary uniform distributions›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Fast_Dice_Roll <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Bernoulli.html">Bernoulli</a>
  <a href="While_SPMF.html">While_SPMF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This formalisation follows the ideas by J\'er\'emie Lumbroso \cite{Lumbroso2013arxiv}.›</span></span>

<span class="keyword1" id="Fast_Dice_Roll-sample_bits_fusion"><span class="command">lemma</span></span> sample_bits_fusion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">v</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"bind_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> bind_pmf <span class="main">(</span>pmf_of_set UNIV<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">c</span> <span class="main">+</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
   bind_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="free">f</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> bind_pmf <span class="main">(</span>map_pmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">c</span> <span class="main">+</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>pair_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>pmf_of_set UNIV<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">f</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> bind_pmf <span class="main">(</span>map_pmf <span class="var">?f</span> <span class="main">_</span><span class="main">)</span> <span class="main">_</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pair_pmf_def bind_map_pmf bind_assoc_pmf bind_return_pmf<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf <span class="var">?f</span> <span class="main">(</span>pair_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>pmf_of_set UNIV<span class="main">)</span><span class="main">)</span> <span class="main">=</span> pmf_of_set <span class="main">{..&lt;</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">v</span><span class="main">}</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"map_pmf <span class="var">?f</span> <span class="var">?p</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> pmf_eqI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="var">?f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span> <span class="operator">arith</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">i'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">≡</span> <span class="skolem">i</span> <span class="keyword1">div</span> <span class="numeral">2</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">≡</span> odd <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> <span class="var">?f</span> <span class="main">(</span><span class="skolem">i'</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> i'_def b_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pmf <span class="var">?l</span> <span class="skolem">i</span> <span class="main">=</span> pmf <span class="var">?r</span> <span class="skolem">i</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> i<span class="main"><span class="keyword3">;</span></span> <span class="operator">subst</span> pmf_map_inj'<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf_pair i'_def assms lessThan_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Fast_Dice_Roll-sample_bits_fusion2"><span class="command">lemma</span></span> sample_bits_fusion2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">v</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"bind_pmf <span class="main">(</span>pmf_of_set UNIV<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> bind_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">c</span> <span class="main">+</span> <span class="free">v</span> <span class="main">*</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
   bind_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="free">f</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> bind_pmf <span class="main">(</span>map_pmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">c</span> <span class="main">+</span> <span class="free">v</span> <span class="main">*</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>pair_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>pmf_of_set UNIV<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">f</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> bind_pmf <span class="main">(</span>map_pmf <span class="var">?f</span> <span class="main">_</span><span class="main">)</span> <span class="main">_</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> pair_pmf_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> bind_commute_pmf<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_pmf bind_assoc_pmf bind_return_pmf<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf <span class="var">?f</span> <span class="main">(</span>pair_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>pmf_of_set UNIV<span class="main">)</span><span class="main">)</span> <span class="main">=</span> pmf_of_set <span class="main">{..&lt;</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">v</span><span class="main">}</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"map_pmf <span class="var">?f</span> <span class="var">?p</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> pmf_eqI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="var">?f</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">v</span><span class="main">}</span> <span class="main">×</span> UNIV<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">i'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="skolem">i</span> <span class="main">≥</span> <span class="free">v</span> <span class="keyword1">then</span> <span class="skolem">i</span> <span class="main">-</span> <span class="free">v</span> <span class="keyword1">else</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">≡</span> <span class="skolem">i</span> <span class="main">≥</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> <span class="var">?f</span> <span class="main">(</span><span class="skolem">i'</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> i'_def b_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pmf <span class="var">?l</span> <span class="skolem">i</span> <span class="main">=</span> pmf <span class="var">?r</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">v</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> i<span class="main"><span class="keyword3">;</span></span> <span class="operator">subst</span> pmf_map_inj<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf_pair i'_def assms lessThan_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∉</span> set_pmf <span class="var">?l</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∉</span> set_pmf <span class="var">?r</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessThan_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_pmf_iff <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> set_map_pmf<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">function_internals</span><span class="main">]</span><span class="main">]</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The check for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">v</span></span> <span class="main"><span class="main">&gt;=</span></span> <span class="free"><span class="free">n</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> should be done already at the start of the loop. 
  Otherwise we do not see why this algorithm should be optimal (when we start with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">v</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">n</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">c</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">n</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">1</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, then it can go round a few loops before it returns something).

  We define the algorithm as a least fixpoint. To prove termination, we later show that it is
  equivalent to a while loop which samples bitstrings of a given length, which could in turn 
  be implemented as a loop.  The fixpoint formulation is more elegant because we do not need to
  nest any loops.
›</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>spmf<span class="main">)</span> <span class="entity">fast_dice_roll</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fast_dice_roll</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≥</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> return_spmf <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="keyword1">else</span> <span class="free">fast_dice_roll</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
     <span class="free">fast_dice_roll</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">+</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">}</span> <span class="main">)</span>"</span></span>

<span class="keyword1" id="Fast_Dice_Roll-fast_dice_roll_fixp_induct"><span class="command">lemma</span></span> fast_dice_roll_fixp_induct <span class="main">[</span><span class="operator">case_names</span> adm bottom step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"spmf.admissible <span class="main">(</span><span class="main">λ</span><span class="bound">fast_dice_roll</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>curry <span class="bound">fast_dice_roll</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">c</span><span class="main">.</span> return_pmf None<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">fdr</span><span class="main">.</span> <span class="free">P</span> <span class="bound">fdr</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">c</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">v</span> <span class="main">≥</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="keyword1">if</span> <span class="bound">c</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> return_spmf <span class="bound">c</span> <span class="keyword1">else</span> <span class="bound">fdr</span> <span class="main">(</span><span class="bound">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="bound">c</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span>
        <span class="keyword1">else</span> bind_spmf coin_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="bound">fdr</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">v</span><span class="main">)</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">c</span> <span class="main">+</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> fast_dice_roll"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> fast_dice_roll.fixp_induct<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fast_uniform</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fast_uniform</span> <span class="main">=</span> fast_dice_roll <span class="main">1</span> <span class="main">0</span>"</span></span>

<span class="keyword1" id="Fast_Dice_Roll-spmf_fast_dice_roll_ub"><span class="command">lemma</span></span> spmf_fast_dice_roll_ub<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>bind_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>fast_dice_roll <span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">/</span> <span class="free">n</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ennreal <span class="var">?lhs</span> <span class="main">≤</span> ennreal <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fast_dice_roll_fixp_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> adm <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="dynamic"><span class="dynamic">cont_intro</span></span> ccpo_class.admissible_leI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="operator">simp_all</span>
    <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">fdr</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="skolem">v</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> le<span class="main">:</span> True
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> spmf <span class="main">(</span>bind_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">c</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> return_spmf <span class="bound">c</span> <span class="keyword1">else</span> <span class="skolem">fdr</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="bound">c</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">c'</span><span class="main">.</span> indicator <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span> <span class="bound">c'</span> <span class="main">∂</span>measure_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span>
        <span class="main">(</span><span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">c'</span><span class="main">.</span> indicator <span class="main">{</span><span class="free">n</span> <span class="main">..&lt;</span> <span class="skolem">v</span><span class="main">}</span> <span class="bound">c'</span> <span class="main">*</span> spmf <span class="main">(</span><span class="skolem">fdr</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="bound">c'</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">∂</span>measure_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?then</span> <span class="main">=</span> <span class="var">?found</span> <span class="main">+</span> <span class="var">?continue</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> step.prems
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> nn_integral_add<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ennreal_pmf_bind AE_measure_pmf_iff lessThan_empty_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> nn_integral_cong_AE<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?found</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span> <span class="main">/</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> step.prems le
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_pmf.emeasure_eq_measure measure_pmf_of_set lessThan_empty_iff Iio_Int_singleton<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?continue</span> <span class="main">=</span> <span class="main">(</span><span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">c'</span><span class="main">.</span> indicator <span class="main">{</span><span class="free">n</span> <span class="main">..&lt;</span> <span class="skolem">v</span><span class="main">}</span> <span class="bound">c'</span> <span class="main">*</span> <span class="main">1</span> <span class="main">/</span> <span class="skolem">v</span> <span class="main">*</span> spmf <span class="main">(</span><span class="skolem">fdr</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="bound">c'</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">∂</span>count_space UNIV<span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> step.prems <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nn_integral_measure_pmf lessThan_empty_iff ennreal_mult<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> nn_integral_cong <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">v</span> <span class="main">=</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> ennreal <span class="main">(</span><span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">/</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">*</span> spmf <span class="main">(</span>bind_pmf <span class="main">(</span>pmf_of_set <span class="main">{</span><span class="free">n</span><span class="main">..&lt;</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c'</span><span class="main">.</span> <span class="skolem">fdr</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="bound">c'</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> le step.prems
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> ennreal_pmf_bind<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ennreal_mult<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> nn_integral_measure_pmf nn_integral_0_iff_AE AE_count_space nn_integral_cmult<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> <span class="skolem">v</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pmf_of_set <span class="main">{</span><span class="free">n</span><span class="main">..&lt;</span><span class="skolem">v</span><span class="main">}</span> <span class="main">=</span> map_pmf <span class="main">(</span><span class="main">(+)</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">}</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> map_pmf_of_set_inj<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def lessThan_empty_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">pmf_of_set</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">-</span> <span class="free">n</span>"</span></span><span class="main"><span class="main">]</span></span> diff_less_mono<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"bind_pmf <span class="main">…</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c'</span><span class="main">.</span> <span class="skolem">fdr</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="bound">c'</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> bind_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="skolem">fdr</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_pmf<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ennreal <span class="main">(</span>spmf <span class="main">…</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">/</span> <span class="free">n</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> step.IH<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> *<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> calculation <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> ennreal <span class="main">(</span><span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">/</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">/</span> <span class="free">n</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> le
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">=</span> <span class="free">n</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> divide_right_mono mult_left_mono<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">/</span> <span class="skolem">v</span> <span class="main">*</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">/</span> <span class="free">n</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ennreal_mult<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> le <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add_mono <span class="dynamic"><span class="dynamic">field_simps</span></span> of_nat_diff ennreal_plus<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> ennreal_plus<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> spmf <span class="main">(</span>bind_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> bind_pmf <span class="main">(</span>pmf_of_set UNIV<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="skolem">fdr</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">c</span> <span class="main">+</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_spmf_spmf_of_set<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> spmf <span class="main">(</span>bind_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">v</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="skolem">fdr</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> step.prems
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_bits_fusion<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> step.prems <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> step.IH<span class="main">)</span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Fast_Dice_Roll-spmf_fast_uniform_ub"><span class="command">lemma</span></span> spmf_fast_uniform_ub<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spmf fast_uniform <span class="free">x</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">/</span> <span class="free">n</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{..&lt;</span>Suc <span class="main">0</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> spmf_fast_dice_roll_ub<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="main">1</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fast_uniform_def pmf_of_set_singleton bind_return_pmf <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Fast_Dice_Roll-fast_dice_roll_0"><span class="command">lemma</span></span> fast_dice_roll_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"fast_dice_roll <span class="main">0</span> <span class="free">c</span> <span class="main">=</span> return_pmf None"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">c</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fast_dice_roll_fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_eq_return_pmf_None<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To prove termination, we fold all the iterations that only double into one big step›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fdr_step</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fdr_step</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> return_pmf None
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">x</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span>nat <span class="main">⌈</span>log <span class="numeral">2</span> <span class="main">(</span>max <span class="main">1</span> <span class="free">n</span><span class="main">)</span> <span class="main">-</span> log <span class="numeral">2</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">⌉</span><span class="main">)</span> <span class="keyword1">in</span>
     map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">bs</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span> <span class="bound">x</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">+</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="main">{..&lt;</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Fast_Dice_Roll-fdr_step_unfold"><span class="command">lemma</span></span> fdr_step_unfold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fdr_step <span class="free">v</span> <span class="free">c</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">v</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> return_pmf None 
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">n</span> <span class="main">≤</span> <span class="free">v</span> <span class="keyword1">then</span> return_spmf <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
     fdr_step <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">_</span> <span class="keyword1">then</span> <span class="main">_</span> <span class="keyword1">else</span> <span class="var">?else</span><span class="main">)</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> v<span class="main">:</span> False
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">v</span> <span class="main">::</span> nat<span class="main">.</span> <span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span>nat <span class="main">⌈</span>log <span class="numeral">2</span> <span class="main">(</span>max <span class="main">1</span> <span class="free">n</span><span class="main">)</span> <span class="main">-</span> log <span class="numeral">2</span> <span class="bound">v</span><span class="main">⌉</span><span class="main">)</span> <span class="main">::</span> nat"</span></span>
  <span class="keyword1"><span class="command">have</span></span> x_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="free">v</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> x_def<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="free">v</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> le<span class="main">:</span> True
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="free">v</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> x_def log_le<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{..&lt;</span><span class="main">1</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span> <span class="main">::</span> nat<span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> le v <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fdr_step_def spmf_of_set_singleton<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> less<span class="main">:</span> False
    <span class="keyword1"><span class="command">hence</span></span> even<span class="main">:</span> <span class="quoted"><span class="quoted">"even <span class="main">(</span><span class="skolem">x</span> <span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> x_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> x_pos <span class="keyword1"><span class="command">have</span></span> x_ge_1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="free">v</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="free">v</span> <span class="main">=</span> <span class="main">1</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span> <span class="free">v</span> <span class="keyword1">div</span> <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v less <span class="keyword1"><span class="command">unfolding</span></span> x_def 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> log_mult diff_add_eq_diff_diff_swap<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">_</span></span> <span class="main"><span class="main">=</span></span> <span class="numeral"><span class="numeral">2</span></span> <span class="main"><span class="main">^</span></span> <span class="main"><span class="main">⌑</span></span> <span class="keyword1"><span class="keyword1">div</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> le_add_diff_inverse2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> b<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main"><span class="quoted"><span class="main">1</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_leI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> Suc_pred<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">bs</span><span class="main">.</span> <span class="main">(</span><span class="skolem">x</span> <span class="free">v</span> <span class="main">*</span> <span class="free">v</span><span class="main">,</span> <span class="skolem">x</span> <span class="free">v</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="main">{..&lt;</span><span class="skolem">x</span> <span class="free">v</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> v <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fdr_step_def x_def Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> even <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> bind_pmf <span class="main">(</span>pmf_of_set <span class="main">{..&lt;</span><span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">x</span> <span class="free">v</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">bs</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="skolem">x</span> <span class="free">v</span> <span class="main">*</span> <span class="free">v</span><span class="main">,</span> <span class="skolem">x</span> <span class="free">v</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf bind_spmf_spmf_of_set x_pos lessThan_empty_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> bind_spmf coin_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> bind_spmf <span class="main">(</span>spmf_of_set <span class="main">{..&lt;</span><span class="skolem">x</span> <span class="free">v</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">}</span><span class="main">)</span> 
      <span class="main">(</span><span class="main">λ</span><span class="bound">c'</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="skolem">x</span> <span class="free">v</span> <span class="main">*</span> <span class="free">v</span><span class="main">,</span> <span class="skolem">x</span> <span class="free">v</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> <span class="bound">c'</span> <span class="main">+</span> <span class="main">(</span><span class="skolem">x</span> <span class="free">v</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> x_ge_1
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_bits_fusion2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> bind_spmf_spmf_of_set lessThan_empty_iff add.assoc<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> bind_spmf coin_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">bs</span><span class="main">.</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">v</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">v</span><span class="main">)</span><span class="main">,</span> <span class="skolem">x</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">v</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="main">{..&lt;</span><span class="skolem">x</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> * even <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v less <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fdr_step_def Let_def x_def<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fdr_step_def<span class="main">)</span>

<span class="keyword1" id="Fast_Dice_Roll-fdr_step_induct"><span class="command">lemma</span></span> fdr_step_induct <span class="main">[</span><span class="operator">case_names</span> fdr_step<span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">v</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">b</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">v</span> <span class="main">≠</span> <span class="main">0</span><span class="main">;</span> <span class="bound">v</span> <span class="main">&lt;</span> <span class="free">n</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">v</span><span class="main">)</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">c</span> <span class="main">+</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">v</span> <span class="bound">c</span><span class="main">)</span>
  <span class="main">⟹</span> <span class="free">P</span> <span class="free">v</span> <span class="free">c</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">induction_schema</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">pat_completeness</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"Wellfounded.measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">.</span> <span class="free">n</span> <span class="main">-</span> <span class="bound">v</span><span class="main">)</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>spmf<span class="main">)</span> <span class="entity">fdr_alt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fdr_alt</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">v'</span><span class="main">,</span> <span class="bound">c'</span><span class="main">)</span> <span class="main">←</span> fdr_step <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="bound">c'</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> return_spmf <span class="bound">c'</span> <span class="keyword1">else</span> <span class="free">fdr_alt</span> <span class="main">(</span><span class="bound">v'</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="bound">c'</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">}</span>"</span></span>

<span class="keyword1" id="Fast_Dice_Roll-fast_dice_roll_alt"><span class="command">lemma</span></span> fast_dice_roll_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"fdr_alt <span class="main">=</span> fast_dice_roll"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fdr_alt <span class="skolem">v</span> <span class="skolem">c</span> <span class="main">=</span> fast_dice_roll <span class="skolem">v</span> <span class="skolem">c</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span> <span class="skolem">c</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> spmf.leq_antisym<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(=)</span> <span class="main">(</span>fdr_alt <span class="skolem">v</span> <span class="skolem">c</span><span class="main">)</span> <span class="main">(</span>fast_dice_roll <span class="skolem">v</span> <span class="skolem">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">v</span></span> <span class="quoted"><span class="skolem">c</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fdr_alt.fixp_induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> adm bottom step<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> adm <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">fdra</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">v</span></span> <span class="quoted"><span class="skolem">c</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fdr_step_induct<span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> inner<span class="main">:</span> <span class="main">(</span>fdr_step <span class="skolem">v</span> <span class="skolem">c</span><span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> fdr_step_unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> fast_dice_roll.simps<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ord_spmf_bind_reflI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def inner.IH step.IH<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(=)</span> <span class="main">(</span>fast_dice_roll <span class="skolem">v</span> <span class="skolem">c</span><span class="main">)</span> <span class="main">(</span>fdr_alt <span class="skolem">v</span> <span class="skolem">c</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"fast_dice_roll <span class="main">0</span> <span class="skolem">c</span> <span class="main">=</span> return_pmf None"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">v</span></span> <span class="quoted"><span class="skolem">c</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fast_dice_roll_fixp_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> adm <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">fdr</span><span class="main">)</span> <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> fdr_alt.simps<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> fdr_step_unfold<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ord_spmf_bind_reflI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fdr_alt.simps<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> step.IH rel_pmf_return_pmf2 set_pmf_bind_spmf o_def set_pmf_spmf_of_set <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword3"><span class="command">case</span></span> step <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword1"><span class="command">from</span></span> step.IH <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def bind_eq_return_pmf_None<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(=)</span> <span class="main">(</span>fast_dice_roll <span class="skolem">v</span> <span class="skolem">c</span><span class="main">)</span> <span class="main">(</span>fdr_alt <span class="skolem">v</span> <span class="skolem">c</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Fast_Dice_Roll-lossless_fdr_step"><span class="command">lemma</span></span> lossless_fdr_step <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>fdr_step <span class="free">v</span> <span class="free">c</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">v</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fdr_step_def Let_def lessThan_empty_iff<span class="main">)</span>

<span class="keyword1" id="Fast_Dice_Roll-fast_dice_roll_alt_conv_while"><span class="command">lemma</span></span> fast_dice_roll_alt_conv_while<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fdr_alt <span class="free">v</span> <span class="free">c</span> <span class="main">=</span> 
  map_spmf snd <span class="main">(</span>bind_spmf <span class="main">(</span>fdr_step <span class="free">v</span> <span class="free">c</span><span class="main">)</span> <span class="main">(</span>loop_spmf.while <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">.</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">c</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">.</span> fdr_step <span class="main">(</span><span class="bound">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="bound">c</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">c</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> parallel_fixp_induct_2_1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> partial_function_definitions_spmf partial_function_definitions_spmf fdr_alt.mono loop_spmf.while.mono fdr_alt_def loop_spmf.while_def<span class="main"><span class="main">,</span></span> <span class="operator">case_names</span> adm bottom step<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> adm <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">fdr</span> <span class="skolem">while</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> step.IH
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_bind_spmf o_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Fast_Dice_Roll-lossless_fast_dice_roll"><span class="command">lemma</span></span> lossless_fast_dice_roll<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">&lt;</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>fast_dice_roll <span class="free">v</span> <span class="free">c</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?I</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">.</span> <span class="bound">c</span> <span class="main">&lt;</span> <span class="bound">v</span> <span class="main">∧</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">v</span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">c</span> <span class="keyword1">then</span> <span class="free">n</span> <span class="main">+</span> <span class="bound">c</span> <span class="main">-</span> <span class="bound">v</span> <span class="main">+</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> invar<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?I</span> <span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">c'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">c'</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="main">(</span>fdr_step <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">&lt;</span> <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="skolem">c</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v'</span> <span class="skolem">c'</span> <span class="skolem">v</span> <span class="skolem">c</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">safe</span><span class="main">)</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> nat <span class="main">⌈</span>log <span class="numeral">2</span> <span class="main">(</span>max <span class="main">1</span> <span class="free">n</span><span class="main">)</span> <span class="main">-</span> log <span class="numeral">2</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">⌉</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span><span class="main">1</span> <span class="main">&lt;</span> log <span class="numeral">2</span> <span class="main">(</span>real <span class="free">n</span> <span class="main">/</span> real <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> less_le_trans<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> y<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main"><span class="quoted"><span class="main"><span class="quoted"><span class="main">0</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">use</span> I c <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">auto</span>›</span><span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> I c step <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">bs</span></span> <span class="keyword2"><span class="keyword">where</span></span> v'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> c'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">bs</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> bs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">bs</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> fdr_step_def x_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">bs</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">-</span> <span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> distrib_left <span class="keyword1"><span class="command">using</span></span> bs
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> add_strict_left_mono<span class="main">)</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I c <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> mult_left_mono<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">&lt;</span> <span class="skolem">v'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> c' v' <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">=</span> <span class="numeral">2</span> <span class="keyword1">powr</span> <span class="skolem">x</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> powr_realpow v'<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="keyword1">powr</span> <span class="main">(</span>log <span class="numeral">2</span> <span class="main">(</span>max <span class="main">1</span> <span class="free">n</span><span class="main">)</span> <span class="main">-</span> log <span class="numeral">2</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ** I c <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> mult_strict_right_mono<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> x_def log_divide<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> powr_add <span class="keyword1"><span class="command">using</span></span> I c
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> log_divide<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> max_def<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> c' <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> of_nat_add<span class="main">)</span>
    
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"log <span class="numeral">2</span> <span class="main">(</span><span class="free">n</span> <span class="main">/</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I c ** <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> x_def log_divide max_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="keyword1">powr</span> log <span class="numeral">2</span> <span class="main">(</span><span class="free">n</span> <span class="main">/</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="keyword1">powr</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> powr_mono<span class="main">)</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="keyword1">powr</span> log <span class="numeral">2</span> <span class="main">(</span><span class="free">n</span> <span class="main">/</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">n</span> <span class="main">/</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I c <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> real <span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I c <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span> powr_realpow<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="skolem">v'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> v' <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> of_nat_mult<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> loop<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>loop_spmf.while <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">.</span> <span class="free">n</span> <span class="main">≤</span> <span class="bound">c</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">.</span> fdr_step <span class="main">(</span><span class="bound">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="bound">c</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">&lt;</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span> <span class="skolem">c</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> termination_variant_invar<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarify</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">c</span>
    <span class="keyword3"><span class="command">assume</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?I</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">c</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="skolem">c</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">c</span><span class="main">)</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I c <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> nat <span class="main">⌈</span>log <span class="numeral">2</span> <span class="main">(</span>max <span class="main">1</span> <span class="free">n</span><span class="main">)</span> <span class="main">-</span> log <span class="numeral">2</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">⌉</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="main">::</span> <span class="quoted">real</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">≡</span> <span class="main">1</span> <span class="main">/</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">from</span></span> I c <span class="keyword1"><span class="command">have</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> v<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> I c v n <span class="keyword1"><span class="command">have</span></span> x_pos<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> x_def max_def<span class="main">)</span>
    
    <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span><span class="main">1</span> <span class="main">&lt;</span> log <span class="numeral">2</span> <span class="main">(</span>real <span class="free">n</span> <span class="main">/</span> real <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> less_le_trans<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> y<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main"><span class="quoted"><span class="main"><span class="quoted"><span class="main">0</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">use</span> I c <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">auto</span>›</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> log <span class="numeral">2</span> <span class="main">(</span>real <span class="free">n</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> v n
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> x_def log_divide<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> max_def <span class="dynamic"><span class="dynamic">field_simps</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> of_int_ceiling_le_add_one<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="keyword1">powr</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="keyword1">powr</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> powr_mono<span class="main">)</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> powr_add <span class="keyword1"><span class="command">using</span></span> n
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> powr_realpow<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> powr_log_cancel<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p_def <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">c'</span><span class="main">.</span> <span class="free">n</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">+</span> <span class="bound">c'</span> <span class="main">⟶</span> <span class="free">n</span> <span class="main">+</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">+</span> <span class="bound">c'</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">+</span> <span class="skolem">c</span> <span class="main">-</span> <span class="skolem">v</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">+</span> <span class="skolem">c</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">-</span> <span class="skolem">v</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">c</span> <span class="main">+</span> <span class="free">n</span> <span class="main">-</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I c
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">+</span> <span class="skolem">c</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">≥</span> <span class="skolem">v</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int <span class="skolem">c</span> <span class="main">-</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="main">(</span>int <span class="skolem">c</span> <span class="main">-</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">*</span> <span class="main">1</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> x_pos I c <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> mult_strict_left_mono_neg<span class="main">)</span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"int <span class="free">n</span> <span class="main">+</span> <span class="skolem">c</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">-</span> <span class="skolem">v</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">c</span> <span class="main">+</span> int <span class="free">n</span> <span class="main">-</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> int <span class="main">(</span><span class="skolem">c</span> <span class="main">+</span> <span class="free">n</span> <span class="main">-</span> <span class="skolem">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I c <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"int <span class="free">n</span> <span class="main">+</span> <span class="skolem">c</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">-</span> <span class="skolem">v</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">=</span> int <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="skolem">c</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">-</span> <span class="skolem">v</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> True that <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_nat_diff<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{..&lt;</span><span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">∩</span> <span class="var">?X</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> that n v
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disjoint_eq_subset_Compl Collect_neg_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> lessThan_subset_Collect <span class="dynamic"><span class="dynamic">algebra_simps</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">0</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> card <span class="main">(</span><span class="main">{..&lt;</span><span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">∩</span> <span class="var">?X</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_gt_0_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="main">…</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="var">?f</span> <span class="bound">s'</span> <span class="main">&lt;</span> <span class="var">?f</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">c</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>fdr_step <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> True"</span></span>
      <span class="keyword1"><span class="command">using</span></span> I c <span class="keyword1"><span class="command">unfolding</span></span> fdr_step_def x_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def spmf.map_comp o_def spmf_map measure_spmf_of_set vimage_def p_def<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>fdr_step <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?I</span> <span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">c'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">c'</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="main">(</span>fdr_step <span class="main">(</span><span class="skolem">v</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v'</span> <span class="skolem">c'</span> 
      <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> invar<span class="main">)</span><span class="main">(</span><span class="operator">use</span> I c <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span> <span class="main">::</span> real<span class="main">)</span> <span class="main">&lt;</span> <span class="main">1</span> <span class="main">/</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?I</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">c</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms True 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fast_dice_roll_alt<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> fast_dice_roll_alt_conv_while <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> loop <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> invar<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">+</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">+</span> <span class="free">c</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">=</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> fast_dice_roll.simps<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Fast_Dice_Roll-fast_dice_roll_n0"><span class="command">lemma</span></span> fast_dice_roll_n0<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fast_dice_roll <span class="free">v</span> <span class="free">c</span> <span class="main">=</span> return_pmf None"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">c</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fast_dice_roll_fixp_induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>

<span class="keyword1" id="Fast_Dice_Roll-lossless_fast_uniform"><span class="command">lemma</span></span> lossless_fast_uniform <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf fast_uniform <span class="main">⟷</span> <span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> fast_dice_roll_n0 <span class="keyword1"><span class="command">unfolding</span></span> fast_uniform_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fast_uniform_def lossless_fast_dice_roll<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Fast_Dice_Roll-spmf_fast_uniform"><span class="command">lemma</span></span> spmf_fast_uniform<span class="main">:</span> <span class="quoted"><span class="quoted">"spmf fast_uniform <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">/</span> <span class="free">n</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> n<span class="main">:</span> True
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> spmf_fast_uniform_ub
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> spmf_ub_tight<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">x</span><span class="main">.</span> ennreal <span class="main">(</span><span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">/</span> <span class="free">n</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">x</span><span class="main">∈</span><span class="main">{..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">.</span> <span class="main">1</span> <span class="main">/</span> <span class="free">n</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nn_integral_count_space_indicator <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> nn_integral_const <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> nn_integral_cong<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span> ennreal_of_nat_eq_real_of_nat ennreal_mult<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> weight_spmf fast_uniform"</span></span> <span class="keyword1"><span class="command">using</span></span> lossless_fast_uniform n <span class="keyword1"><span class="command">unfolding</span></span> lossless_spmf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">x</span><span class="main">.</span> ennreal <span class="main">(</span><span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">/</span> <span class="free">n</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">with</span></span> fast_dice_roll_n0<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="main">1</span></span> <span class="quoted"><span class="main">0</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> fast_uniform_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Fast_Dice_Roll-fast_uniform_conv_uniform"><span class="command">lemma</span></span> fast_uniform_conv_uniform<span class="main">:</span> <span class="quoted"><span class="quoted">"fast_uniform <span class="free">n</span> <span class="main">=</span> spmf_of_set <span class="main">{..&lt;</span><span class="free">n</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> spmf_eqI<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_fast_uniform spmf_of_set<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Resampling">
<div class="head">
<h1>Theory Resampling</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Resampling.thy
   Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Resampling <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="While_SPMF.html">While_SPMF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Resampling-ord_spmf_lossless"><span class="command">lemma</span></span> ord_spmf_lossless<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(=)</span> <span class="free">p</span> <span class="free">q</span>"</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pmf.rel_eq<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> pmf.rel_mono_strong<span class="main">)</span><span class="main">(</span><span class="operator">use</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main">!</span><span class="main">:</span> ord_option.cases <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> lossless_iff_set_pmf_None›</span><span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">function_internals</span><span class="main">]</span><span class="main">]</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">partial_function</span></span> <span class="main">(</span>spmf<span class="main">)</span> <span class="entity">resample</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> spmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">resample</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">=</span> bind_spmf <span class="main">(</span>spmf_of_set <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="keyword1">then</span> return_spmf <span class="bound">x</span> <span class="keyword1">else</span> <span class="free">resample</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> resample_fixp_induct<span class="main">[</span><span class="operator">case_names</span> adm bottom step<span class="main">]</span> <span class="main">=</span> resample.fixp_induct

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> loop_spmf <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> spmf_of_set <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Resampling-resample_conv_while"><span class="command">lemma</span></span> resample_conv_while<span class="main">:</span> <span class="quoted"><span class="quoted">"resample <span class="free">A</span> <span class="free">B</span> <span class="main">=</span> bind_spmf <span class="main">(</span>spmf_of_set <span class="free">A</span><span class="main">)</span> while"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> parallel_fixp_induct_2_1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> partial_function_definitions_spmf partial_function_definitions_spmf resample.mono while.mono resample_def while_def<span class="main"><span class="main">,</span></span> <span class="operator">case_names</span> adm bottom step<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> adm <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">resample'</span> <span class="skolem">while'</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">z3_rule</span></span><span class="main"><span class="main">(</span></span>33<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Resampling-A_nonempty"><span class="command">lemma</span></span> A_nonempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> B <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1" id="Resampling-B_finite"><span class="command">lemma</span></span> B_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> A B <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>

<span class="keyword1" id="Resampling-lossless_resample"><span class="command">lemma</span></span> lossless_resample<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>resample <span class="free">A</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> B <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∩</span> <span class="free">B</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>while <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> termination_0_1_immediate<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> p<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"card <span class="main"><span class="main"><span class="main">(</span></span></span><span class="free"><span class="free"><span class="free">A</span></span></span> <span class="main"><span class="main"><span class="main">∩</span></span></span> <span class="free"><span class="free"><span class="free">B</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span> <span class="main"><span class="main"><span class="main">/</span></span></span> card <span class="free"><span class="free"><span class="free">A</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_map vimage_def measure_spmf_of_set <span class="dynamic"><span class="dynamic">field_simps</span></span> A_nonempty A not_le card_gt_0_iff B<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> resample_conv_while A A_nonempty<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Resampling-resample_le_sample"><span class="command">lemma</span></span> resample_le_sample<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(=)</span> <span class="main">(</span>resample <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resample_fixp_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> adm <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">resample'</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> B_finite A
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ord_pmf_increaseI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">B</span> <span class="keyword1">then</span> return_spmf <span class="bound">x</span> <span class="keyword1">else</span> <span class="skolem">resample'</span> <span class="free">A</span> <span class="free">B</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>bind_spmf <span class="main">(</span>spmf_of_set <span class="free">A</span><span class="main">)</span> <span class="var">?f</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">∑</span><span class="bound">n</span><span class="main">∈</span><span class="free">B</span> <span class="main">∪</span> <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="free">B</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">∈</span> <span class="free">B</span> <span class="keyword1">then</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="skolem">x</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span> <span class="main">/</span> card <span class="free">A</span> <span class="keyword1">else</span> spmf <span class="main">(</span><span class="skolem">resample'</span> <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">/</span> card <span class="free">A</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> B
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_bind integral_spmf_of_set sum_divide_distrib if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">p</span><span class="main">.</span> spmf <span class="bound">p</span> <span class="main">_</span> <span class="main">/</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sum.cong <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">n</span><span class="main">∈</span><span class="free">B</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="skolem">x</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span> <span class="main">/</span> card <span class="free">A</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">n</span><span class="main">∈</span><span class="free">A</span> <span class="main">-</span> <span class="free">B</span><span class="main">.</span> spmf <span class="main">(</span><span class="skolem">resample'</span> <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">/</span> card <span class="free">A</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> sum.union_disjoint<span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="free">B</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">/</span> card <span class="free">A</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span> <span class="main">+</span> card <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="free">B</span><span class="main">)</span> <span class="main">/</span> card <span class="free">A</span> <span class="main">*</span> spmf <span class="main">(</span><span class="skolem">resample'</span> <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> sum.cong <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">/</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="free">B</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">/</span> card <span class="free">A</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span> <span class="main">+</span> card <span class="main">(</span><span class="free">A</span> <span class="main">-</span> <span class="free">B</span><span class="main">)</span> <span class="main">/</span> card <span class="free">A</span> <span class="main">*</span> spmf <span class="main">(</span>spmf_of_set <span class="free">B</span><span class="main">)</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> add_left_mono mult_left_mono step.IH<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> ord_spmf_eq_leD<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> spmf <span class="main">(</span>spmf_of_set <span class="free">B</span><span class="main">)</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> B
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_of_set <span class="dynamic"><span class="dynamic">field_simps</span></span> A_nonempty card_Diff_subset card_mono of_nat_diff<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>bind_spmf <span class="main">(</span>spmf_of_set <span class="free">A</span><span class="main">)</span> <span class="var">?f</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Resampling-resample_eq_sample"><span class="command">lemma</span></span> resample_eq_sample<span class="main">:</span> <span class="quoted"><span class="quoted">"resample <span class="free">A</span> <span class="free">B</span> <span class="main">=</span> spmf_of_set <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> resample_le_sample lossless_resample <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ord_spmf_lossless<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>