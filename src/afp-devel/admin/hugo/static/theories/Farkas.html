<div id="Farkas">
<div class="head"><h1>Theory Farkas</h1>
<span class="command">theory</span> <span class="name">Farkas</span><br/>
<span class="keyword">imports</span> <a href="../Simplex/Simplex.html"><span class="name">Simplex</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Authors: R. Bottesch, M. W. Haslbeck, R. Thiemann *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Farkas Coefficients via the Simplex Algorithm of Duterte and de~Moura›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Let $c_1,\dots,c_n$ be a finite list of linear inequalities. 
  Let $C$ be a list of pairs $(r_i,c_i)$ where $r_i$ is a rational number.
  We say that $C$ is a list of \emph{Farkas coefficients} if
  the sum of all products $r_i \cdot c_i$ results in an inequality that is 
  trivially unsatisfiable.

  Farkas' Lemma  
  states that a finite set of non-strict linear inequalities is
  unsatisfiable if and only if Farkas coefficients exist. We will prove this lemma
  with the help of the simplex algorithm of Dutertre and de~Moura's.

  Note that the simplex implementation works on four layers, and we will formulate and prove 
  a variant of Farkas' Lemma for each of these layers.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Farkas</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Simplex.Simplex</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Linear Inequalities›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Both Farkas' Lemma and Motzkin's Transposition Theorem require linear combinations 
  of inequalities. To this end we define one type that permits strict and non-strict 
  inequalities which are always of the form ``polynomial R constant'' where R is either 
  $\leq$ or $&lt;$. On this type we can then define a commutative monoid.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A type for the two relations: less-or-equal and less-than.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>le_rel</span><span> </span><span class="delimiter">=</span><span> </span><span>Leq_Rel</span><span> </span><span class="delimiter">|</span><span> </span><span>Lt_Rel</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>rel_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"le_rel ⇒ 'a :: lrv ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_of Leq_Rel = (≤)"</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_of Lt_Rel = (&lt;)"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>le_rel</span><span> </span><span class="delimiter">::</span><span> </span><span>comm_monoid_add</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"zero_le_rel = Leq_Rel"</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>plus_le_rel</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"plus_le_rel Leq_Rel Leq_Rel = Leq_Rel"</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"plus_le_rel _ _ = Lt_Rel"</span></span></span><span> 
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span>le_rel</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a + b + c = a + (b + c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a + b = b + a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 + a = a"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>zero_le_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Leq_Rel_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Leq_Rel = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>zero_le_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>le_constraint</span><span> </span><span class="delimiter">=</span><span> </span><span>Le_Constraint</span><span> </span><span class="delimiter">(</span><span>lec_rel</span><span class="delimiter">:</span><span> </span><span>le_rel</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>lec_poly</span><span class="delimiter">:</span><span> </span><span>linear_poly</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>lec_const</span><span class="delimiter">:</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Leqc ≡ Le_Constraint Leq_Rel"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>le_constraint</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>lrv</span><span class="delimiter">)</span><span> </span><span>comm_monoid_add</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>plus_le_constraint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a le_constraint ⇒ 'a le_constraint ⇒ 'a le_constraint"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"plus_le_constraint (Le_Constraint r1 p1 c1) (Le_Constraint r2 p2 c2) = 
    (Le_Constraint (r1 + r2) (p1 + p2) (c1 + c2))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>zero_le_constraint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a le_constraint"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"zero_le_constraint = Leqc 0 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a le_constraint"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 + a = a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zero_le_constraint_def</span><span> </span><span>Leq_Rel_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a + b = b + a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a + b + c = a + (b + c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>satisfiable_le_constraint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::lrv valuation ⇒ 'a le_constraint ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub>"</span></span></span><span> </span><span>100</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> (Le_Constraint rel l r)) ⟷ (rel_of rel (l⦃v⦄) r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>satisfies_zero_le_constraint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valuate_zero</span><span> </span><span>zero_le_constraint_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>satisfies_sum_le_constraints</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> d"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> (c + d)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>lc</span><span> </span><span>rc</span><span> </span><span>ld</span><span> </span><span>rd</span><span> </span><span>rel1</span><span> </span><span>rel2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c = Le_Constraint rel1 lc rc"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d = Le_Constraint rel2 ld rd"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>d</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_of rel1 (lc⦃v⦄) rc"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>cd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_of rel2 (ld⦃v⦄) rd"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>cd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>le1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lc⦃v⦄ ≤ rc"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rel1</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>le2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ld⦃v⦄ ≤ rd"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rel2</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>le1</span><span> </span><span>le2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_of (rel1 + rel2) ((lc⦃v⦄) + (ld⦃v⦄)) (rc + rd)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rel1</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>rel2</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>le_less_trans</span><span> </span><span>order.strict_iff_order</span><span> </span><span>plus_less</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cd</span><span> </span><span>valuate_add</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>satisfies_sumlist_le_constraints</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ c. c ∈ set (cs :: 'a :: lrv le_constraint list) ⟹ v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> sum_list cs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>cs</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>satisfies_zero_le_constraint</span><span> </span><span>satisfies_sum_le_constraints</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_list_lec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sum_list ls = Le_Constraint 
    (sum_list (map lec_rel ls)) 
    (sum_list (map lec_poly ls)) 
    (sum_list (map lec_const ls))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ls</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zero_le_constraint_def</span><span> </span><span>Leq_Rel_0</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>l</span><span> </span><span>ls</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_list_Leq_Rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((∑x←C. lec_rel (f x)) = Leq_Rel) ⟷ (∀ x ∈ set C. lec_rel (f x) = Leq_Rel)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>c</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel (f c)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Leq_Rel</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Leq_Rel</span><span> </span><span>Leq_Rel_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Leq_Rel_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Farkas' Lemma on Layer 4›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹On layer 4 the algorithm works on a state containing a tableau, atoms (or bounds), 
  an assignment and a satisfiability flag. Only non-strict inequalities appear at this level.
  In order to even state a variant of Farkas' Lemma on layer 4, we 
  need conversions from atoms to non-strict constraints and then further
  to linear inequalities of type @{type le_constraint}. 
  The latter conversion is a partial operation, since non-strict constraints
  of type @{type ns_constraint} permit greater-or-equal constraints, whereas @{type le_constraint}
  allows only less-or-equal.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The advantage of first going via @{type ns_constraint} is that this type permits a multiplication
  with arbitrary rational numbers (the direction of the inequality must be flipped when
  multiplying by a negative number, which is not possible with @{type le_constraint}).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>ns_constraint</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>scaleRat</span><span class="delimiter">)</span><span> </span><span>scaleRat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>scaleRat_ns_constraint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat ⇒ 'a ns_constraint ⇒ 'a ns_constraint"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"scaleRat_ns_constraint r (LEQ_ns p c) = 
    (if (r &lt; 0) then GEQ_ns (r *R p) (r *R c) else LEQ_ns (r *R p) (r *R c))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"scaleRat_ns_constraint r (GEQ_ns p c) = 
    (if (r &gt; 0) then GEQ_ns (r *R p) (r *R c) else LEQ_ns (r *R p) (r *R c))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sat_scale_rat_ns</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub> ns"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub> (f *R ns)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f &lt; 0 | f = 0 | f &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ns</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valuate_scaleRat</span><span> </span><span>scaleRat_leq1</span><span> </span><span>scaleRat_leq2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>scaleRat_scaleRat_ns_constraint</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ 0 ⟹ b ≠ 0"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a *R (b *R (c :: 'a :: lrv ns_constraint)) = (a * b) *R c"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b &gt; 0 ∨ b &lt; 0 ∨ b = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &gt; 0 ∨ a &lt; 0 ∨ a = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_le</span><span> </span><span>not_less</span><span>
</span><span>        </span><span>mult_neg_pos</span><span> </span><span>mult_neg_neg</span><span> </span><span>mult_nonpos_nonneg</span><span> </span><span>mult_nonpos_nonpos</span><span> </span><span>mult_nonneg_nonpos</span><span> </span><span>mult_pos_neg</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lec_of_nsc</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lec_of_nsc (LEQ_ns p c) = (Leqc p c)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>is_leq_ns</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leq_ns (LEQ_ns p c) = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leq_ns (GEQ_ns p c) = False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lec_of_nsc</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leq_ns c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> lec_of_nsc c) ⟷ (v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub> c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>nsc_of_atom</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nsc_of_atom (Leq var b) = LEQ_ns (lp_monom 1 var) b"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"nsc_of_atom (Geq var b) = GEQ_ns (lp_monom 1 var) b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsc_of_atom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub> nsc_of_atom a ⟷ v ⊨<span class="hidden">⇩</span><sub>a</sub> a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We say that $C$ is a list of Farkas coefficients \emph{for a given tableau $t$ and atom set $as$}, if
  it is a list of pairs $(r,a)$ such that $a \in as$, $r$ is non-zero, $r \cdot a$ is a
  `less-than-or-equal'-constraint, and the linear combination
  of inequalities must result in an inequality of the form $p \leq c$, where $c &lt; 0$ and $t \models
  p = 0$.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>farkas_coefficients_atoms_tableau</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"farkas_coefficients_atoms_tableau (as :: 'a :: lrv atom set) t C = (∃ p c. 
    (∀(r,a) ∈ set C. a ∈ as ∧ is_leq_ns (r *R nsc_of_atom a) ∧ r ≠ 0) ∧
    (∑(r,a) ← C. lec_of_nsc (r *R nsc_of_atom a)) = Leqc p c ∧
    c &lt; 0 ∧
    (∀ v :: 'a valuation. v ⊨<span class="hidden">⇩</span><sub>t</sub> t ⟶(p⦃v⦄ = 0)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We first prove that if the check-function detects a conflict, then 
  Farkas coefficients do exist for the tableau and atom set for which the
  conflict is detected.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bound_atoms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'a) state ⇒ 'a atom set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"ℬ<span class="hidden">⇩</span><sub>A</sub>"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bound_atoms s = (λ(v,x). Geq v x) ` (set_of_map (ℬ<span class="hidden">⇩</span><sub>l</sub> s)) ∪ 
                   (λ(v,x). Leq v x) ` (set_of_map (ℬ<span class="hidden">⇩</span><sub>u</sub> s))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>PivotUpdateMinVars</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_check</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>check</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"check s' = s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒰 s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ 𝒰 s'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇ s'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"△ (𝒯 s')"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>s</sub> s'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"◇ s'"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>index</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"index_valid as s'"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_atoms_tableau (snd ` as) (𝒯 s') C"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Q</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ s f p c C. set C ⊆ ℬ<span class="hidden">⇩</span><sub>A</sub> s ∧
    distinct C ∧
    (∀a ∈ set C. is_leq_ns (f (atom_var a) *R nsc_of_atom a) ∧ f (atom_var a) ≠ 0) ∧
    (∑a ← C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) = Leqc p c ∧
    c &lt; 0 ∧
    (∀ v :: 'a valuation. v ⊨<span class="hidden">⇩</span><sub>t</sub> 𝒯 s ⟶(p⦃v⦄ = 0))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ s. 𝒰 s ⟶ (∃ f p c C. ?Q s f p c C)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P (check s')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>check_induct''</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="var">?P</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>s</span><span> </span><span>x<span class="hidden">⇩</span><sub>i</sub></span><span> </span><span>dir</span><span> </span><span>I</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dir</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dir = Positive ∨ dir = Negative"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?eq</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(eq_for_lvar (𝒯 s) x<span class="hidden">⇩</span><sub>i</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>X<span class="hidden">⇩</span><sub>j</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X<span class="hidden">⇩</span><sub>j</sub> = rvars_eq ?eq"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>XL<span class="hidden">⇩</span><sub>j</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"XL<span class="hidden">⇩</span><sub>j</sub> = Abstract_Linear_Poly.vars_list (rhs ?eq)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set XL<span class="hidden">⇩</span><sub>j</sub> = X<span class="hidden">⇩</span><sub>j</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XL<span class="hidden">⇩</span><sub>j</sub>_def</span><span> </span><span>X<span class="hidden">⇩</span><sub>j</sub>_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_vars_list</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>XL<span class="hidden">⇩</span><sub>j</sub>_distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct XL<span class="hidden">⇩</span><sub>j</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XL<span class="hidden">⇩</span><sub>j</sub>_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_vars_list</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = coeff (rhs ?eq)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bounds_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ<span class="hidden">⇩</span><sub>A</sub> (set_unsat I s) = ℬ<span class="hidden">⇩</span><sub>A</sub> s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ<span class="hidden">⇩</span><sub>u</sub> (set_unsat I s) = ℬ<span class="hidden">⇩</span><sub>u</sub> s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ<span class="hidden">⇩</span><sub>l</sub> (set_unsat I s) = ℬ<span class="hidden">⇩</span><sub>l</sub> s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>boundsl_def</span><span> </span><span>boundsu_def</span><span> </span><span>bound_atoms_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒯 (set_unsat I s) = 𝒯 s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒰 (set_unsat I s) = True"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?p</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"rhs ?eq - lp_monom 1 x<span class="hidden">⇩</span><sub>i</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p_eval_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?p ⦃ v ⦄ = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>t</sub> 𝒯 s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a valuation"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?eq ∈ set (𝒯 s)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>eq_for_lvar</span><span> </span><span>local.min_lvar_not_in_bounds_lvars</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>e</sub> ?eq"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>eqT</span><span> </span><span>satisfies_tableau_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?eq = (lhs ?eq, rhs ?eq)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="var">?eq</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lhs ?eq = x<span class="hidden">⇩</span><sub>i</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>eq_for_lvar</span><span> </span><span>local.min_lvar_not_in_bounds_lvars</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>e</sub> (x<span class="hidden">⇩</span><sub>i</sub>, rhs ?eq)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>satisfies_eq_iff</span><span> </span><span>valuate_minus</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Xj_rvars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X<span class="hidden">⇩</span><sub>j</sub> ⊆ rvars (𝒯 s)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X<span class="hidden">⇩</span><sub>j</sub>_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span>min_lvar_not_in_bounds_lvars</span><span> </span><span>rvars_of_lvar_rvars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xi_lvars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x<span class="hidden">⇩</span><sub>i</sub> ∈ lvars (𝒯 s)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span>min_lvar_not_in_bounds_lvars</span><span> </span><span>rvars_of_lvar_rvars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lvars (𝒯 s) ∩ rvars (𝒯 s) = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span>normalized_tableau_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>xi_lvars</span><span> </span><span>Xj_rvars</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xi_Xj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x<span class="hidden">⇩</span><sub>i</sub> ∉ X<span class="hidden">⇩</span><sub>j</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rhs_eval_xi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(rhs (eq_for_lvar (𝒯 s) x<span class="hidden">⇩</span><sub>i</sub>)) ⦃⟨𝒱 s⟩⦄ = ⟨𝒱 s⟩ x<span class="hidden">⇩</span><sub>i</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(rhs eq) ⦃ v ⦄ = v (lhs eq)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>e</sub> eq"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a valuation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>satisfies_eq_def</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨𝒱 s⟩ ⊨<span class="hidden">⇩</span><sub>e</sub> eq_for_lvar (𝒯 s) x<span class="hidden">⇩</span><sub>i</sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span>satisfies_tableau_def</span><span> </span><span>eq_for_lvar</span><span> </span><span>curr_val_satisfies_no_lhs_def</span><span> </span><span>xi_lvars</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_for_lvar</span><span> </span><span>xi_lvars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ℬ<span class="hidden">⇩</span><sub>l</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Direction.LB dir"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ℬ<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Direction.UB dir"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lt</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Direction.lt dir"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?le</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Simplex.le ?lt"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Geq</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Direction.GE dir"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Leq</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Direction.LE dir"</span></span></span><span> 
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(if A x &lt; 0 then ?ℬ<span class="hidden">⇩</span><sub>l</sub> s x = Some (⟨𝒱 s⟩ x) else ?ℬ<span class="hidden">⇩</span><sub>u</sub> s x = Some (⟨𝒱 s⟩ x)) ∧ A x ≠ 0"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ X<span class="hidden">⇩</span><sub>j</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Some (⟨𝒱 s⟩ x) = (?ℬ<span class="hidden">⇩</span><sub>l</sub> s x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A x &lt; 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cmp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ⊳<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>b</sub> ?lt (⟨𝒱 s⟩ x) (?ℬ<span class="hidden">⇩</span><sub>l</sub> s x)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>that</span><span> </span><span>dir</span><span> </span><span>min_rvar_incdec_eq_None</span><span class="delimiter">[</span><span>OF</span><span> </span><span>3</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X<span class="hidden">⇩</span><sub>j</sub>_def</span><span> </span><span>A_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ℬ<span class="hidden">⇩</span><sub>l</sub> s x = Some c"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ℬ<span class="hidden">⇩</span><sub>l</sub> s x"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bound_compare_defs</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = ⟨𝒱 s⟩ x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ rvars (𝒯 s)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>x</span><span> </span><span>Xj_rvars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (- lvars (𝒯 s))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normalized_tableau_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈(- lvars (𝒯 s)). in_bounds x ⟨𝒱 s⟩ (ℬ<span class="hidden">⇩</span><sub>l</sub> s, ℬ<span class="hidden">⇩</span><sub>u</sub> s)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>curr_val_satisfies_no_lhs_def</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>satisfies_bounds_set.simps</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_bounds x ⟨𝒱 s⟩ (ℬ<span class="hidden">⇩</span><sub>l</sub> s, ℬ<span class="hidden">⇩</span><sub>u</sub> s)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?le (⟨𝒱 s⟩ x) c"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cmp</span><span> </span><span>c</span><span> </span><span>dir</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bound_compare_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span>dir</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Some (⟨𝒱 s⟩ x) = (?ℬ<span class="hidden">⇩</span><sub>u</sub> s x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; A x"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cmp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ⊲<span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>b</sub> ?lt (⟨𝒱 s⟩ x) (?ℬ<span class="hidden">⇩</span><sub>u</sub> s x)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>that</span><span> </span><span>min_rvar_incdec_eq_None</span><span class="delimiter">[</span><span>OF</span><span> </span><span>3</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X<span class="hidden">⇩</span><sub>j</sub>_def</span><span> </span><span>A_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ℬ<span class="hidden">⇩</span><sub>u</sub> s x = Some c"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ℬ<span class="hidden">⇩</span><sub>u</sub> s x"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bound_compare_defs</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = ⟨𝒱 s⟩ x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ rvars (𝒯 s)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>x</span><span> </span><span>Xj_rvars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (- lvars (𝒯 s))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normalized_tableau_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈(- lvars (𝒯 s)). in_bounds x ⟨𝒱 s⟩ (ℬ<span class="hidden">⇩</span><sub>l</sub> s, ℬ<span class="hidden">⇩</span><sub>u</sub> s)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>curr_val_satisfies_no_lhs_def</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>satisfies_bounds_set.simps</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_bounds x ⟨𝒱 s⟩ (ℬ<span class="hidden">⇩</span><sub>l</sub> s, ℬ<span class="hidden">⇩</span><sub>u</sub> s)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?le c (⟨𝒱 s⟩ x)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cmp</span><span> </span><span>c</span><span> </span><span>dir</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bound_compare_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span>dir</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A x ≠ 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>coeff_zero</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A_def</span><span> </span><span>X<span class="hidden">⇩</span><sub>j</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l_Ba</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ∈ ℬ<span class="hidden">⇩</span><sub>A</sub> s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ∈ {?Geq x<span class="hidden">⇩</span><sub>i</sub> (the (?ℬ<span class="hidden">⇩</span><sub>l</sub> s x<span class="hidden">⇩</span><sub>i</sub>))}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>l</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l = ?Geq x<span class="hidden">⇩</span><sub>i</sub> (the (?ℬ<span class="hidden">⇩</span><sub>l</sub> s x<span class="hidden">⇩</span><sub>i</sub>))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ℬ<span class="hidden">⇩</span><sub>l</sub> s x<span class="hidden">⇩</span><sub>i</sub> = Some c"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ℬ<span class="hidden">⇩</span><sub>l</sub> s x<span class="hidden">⇩</span><sub>i</sub>"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bound_compare_defs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x<span class="hidden">⇩</span><sub>i</sub>, c) ∈ set_of_map (?ℬ<span class="hidden">⇩</span><sub>l</sub> s)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_of_map_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ∈ ℬ<span class="hidden">⇩</span><sub>A</sub> s"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>l</span><span> </span><span>bound_atoms_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bl</span><span> </span><span>bl'</span><span> </span><span>dir</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?negA</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"filter (λ x. A x &lt; 0) XL<span class="hidden">⇩</span><sub>j</sub>"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?posA</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"filter (λ x. ¬ A x &lt; 0) XL<span class="hidden">⇩</span><sub>j</sub>"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>neg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"neg = (if dir = Positive then (λ x :: rat. x) else uminus)"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>negP</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"negP = (if dir = Positive then (λ x :: linear_poly. x) else uminus)"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>nega</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nega = (if dir = Positive then (λ x :: 'a. x) else uminus)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dir</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dirn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dir = Positive ∧ neg = (λ x. x) ∧ negP = (λ x. x) ∧ nega = (λ x. x)
      ∨ dir = Negative ∧ neg = uminus ∧ negP = uminus ∧ nega = uminus"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span> </span><span>negP_def</span><span> </span><span>nega_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C = map (λx. ?Geq x (the (?ℬ<span class="hidden">⇩</span><sub>l</sub> s x))) ?negA 
                        @ map (λ x. ?Leq x (the (?ℬ<span class="hidden">⇩</span><sub>u</sub> s x)))  ?posA
                        @ [?Geq x<span class="hidden">⇩</span><sub>i</sub> (the (?ℬ<span class="hidden">⇩</span><sub>l</sub> s x<span class="hidden">⇩</span><sub>i</sub>))]"</span></span></span><span>  
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f = (λx. if x = x<span class="hidden">⇩</span><sub>i</sub> then neg (-1) else neg (A x))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = (∑x←C. lec_const (lec_of_nsc (f (atom_var x) *R nsc_of_atom x)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?q</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"negP ?p"</span></span></span><span> 
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bounds_id</span><span> </span><span>t_id</span><span> </span><span>u_id</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>impI</span><span> </span><span>conjI</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>t</sub> 𝒯 s ⟹ ?q ⦃ v ⦄ = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a valuation"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dirn</span><span> </span><span>p_eval_zero</span><span class="delimiter">[</span><span>of</span><span> </span><span>v</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valuate_minus</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set C ⊆ ℬ<span class="hidden">⇩</span><sub>A</sub> s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span> </span><span>set_append</span><span> </span><span>set_map</span><span> </span><span>set_filter</span><span> </span><span>list.simps</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>l_Ba</span><span> </span><span>dir</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Un_least</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bound_atoms_def</span><span> </span><span>set_of_map_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>is_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈set C. is_leq_ns (f (atom_var a) *R nsc_of_atom a) ∧ f (atom_var a) ≠ 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dirn</span><span> </span><span>xi_Xj</span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span> </span><span>f_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑a ← C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) = Leqc ?q c"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_list_lec</span><span> </span><span>le_constraint.simps</span><span> </span><span>map_map</span><span> </span><span>o_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>scale_poly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a atom ⇒ linear_poly"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"scale_poly = (λx. lec_poly (lec_of_nsc (f (atom_var x) *R nsc_of_atom x)))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x←C. scale_poly x) =
            (∑x←?negA. scale_poly (?Geq x (the (?ℬ<span class="hidden">⇩</span><sub>l</sub> s x))))
          + (∑x←?posA. scale_poly (?Leq x (the (?ℬ<span class="hidden">⇩</span><sub>u</sub> s x))))
          - negP (lp_monom 1 x<span class="hidden">⇩</span><sub>i</sub>)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dirn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>comp_def</span><span> </span><span>scale_poly_def</span><span> </span><span>f_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x←?negA. scale_poly (?Geq x (the (?ℬ<span class="hidden">⇩</span><sub>l</sub> s x))))
          =  (∑x← ?negA. negP (A x *R lp_monom 1 x))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scale_poly_def</span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dirn</span><span> </span><span>xi_Xj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>map_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x←?posA. scale_poly (?Leq x (the (?ℬ<span class="hidden">⇩</span><sub>u</sub> s x))))
          =  (∑x← ?posA. negP (A x *R lp_monom 1 x))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scale_poly_def</span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dirn</span><span> </span><span>xi_Xj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>map_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x← ?negA. negP (A x *R lp_monom 1 x)) +
              (∑x← ?posA. negP (A x *R lp_monom 1 x))
             = negP (rhs (eq_for_lvar (𝒯 s) x<span class="hidden">⇩</span><sub>i</sub>))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dirn</span><span> </span><span>XL<span class="hidden">⇩</span><sub>j</sub>_distinct</span><span> </span><span>coeff_zero</span><span>            
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">;</span><span> </span><span>intro</span><span> </span><span>poly_eqI</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_eqI</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>coeff_sum_list</span><span> </span><span>A_def</span><span> </span><span>X<span class="hidden">⇩</span><sub>j</sub>_def</span><span> 
</span><span>              </span><span>uminus_sum_list_map</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>o_def</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x←C. lec_poly (lec_of_nsc (f (atom_var x) *R nsc_of_atom x))) = ?q"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scale_poly_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dirn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x←C. lec_rel (lec_of_nsc (f (atom_var x) *R nsc_of_atom x))) = Leq_Rel"</span></span></span><span>  
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_list_Leq_Rel</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ set C"</span></span></span><span> 
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel (lec_of_nsc (f (atom_var c) *R nsc_of_atom c)) = Leq_Rel"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_leq</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f (atom_var c) *R nsc_of_atom c"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>c_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>scale_const_f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a atom ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"scale_const_f x = lec_const (lec_of_nsc (f (atom_var x) *R nsc_of_atom x))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ℬ<span class="hidden">⇩</span><sub>l</sub> s x<span class="hidden">⇩</span><sub>i</sub> = Some d"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ℬ<span class="hidden">⇩</span><sub>l</sub> s x<span class="hidden">⇩</span><sub>i</sub>"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bound_compare_defs</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = (∑x←map (λx. ?Geq x (the (?ℬ<span class="hidden">⇩</span><sub>l</sub> s x))) ?negA. scale_const_f x)
                     + (∑x← map (λx. ?Leq x (the (?ℬ<span class="hidden">⇩</span><sub>u</sub> s x))) ?posA. scale_const_f x) 
                   - nega d"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c_def</span><span> </span><span>C_def</span><span> </span><span>f_def</span><span> </span><span>scale_const_f_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dirn</span><span> </span><span>rhs_eval_xi</span><span> </span><span>bl'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x←map (λx. ?Geq x (the (?ℬ<span class="hidden">⇩</span><sub>l</sub> s x))) ?negA. scale_const_f x) =
              (∑x← ?negA. nega (A x *R the (?ℬ<span class="hidden">⇩</span><sub>l</sub> s x)))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xi_Xj</span><span> </span><span>dirn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>map_cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>f_def</span><span> </span><span>scale_const_f_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑x←?negA. nega (A x *R ⟨𝒱 s⟩ x))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>map_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x←map (λx. ?Leq x (the (?ℬ<span class="hidden">⇩</span><sub>u</sub> s x))) ?posA. scale_const_f x) =
              (∑x← ?posA. nega (A x *R the (?ℬ<span class="hidden">⇩</span><sub>u</sub> s x)))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xi_Xj</span><span> </span><span>dirn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>map_cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>f_def</span><span> </span><span>scale_const_f_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑x← ?posA. nega (A x *R ⟨𝒱 s⟩ x))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>map_cong</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x←?negA. nega (A x *R ⟨𝒱 s⟩ x)) + (∑x←?posA. nega (A x *R ⟨𝒱 s⟩ x))
             = (∑x←?negA @ ?posA. nega (A x *R ⟨𝒱 s⟩ x))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑x∈ X<span class="hidden">⇩</span><sub>j</sub>. nega (A x *R ⟨𝒱 s⟩ x))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>XL<span class="hidden">⇩</span><sub>j</sub>_distinct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_list_distinct_conv_sum_set</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = nega (∑x∈ X<span class="hidden">⇩</span><sub>j</sub>. (A x *R ⟨𝒱 s⟩ x))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dirn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_negf</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x∈ X<span class="hidden">⇩</span><sub>j</sub>. (A x *R ⟨𝒱 s⟩ x)) = ((rhs ?eq) ⦃⟨𝒱 s⟩⦄)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A_def</span><span> </span><span>X<span class="hidden">⇩</span><sub>j</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>linear_poly_sum</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_negf</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ⟨𝒱 s⟩ x<span class="hidden">⇩</span><sub>i</sub>"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rhs_eval_xi</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nega (⟨𝒱 s⟩ x<span class="hidden">⇩</span><sub>i</sub>) - nega d &lt; 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lt (⟨𝒱 s⟩ x<span class="hidden">⇩</span><sub>i</sub>) d"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dirn</span><span> </span><span>3</span><span class="delimiter">(</span><span>2</span><span>-</span><span class="delimiter">)</span><span> </span><span>bl'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bound_compare_defs</span><span class="delimiter">)</span><span>   
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dirn</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>minus_lt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct C"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>XL<span class="hidden">⇩</span><sub>j</sub>_distinct</span><span> </span><span>xi_Xj</span><span> </span><span>dirn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>distinct_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>U</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span>p</span><span> </span><span>c</span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Qs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q s f p c C"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>check</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>index</span><span class="delimiter">[</span><span>folded</span><span> </span><span>check_tableau_index_valid</span><span class="delimiter">[</span><span>OF</span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>check</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>index</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"index_valid as s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>check_tableau_equiv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>U</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>check</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>t</sub> 𝒯 s = v ⊨<span class="hidden">⇩</span><sub>t</sub> 𝒯 s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a valuation"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?C</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λ a. (f (atom_var a), a)) C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set C ⊆ ℬ<span class="hidden">⇩</span><sub>A</sub> s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Qs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⊆ snd ` as"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>index</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bound_atoms_def</span><span> </span><span>index_valid_def</span><span> </span><span>set_of_map_def</span><span> </span><span>boundsl_def</span><span> </span><span>boundsu_def</span><span> </span><span>o_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set ?C ⊆ snd ` as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients_atoms_tableau_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?C</span><span class="delimiter">]</span><span> </span><span>conjI</span><span class="delimiter">,</span><span>
</span><span>        </span><span>insert</span><span> </span><span>Qs</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>id</span><span class="delimiter">]</span><span> </span><span>sub</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>o_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next, we show that a conflict found by the assert-bound function also gives rise to
  Farkas coefficients.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Update</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_assert_bound</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ 𝒰 s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>s</sub> s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"△ (𝒯 s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∇ s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"◇ s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>index</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"index_valid as s"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒰 (assert_bound ia s)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_atoms_tableau (snd ` (insert ia as)) (𝒯 s) C"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ia</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ia = (i,a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` insert ia as"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ x c d. Leq x c ∈ ?A ∧ Geq x d ∈ ?A ∧ c &lt; d"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Geq</span><span> </span><span>x</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"updateℬℐ (Direction.UBI_upd (Direction (λx y. y &lt; x) ℬ<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>u</sub> ℬ<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub> ℬ<span class="hidden">⇩</span><sub>u</sub> ℬ<span class="hidden">⇩</span><sub>l</sub> ℐ<span class="hidden">⇩</span><sub>u</sub> ℐ<span class="hidden">⇩</span><sub>l</sub> ℬ<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub>_update Geq Leq (≤)))
                        i x d s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒰 ?s = 𝒰 s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"△ (𝒯 ?s)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇ ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tableau_valuated_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>idd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ lvars (𝒯 ?s) ⟹ 𝒰 (update x d ?s) = 𝒰 ?s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>update_unsat_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>norm</span><span> </span><span>val</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>U</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ia</span><span> </span><span>Geq</span><span class="delimiter">]</span><span> </span><span>inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>id</span><span> </span><span>idd</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊲<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>b</sub> (λx y. y &lt; x) d (ℬ<span class="hidden">⇩</span><sub>u</sub> s x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Bu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ<span class="hidden">⇩</span><sub>u</sub> s x = Some c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; d"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ<span class="hidden">⇩</span><sub>u</sub> s x"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bound_compare_defs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Bu</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Mapping.lookup (ℬ<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>u</sub> s) x = Some (j,c)"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>boundsu_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>index</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>index_valid_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(j, Leq x c) ∈ as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>xc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Leq x c ∈ ?A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Geq x d ∈ ?A"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ia</span><span> </span><span>Geq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xc</span><span> </span><span>xd</span><span> </span><span>lt</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Leq</span><span> </span><span>x</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"updateℬℐ (Direction.UBI_upd (Direction (&lt;) ℬ<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub> ℬ<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>u</sub> ℬ<span class="hidden">⇩</span><sub>l</sub> ℬ<span class="hidden">⇩</span><sub>u</sub> ℐ<span class="hidden">⇩</span><sub>l</sub> ℐ<span class="hidden">⇩</span><sub>u</sub> ℬ<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>u</sub>_update Leq Geq (≥))) i x c s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒰 ?s = 𝒰 s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"△ (𝒯 ?s)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇ ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tableau_valuated_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>idd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ lvars (𝒯 ?s) ⟹ 𝒰 (update x c ?s) = 𝒰 ?s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>update_unsat_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>norm</span><span> </span><span>val</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>U</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ia</span><span> </span><span>Leq</span><span class="delimiter">]</span><span> </span><span>inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>id</span><span> </span><span>idd</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊲<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>b</sub> (&lt;) c (ℬ<span class="hidden">⇩</span><sub>l</sub> s x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Bl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ<span class="hidden">⇩</span><sub>l</sub> s x = Some d"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; d"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℬ<span class="hidden">⇩</span><sub>l</sub> s x"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bound_compare_defs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Bl</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Mapping.lookup (ℬ<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>l</sub> s) x = Some (j,d)"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>boundsl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>index</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>index_valid_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(j, Geq x d) ∈ as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>xd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Geq x d ∈ ?A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Leq x c ∈ ?A"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ia</span><span> </span><span>Leq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xc</span><span> </span><span>xd</span><span> </span><span>lt</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Leq x c ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Geq x d ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients_atoms_tableau_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>conjI</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?C</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[(-1, Geq x d), (1,Leq x c)]"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(r,a)∈set ?C. a ∈ ?A ∧ is_leq_ns (r *R nsc_of_atom a) ∧ r ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c - d &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cd</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>minus_lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valuate_zero</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Moreover, we prove that all other steps of the simplex algorithm on layer~4, such as pivoting,
  asserting bounds without conflict, etc., preserve Farkas coefficients.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_coefficients_atoms_tableau_mono</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as ⊆ bs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"farkas_coefficients_atoms_tableau as t C ⟹ farkas_coefficients_atoms_tableau bs t C"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients_atoms_tableau_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>AssertAllState'''</span><span> </span><span class="delimiter">=</span><span> </span><span>AssertAllState''</span><span> </span><span>init</span><span> </span><span>ass_bnd</span><span> </span><span>chk</span><span> </span><span class="delimiter">+</span><span> </span><span>Update</span><span> </span><span>update</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span>PivotUpdateMinVars</span><span> </span><span>eq_idx_for_lvar</span><span> </span><span>min_lvar_not_in_bounds</span><span> </span><span>min_rvar_incdec_eq</span><span> </span><span>pivot_and_update</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ass_bnd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i × 'a :: lrv atom ⇒ _"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>chk</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'a) state ⇒ ('i, 'a) state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>update</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a :: lrv ⇒ ('i, 'a) state ⇒ ('i, 'a) state"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq_idx_for_lvar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"tableau ⇒ var ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>min_lvar_not_in_bounds</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i,'a::lrv) state ⇒ var option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>min_rvar_incdec_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i,'a) Direction ⇒ ('i,'a) state ⇒ eq ⇒ 'i list + var"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>pivot_and_update</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"var ⇒ var ⇒ 'a ⇒ ('i,'a) state ⇒ ('i,'a) state"</span></span></span><span>
</span><span>    </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ass_bnd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ass_bnd = Update.assert_bound update"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>chk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chk = PivotUpdateMinVars.check eq_idx_for_lvar min_lvar_not_in_bounds min_rvar_incdec_eq pivot_and_update"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>AssertAllState'''</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_assert_bound_loop</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒰 (assert_bound_loop as (init t))"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>norm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"△ t"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_atoms_tableau (snd ` set as) t C"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ as s. 𝒰 s ⟶ (∃ C. farkas_coefficients_atoms_tableau (snd ` as) (𝒯 s) C)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"assert_bound_loop as (init t)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ 𝒰 (init t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>init_unsat_flag</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒯 (assert_bound_loop as (init t)) = t ∧ 
    (𝒰 (assert_bound_loop as (init t)) ⟶ (∃ C. farkas_coefficients_atoms_tableau (snd ` set as) (𝒯 (init t)) C))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>AssertAllState''Induct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>norm</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>ass_bnd</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ 𝒰 (init t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>init_unsat_flag</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒯 (init t) = t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>init_tableau_id</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` as ⊆ snd ` bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>farkas_coefficients_atoms_tableau_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>s</span><span> </span><span>a</span><span> </span><span>ats</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"assert_bound a s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒯 ?s = 𝒯 s"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ass_bnd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>assert_bound_nolhs_tableau_id</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>3</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = 𝒯 s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span>tab</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒰 ?s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>farkas_assert_bound</span><span class="delimiter">[</span><span>OF</span><span> </span><span>3</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span>-</span><span>6</span><span class="delimiter">,</span><span>8</span><span class="delimiter">)</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_atoms_tableau (snd ` insert a (set ats)) (𝒯 (init (𝒯 s))) C"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>init_tableau_id</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>init_tableau_id</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Now we get to the main result for layer~4: If the main algorithm returns unsat,
  then there are Farkas coefficients for the tableau and atom set that were given as
  input for this layer.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_assert_all_state</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>U</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒰 (assert_all_state t as)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>norm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"△ t"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_atoms_tableau (snd ` set as) t C"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"assert_bound_loop as (init t)"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒰 (assert_bound_loop as (init t))"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>farkas_assert_bound_loop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>norm</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>AssertAllState''_tableau_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>norm</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒯 ?s = t"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>init_tableau_id</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>U</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒰 (check ?s)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chk</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>farkas_check</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span> </span><span>U</span><span> </span><span>False</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>T</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>norm</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>AssertAllState''_precond</span><span class="delimiter">[</span><span>OF</span><span> </span><span>norm</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>Let_def</span><span class="delimiter">]</span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>o</sub><span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>h</sub><span class="hidden">⇩</span><sub>s</sub> ?s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"◇ ?s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∇ ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>AssertAllState''_index_valid</span><span class="delimiter">[</span><span>OF</span><span> </span><span>norm</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"index_valid (set as) ?s"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Farkas' Lemma on Layer 3›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹There is only a small difference between layers 3 and 4, namely that there is no 
  simplex algorithm (@{const assert_all_state}) on layer 3, but just a tableau and atoms.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Hence, one task is to link the unsatisfiability flag 
  on layer 4 with unsatisfiability of the original tableau and atoms (layer 3). This can
  be done via the existing soundness results of the simplex algorithm.
  Moreover, we give an easy proof that the existence of Farkas coefficients for a tableau and 
  set of atoms implies unsatisfiability.›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_coefficients_atoms_tableau_unsat</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"farkas_coefficients_atoms_tableau as t C"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄ v. v ⊨<span class="hidden">⇩</span><sub>t</sub> t ∧ v ⊨<span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>s</sub> as"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ v. v ⊨<span class="hidden">⇩</span><sub>t</sub> t ∧ v ⊨<span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>s</sub> as"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>t</sub> t ∧ v ⊨<span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>s</sub> as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>isleq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀(r,a) ∈ set C. a ∈ as ∧ is_leq_ns (r *R nsc_of_atom a) ∧ r ≠ 0)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(r,a) ← C. lec_of_nsc (r *R nsc_of_atom a)) = Leqc p c"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cltz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p⦃v⦄ = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>farkas_coefficients_atoms_tableau_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(r,a) ∈ set C. v ⊨<span class="hidden">⇩</span><sub>a</sub> a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>isleq</span><span> </span><span>leq</span><span>
</span><span>      </span><span>satisfies_atom_set_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(r,a) ∈ set C"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span>fa</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>va</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>a</sub> a"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>satisfies_atom_set_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub> (r *R nsc_of_atom a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsc_of_atom</span><span> </span><span>sat_scale_rat_ns</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span>isleq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leq_ns (r *R nsc_of_atom a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lec_of_nsc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>v</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> lec_of_nsc (r *R nsc_of_atom a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>v</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> Leqc p c"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>leq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>satisfies_sumlist_le_constraints</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>v</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cltz</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next is the main result for layer~3: a tableau and a finite set of atoms are unsatisfiable
  if and only if there is a list of Farkas coefficients for the set of atoms and the tableau.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_coefficients_atoms_tableau</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>norm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"△ t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite as"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ C. farkas_coefficients_atoms_tableau as t C) ⟷ (∄ v. v ⊨<span class="hidden">⇩</span><sub>t</sub> t ∧ v ⊨<span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>s</sub> as)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"as = set bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>unsat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∄ v. v ⊨<span class="hidden">⇩</span><sub>t</sub> t ∧ v ⊨<span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>s</sub> as"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?as</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λ x. ((),x)) bs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>AssertAllState'''</span><span> </span><span>init_state</span><span> </span><span>assert_bound_code</span><span> </span><span>check_code</span><span> </span><span>update_code</span><span>
</span><span>    </span><span>eq_idx_for_lvar</span><span> </span><span>min_lvar_not_in_bounds</span><span> </span><span>min_rvar_incdec_eq</span><span> </span><span>pivot_and_update_code</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assert_bound_code_def</span><span> </span><span>check_code_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?call</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"assert_all t ?as"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set ?as = as"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>as</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assert_all_sat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>norm</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="var">?as</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>id</span><span class="delimiter">]</span><span> </span><span>unsat</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?call = Inl I"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="var">?call</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>assert_all_def</span><span> </span><span>Let_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒰 (assert_all_state_code t ?as)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assert_all_state_code_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>farkas_assert_all_state</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>assert_all_state_code_def</span><span class="delimiter">]</span><span> </span><span>norm</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>id</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_atoms_tableau as t C"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>farkas_coefficients_atoms_tableau_unsat</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Farkas' Lemma on Layer 2›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The main difference between layers 2 and 3 is the introduction of slack-variables in layer 3
  via the preprocess-function. Our task here is to show that Farkas coefficients at layer 3 (where 
  slack-variables are used) can be converted into Farkas coefficients for layer 2 (before the
  preprocessing).›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We also need to adapt the previos notion of Farkas coefficients, which was used in 
  @{const farkas_coefficients_atoms_tableau}, for layer~2. At layer 3, Farkas coefficients
  are the coefficients in a linear combination of atoms that evaluates to an inequality of
  the form $p \leq c$, where $p$ is a linear polynomial, $c &lt; 0$, and $t \models p = 0$ holds.
  At layer 2, the atoms are replaced by non-strict constraints where the left-hand side is a
  polynomial in the original variables, but the corresponding linear combination (with Farkas
  coefficients) evaluates directly to the inequality $0 \leq c$, with $c &lt; 0$. The implication
  $t \models p = 0$ is no longer possible in this layer, since there is no tableau $t$, nor is it
  needed, since $p$ is $0$. Thus, the statement defining Farkas coefficients must be changed
  accordingly.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>farkas_coefficients_ns</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"farkas_coefficients_ns ns C = (∃ c.
    (∀(r, n) ∈ set C. n ∈ ns ∧ is_leq_ns (r *R n) ∧ r ≠ 0) ∧
    (∑(r, n) ← C. lec_of_nsc (r *R n)) = Leqc 0 c ∧
    c &lt; 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The easy part is to prove that Farkas coefficients imply unsatisfiability.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_coefficients_ns_unsat</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"farkas_coefficients_ns ns C"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄ v. v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>s</sub> ns"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ v. v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>s</sub> ns"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>s</sub> ns"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>isleq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀(a,n) ∈ set C. n ∈ ns ∧ is_leq_ns (a *R n) ∧ a ≠ 0)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(a,n) ← C. lec_of_nsc (a *R n)) = Leqc 0 c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cltz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>farkas_coefficients_ns_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,n) ∈ set C"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n</span><span> </span><span>*</span><span> </span><span>isleq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub> n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub> (a *R n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sat_scale_rat_ns</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n</span><span> </span><span>isleq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leq_ns (a *R n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lec_of_nsc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>v</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> lec_of_nsc (a *R n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>v</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> Leqc 0 c"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>leq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>satisfies_sumlist_le_constraints</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>v</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cltz</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>leD</span><span> </span><span>satisfiable_le_constraint.simps</span><span> </span><span>valuate_zero</span><span> </span><span>rel_of.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In order to eliminate the need for a tableau, we require the notion of an arbitrary substitution
  on polynomials, where all variables can be replaced at once. The existing simplex formalization 
  provides only a function to replace one variable at a time.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>subst_poly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(var ⇒ linear_poly) ⇒ linear_poly ⇒ linear_poly"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"subst_poly σ p = (∑ x ∈ vars p. coeff p x *R σ x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_poly_0</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_poly σ 0 = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_poly_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valuate_subst_poly</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(subst_poly σ p) ⦃ v ⦄ = (p ⦃ (λ x. ((σ x) ⦃ v ⦄)) ⦄)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>linear_poly_sum</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>subst_poly_def</span><span> </span><span>valuate_sum</span><span> </span><span>valuate_scaleRat</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_poly_add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_poly σ (p + q) = subst_poly σ p + subst_poly σ q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>linear_poly_eqI</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>valuate_add</span><span> </span><span>valuate_subst_poly</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>subst_poly_lec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(var ⇒ linear_poly) ⇒ 'a le_constraint ⇒ 'a le_constraint"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"subst_poly_lec σ (Le_Constraint rel p c) = Le_Constraint rel (subst_poly σ p) c"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_poly_lec_0</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_poly_lec σ 0 = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>zero_le_constraint_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_poly_lec_add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_poly_lec σ (c1 + c2) = subst_poly_lec σ c1 + subst_poly_lec σ c2"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c1</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>c2</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subst_poly_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_poly_lec_sum_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_poly_lec σ (sum_list ps) = sum_list (map (subst_poly_lec σ) ps)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ps</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subst_poly_lec_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_poly_lp_monom</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_poly σ (lp_monom r x) = r *R σ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_poly_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vars_lp_monom</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_poly_scaleRat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_poly σ (r *R p) = r *R (subst_poly σ p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>linear_poly_eqI</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>valuate_scaleRat</span><span> </span><span>valuate_subst_poly</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We need several auxiliary properties of the preprocess-function which are not present
  in the simplex formalization.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Tableau_is_monom_preprocess'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, p) ∈ set (Tableau (preprocess' cs start))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_monom p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>cs</span><span> </span><span>start</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>preprocess'.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>preprocess'_atoms_to_constraints'</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preprocess' cs start = S"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (Atoms S) ⊆ {(i,qdelta_constraint_to_atom c v) | i c v. (i,c) ∈ set cs ∧ 
     (¬ is_monom (poly c) ⟶ Poly_Mapping S (poly c) = Some v)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>cs</span><span> </span><span>start</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>preprocess'.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">+</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monom_of_atom_coeff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_monom (poly ns)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = qdelta_constraint_to_atom ns v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(monom_coeff (poly ns)) *R nsc_of_atom a = ns"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>is_monom_monom_coeff_not_zero</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>ns</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>atom.split</span><span> </span><span>ns_constraint.split</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monom_poly_assemble</span><span> </span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The next lemma provides the functionality that is required to convert an
  atom back to a non-strict constraint, i.e., it is a kind of inverse of the preprocess-function.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>preprocess'_atoms_to_constraints</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"preprocess' cs start = S"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>start</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"start = start_fresh_variable cs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ns = (case a of Leq v c ⇒ LEQ_ns q c | Geq v c ⇒ GEQ_ns q c)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ snd ` set (Atoms S)"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(atom_var a ∉ fst ` set (Tableau S) ⟶ (∃ r. r ≠ 0 ∧ r *R nsc_of_atom a ∈ snd ` set cs))
    ∧  ((atom_var a, q) ∈ set (Tableau S) ⟶ ns ∈ snd ` set cs)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"preprocess' cs start"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ia</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(i,a) ∈ set (Atoms S)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>preprocess'_atoms_to_constraints'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span>v</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = qdelta_constraint_to_atom c v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(i,c) ∈ set cs"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nmonom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_monom (poly c) ⟹ Poly_Mapping S (poly c) = Some v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>c'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ snd ` set cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?p</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"poly c"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_monom ?p"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>av</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"atom_var a = monom_var ?p"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Tableau_is_monom_preprocess'</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?p</span><span> </span><span>cs</span><span> </span><span>start</span><span class="delimiter">]</span><span> </span><span>True</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, ?p) ∉ set (Tableau ?S)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(atom_var a, q) ∈ set (Tableau S)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(monom_var ?p, q) ∈ set (Tableau S)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>av</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"monom_var ?p ∈ lvars (Tableau S)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lvars_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lvars_tableau_ge_start</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>this</span><span class="delimiter">[</span><span>folded</span><span> </span><span>S</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"monom_var ?p ≥ start"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"monom_var ?p ∈ vars_constraints (map snd cs)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>c</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(i,c)"</span></span></span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>monom_var_in_vars</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>start_fresh_variable_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>start</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>monom_of_atom_coeff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>True</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃r. r ≠ 0 ∧ r *R nsc_of_atom a = c"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"monom_coeff ?p"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>av</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"atom_var a = v"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>nmonom</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Poly_Mapping S ?p = Some v"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>preprocess'_Tableau_Poly_Mapping_Some</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">[</span><span>folded</span><span> </span><span>S</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(atom_var a, ?p) ∈ set (Tableau (preprocess' cs start))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>av</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"atom_var a ∈ fst ` set (Tableau S)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(atom_var a, q) ∈ set (Tableau S)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>tab</span><span> </span><span>this</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q = ?p"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lvars_distinct</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>start</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>S</span><span> </span><span>lhs_def</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_beta'</span><span> </span><span>eq_key_imp_eq_value</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ns = c"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ns</span><span> </span><span>qp</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>av</span><span> </span><span>a</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ns ∈ snd ` set cs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next follows the major technical lemma of this part, 
  namely that Farkas coefficients on layer~3 for preprocessed constraints can
  be converted into Farkas coefficients on layer~2.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_coefficients_preprocess'</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>pp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"preprocess' cs (start_fresh_variable cs) = S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ft</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"farkas_coefficients_atoms_tableau (snd ` set (Atoms S)) (Tableau S) C"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_ns (snd ` set cs) C"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ft</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>farkas_coefficients_atoms_tableau_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (r,a) ∈ set C. a ∈ snd ` set (Atoms S) ∧ is_leq_ns (r *R nsc_of_atom a) ∧ r ≠ 0"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(∑(r,a)←C. lec_of_nsc (r *R nsc_of_atom a)) = Leqc p c"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"c &lt; 0"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀v :: QDelta valuation. v ⊨<span class="hidden">⇩</span><sub>t</sub> Tableau S ⟹ p ⦃ v ⦄ = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ft</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients_atoms_tableau_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>0</span><span> </span><span class="delimiter">=</span><span> </span><span>0</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, b)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>split</span><span class="delimiter">]</span><span> </span><span>0</span><span class="delimiter">(</span><span>2</span><span>-</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Tableau S"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"var ⇒ linear_poly"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ = (λ x. case map_of ?T x of Some p ⇒ p | None ⇒ lp_monom 1 x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λr a s ns. ns ∈ (snd ` set cs) ∧ is_leq_ns (s *R ns) ∧ s ≠ 0 ∧
      subst_poly_lec σ (lec_of_nsc (r *R nsc_of_atom a)) = lec_of_nsc (s *R ns))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s ns. ?P r a s ns"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>ra</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(r,a) ∈ set C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>r</span><span> </span><span>a</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ snd ` set (Atoms S)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ra</span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>0</span><span> </span><span>ra</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>is_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leq_ns (r *R nsc_of_atom a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"atom_var a"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_of ?T ?x"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>σ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ?x = q"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>σ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Some</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xqT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?x, q) ∈ set ?T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>map_of_SomeD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ns</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ns = (case a of Leq v c ⇒ LEQ_ns q c
                                     | Geq v c ⇒ GEQ_ns q c)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>preprocess'_atoms_to_constraints</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pp</span><span> </span><span>refl</span><span> </span><span>ns_def</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>xqT</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ns_mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ns ∈ snd ` set cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_poly_lec σ (lec_of_nsc (r *R nsc_of_atom a))
               = lec_of_nsc (r *R ns)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_leq</span><span> </span><span>σ</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ns_def</span><span> </span><span>subst_poly_scaleRat</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>id</span><span> </span><span>is_leq</span><span> </span><span>σ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>is_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leq_ns (r *R ns)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ns_def</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>r</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ns</span><span class="delimiter">]</span><span> </span><span>conjI</span><span> </span><span>ns_mem</span><span> </span><span>id</span><span> </span><span>is_leq</span><span> </span><span>conjI</span><span> </span><span>r0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?x ∉ fst ` set ?T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>map_of_eq_None_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>preprocess'_atoms_to_constraints</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pp</span><span> </span><span>refl</span><span> </span><span>refl</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rr *R nsc_of_atom a ∈ (snd ` set cs)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rr0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rr ≠ 0"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>None</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ?x = lp_monom 1 ?x"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>σ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ns</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ns = rr *R nsc_of_atom a"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = r / rr"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rr0</span><span> </span><span>r0</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>s_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>is_leq</span><span> </span><span>σ</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_poly_lec σ (lec_of_nsc (r *R nsc_of_atom a)) 
        = lec_of_nsc (r *R nsc_of_atom a)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subst_poly_scaleRat</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r *R nsc_of_atom a = s *R ns"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ns_def</span><span> </span><span>s_def</span><span>
</span><span>          </span><span>scaleRat_scaleRat_ns_constraint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rr0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rr0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_poly_lec σ (lec_of_nsc (r *R nsc_of_atom a))
            = lec_of_nsc (s *R ns)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leq_ns (s *R ns)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_leq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ns_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rr</span><span> </span><span>s0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ ra. ∃ s ns. (fst ra, snd ra) ∈ set C ⟶ ?P (fst ra) (snd ra) s ns"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>choice</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ ra. ∃ ns. (fst ra, snd ra) ∈ set C ⟶ ?P (fst ra) (snd ra) (s ra) ns"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>choice</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ns</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ r a. (r,a) ∈ set C ⟹ ?P r a (s (r,a)) (ns (r,a))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>NC</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NC = map (λ(r,a). (s (r,a), ns (r,a))) C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(s, ns)←map (λ(r,a). (s (r,a), ns (r,a))) C'. lec_of_nsc (s *R ns)) =
        (∑(r, a)←C'. subst_poly_lec σ (lec_of_nsc (r *R nsc_of_atom a)))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set C' ⊆ set C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C'</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>C'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>C'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x←a # C'. lec_of_nsc (s x *R ns x)) = 
          lec_of_nsc (s a *R ns a) + (∑x←C'. lec_of_nsc (s x *R ns x))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x←C'. lec_of_nsc (s x *R ns x)) = (∑(r, a)←C'. subst_poly_lec σ (lec_of_nsc (r *R nsc_of_atom a)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_beta'</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_of_nsc (s a *R ns a) = subst_poly_lec σ (lec_of_nsc (fst a *R nsc_of_atom (snd a)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set C"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ns</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_beta'</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(r, a)←C. subst_poly_lec σ (lec_of_nsc (r *R nsc_of_atom a)))
             = subst_poly_lec σ (∑(r, a)←C. (lec_of_nsc (r *R nsc_of_atom a)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_poly_lec_sum_list</span><span> </span><span>case_prod_beta'</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(r, a)←C. (lec_of_nsc (r *R nsc_of_atom a))) = Leqc p c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_poly_lec σ (Leqc p c) = Leqc (subst_poly σ p) c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_poly σ p = 0"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_valuate_zero</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"QDelta valuation"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(subst_poly σ p) ⦃ v ⦄ = (p ⦃ λx. ((σ x) ⦃ v ⦄) ⦄)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valuate_subst_poly</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = 0"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>0</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ a) ⦃ v ⦄ = (q ⦃ λx. ((σ x) ⦃ v ⦄) ⦄)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, q) ∈ set (Tableau S)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>q</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map fst ?T)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normalized_tableau_preprocess'</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normalized_tableau_def</span><span> </span><span>lhs_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_beta'</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ a = q"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>σ_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ⦃ v ⦄ = (q ⦃ λx. ((σ x) ⦃ v ⦄) ⦄)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars q ⊆ rvars ?T"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rvars_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ x) ⦃ v ⦄ = v x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ rvars ?T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ lvars (Tableau S)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>normalized_tableau_preprocess'</span><span> </span><span>assms</span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>normalized_tableau_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ fst ` set (Tableau S)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lvars_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_of ?T x = None"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_of_eq_None_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ x = lp_monom 1 x"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>σ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lp_monom 1 x) ⦃ v ⦄ = v x"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>valuate_depend</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx. ((σ x) ⦃ v ⦄)) ⊨<span class="hidden">⇩</span><sub>t</sub> ?T"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>satisfies_tableau_def</span><span> </span><span>satisfies_eq_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(subst_poly σ p) ⦃ v ⦄ = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(s, n)←NC. lec_of_nsc (s *R n)) = Le_Constraint Leq_Rel 0 c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NC_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ns (r,a) ∈ snd ` set cs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leq_ns (s (r, a) *R ns (r, a))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s (r, a) ≠ 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(r, a) ∈ set C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>r</span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ns</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"farkas_coefficients_ns (snd ` set cs) NC"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients_ns_def</span><span> </span><span>NC_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>preprocess'_unsat_indexD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ set (UnsatIndices (preprocess' ns j)) ⟹ 
  ∃ c. poly c = 0 ∧ ¬ zero_satisfies c ∧ (i,c) ∈ set ns"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ns</span><span> </span><span>j</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>preprocess'.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>preprocess'_unsat_index_farkas_coefficients_ns</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ set (UnsatIndices (preprocess' ns j))"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_ns (snd ` set ns) C"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>preprocess'_unsat_indexD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>contr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"poly c = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ zero_satisfies c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(i,c) ∈ set ns"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>mem</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ snd ` set ns"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?c</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ns_constraint_const c"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = (case c of LEQ_ns _ _ ⇒ 1 | _ ⇒ (-1 :: rat))"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d = (case c of LEQ_ns _ _ ⇒ ?c | _ ⇒ - ?c)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(- x &lt; 0) = (0 &lt; x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>QDelta</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uminus_less_lrv</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients_ns_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[(r,c)]"</span></span></span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>d</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>mem</span><span> </span><span>contr</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"c"</span></span></span><span class="delimiter">,</span><span> 
</span><span>        </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>r_def</span><span> </span><span>d_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The combination of the previous results easily provides the main result of this section:
  a finite set of non-strict constraints on layer~2 is unsatisfiable if and only if there are Farkas coefficients.
  Again, here we use results from the simplex formalization, namely soundness of the preprocess-function.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_coefficients_ns</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (ns :: QDelta ns_constraint set)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ C. farkas_coefficients_ns ns C) ⟷ (∄ v. v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>s</sub> ns)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_ns ns C"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>farkas_coefficients_ns_unsat</span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄ v. v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>s</sub> ns"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>unsat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∄ v. v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>s</sub> ns"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>nsl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ns = set nsl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?cs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (Pair ()) nsl"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span>t</span><span> </span><span>ias</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>part1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"preprocess_part_1 ?cs = (t,ias,I)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"preprocess_part_1 ?cs"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?as</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set ias"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"start_fresh_variable ?cs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ?as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ias = Atoms (preprocess' ?cs ?s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Tableau (preprocess' ?cs ?s)"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"I = UnsatIndices (preprocess' ?cs ?s)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>part1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>preprocess_part_1_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>norm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"△ t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normalized_tableau_preprocess'</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?cs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>id</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>a</sub><span class="hidden">⇩</span><sub>s</sub> ?as"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>t</sub> t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>preprocess'_sat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>id</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>id</span><span class="delimiter">]</span><span> </span><span>unsat</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ns</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set I ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ set I"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_not_in_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>preprocess'_unsat_index_farkas_coefficients_ns</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>id</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃C. farkas_coefficients_ns (snd ` set ?cs) C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>farkas_coefficients_atoms_tableau</span><span class="delimiter">[</span><span>OF</span><span> </span><span>norm</span><span> </span><span>fin</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"farkas_coefficients_atoms_tableau ?as t C
     ∨ (∃C. farkas_coefficients_ns (snd ` set ?cs) C)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>farkas_coefficients_preprocess'</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?cs</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_ns (snd ` set ?cs) C"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>part1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>preprocess_part_1_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set ?cs = ns"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ns</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_ns ns C"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Farkas' Lemma on Layer 1›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The main difference of layers 1 and 2 is the restriction to non-strict constraints via delta-rationals.
  Since we now work with another constraint type, @{type constraint}, we again need translations into
  linear inequalities of type @{type le_constraint}. Moreover, we also need to define scaling of constraints
  where flipping the comparison sign may be required.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>is_le</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"constraint ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_le (LT _ _) = True"</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_le (LEQ _ _) = True"</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_le _ = False"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lec_of_constraint</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lec_of_constraint (LEQ p c) = (Le_Constraint Leq_Rel p c)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_of_constraint (LT p c) = (Le_Constraint Lt_Rel p c)"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lec_of_constraint</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_le c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> (lec_of_constraint c)) ⟷ (v ⊨<span class="hidden">⇩</span><sub>c</sub> c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>constraint</span><span> </span><span class="delimiter">::</span><span> </span><span>scaleRat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>scaleRat_constraint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat ⇒ constraint ⇒ constraint"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"scaleRat_constraint r cc = (if r = 0 then LEQ 0 0 else 
  (case cc of 
    LEQ p c ⇒
     (if (r &lt; 0) then GEQ (r *R p) (r *R c) else LEQ (r *R p) (r *R c))
  | LT p c ⇒
     (if (r &lt; 0) then GT (r *R p) (r *R c) else LT (r *R p) (r *R c))
  | GEQ p c ⇒ 
    (if (r &gt; 0) then GEQ (r *R p) (r *R c) else LEQ (r *R p) (r *R c))
  | GT p c ⇒ 
    (if (r &gt; 0) then GT (r *R p) (r *R c) else LT (r *R p) (r *R c))
  | LTPP p q ⇒
     (if (r &lt; 0) then GT (r *R (p - q)) 0 else LT (r *R (p - q)) 0)
  | LEQPP p q ⇒
     (if (r &lt; 0) then GEQ (r *R (p - q)) 0 else LEQ (r *R (p - q)) 0)
  | GTPP p q ⇒
     (if (r &gt; 0) then GT (r *R (p - q)) 0 else LT (r *R (p - q)) 0)
  | GEQPP p q ⇒
     (if (r &gt; 0) then GEQ (r *R (p - q)) 0 else LEQ (r *R (p - q)) 0)
  | EQPP p q ⇒ LEQ (r *R (p - q)) 0 ― ‹We do not keep equality, since the aim is 
        to convert the scaled constraints into inequalities, which will then be summed up.›
  | EQ p c ⇒ LEQ (r *R p) (r *R c) 
))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sat_scale_rat</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v :: rat valuation) ⊨<span class="hidden">⇩</span><sub>c</sub> c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub> (r *R c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r &lt; 0 ∨ r = 0 ∨ r &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>right_diff_distrib</span><span> 
</span><span>        </span><span>valuate_minus</span><span> </span><span>valuate_scaleRat</span><span> </span><span>scaleRat_leq1</span><span> </span><span>scaleRat_leq2</span><span> </span><span>valuate_zero</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the following definition of Farkas coefficients (for layer 1), the main difference to
  @{const farkas_coefficients_ns} is that the linear combination evaluates either to
  a strict inequality where the constant must be non-positive, or to a non-strict inequality where
  the constant must be negative.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>farkas_coefficients</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"farkas_coefficients cs C = (∃ d rel. 
    (∀ (r,c) ∈ set C. c ∈ cs ∧ is_le (r *R c) ∧ r ≠ 0) ∧
    (∑ (r,c) ← C. lec_of_constraint (r *R c)) = Le_Constraint rel 0 d ∧ 
    (rel = Leq_Rel ∧ d &lt; 0 ∨ rel = Lt_Rel ∧ d ≤ 0))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Again, the existence Farkas coefficients immediately implies unsatisfiability.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_coefficients_unsat</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"farkas_coefficients cs C"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄ v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span>rel</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>isleq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀(r,c) ∈ set C. c ∈ cs ∧ is_le (r *R c) ∧ r ≠ 0)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑ (r,c) ← C. lec_of_constraint (r *R c)) = Le_Constraint rel 0 d"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>choice</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel = Lt_Rel ∧ d ≤ 0 ∨ rel = Leq_Rel ∧ d &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>farkas_coefficients_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(r,c) ∈ set C"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span> </span><span>*</span><span> </span><span>isleq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub> c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub> (r *R c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sat_scale_rat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span> </span><span>isleq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_le (r *R c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lec_of_constraint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>v</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> lec_of_constraint (r *R c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>v</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> Le_Constraint rel 0 d"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>leq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>satisfies_sumlist_le_constraints</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>v</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>choice</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rel</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valuate_zero</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Now follows the difficult implication. 
  The major part is proving that the translation @{const constraint_to_qdelta_constraint} 
  preserves the existence of Farkas coefficients via pointwise compatibility of the sum.
  Here, compatibility links a strict or non-strict inequality from the input constraint to
  a translated non-strict inequality over delta-rationals.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>compatible_cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"compatible_cs (Le_Constraint Leq_Rel p c) (Le_Constraint Leq_Rel q d) = (q = p ∧ d = QDelta c 0)"</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"compatible_cs (Le_Constraint Lt_Rel p c) (Le_Constraint Leq_Rel q d) = (q = p ∧ qdfst d = c)"</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"compatible_cs _ _ = False"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compatible_cs_0_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"compatible_cs 0 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>code_simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compatible_cs_plus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"compatible_cs c1 d1 ⟹ compatible_cs c2 d2 ⟹ compatible_cs (c1 + c2) (d1 + d2)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c1</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>d1</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>c2</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>d2</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel c1"</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel d1"</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel c2"</span></span></span><span class="delimiter">;</span><span> 
</span><span>      </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel d2"</span></span></span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>plus_QDelta_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unsat_farkas_coefficients</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄ v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite cs"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients cs C"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>csl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cs = set csl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?csl</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (Pair ()) csl"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ns</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd ` set (to_ns ?csl))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?nsl</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"concat (map constraint_to_qdelta_constraint csl)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set ?csl = cs"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>id2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?ns = set ?nsl"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>to_ns_def</span><span> </span><span>set_concat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SolveExec'Default.to_ns_sat</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?csl</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>id</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unsat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∄ v. ⟨v⟩ ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>s</sub> ?ns"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ?ns"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄ v. v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>s</sub> ?ns"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ v. v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>s</sub> ?ns"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>model</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>s</sub> ?ns"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?v</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Mapping.Mapping (λ x. Some (v x))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v = ⟨?v⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map2fun_def</span><span> </span><span>Mapping.lookup.abs_eq</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>model</span><span> </span><span>this</span><span> </span><span>unsat</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>farkas_coefficients_ns</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin</span><span class="delimiter">]</span><span> </span><span>this</span><span> </span><span>id2</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>farkas</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"farkas_coefficients_ns (set ?nsl) N"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>farkas_coefficients_ns_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>is_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ a n. (a,n) ∈ set N ⟹ n ∈ set ?nsl ∧ is_leq_ns (a *R n) ∧ a ≠ 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(a,n)←N. lec_of_nsc (a *R n)) = Le_Constraint Leq_Rel 0 d"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>d0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?prop</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ NN C. (∀ (a,c) ∈ set C. c ∈ cs ∧ is_le (a *R c) ∧ a ≠ 0)
      ∧ compatible_cs (∑ (a,c) ← C. lec_of_constraint (a *R c)) 
          (∑(a,n)←NN. lec_of_nsc (a *R n))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set NN ⊆ set N ⟹ ∃ C. ?prop NN C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>NN</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>NN</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?prop Nil Nil"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>compatible_cs_0_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>an</span><span> </span><span>NN</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>an</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"an = (a,n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span> </span><span>an</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?prop NN C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,n) ∈ set N"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>compat_CN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"compatible_cs (∑(f, c)←C. lec_of_constraint (f *R c)) 
      (∑(a,n)←NN. lec_of_nsc (a *R n))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n</span><span> </span><span>is_leq</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ cs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ set (constraint_to_qdelta_constraint c)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>is_leq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>is_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leq_ns (a *R n) ∧ a ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>is_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_le (a *R c)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>      </span><span>a0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>compat_cn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"compatible_cs (lec_of_constraint (a *R c)) (lec_of_nsc (a *R n))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>atomize</span><span class="delimiter">(</span><span>full</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>is_leq</span><span> </span><span>nc</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>QDelta_0_0</span><span> </span><span>scaleRat_QDelta_def</span><span> </span><span>qdsnd_0</span><span> </span><span>qdfst_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?C</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cons (a, c) C"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?N</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cons (a, n) NN"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?prop ?N ?C"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>an</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (a,c) ∈ set ?C. c ∈ cs ∧ is_le (a *R c) ∧ a ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>is_less</span><span> </span><span>a0</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compatible_cs (∑(a, c)←?C. lec_of_constraint (a *R c)) (∑(a,n)←?N. lec_of_nsc (a *R n))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compatible_cs_plus</span><span class="delimiter">[</span><span>OF</span><span> </span><span>compat_cn</span><span> </span><span>compat_CN</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>an</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subset_refl</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>sum</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>is_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀(a, c)∈set C. c ∈ cs ∧ is_le (a *R c) ∧ a ≠ 0)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>compat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"compatible_cs (∑(f, c)←C. lec_of_constraint (f *R c)) (Le_Constraint Leq_Rel 0 d)"</span></span></span><span> 
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"compatible_cs ?sum _"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rel</span><span> </span><span>p</span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?sum = Le_Constraint rel p e"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="var">?sum</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>compat</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?sum = Le_Constraint rel 0 e"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rel</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(rel = Leq_Rel ∧ e &lt; 0 ∨ rel = Lt_Rel ∧ e ≤ 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compat</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>sum</span><span class="delimiter">]</span><span> </span><span>d0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rel</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_QDelta_def</span><span> </span><span>qdfst_0</span><span> </span><span>qdsnd_0</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>is_less</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>sum</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>e</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally we can prove on layer 1 that a finite set of constraints is 
  unsatisfiable if and only if there are Farkas coefficients.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_coefficients</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite cs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ C. farkas_coefficients cs C) ⟷ (∄ v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>farkas_coefficients_unsat</span><span> </span><span>unsat_farkas_coefficients</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Corollaries from the Literature›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In this section, we convert the previous variations of Farkas' Lemma into more 
  well-known forms of this result.
  Moreover, instead of referring to the various constraint types of the simplex formalization, we
  now speak solely about constraints of type @{type le_constraint}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Farkas' Lemma on Delta-Rationals›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We start with Lemma~2 of \cite{Bromberger2017}, a
  variant of Farkas' Lemma for delta-rationals. To be more precise, it states
  that a set of non-strict inequalities over delta-rationals is unsatisfiable
  if and only if there is a linear combination of the inequalities that results
  in a trivial unsatisfiable constraint $0 &lt; const$ for some negative constant $const$.
  We can easily prove this statement via the lemma @{thm [source] farkas_coefficients_ns} 
  and some conversions between the 
  different constraint types.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Farkas'_Lemma_Delta_Rationals</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>cs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"QDelta le_constraint set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>only_non_strict</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel ` cs ⊆ {Leq_Rel}"</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite cs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∄ v. ∀ c ∈ cs. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c) ⟷ 
       (∃ C const. (∀ (r, c) ∈ set C. r &gt; 0 ∧ c ∈ cs)
         ∧ (∑ (r,c) ← C. Leqc (r *R lec_poly c) (r *R lec_const c)) = Leqc 0 const
         ∧ const &lt; 0)"</span></span></span><span> 
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ cs"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>only_non_strict</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel c = Leq_Rel"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ p const. c = Leqc p const"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>leqc</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?to_ns</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ c. LEQ_ns (lec_poly c) (lec_const c)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ns</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"?to_ns ` cs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fin</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ?ns"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>s</sub> ?ns ⟷ (∀ c ∈ cs. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leqc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = (∄ v. v ⊨<span class="hidden">⇩</span><sub>n</sub><span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>s</sub> ?ns)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∃C. farkas_coefficients_ns ?ns C)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients_ns</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ?rhs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_ns ?ns C"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span>const</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>is_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (s, n) ∈ set C. n ∈ ?ns ∧ is_leq_ns (s *R n) ∧ s ≠ 0"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(s, n)←C. lec_of_nsc (s *R n)) = Leqc 0 const"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"const &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients_ns_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?C</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λ (s,n). (s,lec_of_nsc n)) C"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?C</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>const</span><span class="delimiter">]</span><span> </span><span>conjI</span><span> </span><span>c0</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>sum</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_map</span><span> </span><span>o_def</span><span> </span><span>set_map</span><span class="delimiter">,</span><span> 
</span><span>        </span><span>intro</span><span> </span><span>ballI</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>n</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, n) ∈ set C"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>is_leq</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_ns</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ ?ns"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>is_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leq_ns (s *R n)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n_ns</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ cs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n = LEQ_ns (lec_poly c) (lec_const c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>leqc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Leqc p d ∈ cs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n = LEQ_ns p d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>is_leq</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?n</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_of_nsc n"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>cs</span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?n ∈ cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; s ∧ ?n ∈ cs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s0</span><span> </span><span>mem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Leqc (s *R lec_poly ?n) (s *R lec_const ?n) = lec_of_nsc (s *R n)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>id</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x←C. case case x of (s, n) ⇒ (s, lec_of_nsc n) of
             (r, c) ⇒ Leqc (r *R lec_poly c) (r *R lec_const c)) =
             (∑(s, n)←C. lec_of_nsc (s *R n))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map ?f C) = sum_list (map ?g C)"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sum_list</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>map_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>pair</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pair ∈ set C"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>pair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pair = (s,n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?f pair = ?g pair"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pair</span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mem</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>pair</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span>const</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ r c. (r,c) ∈ set C ⟹ 0 &lt; r ∧ c ∈ cs"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(r, c)←C. Leqc (r *R lec_poly c) (r *R lec_const c)) = Leqc 0 const"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"const &lt; 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?C</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λ (r,c). (r, ?to_ns c)) C"</span></span></span><span>  
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients_ns ?ns C"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients_ns_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?C</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>const</span><span class="delimiter">]</span><span> </span><span>conjI</span><span> </span><span>const</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>sum</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(s, n)∈set ?C. n ∈ ?ns ∧ is_leq_ns (s *R n) ∧ s ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(s, n)←?C. lec_of_nsc (s *R n)) 
        = (∑(r, c)←C. Leqc (r *R lec_poly c) (r *R lec_const c))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>map_map</span><span> </span><span>o_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sum_list</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>map_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Motzkin's Transposition Theorem or the Kuhn-Fourier Theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next, we prove a generalization of Farkas' Lemma that permits arbitrary combinations
  of strict and non-strict inequalities: Motzkin's Transposition Theorem
  which is also known as the Kuhn--Fourier Theorem.

  The proof is mainly based on the lemma @{thm [source] farkas_coefficients}, 
  again requiring conversions between constraint types.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Motzkin's_transposition_theorem</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>cs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat le_constraint set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite cs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∄ v. ∀ c ∈ cs. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c) ⟷ 
       (∃ C const rel. (∀ (r, c) ∈ set C. r &gt; 0 ∧ c ∈ cs)
         ∧ (∑ (r,c) ← C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) 
               = Le_Constraint rel 0 const
         ∧ (rel = Leq_Rel ∧ const &lt; 0 ∨ rel = Lt_Rel ∧ const ≤ 0))"</span></span></span><span> 
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?to_cs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ c. (case lec_rel c of Leq_Rel ⇒ LEQ | _ ⇒ LT) (lec_poly c) (lec_const c)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>to_cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub> ?to_cs c ⟷ v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel c"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?cs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"?to_cs ` cs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fin</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ?cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> ?cs ⟷ (∀ c ∈ cs. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>to_cs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = (∄ v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> ?cs)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∃C. farkas_coefficients ?cs C)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ?rhs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients ?cs C"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span>const</span><span> </span><span>rel</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>is_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (s, n) ∈ set C. n ∈ ?cs ∧ is_le (s *R n) ∧ s ≠ 0"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(s, n)←C. lec_of_constraint (s *R n)) = Le_Constraint rel 0 const"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(rel = Leq_Rel ∧ const &lt; 0 ∨ rel = Lt_Rel ∧ const ≤ 0)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?C</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λ (s,n). (s,lec_of_constraint n)) C"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?C</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>const</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>rel</span><span class="delimiter">]</span><span> </span><span>conjI</span><span> </span><span>c0</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>map_map</span><span> </span><span>o_def</span><span> </span><span>set_map</span><span> </span><span>sum</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> 
</span><span>        </span><span>intro</span><span> </span><span>ballI</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>n</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, n) ∈ set C"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>is_leq</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_ns</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ ?cs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>is_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_le (s *R n)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n_ns</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ cs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n = ?to_cs c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>is_leq</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel c"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s0</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?c</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_of_constraint n"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?c ∈ cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel c"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; s ∧ ?c ∈ cs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s0</span><span> </span><span>mem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_of_constraint (s *R n) = Le_Constraint (lec_rel ?c) (s *R lec_poly ?c) (s *R lec_const ?c)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel c"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>id</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x←C. case case x of (s, n) ⇒ (s, lec_of_constraint n) of
             (r, c) ⇒ Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) =
            (∑(s, n)←C. lec_of_constraint (s *R n))"</span></span></span><span> 
</span><span>        </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map ?f C) = sum_list (map ?g C)"</span></span></span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sum_list</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>map_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>pair</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pair ∈ set C"</span></span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>pair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pair = (r,c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?f pair = ?g pair"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pair</span><span> </span><span>split</span><span> </span><span>id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mem</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>pair</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span>const</span><span> </span><span>rel</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ r c. (r,c) ∈ set C ⟹ 0 &lt; r ∧ c ∈ cs"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(r, c)←C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) 
           = Le_Constraint rel 0 const"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel = Leq_Rel ∧ const &lt; 0 ∨ rel = Lt_Rel ∧ const ≤ 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?C</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λ (r,c). (r, ?to_cs c)) C"</span></span></span><span>  
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ C. farkas_coefficients ?cs C"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>farkas_coefficients_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?C</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>const</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>rel</span><span class="delimiter">]</span><span> </span><span>conjI</span><span> </span><span>const</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>sum</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(s, n)∈set ?C. n ∈ ?cs ∧ is_le (s *R n) ∧ s ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>le_rel.splits</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(s, n)←?C. lec_of_constraint (s *R n)) 
        = (∑(r, c)←C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>map_map</span><span> </span><span>o_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sum_list</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>map_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>le_rel.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Farkas' Lemma›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally we derive the commonly used form of Farkas' Lemma,
  which easily follows from @{thm [source] Motzkin's_transposition_theorem}. 
  It only permits non-strict inequalities and, as a result, 
  the sum of inequalities will always be non-strict.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Farkas'_Lemma</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>cs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat le_constraint set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>only_non_strict</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel ` cs ⊆ {Leq_Rel}"</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite cs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∄ v. ∀ c ∈ cs. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c) ⟷ 
       (∃ C const. (∀ (r, c) ∈ set C. r &gt; 0 ∧ c ∈ cs)
         ∧ (∑ (r,c) ← C. Leqc (r *R lec_poly c) (r *R lec_const c)) = Leqc 0 const
         ∧ const &lt; 0)"</span></span></span><span> 
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ cs"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>only_non_strict</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel c = Leq_Rel"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ p const. c = Leqc p const"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>leqc</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lhs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃C const rel.
       (∀(r, c)∈set C. 0 &lt; r ∧ c ∈ cs) ∧
       (∑(r, c)←C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) 
           = Le_Constraint rel 0 const ∧
       (rel = Leq_Rel ∧ const &lt; 0 ∨ rel = Lt_Rel ∧ const ≤ 0)"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Motzkin's_transposition_theorem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span>const</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ r c. (r, c)∈set C ⟹ 0 &lt; r ∧ c ∈ cs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(r, c)←C. Leqc (r *R lec_poly c) (r *R lec_const c)) = Leqc 0 const"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"const &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?lhs</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>const</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>Leq_Rel</span><span class="delimiter">]</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (r,c) ∈ set C. 0 &lt; r ∧ c ∈ cs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(r, c)← C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) =
        Leqc 0 const"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sum_list</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>map_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>leqc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>const</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span>const</span><span> </span><span>rel</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ r c. (r, c)∈set C ⟹ 0 &lt; r ∧ c ∈ cs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(r, c)←C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) 
        = Le_Constraint rel 0 const"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel = Leq_Rel ∧ const &lt; 0 ∨ rel = Lt_Rel ∧ const ≤ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(r, c)←C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) = 
          (∑(r, c)←C. Leqc (r *R lec_poly c) (r *R lec_const c))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_  = ?sum"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sum_list</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>map_cong</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>leqc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel ?sum = Leq_Rel"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_list_lec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_list_Leq_Rel</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>sum</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel = Leq_Rel"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>const</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"const &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>const</span><span class="delimiter">]</span><span> </span><span>conjI</span><span> </span><span>const</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>sum</span><span> </span><span>id</span><span> </span><span>C</span><span> </span><span>rel</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We also present slightly modified versions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_list_map_filter_sum</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b :: comm_monoid_add"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map f (filter g xs)) + sum_list (map f (filter (Not o g) xs)) = sum_list (map f xs)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A version where every constraint obtains exactly one coefficient and where 0 coefficients are allowed.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Farkas'_Lemma_set_sum</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>cs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat le_constraint set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>only_non_strict</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel ` cs ⊆ {Leq_Rel}"</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite cs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∄ v. ∀ c ∈ cs. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c) ⟷ 
       (∃ C const. (∀ c ∈ cs. C c ≥ 0)
         ∧ (∑ c ∈ cs. Leqc ((C c) *R lec_poly c) ((C c) *R lec_const c)) = Leqc 0 const
         ∧ const &lt; 0)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Farkas'_Lemma</span><span class="delimiter">[</span><span>OF</span><span> </span><span>only_non_strict</span><span> </span><span>fin</span><span class="delimiter">]</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>standard</span><span class="delimiter">;</span><span> </span><span>elim</span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>C</span><span> </span><span>const</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite_distinct_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>csl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>csl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set csl = cs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct csl"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?list</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"filter (λ c. C c ≠ 0) csl"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?C</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λ c. (C c, c)) ?list"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?C</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>const</span><span class="delimiter">]</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(r, c)←?C. Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c))
      = (∑(r, c)←map (λc. (C c, c)) csl. Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>map_map</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_list_map_filter</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zero_le_constraint_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = Le_Constraint Leq_Rel 0 const"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>csl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum.distinct_set_conv_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dist</span><span class="delimiter">]</span><span> </span><span>map_map</span><span> </span><span>o_def</span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(r, c)←?C. Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c)) = Le_Constraint Leq_Rel 0 const"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"const &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(r, c)∈set ?C. 0 &lt; r ∧ c ∈ cs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_map</span><span> </span><span>set_filter</span><span> </span><span>csl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>C</span><span> </span><span>const</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>CC</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CC = (λ c. sum_list (map fst (filter (λ rc. snd rc = c) C)))"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ C const. (∀ c ∈ cs. C c ≥ 0)
         ∧ (∑ c ∈ cs. Leqc ((C c) *R lec_poly c) ((C c) *R lec_const c)) = Leqc 0 const
         ∧ const &lt; 0)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>CC</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>const</span><span class="delimiter">]</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀c∈cs. 0 ≤ CC c"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CC_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sum_list_nonneg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"const &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set C ⊆ cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑c∈cs. Le_Constraint Leq_Rel (CC c *R lec_poly c) (CC c *R lec_const c)) = Le_Constraint Leq_Rel 0 const"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fin</span><span> </span><span>snd</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CC_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>cs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>c</span><span> </span><span>cs</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?D</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"filter (Not ∘ (λrc. snd rc = c)) C"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set ?D ⊆ cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>*</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑a← ?D. case a of (r, c) ⇒ Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c)) = 
        (∑(r, c)←?D. Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum.insert</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_list_map_filter_sum</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ rc. snd rc = c"</span></span></span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(+)"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>*</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ xs. sum_list (map _ xs)"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>rc</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"rc"</span></span></span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd rc = c"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>field_simps</span><span> </span><span>scaleRat_left_distrib</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zero_le_constraint_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A version with indexed constraints, i.e., in particular where constraints may occur several
  times.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Farkas'_Lemma_indexed</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ rat le_constraint"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>only_non_strict</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel ` c ` Is ⊆ {Leq_Rel}"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite Is"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∄ v. ∀ i ∈ Is. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c i) ⟷ 
       (∃ C const. (∀ i ∈ Is. C i ≥ 0)
         ∧ (∑ i ∈ Is. Leqc ((C i) *R lec_poly (c i)) ((C i) *R lec_const (c i))) = Leqc 0 const
         ∧ const &lt; 0)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?C</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ` Is"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ?C"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∄ v. ∀ i ∈ Is. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c i) = (∄ v. ∀ cc ∈ ?C. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> cc)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∃ C const. (∀ i ∈ Is. C i ≥ 0)
         ∧ (∑ i ∈ Is. Leqc ((C i) *R lec_poly (c i)) ((C i) *R lec_const (c i))) = Leqc 0 const
         ∧ const &lt; 0)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l = ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?r</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span>const</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ i ∈ Is. C i ≥ 0)"</span></span></span><span> 
</span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑ i ∈ Is. Leqc ((C i) *R lec_poly (c i)) ((C i) *R lec_const (c i))) = Leqc 0 const"</span></span></span><span> 
</span><span>         </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"const &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite_distinct_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`finite Is`</span></span></span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Isl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>isl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set Isl = Is"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct Isl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?CC</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"filter (λ rc. fst rc ≠ 0) (map (λ i. (C i, c i)) Isl)"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?l</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Farkas'_Lemma</span><span class="delimiter">[</span><span>OF</span><span> </span><span>only_non_strict</span><span> </span><span>fin</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?CC</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>const</span><span class="delimiter">]</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"const &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (r, ca) ∈ set ?CC. 0 &lt; r ∧ ca ∈ ?C"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>isl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(r, c)←?CC. Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c)) =
        Le_Constraint Leq_Rel 0 const"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_list_map_filter</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zero_le_constraint_def</span><span class="delimiter">,</span><span>
</span><span>          </span><span>unfold</span><span> </span><span>map_map</span><span> </span><span>o_def</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>sum_list_distinct_conv_sum_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dist</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?l</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Farkas'_Lemma_set_sum</span><span class="delimiter">[</span><span>OF</span><span> </span><span>only_non_strict</span><span> </span><span>fin</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span>const</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀c∈ ?C. 0 ≤ C c)"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑c∈ ?C. Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =
        Le_Constraint Leq_Rel 0 const"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"const &lt; 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>I</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I = (λ i. (C (c i) / rat_of_nat (card (Is ∩ { j. c i = c j}))))"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?r</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>I</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>const</span><span class="delimiter">]</span><span> </span><span>conjI</span><span> </span><span>const</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ Is. 0 ≤ I i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nonneg</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑ i ∈ Is. Le_Constraint Leq_Rel (I i *R lec_poly (c i)) (I i *R lec_const (c i))) =
        Le_Constraint Leq_Rel 0 const"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum.image_gen</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite Is›</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>c</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>cc</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>II</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"II = (Is ∩ {j. cc = c j})"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"II ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>II_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finII</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite II"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite Is›</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>II_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card II ≠ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?C</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ II. rat_of_nat (card II)"</span></span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ii</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ii = C cc / rat_of_nat (card II)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈{x ∈ Is. c x = cc}. Le_Constraint Leq_Rel (I i *R lec_poly (c i)) (I i *R lec_const (c i)))
          = (∑ i∈ II. Le_Constraint Leq_Rel (ii *R lec_poly cc) (ii *R lec_const cc))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>I_def</span><span> </span><span>ii_def</span><span> </span><span>II_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = Le_Constraint Leq_Rel ((?C II * ii) *R lec_poly cc) ((?C II * ii) *R lec_const cc)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finII</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>II</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zero_le_constraint_def</span><span> </span><span>field_simps</span><span>
</span><span>            </span><span>scaleRat_left_distrib</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C II * ii = C cc"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ii_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Matrix_Farkas">
<div class="head"><h1>Theory Matrix_Farkas</h1>
<span class="command">theory</span> <span class="name">Matrix_Farkas</span><br/>
<span class="keyword">imports</span> <a href="Farkas.html"><span class="name">Farkas</span></a> <a href="Matrix.html"><span class="name">Matrix</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: R. Thiemann *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Farkas Lemma for Matrices›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In this part we convert the simplex-structures like linear polynomials, etc., into
  equivalent formulations using matrices and vectors. As a result we present Farkas' Lemma
  via matrices and vectors.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Matrix_Farkas</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Farkas</span><span>
</span><span>  </span><span>Jordan_Normal_Form.Matrix</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>poly_of_vec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat vec ⇒ linear_poly"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"λ v x. if (x &lt; dim_vec v) then v $ x else 0"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>val_of_vec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat vec ⇒ rat valuation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"val_of_vec v x = v $ x"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valuate_poly_of_vec</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w ∈ carrier_vec n"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ carrier_vec n"</span></span></span><span>  
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valuate (poly_of_vec v) (val_of_vec w) = v ∙ w"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>val_of_vec_def</span><span> </span><span>scalar_prod_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sum.mono_neutral_left</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>constraints_of_mat_vec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat mat ⇒ rat vec ⇒ rat le_constraint set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"constraints_of_mat_vec A b = (λ i . Leqc (poly_of_vec (row A i)) (b $ i)) ` {0 ..&lt; dim_row A}"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>constraints_of_mat_vec_solution_main</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ carrier_mat nr nc"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier_vec nc"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ carrier_vec nr"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A *<span class="hidden">⇩</span><sub>v</sub> x ≤ b"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ constraints_of_mat_vec A b"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val_of_vec x ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>constraints_of_mat_vec_def</span><span class="delimiter">]</span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; nr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c = Leqc (poly_of_vec (row A i)) (b $ i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ri</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"row A i ∈ carrier_vec nc"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sol</span><span> </span><span>i</span><span> </span><span>A</span><span> </span><span>x</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A *<span class="hidden">⇩</span><sub>v</sub> x) $ i ≤ b $ i"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_eq_vec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val_of_vec x ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c</span><span> </span><span>satisfiable_le_constraint.simps</span><span> </span><span>rel_of.simps</span><span>
</span><span>      </span><span>valuate_poly_of_vec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span> </span><span>ri</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span>x</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_poly_of_vec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars (poly_of_vec v) ⊆ { 0 ..&lt; dim_vec v}"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>transfer'</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_constraints_of_mat_vec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (constraints_of_mat_vec A b)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>constraints_of_mat_vec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lec_rec_constraints_of_mat_vec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lec_rel ` constraints_of_mat_vec A b ⊆ {Leq_Rel}"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>constraints_of_mat_vec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>constraints_of_mat_vec_solution_1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ carrier_mat nr nc"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ carrier_vec nr"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ x ∈ carrier_vec nc. A *<span class="hidden">⇩</span><sub>v</sub> x ≤ b"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ v. ∀ c ∈ constraints_of_mat_vec A b. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>constraints_of_mat_vec_solution_main</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span> </span><span>_</span><span> </span><span>b</span><span> </span><span>_</span><span class="delimiter">]</span><span> </span><span>sol</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>constraints_of_mat_vec_solution_2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ carrier_mat nr nc"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ carrier_vec nr"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ v. ∀ c ∈ constraints_of_mat_vec A b. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ x ∈ carrier_vec nc. A *<span class="hidden">⇩</span><sub>v</sub> x ≤ b"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sol</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ constraints_of_mat_vec A b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = vec nc (λ i. v i)"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier_vec nc"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"row A i ∙ x ≤ b $ i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; nr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Leqc (poly_of_vec (row A i)) (b $ i) ∈ constraints_of_mat_vec A b"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>constraints_of_mat_vec_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sol</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valuate (poly_of_vec (row A i)) v ≤ b $ i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valuate (poly_of_vec (row A i)) v = valuate (poly_of_vec (row A i)) (val_of_vec x)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valuate_depend</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>A</span><span> </span><span>that</span><span class="delimiter">,</span><span> 
</span><span>          </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>x_def</span><span> </span><span>val_of_vec_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>set_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vars_poly_of_vec</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = row A i ∙ x"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>valuate_poly_of_vec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>that</span><span> </span><span>A</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A *<span class="hidden">⇩</span><sub>v</sub> x ≤ b"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_eq_vec_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>A</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>constraints_of_mat_vec_solution</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ carrier_mat nr nc"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ carrier_vec nr"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ x ∈ carrier_vec nc. A *<span class="hidden">⇩</span><sub>v</sub> x ≤ b) = 
    (∃ v. ∀ c ∈ constraints_of_mat_vec A b. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>constraints_of_mat_vec_solution_1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>constraints_of_mat_vec_solution_2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_lemma_matrix</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat mat"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ carrier_mat nr nc"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ carrier_vec nr"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ x ∈ carrier_vec nc. A *<span class="hidden">⇩</span><sub>v</sub> x ≤ b) ⟷ 
  (∀ y. y ≥ 0<span class="hidden">⇩</span><sub>v</sub> nr ⟶ mat_of_row y * A = 0<span class="hidden">⇩</span><sub>m</sub> 1 nc ⟶ y ∙ b ≥ 0)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cs = constraints_of_mat_vec A b"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {0 ..&lt; nr}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dim</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dim_row A = nr"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sum_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑ i = 0..&lt;nr. f i) = sum_list (map f [0..&lt;nr])"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_list_distinct_conv_sum_set</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ x ∈ carrier_vec nc. A *<span class="hidden">⇩</span><sub>v</sub> x ≤ b) =
   (¬ (∄ v. ∀ c ∈ cs. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> c))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>constraints_of_mat_vec_solution</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>cs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (¬ (∄v. ∀i∈{0..&lt;nr}. v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> Le_Constraint Leq_Rel (poly_of_vec (row A i)) (b $ i)))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cs_def</span><span> </span><span>constraints_of_mat_vec_def</span><span> </span><span>dim</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∄C.
        (∀i∈{0..&lt;nr}. 0 ≤ C i) ∧
         (∑i = 0..&lt;nr. (C i *R poly_of_vec (row A i))) = 0 ∧
         (∑i = 0..&lt;nr. (C i * b $ i)) &lt; 0)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Farkas'_Lemma_indexed</span><span class="delimiter">[</span><span>OF</span><span> 
</span><span>        </span><span>lec_rec_constraints_of_mat_vec</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>constraints_of_mat_vec_def</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>A</span><span> </span><span>b</span><span class="delimiter">,</span><span>
</span><span>        </span><span>unfolded</span><span> </span><span>dim</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>fin</span><span class="delimiter">]</span><span> </span><span>sum_id</span><span> </span><span>sum_list_lec</span><span> </span><span>le_constraint.simps</span><span> 
</span><span>        </span><span>sum_list_Leq_Rel</span><span> </span><span>map_map</span><span> </span><span>o_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_id</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀ C. (∀i∈ {0..&lt;nr}. 0 ≤ C i) ⟶ 
         (∑i = 0..&lt;nr. (C i *R poly_of_vec (row A i))) = 0 ⟶
         (∑i = 0..&lt;nr. (C i * b $ i)) ≥ 0)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀ y. y ≥ 0<span class="hidden">⇩</span><sub>v</sub> nr ⟶ mat_of_row y * A = 0<span class="hidden">⇩</span><sub>m</sub> 1 nc ⟶ y ∙ b ≥ 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>standard</span><span class="delimiter">;</span><span> </span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C = (λ i. y $ i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>main</span><span> </span><span class="delimiter">=</span><span> </span><span>*</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>C</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>*</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier_vec nr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ∈ {0..&lt;nr} ⟹ 0 ≤ C i"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_eq_vec_def</span><span> </span><span>C_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sum_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i = 0..&lt;nr. C i *R poly_of_vec (row A i)) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>zero_coeff_zero</span><span> </span><span>coeff_sum</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i = 0..&lt;nr. coeff (y $ i *R poly_of_vec (row A i)) v) = 
            (∑i &lt; nr. y $ i * coeff (poly_of_vec (row A i)) v)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"v &lt; nc"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i &lt; nr. y $ i * coeff (poly_of_vec (row A i)) v) = 
              (∑i &lt; nr. y $ i * 0)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ x. _ * x"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>A</span><span> </span><span>False</span><span class="delimiter">,</span><span> </span><span>transfer</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i&lt;nr. y $ i * coeff (poly_of_vec (row A i)) v) =
              (∑i&lt;nr. y $ i * row A i $ v)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ x. _ * x"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>A</span><span> </span><span>True</span><span class="delimiter">,</span><span> </span><span>transfer</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (mat_of_row y * A) $$ (0,v)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>times_mat_def</span><span> </span><span>scalar_prod_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span>y</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>*</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i = 0..&lt;nr. coeff (y $ i *R poly_of_vec (row A i)) v) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>main</span><span class="delimiter">[</span><span>OF</span><span> </span><span>nonneg</span><span> </span><span>sum_0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (∑i = 0..&lt;nr. C i * b $ i)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span>C_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = vec nr C"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier_vec nr"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>y_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>main</span><span> </span><span class="delimiter">=</span><span> </span><span>*</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>y</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>*</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≥ 0<span class="hidden">⇩</span><sub>v</sub> nr"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>less_eq_vec_def</span><span> </span><span>y_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>prod0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mat_of_row y * A = 0<span class="hidden">⇩</span><sub>m</sub> 1 nc"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; nc"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ x. coeff x j"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>coeff_sum</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 = (∑i = 0..&lt;nr. C i * coeff (poly_of_vec (row A i)) j)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑i = 0..&lt;nr. C i * row A i $ j)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ x. _ * x"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>A</span><span> </span><span>j</span><span class="delimiter">,</span><span> </span><span>transfer</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = y ∙ col A j"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span>y_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span>j</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>sum.cong</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∙ col A j = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>eq_matI</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>A</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>main</span><span class="delimiter">[</span><span>OF</span><span> </span><span>y0</span><span> </span><span>prod0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ y ∙ b"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>scalar_prod_def</span><span> </span><span>y_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>farkas_lemma_matrix'</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat mat"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ carrier_mat nr nc"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ carrier_vec nr"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ x ≥ 0<span class="hidden">⇩</span><sub>v</sub> nc. A *<span class="hidden">⇩</span><sub>v</sub> x = b) ⟷ 
  (∀ y ∈ carrier_vec nr. mat_of_row y * A ≥ 0<span class="hidden">⇩</span><sub>m</sub> 1 nc ⟶ y ∙ b ≥ 0)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B = (- 1<span class="hidden">⇩</span><sub>m</sub> nc) @<span class="hidden">⇩</span><sub>r</sub> (A @<span class="hidden">⇩</span><sub>r</sub> -A)"</span></span></span><span>   
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>b'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b' = 0<span class="hidden">⇩</span><sub>v</sub> nc @<span class="hidden">⇩</span><sub>v</sub> (b @<span class="hidden">⇩</span><sub>v</sub> -b)"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = nc + (nr + nr)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>id0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0<span class="hidden">⇩</span><sub>v</sub> (nc + (nr + nr)) = 0<span class="hidden">⇩</span><sub>v</sub> nc @<span class="hidden">⇩</span><sub>v</sub> (0<span class="hidden">⇩</span><sub>v</sub> nr @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> nr)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>eq_vecI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ carrier_mat n nc"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>B_def</span><span> </span><span>n_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b' ∈ carrier_vec n"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b'_def</span><span> </span><span>n_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ x ≥ 0<span class="hidden">⇩</span><sub>v</sub> nc. A *<span class="hidden">⇩</span><sub>v</sub> x = b) = (∃ x. x ∈ carrier_vec nc ∧ x ≥ 0<span class="hidden">⇩</span><sub>v</sub> nc ∧ A *<span class="hidden">⇩</span><sub>v</sub> x = b)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>Ex</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>A</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_eq_vec_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∃ x ∈ carrier_vec nc. x ≥ 0<span class="hidden">⇩</span><sub>v</sub> nc ∧ A *<span class="hidden">⇩</span><sub>v</sub> x = b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∃ x ∈ carrier_vec nc. 1<span class="hidden">⇩</span><sub>m</sub> nc *<span class="hidden">⇩</span><sub>v</sub> x ≥ 0<span class="hidden">⇩</span><sub>v</sub> nc ∧ A *<span class="hidden">⇩</span><sub>v</sub> x ≤ b ∧ A *<span class="hidden">⇩</span><sub>v</sub> x ≥ b)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bex_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>A</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∃ x ∈ carrier_vec nc. (- 1<span class="hidden">⇩</span><sub>m</sub> nc) *<span class="hidden">⇩</span><sub>v</sub> x ≤ 0<span class="hidden">⇩</span><sub>v</sub> nc ∧ A *<span class="hidden">⇩</span><sub>v</sub> x ≤ b ∧ (- A) *<span class="hidden">⇩</span><sub>v</sub> x ≤ -b)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bex_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>A</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_eq_vec_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∃ x ∈ carrier_vec nc. B *<span class="hidden">⇩</span><sub>v</sub> x ≤ b')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bex_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>A</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>B_def</span><span> </span><span>b'_def</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>subst</span><span> </span><span>append_rows_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conj_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>append_rows_le</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀y≥0<span class="hidden">⇩</span><sub>v</sub> n. mat_of_row y * B = 0<span class="hidden">⇩</span><sub>m</sub> 1 nc ⟶ y ∙ b' ≥ 0)"</span></span></span><span>   
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>farkas_lemma_matrix</span><span class="delimiter">[</span><span>OF</span><span> </span><span>B</span><span> </span><span>b'</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀ y. y ∈ carrier_vec n ⟶ y≥0<span class="hidden">⇩</span><sub>v</sub> n ⟶ mat_of_row y * B = 0<span class="hidden">⇩</span><sub>m</sub> 1 nc ⟶ y ∙ b' ≥ 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>All</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_eq_vec_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀ y ∈ carrier_vec n. y≥0<span class="hidden">⇩</span><sub>v</sub> n ⟶ mat_of_row y * B = 0<span class="hidden">⇩</span><sub>m</sub> 1 nc ⟶ y ∙ b' ≥ 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀y1 ∈carrier_vec nc. ∀y2 ∈carrier_vec nr. ∀y3 ∈carrier_vec nr.
              0<span class="hidden">⇩</span><sub>v</sub> nc @<span class="hidden">⇩</span><sub>v</sub> (0<span class="hidden">⇩</span><sub>v</sub> nr @<span class="hidden">⇩</span><sub>v</sub> 0<span class="hidden">⇩</span><sub>v</sub> nr) ≤ y1 @<span class="hidden">⇩</span><sub>v</sub> y2 @<span class="hidden">⇩</span><sub>v</sub> y3  ⟶
              mat_of_row (y1 @<span class="hidden">⇩</span><sub>v</sub> y2 @<span class="hidden">⇩</span><sub>v</sub> y3) * ((- 1<span class="hidden">⇩</span><sub>m</sub> nc) @<span class="hidden">⇩</span><sub>r</sub> (A @<span class="hidden">⇩</span><sub>r</sub> -A)) = 0<span class="hidden">⇩</span><sub>m</sub> 1 nc 
              ⟶ 0 ≤ (y1 @<span class="hidden">⇩</span><sub>v</sub> y2 @<span class="hidden">⇩</span><sub>v</sub> y3) ∙ (0<span class="hidden">⇩</span><sub>v</sub> nc @<span class="hidden">⇩</span><sub>v</sub> (b @<span class="hidden">⇩</span><sub>v</sub> -b)))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span> </span><span>all_vec_append</span><span> </span><span>id0</span><span> </span><span>b'_def</span><span> </span><span>B_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀y1 ∈carrier_vec nc. ∀y2 ∈carrier_vec nr. ∀y3 ∈carrier_vec nr.
              0<span class="hidden">⇩</span><sub>v</sub> nc ≤ y1 ⟶ 0<span class="hidden">⇩</span><sub>v</sub> nr ≤ y2 ⟶ 0<span class="hidden">⇩</span><sub>v</sub> nr ≤ y3 ⟶
              (- mat_of_row y1) + 
              (mat_of_row y2 * A - (mat_of_row y3 * A)) = 0<span class="hidden">⇩</span><sub>m</sub> 1 nc 
              ⟶ y2 ∙ b - y3 ∙ b ≥ 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ball_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>append_vec_le</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>append_vec_le</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>A</span><span> </span><span>b</span><span class="delimiter">,</span><span>
</span><span>      </span><span>subst</span><span> </span><span>scalar_prod_append</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>scalar_prod_append</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>subst</span><span> </span><span>mat_of_row_mult_append_rows</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>      </span><span>subst</span><span> </span><span>mat_of_row_mult_append_rows</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>      </span><span>subst</span><span> </span><span>add_uminus_minus_mat</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀y1 ∈carrier_vec nc. ∀y2 ∈carrier_vec nr. ∀y3 ∈carrier_vec nr.
              0<span class="hidden">⇩</span><sub>v</sub> nc ≤ y1 ⟶ 0<span class="hidden">⇩</span><sub>v</sub> nr ≤ y2 ⟶ 0<span class="hidden">⇩</span><sub>v</sub> nr ≤ y3 ⟶
              mat_of_row y1 = mat_of_row y2 * A - mat_of_row y3 * A
              ⟶ y2 ∙ b - y3 ∙ b ≥ 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>intro</span><span> </span><span>ball_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⟶)"</span></span></span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>standard</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>y1</span><span> </span><span>y2</span><span> </span><span>y3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ x. mat_of_row y1 + x"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span>-</span><span>3</span><span class="delimiter">)</span><span> </span><span>A</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>assoc_add_mat</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>        </span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>add_uminus_minus_mat</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>        </span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>minus_r_inv_mat</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span>
</span><span>        </span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>right_add_zero_mat</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span>
</span><span>        </span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>left_add_zero_mat</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>y1</span><span> </span><span>y2</span><span> </span><span>y3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>1</span><span>-</span><span>3</span><span class="delimiter">)</span><span> </span><span>A</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>eq_matI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀y1 ∈carrier_vec nc. ∀y2 ∈carrier_vec nr. ∀y3 ∈carrier_vec nr.
              0<span class="hidden">⇩</span><sub>v</sub> nc ≤ y1 ⟶ 0<span class="hidden">⇩</span><sub>v</sub> nr ≤ y2 ⟶ 0<span class="hidden">⇩</span><sub>v</sub> nr ≤ y3 ⟶
              mat_of_row y1 = mat_of_row (y2 - y3) * A
              ⟶ (y2 - y3) ∙ b ≥ 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ball_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>imp_cong</span><span> </span><span>refl</span><span> 
</span><span>      </span><span>arg_cong2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span class="delimiter">]</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(=)"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>      </span><span>subst</span><span> </span><span>minus_mult_distrib_mat</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>A</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minus_scalar_prod_distrib</span><span> </span><span>mat_of_rows_def</span><span> 
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ x. x * _"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀y1 ∈carrier_vec nc. ∀y2 ∈carrier_vec nr. ∀y3 ∈carrier_vec nr.
              0<span class="hidden">⇩</span><sub>v</sub> nc ≤ y1 ⟶ 0<span class="hidden">⇩</span><sub>v</sub> nr ≤ y2 ⟶ 0<span class="hidden">⇩</span><sub>v</sub> nr ≤ y3 ⟶
              y1 = row (mat_of_row (y2 - y3) * A) 0
              ⟶ (y2 - y3) ∙ b ≥ 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ball_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⟶)"</span></span></span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>standard</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>y1</span><span> </span><span>y2</span><span> </span><span>y3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ x. row x 0"</span></span></span><span class="delimiter">]</span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span>-</span><span>3</span><span class="delimiter">)</span><span> </span><span>A</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀y2 ∈carrier_vec nr. ∀y3 ∈carrier_vec nr.
              0<span class="hidden">⇩</span><sub>v</sub> nc ≤ row (mat_of_row (y2 - y3) * A) 0 ⟶ 0<span class="hidden">⇩</span><sub>v</sub> nr ≤ y2 ⟶ 0<span class="hidden">⇩</span><sub>v</sub> nr ≤ y3 ⟶
              row (mat_of_row (y2 - y3) * A) 0 ∈ carrier_vec nc
              ⟶ (y2 - y3) ∙ b ≥ 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀y2 ∈carrier_vec nr. ∀y3 ∈carrier_vec nr.
              0<span class="hidden">⇩</span><sub>v</sub> nc ≤ row (mat_of_row (y2 - y3) * A) 0 ⟶ 0<span class="hidden">⇩</span><sub>v</sub> nr ≤ y2 ⟶ 0<span class="hidden">⇩</span><sub>v</sub> nr ≤ y3 
              ⟶ (y2 - y3) ∙ b ≥ 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ball_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⟶)"</span></span></span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>A</span><span class="delimiter">,</span><span>
</span><span>        </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>row_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀ y ∈ carrier_vec nr. row (mat_of_row y * A) 0 ≥ 0<span class="hidden">⇩</span><sub>v</sub> nc ⟶ y ∙ b ≥ 0)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>standard</span><span class="delimiter">;</span><span> </span><span>intro</span><span> </span><span>ballI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>y2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y2 = vec nr (λ i. if y $ i ≥ 0 then y $ i else 0)"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>y3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y3 = vec nr (λ i. if y $ i ≥ 0 then 0 else - y $ i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y = y2 - y3"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>y2_def</span><span> </span><span>y3_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>eq_vecI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>y2</span><span> </span><span>y3</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>       </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>y2_def</span><span> </span><span>y3_def</span><span> </span><span>less_eq_vec_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∀ y ∈ carrier_vec nr. mat_of_row y * A ≥ 0<span class="hidden">⇩</span><sub>m</sub> 1 nc ⟶ y ∙ b ≥ 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ball_cong</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⟶)"</span></span></span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">,</span><span>
</span><span>      </span><span>insert</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_eq_vec_def</span><span> </span><span>less_eq_mat_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Simplex_for_Reals">
<div class="head"><h1>Theory Simplex_for_Reals</h1>
<span class="command">theory</span> <span class="name">Simplex_for_Reals</span><br/>
<span class="keyword">imports</span> <a href="Farkas.html"><span class="name">Farkas</span></a> <a href="../Simplex/Simplex_Incremental.html"><span class="name">Simplex_Incremental</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: R. Thiemann *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Unsatisfiability over the Reals›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹By using Farkas' Lemma we prove that a finite set of 
  linear rational inequalities is satisfiable over the rational numbers
  if and only if it is satisfiable over the real numbers.
  Hence, the simplex algorithm either gives a rational solution or
  shows unsatisfiability over the real numbers.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Simplex_for_Reals</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>    </span><span>Farkas</span><span>
</span><span>    </span><span>Simplex.Simplex_Incremental</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>real</span><span> </span><span class="delimiter">::</span><span> </span><span>lrv</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>scaleRat_real</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat ⇒ real ⇒ real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x *R y = real_of_rat x * y"</span></span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>field_simps</span><span> </span><span>of_rat_mult</span><span> </span><span>of_rat_add</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>real_satisfies_constraints</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real valuation ⇒ constraint set ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub>"</span></span></span><span> </span><span>100</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs ≡ ∀ c ∈ cs. v ⊨<span class="hidden">⇩</span><sub>c</sub> c"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>of_rat_val</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat valuation ⇒ real valuation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"of_rat_val v x = of_rat (v x)"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_rat_val_eval</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⦃of_rat_val v⦄ = of_rat (p ⦃v⦄)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>of_rat_val_def</span><span> </span><span>linear_poly_sum</span><span> </span><span>of_rat_sum</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.cong</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>of_rat_mult</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_rat_val_constraint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_rat_val v ⊨<span class="hidden">⇩</span><sub>c</sub> c ⟷ v ⊨<span class="hidden">⇩</span><sub>c</sub> c"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>of_rat_val_eval</span><span> </span><span>of_rat_less</span><span> </span><span>of_rat_less_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_rat_val_constraints</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_rat_val v ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs ⟷ v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>of_rat_val_constraint</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sat_scale_rat_real</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v :: real valuation) ⊨<span class="hidden">⇩</span><sub>c</sub> c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub> (r *R c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r &lt; 0 ∨ r = 0 ∨ r &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>right_diff_distrib</span><span> 
</span><span>        </span><span>valuate_minus</span><span> </span><span>valuate_scaleRat</span><span> </span><span>scaleRat_leq1</span><span> </span><span>scaleRat_leq2</span><span> </span><span>valuate_zero</span><span>
</span><span>        </span><span>of_rat_less</span><span> </span><span>of_rat_mult</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>of_rat_lec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"rat le_constraint ⇒ real le_constraint"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"of_rat_lec (Le_Constraint r p c) = Le_Constraint r p (of_rat c)"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lec_of_constraint_real</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_le c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> of_rat_lec (lec_of_constraint c)) ⟷ (v ⊨<span class="hidden">⇩</span><sub>c</sub> c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_rat_lec_add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_rat_lec (c + d) = of_rat_lec c + of_rat_lec d"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>d</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>of_rat_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_rat_lec_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_rat_lec 0 = 0"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>zero_le_constraint_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_rat_lec_sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"of_rat_lec (sum_list c) = sum_list (map of_rat_lec c)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>of_rat_lec_zero</span><span> </span><span>of_rat_lec_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This is the main lemma: a finite set of linear constraints is 
  satisfiable over Q if and only if it is satisfiable over R.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rat_real_conversion</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite cs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ v :: rat valuation. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs) ⟷ (∃ v :: real valuation. v ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs ⟹ ∃v. v ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>of_rat_val_constraint</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃v. v ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>farkas_coefficients</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"farkas_coefficients cs C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>farkas_coefficients_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span>rel</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>isleq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀(r,c) ∈ set C. c ∈ cs ∧ is_le (r *R c) ∧ r ≠ 0)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑ (r,c) ← C. lec_of_constraint (r *R c)) = Le_Constraint rel 0 d"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>choice</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel = Lt_Rel ∧ d ≤ 0 ∨ rel = Leq_Rel ∧ d &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span>c</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(r,c) ∈ set C"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span> </span><span>*</span><span> </span><span>isleq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub> c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>c</sub> (r *R c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sat_scale_rat_real</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span> </span><span>isleq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_le (r *R c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lec_of_constraint_real</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>v</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> of_rat_lec (lec_of_constraint (r *R c))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>v</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Le_Constraint rel 0 (of_rat d) = of_rat_lec (∑ (r,c) ← C. lec_of_constraint (r *R c))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>leq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑ (r,c) ← C. of_rat_lec (lec_of_constraint (r *R c)))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?sum"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>of_rat_lec_sum</span><span> </span><span>map_map</span><span> </span><span>o_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>sum_list</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Le_Constraint rel 0 (of_rat d) = ?sum"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ⊨<span class="hidden">⇩</span><sub>l</sub><span class="hidden">⇩</span><sub>e</sub> Le_Constraint rel 0 (of_rat d)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>leq</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>satisfies_sumlist_le_constraints</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>v</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>choice</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>linear_poly_sum</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The main result of simplex, now using unsatisfiability over the reals.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>i_satisfies_cs_real</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub>"</span></span></span><span> </span><span>100</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(I,v) ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> cs ⟷ v ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> Simplex.restrict_to I cs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>simplex_index_real</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"simplex_index cs = Unsat I ⟹ set I ⊆ fst ` set cs ∧ ¬ (∃ v. (set I, v) ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set cs) ∧ 
     (distinct_indices cs ⟶ (∀ J ⊂ set I. (∃ v. (J, v) ⊨<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set cs)))"</span></span></span><span> </span><span class="comment">― ‹minimal unsat core over the reals›</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"simplex_index cs = Sat v ⟹ ⟨v⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> (snd ` set cs)"</span></span></span><span> </span><span class="comment">― ‹satisfying assingment›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simplex_index</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>I</span><span class="delimiter">]</span><span> </span><span>simplex_index</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>v</span><span class="delimiter">]</span><span> 
</span><span>    </span><span>rat_real_conversion</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Simplex.restrict_to (set I) (set cs)"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>simplex_real</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"simplex cs = Unsat I ⟹ ¬ (∃ v. v ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set cs)"</span></span></span><span> </span><span class="comment">― ‹unsat of original constraints over the reals›</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"simplex cs = Unsat I ⟹ set I ⊆ {0..&lt;length cs} ∧ ¬ (∃ v. v ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> {cs ! i | i. i ∈ set I})
    ∧ (∀J⊂set I. ∃v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> {cs ! i |i. i ∈ J})"</span></span></span><span> </span><span class="comment">― ‹minimal unsat core over reals›</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"simplex cs = Sat v ⟹ ⟨v⟩ ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set cs"</span></span></span><span>  </span><span class="comment">― ‹satisfying assignment over the rationals›</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>simplex</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>rat_real_conversion</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_set</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>unsat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"simplex cs = Inl I"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {cs ! i |i. i ∈ set I}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>simplex</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unsat</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>rat_real_conversion</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set I ⊆ {0..&lt;length cs} ∧ ¬ (∃ v. v ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> {cs ! i | i. i ∈ set I})
    ∧ (∀J⊂set I. ∃v. v ⊨<span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> {cs ! i |i. i ∈ J})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>simplex</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Define notion of minimal unsat core over the reals:
  the subset has to be unsat over the reals, and every proper subset has
  to be satisfiable over the rational numbers.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>minimal_unsat_core_real</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i set ⇒ 'i i_constraint list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"minimal_unsat_core_real I ics  = ((I ⊆ fst ` set ics) ∧ (¬ (∃ v. (I,v) ⊨<span class="hidden">⇩</span><sub>r</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set ics))
     ∧ (distinct_indices ics ⟶ (∀ J. J ⊂ I ⟶ (∃ v. (J,v) ⊨<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>c</sub><span class="hidden">⇩</span><sub>s</sub> set ics))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Because of equi-satisfiability the two notions of minimal unsat cores coincide.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minimal_unsat_core_real_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"minimal_unsat_core_real I ics = minimal_unsat_core I ics"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"minimal_unsat_core_real I ics ⟹ minimal_unsat_core I ics"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>minimal_unsat_core_real_def</span><span> </span><span>minimal_unsat_core_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>of_rat_val_constraint</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"minimal_unsat_core I ics"</span></span></span><span>     
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"minimal_unsat_core_real I ics"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>minimal_unsat_core_real_def</span><span> </span><span>minimal_unsat_core_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rat_real_conversion</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Simplex.restrict_to I (set ics)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Easy consequence: The incremental simplex algorithm is also sound wrt. 
  minimal-unsat-cores over the reals.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>incremental_simplex_real</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>init_simplex</span><span>
</span><span>  </span><span>assert_simplex_ok</span><span>
</span><span>  </span><span>assert_simplex_unsat</span><span class="delimiter">[</span><span>folded</span><span> </span><span>minimal_unsat_core_real_conv</span><span class="delimiter">]</span><span>
</span><span>  </span><span>assert_all_simplex_ok</span><span>
</span><span>  </span><span>assert_all_simplex_unsat</span><span class="delimiter">[</span><span>folded</span><span> </span><span>minimal_unsat_core_real_conv</span><span class="delimiter">]</span><span>
</span><span>  </span><span>check_simplex_ok</span><span>
</span><span>  </span><span>check_simplex_unsat</span><span class="delimiter">[</span><span>folded</span><span> </span><span>minimal_unsat_core_real_conv</span><span class="delimiter">]</span><span>
</span><span>  </span><span>solution_simplex</span><span>
</span><span>  </span><span>backtrack_simplex</span><span>
</span><span>  </span><span>checked_invariant_simplex</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div>