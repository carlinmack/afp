<div id="HOLCFUtils">
<div class="head">
<h1>Theory HOLCFUtils</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹HOLCF Utility lemmas›</span></span>
<span class="keyword1"><span class="command">theory</span></span> HOLCFUtils
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../../HOL/HOLCF/HOLCF.html"></a><a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> to define the denotational semantics. By default, HOLCF does not turn the regular <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>set›</span></span></span></span> type into a partial order, so this is done here. Some of the lemmas here are contributed by Brian Huffman.

We start by making the type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bool›</span></span></span></span> a pointed chain-complete partial order.
›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> bool <span class="main">::</span> <span class="quoted">po</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊑</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">unfold</span> below_bool_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">fast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instance</span></span> bool <span class="main">::</span> <span class="quoted">chfin</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> finite_range_imp_finch<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_chain_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">instance</span></span> bool <span class="main">::</span> <span class="quoted">pcpo</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> False <span class="main">⊑</span> <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> below_bool_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">::</span>bool<span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊑</span> <span class="bound">y</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> is_lub_bool<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">&lt;&lt;|</span> <span class="main">(</span>True <span class="main">∈</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_lub_def is_ub_def below_bool_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> lub_bool<span class="main">:</span> <span class="quoted"><span class="quoted">"lub <span class="free">S</span> <span class="main">=</span> <span class="main">(</span>True <span class="main">∈</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> is_lub_bool <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lub_eqI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bottom_eq_False<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span> <span class="main">=</span> False"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> below_antisym <span class="main"><span class="main">[</span></span><span class="operator">OF</span> minimal<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> below_bool_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
To convert between the squared syntax used by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../../HOL/HOLCF/HOLCF.html"></a><a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> and the regular, round syntax for sets, we state some of the equivalencies.
›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span> <span class="quoted">po</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⊑</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">unfold</span> below_set_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">fast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sqsubset_is_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> below_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> is_lub_set<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">&lt;&lt;|</span> <span class="main">⋃</span><span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_lub_def is_ub_def below_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>

<span class="keyword1"><span class="command">lemma</span></span> lub_is_union<span class="main">:</span> <span class="quoted"><span class="quoted">"lub <span class="free">S</span> <span class="main">=</span> <span class="main">⋃</span><span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> is_lub_set <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lub_eqI<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span> <span class="quoted">cpo</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">fast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> is_lub_set<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> emptyset_is_bot<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">⊑</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>sqsubset_is_subset<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span> <span class="quoted">pcpo</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">fast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> emptyset_is_bot<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bot_bool_is_emptyset<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> emptyset_is_bot <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> bottomI <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
To actually use these instance in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fixrec›</span></span></span></span> definitions or fixed-point inductions, we need continuity requrements for various boolean and set operations.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_disj <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> g<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">∨</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cont_apply <span class="main"><span class="main">[</span></span><span class="operator">OF</span> f<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> chfindom_monofun2cont<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> monofunI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> below_bool_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cont_compose <span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ g<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> chfindom_monofun2cont<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> monofunI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> below_bool_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_imp<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> g<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">⟶</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> imp_conv_disj <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cont2cont_disj<span class="main"><span class="main">[</span></span><span class="operator">OF</span> f g<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_Collect <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> contI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> cont2contlubE <span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_lub_def is_ub_def below_set_def lub_bool<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_mem <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cont_compose <span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> contI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_lub_def is_ub_def below_bool_def lub_is_union<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_union <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span>
<span class="main">⟹</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">∪</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Un_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_insert <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> insert <span class="free">y</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> insert_def <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic"><span class="dynamic">cont2cont</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> adm_subset <span class="main">=</span> adm_below<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'b</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>type set"</span></span><span class="main">,</span> <span class="operator">unfolded</span> sqsubset_is_subset<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_UNION<span class="main">[</span><span class="operator">cont2cont</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="free">f</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span> <span class="free">f</span> <span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> contI2<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> Mono Limit<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword3"><span class="command">case</span></span> Mono
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"monofun <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">f</span> <span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> monofunI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span>sqsubset_is_subset <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> monofunE<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">THEN</span> cont2mono<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span> monofunE<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">THEN</span> cont2mono<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Limit <span class="skolem">Y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">f</span> <span class="main">(</span><span class="main">⨆</span> <span class="bound">i</span><span class="main">.</span> <span class="skolem">Y</span> <span class="bound">i</span><span class="main">)</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="main">⨆</span> <span class="bound">j</span><span class="main">.</span> <span class="skolem">Y</span> <span class="bound">j</span><span class="main">)</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">⨆</span> <span class="bound">k</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">f</span> <span class="main">(</span><span class="skolem">Y</span> <span class="bound">k</span><span class="main">)</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="skolem">Y</span> <span class="bound">k</span><span class="main">)</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">f</span> <span class="main">(</span><span class="main">⨆</span> <span class="bound">i</span><span class="main">.</span> <span class="skolem">Y</span> <span class="bound">i</span><span class="main">)</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="main">⨆</span> <span class="bound">j</span><span class="main">.</span> <span class="skolem">Y</span> <span class="bound">j</span><span class="main">)</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">∈</span><span class="free">f</span> <span class="main">(</span><span class="main">⨆</span> <span class="bound">i</span><span class="main">.</span> <span class="skolem">Y</span> <span class="bound">i</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span> <span class="free">g</span> <span class="main">(</span><span class="main">⨆</span> <span class="bound">j</span><span class="main">.</span> <span class="skolem">Y</span> <span class="bound">j</span><span class="main">)</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⨆</span> <span class="bound">i</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Y</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span> <span class="main">(</span><span class="main">⨆</span> <span class="bound">j</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="skolem">Y</span> <span class="bound">j</span><span class="main">)</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cont2contlubE<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span> Limit<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span> cont2contlubE<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>2<span class="main"><span class="main"><span class="main">)</span></span></span> Limit<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> yi<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Y</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> xj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span> <span class="free">g</span> <span class="main">(</span><span class="skolem">Y</span> <span class="skolem">j</span><span class="main">)</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>lub_is_union<span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">≤</span><span class="skolem">k</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">≤</span><span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"max <span class="skolem">i</span> <span class="skolem">j</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> meta_allE<span class="main">)</span><span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> yi <span class="keyword2"><span class="keyword">and</span></span> xj <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Y</span> <span class="skolem">k</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span> <span class="free">g</span> <span class="main">(</span><span class="skolem">Y</span> <span class="skolem">k</span><span class="main">)</span> <span class="skolem">y</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> monofunE<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">THEN</span> cont2mono<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">OF</span> chain_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Limit<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">≤</span><span class="skolem">k</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
        <span class="keyword2"><span class="keyword">and</span></span> monofunE<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">THEN</span> cont2mono<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">OF</span> chain_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Limit<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span><span class="main">≤</span><span class="skolem">k</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>sqsubset_is_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">Y</span> <span class="skolem">k</span><span class="main">)</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="skolem">Y</span> <span class="skolem">k</span><span class="main">)</span> <span class="bound">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span> <span class="main">(</span><span class="main">⨆</span> <span class="bound">k</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">f</span> <span class="main">(</span><span class="skolem">Y</span> <span class="bound">k</span><span class="main">)</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span><span class="skolem">Y</span> <span class="bound">k</span><span class="main">)</span> <span class="bound">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>lub_is_union<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>sqsubset_is_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_Let_simple<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span> <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">t</span> <span class="keyword1">in</span> <span class="free">g</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Let_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">.</span></span>


<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_list <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f1</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f2</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_list <span class="main">(</span><span class="free">f1</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As with the continuity lemmas, we need admissibility lemmas.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> adm_not_mem<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"adm <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">y</span> <span class="main">∉</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> t <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="free">f</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> adm_subst<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> admI<span class="main">)</span>
<span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'b</span> set"</span></span>
<span class="keyword3"><span class="command">assume</span></span> chain<span class="main">:</span> <span class="quoted"><span class="quoted">"chain <span class="skolem">Y</span>"</span></span>
<span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="free">y</span> <span class="main">∉</span> <span class="skolem">Y</span> <span class="bound">i</span>"</span></span> <span class="keyword1"><span class="command">hence</span></span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⨆</span> <span class="bound">i</span><span class="main">.</span> <span class="free">y</span> <span class="main">∈</span> <span class="skolem">Y</span> <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∉</span> <span class="main">(</span><span class="main">⨆</span> <span class="bound">i</span><span class="main">.</span> <span class="skolem">Y</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> chain <span class="keyword1"><span class="command">unfolding</span></span> lub_bool lub_is_union <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> adm_id<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"adm <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="main">.</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> adm_chfin<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> adm_Not<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"adm Not"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> adm_chfin<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> adm_prod_split<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"adm <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>fst <span class="bound">p</span><span class="main">)</span> <span class="main">(</span>snd <span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"adm <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> split_def <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> adm_ball'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">y</span><span class="main">.</span> adm <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span> <span class="bound">x</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"adm <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">A</span> <span class="bound">x</span> <span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> Ball_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> adm_all<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> adm_not_conj<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>adm <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span> adm <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> adm <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="main">(</span><span class="free">P</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> adm_single_valued<span class="main">:</span>
 <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
 <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"adm <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> single_valued <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">unfolding</span></span> single_valued_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> adm_lemmas adm_not_mem <span class="dynamic"><span class="dynamic">cont2cont</span></span> adm_subst<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
To match Shivers' syntax we introduce the power-syntax for iterated function application.
›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">niceiterate</span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span>_<span class="keyword1"><span class="hidden">⇗</span><sup></sup></span>_<span class="keyword1"><span class="hidden">⇖</span></span><span class="keyword3">)</span>"</span> <span class="main">[</span>1000<span class="main">]</span> 1000<span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">niceiterate</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> iterate <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="CPSScheme">
<div class="head">
<h1>Theory CPSScheme</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Syntax"</span></span>

<span class="keyword1"><span class="command">theory</span></span> CPSScheme
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
First, we define the syntax tree of a program in our toy functional language, using continuation passing style, corresponding to section 3.2 in Shivers' dissertation.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We assume that the program to be investigated is already parsed into a syntax tree. Furthermore, we assume that distinct labels were added to distinguish different code positions and that the program has been alphatised, i.e. that each variable name is only bound once. This binding position is, as a convenience, considered part of the variable name.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> label <span class="main">=</span> <span class="quoted">nat</span>
<span class="keyword1"><span class="command">type_synonym</span></span> var <span class="main">=</span> <span class="quoted"><span class="quoted">"label <span class="main">×</span> string"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted">"<span class="entity">binder</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"var <span class="main">⇒</span> label"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">binder</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> fst <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The syntax consists now of lambda abstractions, call expressions and values, which can either be lambdas, variable references, constants or primitive operations. A program is a lambda expression.

Shivers' language has as the set of basic values integers plus a special value for \textit{false}. We simplified this to just the set of integers. The conditional <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>If›</span></span></span></span> considers zero as false and any other number as true.

Shivers also restricts the values in a call expression: No constant maybe be used as the called value, and no primitive operation may occur as an argument. This restriction is dropped here and just leads to runtime errors when evaluating the program.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> prim <span class="main">=</span> Plus <span class="quoted">label</span> <span class="main">|</span> If <span class="quoted">label</span> <span class="quoted">label</span>
<span class="keyword1"><span class="command">datatype</span></span> lambda <span class="main">=</span> Lambda <span class="quoted">label</span> <span class="quoted"><span class="quoted">"var list"</span></span> <span class="quoted">call</span>
     <span class="keyword2"><span class="keyword">and</span></span> call <span class="main">=</span> App <span class="quoted">label</span> <span class="quoted">val</span> <span class="quoted"><span class="quoted">"val list"</span></span>
              <span class="main">|</span> Let <span class="quoted">label</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list"</span></span> <span class="quoted">call</span>
     <span class="keyword2"><span class="keyword">and</span></span> val <span class="main">=</span> L <span class="quoted">lambda</span> <span class="main">|</span> R <span class="quoted">label</span> <span class="quoted">var</span> <span class="main">|</span> C <span class="quoted">label</span> <span class="quoted">int</span> <span class="main">|</span> P <span class="quoted">prim</span>

<span class="keyword1"><span class="command">datatype_compat</span></span> lambda call val

<span class="keyword1"><span class="command">type_synonym</span></span> prog <span class="main">=</span> <span class="quoted">lambda</span>

<span class="keyword1"><span class="command">lemmas</span></span> mutual_lambda_call_var_inducts <span class="main">=</span>
  compat_lambda.induct
  compat_call.induct
  compat_val.induct
  compat_val_list.induct
  compat_nat_char_list_prod_lambda_prod_list.induct
  compat_nat_char_list_prod_lambda_prod.induct

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Three example programs. These were generated using the Haskell implementation
of Shivers' algorithm that we wrote as a prototype\cite{HaskProto}.
›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">ex1</span> <span class="main">==</span> <span class="main">(</span>Lambda <span class="main">1</span> <span class="main">[</span><span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="inner_quoted">''cont''</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span>App <span class="numeral">2</span> <span class="main">(</span>R <span class="numeral">3</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="inner_quoted">''cont''</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span>C <span class="numeral">4</span> <span class="main">0</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">ex2</span> <span class="main">==</span> <span class="main">(</span>Lambda <span class="main">1</span> <span class="main">[</span><span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="inner_quoted">''cont''</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span>App <span class="numeral">2</span> <span class="main">(</span>P <span class="main">(</span>Plus <span class="numeral">3</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span>C <span class="numeral">4</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>C <span class="numeral">5</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>R <span class="numeral">6</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="inner_quoted">''cont''</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">ex3</span> <span class="main">==</span> <span class="main">(</span>Lambda <span class="main">1</span> <span class="main">[</span><span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="inner_quoted">''cont''</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span>Let <span class="numeral">2</span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="inner_quoted">''rec''</span><span class="main">)</span><span class="main">,</span><span class="main">(</span>Lambda <span class="numeral">3</span> <span class="main">[</span><span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="inner_quoted">''p''</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="inner_quoted">''i''</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="inner_quoted">''c_''</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span>App <span class="numeral">4</span> <span class="main">(</span>P <span class="main">(</span>If <span class="numeral">5</span> <span class="numeral">6</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span>R <span class="numeral">7</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="inner_quoted">''i''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>L <span class="main">(</span>Lambda <span class="numeral">8</span> <span class="main">[]</span> <span class="main">(</span>App <span class="numeral">9</span> <span class="main">(</span>P <span class="main">(</span>Plus <span class="numeral">10</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span>R <span class="numeral">11</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="inner_quoted">''p''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>R <span class="numeral">12</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="inner_quoted">''i''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>L <span class="main">(</span>Lambda <span class="numeral">13</span> <span class="main">[</span><span class="main">(</span><span class="numeral">13</span><span class="main">,</span><span class="inner_quoted">''p_''</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span>App <span class="numeral">14</span> <span class="main">(</span>P <span class="main">(</span>Plus <span class="numeral">15</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span>R <span class="numeral">16</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="inner_quoted">''i''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>C <span class="numeral">17</span> <span class="main">(</span><span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>L <span class="main">(</span>Lambda <span class="numeral">18</span> <span class="main">[</span><span class="main">(</span><span class="numeral">18</span><span class="main">,</span><span class="inner_quoted">''i_''</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span>App <span class="numeral">19</span> <span class="main">(</span>R <span class="numeral">20</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="inner_quoted">''rec''</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span>R <span class="numeral">21</span> <span class="main">(</span><span class="numeral">13</span><span class="main">,</span><span class="inner_quoted">''p_''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>R <span class="numeral">22</span> <span class="main">(</span><span class="numeral">18</span><span class="main">,</span><span class="inner_quoted">''i_''</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>R <span class="numeral">23</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="inner_quoted">''c_''</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>L <span class="main">(</span>Lambda <span class="numeral">24</span> <span class="main">[]</span> <span class="main">(</span>App <span class="numeral">25</span> <span class="main">(</span>R <span class="numeral">26</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="inner_quoted">''c_''</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span>R <span class="numeral">27</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="inner_quoted">''p''</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span>App <span class="numeral">28</span> <span class="main">(</span>R <span class="numeral">29</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="inner_quoted">''rec''</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span>C <span class="numeral">30</span> <span class="main">0</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>C <span class="numeral">31</span> <span class="numeral">10</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>R <span class="numeral">32</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="inner_quoted">''cont''</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
              
<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Eval">
<div class="head">
<h1>Theory Eval</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Standard semantics"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Eval
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a> <a href="HOLCFUtils.html">HOLCFUtils</a> <a href="CPSScheme.html">CPSScheme</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We begin by giving the standard semantics for our language. Although this is not actually used to show any results, it is helpful to see that the later algorithms ``look similar'' to the evaluation code and the relation between calls done during evaluation and calls recorded by the control flow graph.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We follow the definition in Figure 3.1 and 3.2 of Shivers' dissertation, with the clarifications from Section 4.1. As explained previously, our set of values encompasses just the integers, there is no separate value for \textit{false}. Also, values and procedures are not distinguished by the type system.

Due to recursion, one variable can have more than one currently valid binding, and due to closures all bindings can possibly be accessed. A simple call stack is therefore not sufficient. Instead we have a \textit{contour counter}, which is increased in each evaluation step. It can also be thought of as a time counter. The variable environment maps tuples of variables and contour counter to values, thus allowing a variable to have more than one active binding.  A contour environment lists the currently visible binding for each binding position and is preserved when a lambda expression is turned into a closure.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> contour <span class="main">=</span> <span class="quoted">nat</span>
<span class="keyword1"><span class="command">type_synonym</span></span> benv <span class="main">=</span> <span class="quoted"><span class="quoted">"label <span class="main">⇀</span> contour"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> closure <span class="main">=</span> <span class="quoted"><span class="quoted">"lambda <span class="main">×</span> benv"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The set of semantic values consist of the integers, closures, primitive operations and a special value <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Stop›</span></span></span></span>. This is passed as an argument to the program and represents the terminal continuation. When this value occurs in the first position of a call, the program terminates.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> d <span class="main">=</span> DI <span class="quoted">int</span>
           <span class="main">|</span> DC <span class="quoted">closure</span>
           <span class="main">|</span> DP <span class="quoted">prim</span>
           <span class="main">|</span> Stop

<span class="keyword1"><span class="command">type_synonym</span></span> venv <span class="main">=</span> <span class="quoted"><span class="quoted">"var <span class="main">×</span> contour <span class="main">⇀</span> d"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>𝒜›</span></span></span></span> evaluates a syntactic value into a semantic datum. Constants and primitive operations are left untouched. Variable references are resolved in two stages: First the current binding contour is fetched from the binding environment <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>β›</span></span></span></span>, then the stored value is fetched from the variable environment <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ve›</span></span></span></span>. A lambda expression is bundled with the current contour environment to form a closure.
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">evalV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"val <span class="main">⇒</span> benv <span class="main">⇒</span> venv <span class="main">⇒</span> d"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">𝒜</span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">𝒜</span></span> <span class="main">(</span>C <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span> DI <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>
  <span class="main">|</span>     <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">𝒜</span></span> <span class="main">(</span>P <span class="free"><span class="bound"><span class="entity">prim</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span> DP <span class="free"><span class="bound"><span class="entity">prim</span></span></span>"</span></span>
  <span class="main">|</span>     <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">𝒜</span></span> <span class="main">(</span>R <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">var</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span>
           <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="main">(</span>binder <span class="free"><span class="bound"><span class="entity">var</span></span></span><span class="main">)</span> <span class="keyword1">of</span>
              Some <span class="bound">l</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">var</span></span></span><span class="main">,</span><span class="bound">l</span><span class="main">)</span> <span class="keyword1">of</span> Some <span class="bound">d</span> <span class="main">⇒</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">|</span>     <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">𝒜</span></span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">lam</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span> DC <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lam</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The answer domain of our semantics is the set of integers, lifted to obtain an additional element denoting bottom. Shivers distinguishes runtime errors from non-termination. Here, both are represented by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⊥›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> ans <span class="main">=</span> <span class="quoted"><span class="quoted">"int lift"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
To be able to do case analysis on the custom datatypes <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lambda›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>d›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>call›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prim›</span></span></span></span> inside a function defined with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fixrec›</span></span></span></span>, we need continuity results for them. These are all of the same shape and proven by case analysis on the discriminator.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_lambda <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_lambda <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_d <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f1</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f2</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f3</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f4</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_d <span class="main">(</span><span class="free">f1</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f3</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f4</span> <span class="bound">x</span><span class="main">)</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_call <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f1</span> <span class="bound">x</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f2</span> <span class="bound">x</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_call <span class="main">(</span><span class="free">f1</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x</span><span class="main">)</span> <span class="free">c</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">c</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_prim <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f1</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f2</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_prim <span class="main">(</span><span class="free">f1</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
As usual, the semantics of a functional language is given as a denotational semantics. To that end, two functions are defined here: <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span> applies a procedure to a list of arguments. Here closures are unwrapped, the primitive operations are implemented and the terminal continuation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Stop›</span></span></span></span> is handled. <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>𝒞›</span></span></span></span> evaluates a call expression, either by evaluating procedure and arguments and passing them to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span>, or by adding the bindings of a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Let›</span></span></span></span> expression to the environment.

Note how the contour counter is incremented before each call to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span> or when a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Let›</span></span></span></span> expression is evaluated.

With mutually recursive equations, such as those given here, the existence of a function satisfying these is not obvious. Therefore, the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fixrec›</span></span></span></span> command from the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../../HOL/HOLCF/HOLCF.html"></a><a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> package is used. This takes a set of equations and builds a functional from that. It mechanically proofs that this functional is continuous and thus a least fixed point exists. This is then used to define <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>𝒞›</span></span></span></span> and proof the equations given here. To use the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../../HOL/HOLCF/HOLCF.html"></a><a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> setup, the continuous function arrow <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>→›</span></span></span></span> with application operator <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⋅›</span></span></span></span> is used and our types are wrapped in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>discr›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lift›</span></span></span></span> to indicate which partial order is to be used.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> fstate <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>d <span class="main">×</span> d list <span class="main">×</span> venv <span class="main">×</span> contour<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> cstate <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>call <span class="main">×</span> benv <span class="main">×</span> venv <span class="main">×</span> contour<span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">fixrec</span></span>   <span class="entity">evalF</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fstate discr <span class="main">→</span> ans"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">ℱ</span>"</span><span class="main">)</span>
     <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">evalC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"cstate discr <span class="main">→</span> ans"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">𝒞</span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">evalF</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">fstate</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> undiscr <span class="free"><span class="bound"><span class="entity">fstate</span></span></span> <span class="keyword1">of</span>
             <span class="main">(</span>DC <span class="main">(</span>Lambda <span class="bound">lab</span> <span class="bound">vs</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span> <span class="bound">as</span><span class="main">,</span> <span class="bound">ve</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
               <span class="main">(</span><span class="keyword1">if</span> length <span class="bound">vs</span> <span class="main">=</span> length <span class="bound">as</span>
                <span class="keyword1">then</span> <span class="keyword1">let</span> <span class="bound">β'</span> <span class="main">=</span> <span class="bound">β</span> <span class="main">(</span><span class="bound">lab</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">)</span><span class="main">;</span>
                         <span class="bound">ve'</span> <span class="main">=</span> map_upds <span class="bound">ve</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="bound">vs</span><span class="main">)</span> <span class="bound">as</span>
                     <span class="keyword1">in</span> <span class="keyword1"><span class="free">𝒞</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">β'</span><span class="main">,</span><span class="bound">ve'</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword1">else</span> <span class="main">⊥</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>DP <span class="main">(</span>Plus <span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="main">[</span>DI <span class="bound">a1</span><span class="main">,</span> DI <span class="bound">a2</span><span class="main">,</span> <span class="bound">cnt</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
                     <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> Suc <span class="bound">b</span><span class="main">;</span>
                         <span class="bound">β</span>  <span class="main">=</span> <span class="main">[</span><span class="bound">c</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                     <span class="keyword1">in</span> <span class="keyword1"><span class="free">ℱ</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="main">[</span>DI <span class="main">(</span><span class="bound">a1</span> <span class="main">+</span> <span class="bound">a2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>DP <span class="main">(</span>prim.If <span class="bound">ct</span> <span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="main">[</span>DI <span class="bound">v</span><span class="main">,</span> <span class="bound">contt</span><span class="main">,</span> <span class="bound">contf</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
                  <span class="main">(</span><span class="keyword1">if</span> <span class="bound">v</span> <span class="main">≠</span> <span class="main">0</span>
                   <span class="keyword1">then</span> <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> Suc <span class="bound">b</span><span class="main">;</span>
                            <span class="bound">β</span> <span class="main">=</span> <span class="main">[</span><span class="bound">ct</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                        <span class="keyword1">in</span> <span class="keyword1"><span class="free">ℱ</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">contt</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span>
                   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> Suc <span class="bound">b</span><span class="main">;</span>
                            <span class="bound">β</span> <span class="main">=</span> <span class="main">[</span><span class="bound">cf</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                        <span class="keyword1">in</span> <span class="keyword1"><span class="free">ℱ</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">contf</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>Stop<span class="main">,</span><span class="main">[</span>DI <span class="bound">i</span><span class="main">]</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> Def <span class="bound">i</span>
            <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">⊥</span>
        <span class="main">)</span>"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">𝒞</span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">cstate</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> undiscr <span class="free"><span class="bound"><span class="entity">cstate</span></span></span> <span class="keyword1">of</span>
             <span class="main">(</span>App <span class="bound">lab</span> <span class="bound">f</span> <span class="bound">vs</span><span class="main">,</span><span class="bound">β</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
                 <span class="keyword1">let</span> <span class="bound">f'</span> <span class="main">=</span> <span class="keyword1">𝒜</span> <span class="bound">f</span> <span class="bound">β</span> <span class="bound">ve</span><span class="main">;</span>
                     <span class="bound">as</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">𝒜</span> <span class="bound">v</span> <span class="bound">β</span> <span class="bound">ve</span><span class="main">)</span> <span class="bound">vs</span><span class="main">;</span>
                     <span class="bound">b'</span> <span class="main">=</span> Suc <span class="bound">b</span>
                  <span class="keyword1">in</span> <span class="keyword1"><span class="free">ℱ</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">as</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>Let <span class="bound">lab</span> <span class="bound">ls</span> <span class="bound">c'</span><span class="main">,</span><span class="bound">β</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
                 <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> Suc <span class="bound">b</span><span class="main">;</span>
                     <span class="bound">β'</span> <span class="main">=</span> <span class="bound">β</span> <span class="main">(</span><span class="bound">lab</span> <span class="main">↦</span> <span class="bound">b'</span><span class="main">)</span><span class="main">;</span>
                    <span class="bound">ve'</span> <span class="main">=</span> <span class="bound">ve</span> <span class="main">++</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="bound">β'</span> <span class="bound">ve</span><span class="main">)</span><span class="main">)</span> <span class="bound">ls</span><span class="main">)</span>
                 <span class="keyword1">in</span> <span class="keyword1"><span class="free">𝒞</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">c'</span><span class="main">,</span><span class="bound">β'</span><span class="main">,</span><span class="bound">ve'</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span>
        <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
To evaluate a full program, it is passed to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span> with proper initializations of the other arguments. We test our semantics function against two example programs and observe that the expected value is returned. 
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">evalCPS</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> ans"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">\&lt;PR&gt;</span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">\&lt;PR&gt;</span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ve</span> <span class="main">=</span> Map.empty<span class="main">;</span>
                          <span class="bound">β</span> <span class="main">=</span> Map.empty<span class="main">;</span>
                          <span class="bound">f</span> <span class="main">=</span> <span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="bound">β</span> <span class="bound">ve</span>
                      <span class="keyword1">in</span>  <span class="keyword1">ℱ</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="main">[</span>Stop<span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> correct_ex1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">\&lt;PR&gt;</span> ex1 <span class="main">=</span> Def <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> evalCPS_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> correct_ex2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">\&lt;PR&gt;</span> ex2 <span class="main">=</span> Def <span class="numeral">2</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> evalCPS_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* (The third example takes long to finish, thus is it not ran by default.) 
lemma correct_ex3: "evalCPS ex3 = Def 55"
oops
unfolding evalCPS_def
by simp
*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Utils">
<div class="head">
<h1>Theory Utils</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹General utility lemmas›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Utils <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This is a potpourri of various lemmas not specific to our project. Some of them could very well be included in the default Isabelle library.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Lemmas about the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>single_valued›</span></span></span></span> predicate.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> single_valued_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"single_valued <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> single_valuedI<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> single_valued_insert<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="free">rel</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">rel</span><span class="main">;</span> <span class="bound">x</span><span class="main">=</span><span class="free">a</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span>insert <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="free">rel</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>single_valuedI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span>single_valuedD<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Lemmas about <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ran›</span></span></span></span>, the range of a finite map.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ran_upd<span class="main">:</span> <span class="quoted"><span class="quoted">"ran <span class="main">(</span><span class="free">m</span> <span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> ran <span class="free">m</span> <span class="main">∪</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ran_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ran_map_of<span class="main">:</span> <span class="quoted"><span class="quoted">"ran <span class="main">(</span>map_of <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> snd <span class="main">`</span> set <span class="free">xs</span>"</span></span>
 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>fun_upd_apply <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ran_upd<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ran_concat<span class="main">:</span> <span class="quoted"><span class="quoted">"ran <span class="main">(</span><span class="free">m1</span> <span class="main">++</span> <span class="free">m2</span><span class="main">)</span> <span class="main">⊆</span> ran <span class="free">m1</span> <span class="main">∪</span> ran <span class="free">m2</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ran_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ran_upds<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eq_length<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">ks</span> <span class="main">=</span> length <span class="free">vs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ran <span class="main">(</span>map_upds <span class="free">m</span> <span class="free">ks</span> <span class="free">vs</span><span class="main">)</span> <span class="main">⊆</span> ran <span class="free">m</span> <span class="main">∪</span> set <span class="free">vs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ran <span class="main">(</span>map_upds <span class="free">m</span> <span class="free">ks</span> <span class="free">vs</span><span class="main">)</span> <span class="main">⊆</span> ran <span class="main">(</span><span class="free">m</span><span class="main">++</span>map_of <span class="main">(</span>rev <span class="main">(</span>zip <span class="free">ks</span> <span class="free">vs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> map_upds_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊆</span> ran <span class="free">m</span> <span class="main">∪</span> ran <span class="main">(</span>map_of <span class="main">(</span>rev <span class="main">(</span>zip <span class="free">ks</span> <span class="free">vs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ran_concat<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊆</span> ran <span class="free">m</span> <span class="main">∪</span> snd <span class="main">`</span> set <span class="main">(</span>rev <span class="main">(</span>zip <span class="free">ks</span> <span class="free">vs</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Un_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"ran <span class="free"><span class="free"><span class="free">m</span></span></span>"</span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"ran <span class="free"><span class="free"><span class="free">m</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span> subset_refl ran_map_of<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span><span class="main">⊆</span> ran <span class="free">m</span> <span class="main">∪</span> set <span class="free">vs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>Un_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"ran <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"ran <span class="free">m</span>"</span></span><span class="main"><span class="main">]</span></span> subset_refl <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>set_map <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>set_map<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> sym<span class="main"><span class="main">]</span></span> map_snd_zip<span class="main"><span class="main">[</span></span><span class="operator">OF</span> eq_length<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ran_upd_mem<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> ran <span class="main">(</span><span class="free">m</span> <span class="main">(</span><span class="free">k</span> <span class="main">↦</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ran_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Lemmas about <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>map›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>zip›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fst›</span></span></span></span>/<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>snd›</span></span></span></span>
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_fst_zip<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">=</span> length <span class="free">ys</span> <span class="main">⟹</span> map fst <span class="main">(</span>zip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>list_induct2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> map_snd_zip<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">=</span> length <span class="free">ys</span> <span class="main">⟹</span> map snd <span class="main">(</span>zip <span class="free">xs</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>list_induct2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="SetMap">
<div class="head">
<h1>Theory SetMap</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Set-valued maps›</span></span>
<span class="keyword1"><span class="command">theory</span></span> SetMap
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
For the abstract semantics, we need methods to work with set-valued maps, i.e.\ functions from a key type to sets of values. For this type, some well known operations are introduced and properties shown, either borrowing the nomenclature from finite maps (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sdom›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sran›</span></span></span></span>,...) or of sets (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>{}.›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>∪.›</span></span></span></span>,...).
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">sdom</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">=&gt;</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">=&gt;</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sdom</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">a</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">a</span> <span class="main">~=</span> <span class="main">{}</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">sran</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">=&gt;</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">=&gt;</span> <span class="tfree">'b</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sran</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">∃</span><span class="bound">a</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">a</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sranI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∈</span> <span class="free">m</span> <span class="free">a</span> <span class="main">⟹</span> <span class="free">b</span> <span class="main">∈</span> sran <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sran_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sdom_not_mem<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> sdom <span class="free">m</span> <span class="main">⟹</span> <span class="free">m</span> <span class="free">a</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sdom_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">smap_empty</span> <span class="main">(</span><span class="quoted">"<span class="keyword1">{}.</span>"</span><span class="main">)</span>
 <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">{}.</span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">smap_union</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>type <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>type set<span class="main">)</span>  <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> set<span class="main">)</span>"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">∪.</span> _"</span><span class="main">)</span>
 <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">smap1</span></span></span> <span class="main"><span class="free">∪.</span></span> <span class="free"><span class="bound"><span class="entity">smap2</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span>  <span class="free"><span class="bound"><span class="entity">smap1</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">smap2</span></span></span> <span class="free"><span class="bound"><span class="entity">k</span></span></span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">smap_Union</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>type <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>type set<span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⋃.</span>_"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main"><span class="free">⋃.</span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">{}.</span>"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⋃.</span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ms</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>  <span class="main">∪.</span> <span class="main"><span class="free">⋃.</span></span> <span class="free"><span class="bound"><span class="entity">ms</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">smap_singleton</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>type <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>type set <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">{</span> _ <span class="keyword1">:=</span> _<span class="keyword1">}.</span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">{</span></span><span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main"><span class="free">:=</span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main"><span class="free">}.</span></span> <span class="main">=</span> <span class="main">{}.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">:=</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">smap_less</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"_<span class="keyword3">/ </span><span class="keyword1">⊆.</span> _"</span> <span class="main">[</span>50<span class="main">,</span> 51<span class="main">]</span> 50<span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">smap_less</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">k</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="bound">k</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="bound">k</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sdom_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sdom <span class="main">{}.</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> sdom_def smap_empty_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> sdom_singleton<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sdom <span class="main">{</span><span class="free">k</span> <span class="main">:=</span> <span class="free">vs</span><span class="main">}.</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">k</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sdom_def smap_singleton_def smap_empty_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sran_singleton<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sran <span class="main">{</span><span class="free">k</span> <span class="main">:=</span> <span class="free">vs</span><span class="main">}.</span> <span class="main">=</span> <span class="free">vs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sran_def smap_singleton_def smap_empty_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sran_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sran <span class="main">{}.</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> sran_def smap_empty_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> sdom_union<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sdom <span class="main">(</span><span class="free">m</span> <span class="main">∪.</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> sdom <span class="free">m</span> <span class="main">∪</span> sdom <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>smap_union_def sdom_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sran_union<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sran <span class="main">(</span><span class="free">m</span> <span class="main">∪.</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> sran <span class="free">m</span> <span class="main">∪</span> sran <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>smap_union_def sran_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}.</span> <span class="main">⊆.</span> <span class="main">{}.</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> smap_less_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_less_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">⊆.</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> smap_less_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_less_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">m1</span> <span class="main">⊆.</span> <span class="free">m2</span><span class="main">;</span> <span class="free">m2</span> <span class="main">⊆.</span> <span class="free">m3</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">m1</span> <span class="main">⊆.</span> <span class="free">m3</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> smap_less_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_union_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">ve1</span> <span class="main">⊆.</span> <span class="free">ve1'</span><span class="main">;</span> <span class="free">ve2</span> <span class="main">⊆.</span> <span class="free">ve2'</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">ve1</span> <span class="main">∪.</span> <span class="free">ve2</span> <span class="main">⊆.</span> <span class="free">ve1'</span> <span class="main">∪.</span> <span class="free">ve2'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>smap_less_def smap_union_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_Union_union<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m1</span> <span class="main">∪.</span> <span class="main">⋃.</span><span class="free">ms</span> <span class="main">=</span> <span class="main">⋃.</span><span class="main">(</span><span class="free">m1</span><span class="main">#</span><span class="free">ms</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smap_union_def smap_Union_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_Union_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"list_all2 smap_less <span class="free">ms1</span> <span class="free">ms2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃.</span> <span class="free">ms1</span> <span class="main">⊆.</span> <span class="main">⋃.</span> <span class="free">ms2</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>list_induct2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> list_all2_lengthD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>smap_union_mono<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_singleton_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">⊆</span> <span class="free">v'</span> <span class="main">⟹</span> <span class="main">{</span><span class="free">k</span> <span class="main">:=</span> <span class="free">v</span><span class="main">}.</span> <span class="main">⊆.</span> <span class="main">{</span><span class="free">k</span> <span class="main">:=</span> <span class="free">v'</span><span class="main">}.</span>"</span></span>
 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smap_singleton_def smap_less_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_union_comm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m1</span> <span class="main">∪.</span> <span class="free">m2</span> <span class="main">=</span> <span class="free">m2</span> <span class="main">∪.</span> <span class="free">m1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>smap_union_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_union_empty1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}.</span> <span class="main">∪.</span> <span class="free">m</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>smap_union_def smap_empty_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_union_empty2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">∪.</span> <span class="main">{}.</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>smap_union_def smap_empty_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_union_assoc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m1</span> <span class="main">∪.</span> <span class="free">m2</span><span class="main">)</span> <span class="main">∪.</span> <span class="free">m3</span> <span class="main">=</span> <span class="free">m1</span> <span class="main">∪.</span> <span class="main">(</span><span class="free">m2</span> <span class="main">∪.</span> <span class="free">m3</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>smap_union_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_Union_append<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃.</span> <span class="main">(</span><span class="free">m1</span><span class="main">@</span><span class="free">m2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃.</span> <span class="free">m1</span><span class="main">)</span> <span class="main">∪.</span> <span class="main">(</span><span class="main">⋃.</span> <span class="free">m2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">m1</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_Union_rev<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃.</span> <span class="main">(</span>rev <span class="free">l</span><span class="main">)</span> <span class="main">=</span> <span class="main">⋃.</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>smap_union_comm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_Union_map_rev<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃.</span> <span class="main">(</span>map <span class="free">f</span> <span class="main">(</span>rev <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">⋃.</span> <span class="main">(</span>map <span class="free">f</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> rev_map<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> sym<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> smap_Union_rev<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> refl<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="AbsCF">
<div class="head">
<h1>Theory AbsCF</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Abstract nonstandard semantics"</span></span>

<span class="keyword1"><span class="command">theory</span></span> AbsCF
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a> <a href="HOLCFUtils.html">HOLCFUtils</a> <a href="CPSScheme.html">CPSScheme</a> <a href="Utils.html">Utils</a> <a href="SetMap.html">SetMap</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">default_sort</span></span> <span class="quoted">type</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
After having defined the exact meaning of a control graph, we now alter the algorithm into a statically computable. We note that the contour pointer in the exact semantics is taken from an infinite set. This is unavoidable, as recursion depth is unbounded. But if this were not the case and the set were finite, the function would be calculable, having finite range and domain.

Therefore, we make the set of contour counter values finite and accept that this makes our result less exact, but calculable. We also do not work with values any more but only remember, for each variable, what possible lambdas can occur there. Because we do not have exact values any more, in a conditional expression, both branches are taken.

We want to leave the exact choice of the finite contour set open for now. Therefore, we define a type class capturing the relevant definitions and the fact that the set is finite. Isabelle expects type classes to be non-empty, so we show that the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>unit›</span></span></span></span> type is in this type class.
›</span></span>

<span class="keyword1"><span class="command">class</span></span> contour <span class="main">=</span> finite <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">nb_a</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> label <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1">\&lt;anb&gt;</span></span></span>"</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free"><span class="free"><span class="free">a_initial_contour</span></span></span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1">\&lt;abinit&gt;</span></span></span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> unit <span class="main">::</span> <span class="quoted">contour</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="main">\&lt;anb&gt;</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">()</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="main">\&lt;abinit&gt;</span> <span class="main">=</span> <span class="main">()</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Analogous to the previous section, we define types for binding environments, closures, procedures, semantic values (which are now sets of possible procedures) and variable environment. Their types are parametrized by the chosen set of abstract contours.

The abstract variable environment is a partial map to sets in Shivers' dissertation. As he does not need to distinguish between a key not in the map and a key mapped to the empty set, this presentation is redundant. Therefore, I encoded this as a function from keys to sets of values. The theory <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="SetMap.html"></a><a href="SetMap.html">Shivers-CFA.SetMap</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span> contains functions and lemmas to work with such maps, symbolized by an appended dot (e.g. <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>{}.›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>∪.›</span></span></span></span>).
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'c</span> a_benv <span class="main">=</span> <span class="quoted"><span class="quoted">"label <span class="main">⇀</span> <span class="tfree">'c</span>"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">\&lt;abenv&gt;</span>"</span> <span class="main">[</span>1000<span class="main">]</span><span class="main">)</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'c</span> a_closure <span class="main">=</span> <span class="quoted"><span class="quoted">"lambda <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;abenv&gt;</span>"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">\&lt;aclosure&gt;</span>"</span> <span class="main">[</span>1000<span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'c</span> proc <span class="main">(</span><span class="quoted">"_ <span class="keyword1">\&lt;aproc&gt;</span>"</span> <span class="main">[</span>1000<span class="main">]</span><span class="main">)</span>
  <span class="main">=</span> PC <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">\&lt;aclosure&gt;</span>"</span></span>
  <span class="main">|</span> PP <span class="quoted">prim</span>
  <span class="main">|</span> AStop

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'c</span> a_d <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">\&lt;aproc&gt;</span> set"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">\&lt;ad&gt;</span>"</span> <span class="main">[</span>1000<span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'c</span> a_venv <span class="main">=</span> <span class="quoted"><span class="quoted">"var <span class="main">×</span> <span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">\&lt;ad&gt;</span>"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">\&lt;avenv&gt;</span>"</span> <span class="main">[</span>1000<span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The evaluation function now ignores constants and returns singletons for primitive operations and lambda expressions.
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">evalV_a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"val <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">\&lt;abenv&gt;</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">\&lt;avenv&gt;</span> <span class="main">⇒</span> <span class="tfree">'c</span> <span class="main">\&lt;ad&gt;</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">\&lt;aA&gt;</span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">\&lt;aA&gt;</span></span> <span class="main">(</span>C <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="main">|</span>     <span class="quoted"><span class="quoted">"<span class="main"><span class="free">\&lt;aA&gt;</span></span> <span class="main">(</span>P <span class="free"><span class="bound"><span class="entity">prim</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span> <span class="main">{</span>PP <span class="free"><span class="bound"><span class="entity">prim</span></span></span><span class="main">}</span>"</span></span>
  <span class="main">|</span>     <span class="quoted"><span class="quoted">"<span class="main"><span class="free">\&lt;aA&gt;</span></span> <span class="main">(</span>R <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">var</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span>
           <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="main">(</span>binder <span class="free"><span class="bound"><span class="entity">var</span></span></span><span class="main">)</span> <span class="keyword1">of</span>
              Some <span class="bound">l</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">var</span></span></span><span class="main">,</span><span class="bound">l</span><span class="main">)</span>
            <span class="main">|</span> None <span class="main">⇒</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="main">|</span>     <span class="quoted"><span class="quoted">"<span class="main"><span class="free">\&lt;aA&gt;</span></span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">lam</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span> <span class="main">{</span>PC <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lam</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The types of the calculated graph, the arguments to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aF&gt;›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aC&gt;›</span></span></span></span> resemble closely the types in the exact case, with each type replaced by its abstract counterpart.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'c</span> a_ccache <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>label <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;abenv&gt;</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;aproc&gt;</span><span class="main">)</span> set"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">\&lt;accache&gt;</span>"</span> <span class="main">[</span>1000<span class="main">]</span><span class="main">)</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'c</span> a_ans <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">\&lt;accache&gt;</span>"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">\&lt;aans&gt;</span>"</span> <span class="main">[</span>1000<span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'c</span> a_fstate <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span> <span class="main">\&lt;aproc&gt;</span> <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;ad&gt;</span> list <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;avenv&gt;</span> <span class="main">×</span> <span class="tfree">'c</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">\&lt;afstate&gt;</span>"</span> <span class="main">[</span>1000<span class="main">]</span><span class="main">)</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'c</span> a_cstate <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>call <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;abenv&gt;</span> <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;avenv&gt;</span> <span class="main">×</span> <span class="tfree">'c</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">\&lt;acstate&gt;</span>"</span> <span class="main">[</span>1000<span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
And yet again, cont2cont results need to be shown for our custom data types.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_lambda <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_lambda <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_proc <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f1</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f2</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f3</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_proc <span class="main">(</span><span class="free">f1</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f3</span> <span class="bound">x</span><span class="main">)</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_call <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f1</span> <span class="bound">x</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f2</span> <span class="bound">x</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_call <span class="main">(</span><span class="free">f1</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x</span><span class="main">)</span> <span class="free">c</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">c</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_prim <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f1</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f2</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_prim <span class="main">(</span><span class="free">f1</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We can now define the abstract nonstandard semantics, based on the equations in Figure 4.5 and 4.6 of Shivers' dissertation. In the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>AStop›</span></span></span></span> case, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>{}›</span></span></span></span> is returned, while for wrong arguments, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⊥›</span></span></span></span> is returned. Both actually represent the same value, the empty set, so this is just a aesthetic difference.
›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span>   <span class="entity">a_evalF</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span><span class="main">::</span>contour <span class="main">\&lt;afstate&gt;</span> discr <span class="main">→</span> <span class="tfree">'c</span> <span class="main">\&lt;aans&gt;</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">\&lt;aF&gt;</span>"</span><span class="main">)</span>
     <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">a_evalC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span><span class="main">::</span>contour <span class="main">\&lt;acstate&gt;</span> discr <span class="main">→</span> <span class="tfree">'c</span> <span class="main">\&lt;aans&gt;</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">\&lt;aC&gt;</span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">\&lt;aF&gt;</span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">fstate</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> undiscr <span class="free"><span class="bound"><span class="entity">fstate</span></span></span> <span class="keyword1">of</span>
             <span class="main">(</span>PC <span class="main">(</span>Lambda <span class="bound">lab</span> <span class="bound">vs</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span> <span class="bound">as</span><span class="main">,</span> <span class="bound">ve</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
               <span class="main">(</span><span class="keyword1">if</span> length <span class="bound">vs</span> <span class="main">=</span> length <span class="bound">as</span>
                <span class="keyword1">then</span> <span class="keyword1">let</span> <span class="bound">β'</span> <span class="main">=</span> <span class="bound">β</span> <span class="main">(</span><span class="bound">lab</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">)</span><span class="main">;</span>
                         <span class="bound">ve'</span> <span class="main">=</span> <span class="bound">ve</span> <span class="main">∪.</span> <span class="main">(</span><span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">:=</span> <span class="bound">a</span><span class="main">}.</span><span class="main">)</span> <span class="main">(</span>zip <span class="bound">vs</span> <span class="bound">as</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                     <span class="keyword1">in</span> <span class="main"><span class="free">\&lt;aC&gt;</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">β'</span><span class="main">,</span><span class="bound">ve'</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword1">else</span> <span class="main">⊥</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>PP <span class="main">(</span>Plus <span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">cnts</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
                     <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">;</span>
                         <span class="bound">β</span>  <span class="main">=</span> <span class="main">[</span><span class="bound">c</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                     <span class="keyword1">in</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="bound">cnts</span><span class="main">.</span> <span class="main"><span class="free">\&lt;aF&gt;</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="main">[</span><span class="main">{}</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                        <span class="main">∪</span>
                        <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span> <span class="bound">cont</span><span class="main">)</span> <span class="main">|</span> <span class="bound">cont</span> <span class="main">.</span> <span class="bound">cont</span> <span class="main">∈</span> <span class="bound">cnts</span><span class="main">}</span>
            <span class="main">|</span> <span class="main">(</span>PP <span class="main">(</span>prim.If <span class="bound">ct</span> <span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">cntts</span><span class="main">,</span> <span class="bound">cntfs</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
                  <span class="main">(</span><span class="main">(</span>   <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">ct</span><span class="main">;</span>
                            <span class="bound">β</span> <span class="main">=</span> <span class="main">[</span><span class="bound">ct</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                        <span class="keyword1">in</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="bound">cntts</span> <span class="main">.</span> <span class="main"><span class="free">\&lt;aF&gt;</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                           <span class="main">∪</span><span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">ct</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span> <span class="bound">cnt</span><span class="main">)</span> <span class="main">|</span> <span class="bound">cnt</span> <span class="main">.</span> <span class="bound">cnt</span> <span class="main">∈</span> <span class="bound">cntts</span><span class="main">}</span>
                   <span class="main">)</span><span class="main">∪</span><span class="main">(</span>
                       <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">cf</span><span class="main">;</span>
                            <span class="bound">β</span> <span class="main">=</span> <span class="main">[</span><span class="bound">cf</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                        <span class="keyword1">in</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="bound">cntfs</span> <span class="main">.</span> <span class="main"><span class="free">\&lt;aF&gt;</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                           <span class="main">∪</span><span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">cf</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span> <span class="bound">cnt</span><span class="main">)</span> <span class="main">|</span> <span class="bound">cnt</span> <span class="main">.</span> <span class="bound">cnt</span> <span class="main">∈</span> <span class="bound">cntfs</span><span class="main">}</span>
                   <span class="main">)</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>AStop<span class="main">,</span><span class="main">[</span><span class="main"><span class="bound">_</span></span><span class="main">]</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="main">{}</span>
            <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">⊥</span>
        <span class="main">)</span>"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">\&lt;aC&gt;</span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">cstate</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> undiscr <span class="free"><span class="bound"><span class="entity">cstate</span></span></span> <span class="keyword1">of</span>
             <span class="main">(</span>App <span class="bound">lab</span> <span class="bound">f</span> <span class="bound">vs</span><span class="main">,</span><span class="bound">β</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
                 <span class="keyword1">let</span> <span class="bound">fs</span> <span class="main">=</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">f</span> <span class="bound">β</span> <span class="bound">ve</span><span class="main">;</span>
                     <span class="bound">as</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">v</span> <span class="bound">β</span> <span class="bound">ve</span><span class="main">)</span> <span class="bound">vs</span><span class="main">;</span>
                     <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">lab</span>
                  <span class="keyword1">in</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">f'</span> <span class="main">∈</span> <span class="bound">fs</span><span class="main">.</span> <span class="main"><span class="free">\&lt;aF&gt;</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">as</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">∪</span><span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">lab</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span><span class="bound">f'</span><span class="main">)</span> <span class="main">|</span> <span class="bound">f'</span> <span class="main">.</span> <span class="bound">f'</span><span class="main">∈</span> <span class="bound">fs</span><span class="main">}</span>
            <span class="main">|</span> <span class="main">(</span>Let <span class="bound">lab</span> <span class="bound">ls</span> <span class="bound">c'</span><span class="main">,</span><span class="bound">β</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
                 <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">lab</span><span class="main">;</span>
                     <span class="bound">β'</span> <span class="main">=</span> <span class="bound">β</span> <span class="main">(</span><span class="bound">lab</span> <span class="main">↦</span> <span class="bound">b'</span><span class="main">)</span><span class="main">;</span>
                     <span class="bound">ve'</span> <span class="main">=</span> <span class="bound">ve</span> <span class="main">∪.</span> <span class="main">(</span><span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span> <span class="main">:=</span> <span class="main">(</span><span class="main">\&lt;aA&gt;</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="bound">β'</span> <span class="bound">ve</span><span class="main">)</span><span class="main">}.</span><span class="main">)</span> <span class="bound">ls</span><span class="main">)</span><span class="main">)</span>
                 <span class="keyword1">in</span> <span class="main"><span class="free">\&lt;aC&gt;</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">c'</span><span class="main">,</span><span class="bound">β'</span><span class="main">,</span><span class="bound">ve'</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span>
        <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Again, we name the cases of the induction rule and build a nicer case analysis rule for arguments of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;afstate&gt;›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> a_evalF_evalC_induct <span class="main">=</span> a_evalF_a_evalC.induct<span class="main">[</span><span class="operator">case_names</span> Admissibility Bottom Next<span class="main">]</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">a_evalF_cases</span>
 <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">a_evalF_cases</span> <span class="main">(</span>PC <span class="main">(</span>Lambda <span class="free"><span class="bound"><span class="entity">lab</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> undefined"</span></span>
     <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">a_evalF_cases</span> <span class="main">(</span>PP <span class="main">(</span>Plus <span class="free"><span class="bound"><span class="entity">cp</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">a1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">cnt</span></span></span><span class="main">]</span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> undefined"</span></span>
     <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">a_evalF_cases</span> <span class="main">(</span>PP <span class="main">(</span>prim.If <span class="free"><span class="bound"><span class="entity">cp1</span></span></span> <span class="free"><span class="bound"><span class="entity">cp2</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cntt</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">cntf</span></span></span><span class="main">]</span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> undefined"</span></span>
     <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">a_evalF_cases</span> AStop <span class="main">[</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">]</span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> undefined"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> a_fstate_case_x <span class="main">=</span> a_evalF_cases.cases<span class="main">[</span>
  <span class="operator">OF</span> case_split<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">vs</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">as</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main">.</span> length <span class="bound">vs</span> <span class="main">=</span> length <span class="bound">as</span>"</span></span><span class="main">,</span>
  <span class="operator">case_names</span> <span class="quoted">"Closure"</span> <span class="quoted">"Closure_inv"</span> <span class="quoted">"Plus"</span> <span class="quoted">"If"</span> <span class="quoted">"Stop"</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> a_cl_cases <span class="main">=</span> prod.exhaust<span class="main">[</span><span class="operator">OF</span> lambda.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">a</span> <span class="main"><span class="bound">_</span></span> <span class="main">.</span> <span class="bound">a</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> a_ds_cases <span class="main">=</span> list.exhaust<span class="main">[</span>
  <span class="operator">OF</span> _ list.exhaust<span class="main">,</span>  <span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main">,</span>
  <span class="operator">OF</span> _ _ list.exhaust  <span class="main">,</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span> <span class="main">,</span> 
  <span class="operator">OF</span> _ _ _ list.exhaust<span class="main">,</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span>
  <span class="main">]</span> 
<span class="keyword1"><span class="command">lemmas</span></span> a_ds_cases_stop <span class="main">=</span> list.exhaust<span class="main">[</span><span class="operator">OF</span> _ list.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> a_fstate_case <span class="main">=</span> prod_cases4<span class="main">[</span><span class="operator">OF</span> proc.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main">,</span>
  <span class="operator">OF</span> a_cl_cases prim.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">a</span> <span class="main">.</span> <span class="bound">a</span>"</span></span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">a</span><span class="main">.</span> <span class="bound">a</span>"</span></span><span class="main">,</span>
  <span class="operator">OF</span> case_split a_ds_cases a_ds_cases a_ds_cases_stop<span class="main">,</span>
  <span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">as</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">vs</span> <span class="main"><span class="bound">_</span></span> <span class="main">.</span> length <span class="bound">vs</span> <span class="main">=</span> length <span class="bound">as</span>"</span></span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="bound">ds</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main">.</span> <span class="bound">ds</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="bound">ds</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">ds</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="bound">ds</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">ds</span>"</span></span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Not surprisingly, the abstract semantics of a whole program is defined using <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aF&gt;›</span></span></span></span> with suitably initialized arguments. The function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>the_elem›</span></span></span></span> extracts a value from a singleton set. This works because we know that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aA&gt;›</span></span></span></span> returns such a set when given a lambda expression.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">evalCPS_a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">::</span>contour<span class="main">)</span> <span class="main">\&lt;aans&gt;</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">\&lt;aPR&gt;</span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">\&lt;aPR&gt;</span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ve</span> <span class="main">=</span> <span class="main">{}.</span><span class="main">;</span>
                          <span class="bound">β</span> <span class="main">=</span> Map.empty<span class="main">;</span>
                          <span class="bound">f</span> <span class="main">=</span> <span class="main">\&lt;aA&gt;</span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="bound">β</span> <span class="bound">ve</span>
                      <span class="keyword1">in</span>  <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>the_elem <span class="bound">f</span><span class="main">,</span><span class="main">[</span><span class="main">{</span>AStop<span class="main">}</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="main">\&lt;abinit&gt;</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="ExCF">
<div class="head">
<h1>Theory ExCF</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Exact nonstandard semantics"</span></span>

<span class="keyword1"><span class="command">theory</span></span> ExCF
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a> <a href="HOLCFUtils.html">HOLCFUtils</a> <a href="CPSScheme.html">CPSScheme</a> <a href="Utils.html">Utils</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We now alter the standard semantics given in the previous section to calculate a control flow graph instead of the return value. At this point, we still ``run'' the program in full, so this is not yet the static analysis that we aim for. Instead, this is the reference for the correctness proof of the static analysis: If an edge is recorded here, we expect it to be found by the static analysis as well.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
In preparation of the correctness proof we change the type of the contour counters. Instead of plain natural numbers as in the previous sections we use lists of labels, remembering at each step which part of the program was just evaluated.

Note that for the exact semantics, this is information is not used in any way and it would have been possible to just use natural numbers again. This is reflected by the preorder instance for the contours which only look at the length of the list, but not the entries.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">contour</span> <span class="main">=</span> <span class="main">(</span>UNIV<span class="main">::</span>label list set<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">typedef</span></span> contour <span class="main">=</span> <span class="quoted">contour</span>
  <span class="keyword1"><span class="command">unfolding</span></span> contour_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">initial_contour</span> <span class="main">(</span><span class="quoted">"<span class="keyword1">\&lt;binit&gt;</span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">\&lt;binit&gt;</span></span> <span class="main">=</span> Abs_contour <span class="main">[]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">nb</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">nb</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> Abs_contour <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">#</span> Rep_contour <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> contour <span class="main">::</span> <span class="quoted">preorder</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> le_contour_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">b'</span></span></span> <span class="main">⟷</span> length <span class="main">(</span>Rep_contour <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">≤</span> length <span class="main">(</span>Rep_contour <span class="free"><span class="bound"><span class="entity">b'</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> less_contour_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">b'</span></span></span> <span class="main">⟷</span> length <span class="main">(</span>Rep_contour <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">&lt;</span> length <span class="main">(</span>Rep_contour <span class="free"><span class="bound"><span class="entity">b'</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>le_contour_def less_contour_def Rep_contour_inverse Abs_contour_inverse contour_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Three simple lemmas helping Isabelle to automatically prove statements about contour numbers.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nb_le_less<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nb <span class="free">b</span> <span class="free">c</span> <span class="main">≤</span> <span class="free">b'</span> <span class="main">⟷</span> <span class="free">b</span> <span class="main">&lt;</span> <span class="free">b'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nb_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>le_contour_def less_contour_def Rep_contour_inverse Abs_contour_inverse contour_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> nb_less<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b'</span> <span class="main">&lt;</span> nb <span class="free">b</span> <span class="free">c</span> <span class="main">⟷</span> <span class="free">b'</span> <span class="main">≤</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nb_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>le_contour_def less_contour_def Rep_contour_inverse Abs_contour_inverse contour_def<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> less_imp_le<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span> <span class="main"><span class="main">=</span></span> <span class="quoted">contour</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The other types used in our semantics functions have not changed.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> benv <span class="main">=</span> <span class="quoted"><span class="quoted">"label <span class="main">⇀</span> contour"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> closure <span class="main">=</span> <span class="quoted"><span class="quoted">"lambda <span class="main">×</span> benv"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> d <span class="main">=</span> DI <span class="quoted">int</span>
           <span class="main">|</span> DC <span class="quoted">closure</span>
           <span class="main">|</span> DP <span class="quoted">prim</span>
           <span class="main">|</span> Stop

<span class="keyword1"><span class="command">type_synonym</span></span> venv <span class="main">=</span> <span class="quoted"><span class="quoted">"var <span class="main">×</span> contour <span class="main">⇀</span> d"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
As we do not use the type system to distinguish procedural from non-procedural values, we define a predicate for that.
›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">isProc</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">isProc</span> <span class="main">(</span>DI <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> False"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">isProc</span> <span class="main">(</span>DC <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> True"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">isProc</span> <span class="main">(</span>DP <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> True"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">isProc</span> Stop   <span class="main">=</span> True"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
To please <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../../HOL/HOLCF/HOLCF.html"></a><a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a><span class="antiquote"><span class="antiquote">}</span></span></span></span>, we declare the discrete partial order for our types:
›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> contour <span class="main">::</span> <span class="quoted">discrete_cpo</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>contour<span class="main">)</span> <span class="main">⊑</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">instantiation</span></span> d <span class="main">::</span> <span class="quoted">discrete_cpo</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span>  <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>d<span class="main">)</span> <span class="main">⊑</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> call <span class="main">::</span> <span class="quoted">discrete_cpo</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span>  <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">::</span>call<span class="main">)</span> <span class="main">⊑</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="operator">simp</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The evaluation function for values has only changed slightly: To avoid worrying about incorrect programs, we return zero when a variable lookup fails. If the labels in the program given are correct, this will not happen. Shivers makes this explicit in Section 4.1.3 by restricting the function domains to the valid programs. This is omitted here.
›</span></span>


<span class="keyword1"><span class="command">fun</span></span> <span class="entity">evalV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"val <span class="main">⇒</span> benv <span class="main">⇒</span> venv <span class="main">⇒</span> d"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">𝒜</span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">𝒜</span></span> <span class="main">(</span>C <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span> DI <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>
  <span class="main">|</span>     <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">𝒜</span></span> <span class="main">(</span>P <span class="free"><span class="bound"><span class="entity">prim</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span> DP <span class="free"><span class="bound"><span class="entity">prim</span></span></span>"</span></span>
  <span class="main">|</span>     <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">𝒜</span></span> <span class="main">(</span>R <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">var</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span>
           <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="main">(</span>binder <span class="free"><span class="bound"><span class="entity">var</span></span></span><span class="main">)</span> <span class="keyword1">of</span>
              Some <span class="bound">l</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">var</span></span></span><span class="main">,</span><span class="bound">l</span><span class="main">)</span> <span class="keyword1">of</span> Some <span class="bound">d</span> <span class="main">⇒</span> <span class="bound">d</span> <span class="main">|</span> None <span class="main">⇒</span> DI <span class="main">0</span><span class="main">)</span>
             <span class="main">|</span> None <span class="main">⇒</span> DI <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="main">|</span>     <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">𝒜</span></span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">lam</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span> DC <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lam</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
To be able to do case analysis on the custom datatypes <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lambda›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>d›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>call›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prim›</span></span></span></span> inside a function defined with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fixrec›</span></span></span></span>, we need continuity results for them. These are all of the same shape and proven by case analysis on the discriminator.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_lambda <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_lambda <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_d <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f1</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f2</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f3</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f4</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_d <span class="main">(</span><span class="free">f1</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f3</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f4</span> <span class="bound">x</span><span class="main">)</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_call <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f1</span> <span class="bound">x</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f2</span> <span class="bound">x</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_call <span class="main">(</span><span class="free">f1</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x</span><span class="main">)</span> <span class="free">c</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">c</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_prim <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f1</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span>  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f2</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_prim <span class="main">(</span><span class="free">f1</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Now, our answer domain is not any more the integers, but rather call caches. These are represented as sets containing tuples of call sites (given by their label) and binding environments to the called value. The argument types are unaltered.

In the functions <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>𝒞›</span></span></span></span>, upon every call, a new element is added to the resulting set. The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>STOP›</span></span></span></span> continuation now ignores its argument and retuns the empty set instead. This corresponds to Figure 4.2 and 4.3 in Shivers' dissertation.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> ccache <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>label <span class="main">×</span> benv<span class="main">)</span> <span class="main">×</span> d<span class="main">)</span> set"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> ans <span class="main">=</span> <span class="quoted">ccache</span>

<span class="keyword1"><span class="command">type_synonym</span></span> fstate <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>d <span class="main">×</span> d list <span class="main">×</span> venv <span class="main">×</span> contour<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> cstate <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>call <span class="main">×</span> benv <span class="main">×</span> venv <span class="main">×</span> contour<span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">fixrec</span></span>   <span class="entity">evalF</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fstate discr <span class="main">→</span> ans"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">ℱ</span>"</span><span class="main">)</span>
     <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">evalC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"cstate discr <span class="main">→</span> ans"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">𝒞</span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">ℱ</span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">fstate</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> undiscr <span class="free"><span class="bound"><span class="entity">fstate</span></span></span> <span class="keyword1">of</span>
             <span class="main">(</span>DC <span class="main">(</span>Lambda <span class="bound">lab</span> <span class="bound">vs</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span> <span class="bound">as</span><span class="main">,</span> <span class="bound">ve</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
               <span class="main">(</span><span class="keyword1">if</span> length <span class="bound">vs</span> <span class="main">=</span> length <span class="bound">as</span>
                <span class="keyword1">then</span> <span class="keyword1">let</span> <span class="bound">β'</span> <span class="main">=</span> <span class="bound">β</span> <span class="main">(</span><span class="bound">lab</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">)</span><span class="main">;</span>
                         <span class="bound">ve'</span> <span class="main">=</span> map_upds <span class="bound">ve</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="bound">vs</span><span class="main">)</span> <span class="bound">as</span>
                     <span class="keyword1">in</span> <span class="keyword1"><span class="free">𝒞</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">β'</span><span class="main">,</span><span class="bound">ve'</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword1">else</span> <span class="main">⊥</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>DP <span class="main">(</span>Plus <span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="main">[</span>DI <span class="bound">a1</span><span class="main">,</span> DI <span class="bound">a2</span><span class="main">,</span> <span class="bound">cnt</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
                <span class="main">(</span><span class="keyword1">if</span> isProc <span class="bound">cnt</span>
                 <span class="keyword1">then</span> <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> nb <span class="bound">b</span> <span class="bound">c</span><span class="main">;</span>
                          <span class="bound">β</span>  <span class="main">=</span> <span class="main">[</span><span class="bound">c</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                      <span class="keyword1">in</span> <span class="keyword1"><span class="free">ℱ</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="main">[</span>DI <span class="main">(</span><span class="bound">a1</span> <span class="main">+</span> <span class="bound">a2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span>
                        <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span><span class="bound">cnt</span><span class="main">)</span><span class="main">}</span>
                 <span class="keyword1">else</span> <span class="main">⊥</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>DP <span class="main">(</span>prim.If <span class="bound">ct</span> <span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="main">[</span>DI <span class="bound">v</span><span class="main">,</span> <span class="bound">contt</span><span class="main">,</span> <span class="bound">contf</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
                <span class="main">(</span><span class="keyword1">if</span> isProc <span class="bound">contt</span> <span class="main">∧</span> isProc <span class="bound">contf</span>
                 <span class="keyword1">then</span>
                  <span class="main">(</span><span class="keyword1">if</span> <span class="bound">v</span> <span class="main">≠</span> <span class="main">0</span>
                   <span class="keyword1">then</span> <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> nb <span class="bound">b</span> <span class="bound">ct</span><span class="main">;</span>
                            <span class="bound">β</span> <span class="main">=</span> <span class="main">[</span><span class="bound">ct</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                        <span class="keyword1">in</span> <span class="main">(</span><span class="keyword1"><span class="free">ℱ</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">contt</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span>
                            <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">ct</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span><span class="bound">contt</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
                   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> nb <span class="bound">b</span> <span class="bound">cf</span><span class="main">;</span>
                            <span class="bound">β</span> <span class="main">=</span> <span class="main">[</span><span class="bound">cf</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                        <span class="keyword1">in</span> <span class="main">(</span><span class="keyword1"><span class="free">ℱ</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">contf</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                            <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">cf</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span><span class="bound">contf</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
                 <span class="keyword1">else</span> <span class="main">⊥</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>Stop<span class="main">,</span><span class="main">[</span>DI <span class="bound">i</span><span class="main">]</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="main">{}</span>
            <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">⊥</span>
        <span class="main">)</span>"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">𝒞</span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">cstate</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> undiscr <span class="free"><span class="bound"><span class="entity">cstate</span></span></span> <span class="keyword1">of</span>
             <span class="main">(</span>App <span class="bound">lab</span> <span class="bound">f</span> <span class="bound">vs</span><span class="main">,</span><span class="bound">β</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
                 <span class="keyword1">let</span> <span class="bound">f'</span> <span class="main">=</span> <span class="keyword1">𝒜</span> <span class="bound">f</span> <span class="bound">β</span> <span class="bound">ve</span><span class="main">;</span>
                     <span class="bound">as</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">𝒜</span> <span class="bound">v</span> <span class="bound">β</span> <span class="bound">ve</span><span class="main">)</span> <span class="bound">vs</span><span class="main">;</span>
                     <span class="bound">b'</span> <span class="main">=</span> nb <span class="bound">b</span> <span class="bound">lab</span>
                  <span class="keyword1">in</span> <span class="keyword1">if</span> isProc <span class="bound">f'</span>
                     <span class="keyword1">then</span> <span class="keyword1"><span class="free">ℱ</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">as</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">lab</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span><span class="bound">f'</span><span class="main">)</span><span class="main">}</span>
                     <span class="keyword1">else</span> <span class="main">⊥</span>
            <span class="main">|</span> <span class="main">(</span>Let <span class="bound">lab</span> <span class="bound">ls</span> <span class="bound">c'</span><span class="main">,</span><span class="bound">β</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span>
                 <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> nb <span class="bound">b</span> <span class="bound">lab</span><span class="main">;</span>
                     <span class="bound">β'</span> <span class="main">=</span> <span class="bound">β</span> <span class="main">(</span><span class="bound">lab</span> <span class="main">↦</span> <span class="bound">b'</span><span class="main">)</span><span class="main">;</span>
                    <span class="bound">ve'</span> <span class="main">=</span> <span class="bound">ve</span> <span class="main">++</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="bound">β'</span> <span class="bound">ve</span><span class="main">)</span><span class="main">)</span> <span class="bound">ls</span><span class="main">)</span>
                 <span class="keyword1">in</span> <span class="keyword1"><span class="free">𝒞</span></span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">c'</span><span class="main">,</span><span class="bound">β'</span><span class="main">,</span><span class="bound">ve'</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span>
        <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
In preparation of later proofs, we give the cases of the generated induction rule names and also create a large rule to deconstruct the an value of type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fstate›</span></span></span></span> into the various cases that were used in the definition of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> evalF_evalC_induct <span class="main">=</span> evalF_evalC.induct<span class="main">[</span><span class="operator">case_names</span> Admissibility Bottom Next<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> cl_cases <span class="main">=</span> prod.exhaust<span class="main">[</span><span class="operator">OF</span> lambda.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">a</span> <span class="main"><span class="bound">_</span></span> <span class="main">.</span> <span class="bound">a</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> ds_cases_plus <span class="main">=</span> list.exhaust<span class="main">[</span>
  <span class="operator">OF</span> _ d.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">a</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">a</span>"</span></span><span class="main">,</span>
  <span class="operator">OF</span> _ list.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">x</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main">,</span>
  <span class="operator">OF</span> _ _ d.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">a</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">a</span>"</span></span><span class="main">,</span>
  <span class="operator">OF</span> _ _ list.exhaust<span class="main">,</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">x</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main">,</span>
  <span class="operator">OF</span> _ _ _ list.exhaust<span class="main">,</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span>
  <span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> ds_cases_if <span class="main">=</span> list.exhaust<span class="main">[</span><span class="operator">OF</span> _ d.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">a</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">a</span>"</span></span><span class="main">,</span>
  <span class="operator">OF</span> _ list.exhaust<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ list.exhaust<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> _ list.exhaust<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">of</span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">x</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> ds_cases_stop <span class="main">=</span> list.exhaust<span class="main">[</span><span class="operator">OF</span> _ d.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">a</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">a</span>"</span></span><span class="main">,</span>
  <span class="operator">OF</span> _ list.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">x</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> fstate_case <span class="main">=</span> prod_cases4<span class="main">[</span><span class="operator">OF</span> d.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main">,</span>
  <span class="operator">OF</span> _ cl_cases prim.exhaust<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">a</span> <span class="main">.</span> <span class="bound">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">a</span><span class="main">.</span> <span class="bound">a</span>"</span></span><span class="main">,</span>
  <span class="operator">OF</span> _ case_split ds_cases_plus ds_cases_if ds_cases_stop<span class="main">,</span>
  <span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">as</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">vs</span> <span class="main"><span class="bound">_</span></span> <span class="main">.</span> length <span class="bound">vs</span> <span class="main">=</span> length <span class="bound">as</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="bound">ds</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main">.</span> <span class="bound">ds</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="bound">ds</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">ds</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="bound">ds</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">ds</span>"</span></span><span class="main">,</span>
  <span class="operator">case_names</span> <span class="quoted">"x"</span> <span class="quoted">"Closure"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span>  <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"Plus"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span>   <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"If_True"</span> <span class="quoted">"If_False"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"Stop"</span>  <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span> <span class="quoted">"x"</span><span class="main">]</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The exact semantics of a program again uses <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span> with properly initialized arguments. For the first two examples, we see that the function works as expected.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">evalCPS</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> ans"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">\&lt;PR&gt;</span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">\&lt;PR&gt;</span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">ve</span> <span class="main">=</span> Map.empty<span class="main">;</span>
                          <span class="bound">β</span> <span class="main">=</span> Map.empty<span class="main">;</span>
                          <span class="bound">f</span> <span class="main">=</span> <span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="bound">β</span> <span class="bound">ve</span>
                      <span class="keyword1">in</span>  <span class="keyword1">ℱ</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="main">[</span>Stop<span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="main">\&lt;binit&gt;</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> correct_ex1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">\&lt;PR&gt;</span> ex1 <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="main">[</span><span class="main">1</span> <span class="main">↦</span> <span class="main">\&lt;binit&gt;</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> Stop<span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> evalCPS_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> correct_ex2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">\&lt;PR&gt;</span> ex2 <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="main">1</span> <span class="main">↦</span> <span class="main">\&lt;binit&gt;</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> DP <span class="main">(</span>Plus <span class="numeral">3</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                   <span class="main">(</span><span class="main">(</span><span class="numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="numeral">3</span> <span class="main">↦</span> nb <span class="main">\&lt;binit&gt;</span> <span class="numeral">2</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>  Stop<span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> evalCPS_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="AbsCFCorrect">
<div class="head">
<h1>Theory AbsCFCorrect</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The abstract semantics is correct›</span></span>

<span class="keyword1"><span class="command">theory</span></span> AbsCFCorrect
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="AbsCF.html">AbsCF</a> <a href="ExCF.html">ExCF</a> <span class="quoted">"<a href="../../HOL/HOL-Library/Adhoc_Overloading.html">HOL-Library.Adhoc_Overloading</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">default_sort</span></span> <span class="quoted">type</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The intention of the abstract semantics is to safely approximate the real control flow. This means that every call recorded by the exact semantics must occur in the result provided by the abstract semantics, which in turn is allowed to predict more calls than actually done.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Abstraction functions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This relation is expressed by abstraction functions and approximation relations. For each of our data types, there is an abstraction function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>abs_&lt;type&gt;›</span></span></span></span>, mapping the a value from the exact setup to the corresponding value in the abstract view. The approximation relation then expresses the fact that one abstract value of such a type is safely approximated by another.

Because we need an abstraction function for contours, we extend the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>contour›</span></span></span></span> type class by the abstraction functions and two equations involving the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>nb›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;binit&gt;›</span></span></span></span> symbols.
›</span></span>

<span class="keyword1"><span class="command">class</span></span> contour_a <span class="main">=</span> contour <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">abs_cnt</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"contour <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> abs_cnt_nb<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">abs_cnt</span> <span class="main">(</span>nb <span class="free">b</span> <span class="free">lab</span><span class="main">)</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="main">(</span><span class="free">abs_cnt</span> <span class="free">b</span><span class="main">)</span> <span class="free">lab</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> abs_cnt_initial<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">abs_cnt</span><span class="main">(</span><span class="main">\&lt;binit&gt;</span><span class="main">)</span> <span class="main">=</span> <span class="main">\&lt;abinit&gt;</span>"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> unit <span class="main">::</span> <span class="quoted">contour_a</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"abs_cnt <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">()</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
It would be unwieldly to always write out <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>abs_&lt;type&gt; x›</span></span></span></span>. We would rather like to write <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>|x|›</span></span></span></span> if the type of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> is known, as Shivers does it as well. Isabelle allows one to use the same syntax for different symbols. In that case, it generates more than one parse tree and picks the (hopefully unique) tree that typechecks.

Unfortunately, this does not work well in our case: There are eight <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>abs_&lt;type&gt;›</span></span></span></span> functions and some expressions later have multiple occurrences of these, causing an exponential blow-up of combinations.

Therefore, we use a module by Christian Sternagel and Alexander Krauss for ad-hoc overloading, where the choice of the concrete function is done at parse time and immediately. This is used in the following to set up the the symbol <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>|_|›</span></span></span></span> for the family of abstraction functions.
›</span></span>

<span class="keyword1"><span class="command">consts</span></span> abs <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">|</span>_<span class="keyword1">|</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  abs <span class="quoted">abs_cnt</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">abs_benv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"benv <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>contour_a <span class="main">\&lt;abenv&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">abs_benv</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="main">=</span> map_option abs_cnt <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">β</span></span></span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  abs <span class="quoted">abs_benv</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">abs_closure</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"closure <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>contour_a <span class="main">\&lt;aclosure&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">abs_closure</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="main">|</span><span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">|</span> <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  abs <span class="quoted">abs_closure</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">abs_d</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"d <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>contour_a <span class="main">\&lt;ad&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">abs_d</span> <span class="main">(</span>DI <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">abs_d</span> <span class="main">(</span>DP <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>PP <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">}</span>"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">abs_d</span> <span class="main">(</span>DC <span class="free"><span class="bound"><span class="entity">cl</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>PC <span class="main">|</span><span class="free"><span class="bound"><span class="entity">cl</span></span></span><span class="main">|</span><span class="main">}</span>"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">abs_d</span> <span class="main">(</span>Stop<span class="main">)</span> <span class="main">=</span> <span class="main">{</span>AStop<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  abs <span class="quoted">abs_d</span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">abs_venv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"venv <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>contour_a <span class="main">\&lt;avenv&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">abs_venv</span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">b_a</span><span class="main">)</span><span class="main">.</span> <span class="main">⋃</span><span class="main">{</span><span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="keyword1">of</span> Some <span class="bound">d</span> <span class="main">⇒</span> <span class="main">|</span><span class="bound">d</span><span class="main">|</span> <span class="main">|</span> None <span class="main">⇒</span> <span class="main">{}</span><span class="main">)</span> <span class="main">|</span> <span class="bound">b</span><span class="main">.</span> <span class="main">|</span><span class="bound">b</span><span class="main">|</span> <span class="main">=</span> <span class="bound">b_a</span> <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  abs <span class="quoted">abs_venv</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">abs_ccache</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ccache <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>contour_a <span class="main">\&lt;accache&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">abs_ccache</span> <span class="free"><span class="bound"><span class="entity">cc</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">β</span><span class="main">)</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">cc</span></span></span> <span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span>abs_benv <span class="bound">β</span><span class="main">)</span><span class="main">,</span> <span class="bound">p</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="main">.</span> <span class="bound">p</span><span class="main">∈</span>abs_d <span class="bound">d</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="comment1">(* equivalent, but I already have cont2cont for UNION
  where "abs_ccache cc = { ((c,abs_benv β),p) | c β p d . ((c,β),d) ∈ cc ∧ p ∈ abs_d d}" *)</span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  abs <span class="quoted">abs_ccache</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">abs_fstate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fstate <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>contour_a <span class="main">\&lt;afstate&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">abs_fstate</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ve</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>the_elem <span class="main">|</span><span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">|</span><span class="main">,</span> map abs_d <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">,</span> <span class="main">|</span><span class="free"><span class="bound"><span class="entity">ve</span></span></span><span class="main">|</span><span class="main">,</span> <span class="main">|</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">|</span> <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  abs <span class="quoted">abs_fstate</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">abs_cstate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"cstate <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>contour_a <span class="main">\&lt;acstate&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">abs_cstate</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ve</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span> <span class="main">|</span><span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">|</span><span class="main">,</span> <span class="main">|</span><span class="free"><span class="bound"><span class="entity">ve</span></span></span><span class="main">|</span><span class="main">,</span> <span class="main">|</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">|</span> <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  abs <span class="quoted">abs_cstate</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lemmas about abstraction functions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Some results about the abstractions functions.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> abs_benv_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span>Map.empty<span class="main">|</span> <span class="main">=</span> Map.empty"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> abs_benv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> abs_benv_upd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="free">β</span><span class="main">(</span><span class="free">c</span><span class="main">↦</span><span class="free">b</span><span class="main">)</span><span class="main">|</span> <span class="main">=</span> <span class="main">|</span><span class="free">β</span><span class="main">|</span> <span class="main">(</span><span class="free">c</span> <span class="main">↦</span> <span class="main">|</span><span class="free">b</span><span class="main">|</span> <span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> abs_benv_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> the_elem_is_Proc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isProc <span class="free">cnt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"the_elem <span class="main">|</span><span class="free">cnt</span><span class="main">|</span> <span class="main">∈</span> <span class="main">|</span><span class="free">cnt</span><span class="main">|</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">cnt</span></span><span class="main">)</span><span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">{}</span><span class="main">|</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> abs_ccache_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> abs_cache_singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="free">c</span><span class="main">,</span><span class="free">β</span><span class="main">)</span><span class="main">,</span><span class="free">d</span><span class="main">)</span><span class="main">}</span><span class="main">|</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="free">c</span><span class="main">,</span> <span class="main">|</span><span class="free">β</span><span class="main">|</span> <span class="main">)</span><span class="main">,</span> <span class="bound">p</span><span class="main">)</span> <span class="main">|</span><span class="bound">p</span><span class="main">.</span> <span class="bound">p</span> <span class="main">∈</span> <span class="main">|</span><span class="free">d</span><span class="main">|</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> abs_ccache_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> abs_venv_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span>Map.empty<span class="main">|</span> <span class="main">=</span> <span class="main">{}.</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_venv_def smap_empty_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Approximation relation›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The family of relations defined here capture the notion of safe approximation.
›</span></span>

<span class="keyword1"><span class="command">consts</span></span> approx <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">⪅</span> _"</span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">venv_approx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">\&lt;avenv&gt;</span> <span class="main">⇒</span><span class="tfree">'c</span> <span class="main">\&lt;avenv&gt;</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">venv_approx</span> <span class="main">=</span> smap_less"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  approx <span class="quoted">venv_approx</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ccache_approx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">\&lt;accache&gt;</span> <span class="main">⇒</span><span class="tfree">'c</span> <span class="main">\&lt;accache&gt;</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ccache_approx</span> <span class="main">=</span> less_eq"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  approx <span class="quoted">ccache_approx</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">d_approx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">\&lt;ad&gt;</span> <span class="main">⇒</span><span class="tfree">'c</span> <span class="main">\&lt;ad&gt;</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">d_approx</span> <span class="main">=</span> less_eq"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  approx <span class="quoted">d_approx</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ds_approx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">\&lt;ad&gt;</span> list <span class="main">⇒</span><span class="tfree">'c</span> <span class="main">\&lt;ad&gt;</span> list <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ds_approx</span> <span class="main">=</span> list_all2 d_approx"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  approx <span class="quoted">ds_approx</span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">fstate_approx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">\&lt;afstate&gt;</span> <span class="main">⇒</span><span class="tfree">'c</span> <span class="main">\&lt;afstate&gt;</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">⪅</span> <span class="free"><span class="bound"><span class="entity">ve'</span></span></span> <span class="main">;</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span> <span class="main">⪅</span> <span class="free"><span class="bound"><span class="entity">ds'</span></span></span> <span class="main">⟧</span>
         <span class="main">⟹</span> <span class="free">fstate_approx</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">proc</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ve</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">proc</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ds'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ve'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  approx <span class="quoted">fstate_approx</span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">cstate_approx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">\&lt;acstate&gt;</span> <span class="main">⇒</span><span class="tfree">'c</span> <span class="main">\&lt;acstate&gt;</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">⪅</span> <span class="free"><span class="bound"><span class="entity">ve'</span></span></span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">cstate_approx</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ve</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ve'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">adhoc_overloading</span></span>
  approx <span class="quoted">cstate_approx</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lemmas about the approximation relation›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Most of the following lemmas reduce an approximation statement about larger structures, as they are occurring the semantics functions, to statements about the components.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> venv_approx_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ve1</span> <span class="free">ve2</span> <span class="free">ve3</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">\&lt;avenv&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">ve1</span> <span class="main">⪅</span> <span class="free">ve2</span><span class="main">;</span> <span class="free">ve2</span> <span class="main">⪅</span> <span class="free">ve3</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">ve1</span> <span class="main">⪅</span> <span class="free">ve3</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> venv_approx_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> smap_less_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> abs_venv_union<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="free">ve1</span> <span class="main">++</span> <span class="free">ve2</span><span class="main">|</span> <span class="main">⪅</span> <span class="main">|</span><span class="free">ve1</span><span class="main">|</span> <span class="main">∪.</span> <span class="main">|</span><span class="free">ve2</span><span class="main">|</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> venv_approx_def smap_less_def abs_venv_def smap_union_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">split</span> option.split_asm<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> abs_venv_map_of_rev<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span>map_of <span class="main">(</span>rev <span class="free">l</span><span class="main">)</span><span class="main">|</span> <span class="main">⪅</span> <span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">k</span><span class="main">)</span><span class="main">.</span> <span class="main">|</span><span class="main">[</span><span class="bound">v</span> <span class="main">↦</span> <span class="bound">k</span><span class="main">]</span><span class="main">|</span> <span class="main">)</span> <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> abs_venv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> venv_approx_def smap_less_def <span class="main">)</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">l</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">=</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">k</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> prod.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span>map_of <span class="main">(</span>rev <span class="main">(</span><span class="skolem">a</span><span class="main">#</span><span class="skolem">l</span><span class="main">)</span><span class="main">)</span><span class="main">|</span> <span class="main">⪅</span> <span class="main">(</span> <span class="main">|</span><span class="main">[</span><span class="skolem">v</span> <span class="main">↦</span> <span class="skolem">k</span><span class="main">]</span><span class="main">|</span> <span class="main">∪.</span> <span class="main">|</span>map_of <span class="main">(</span>rev <span class="skolem">l</span><span class="main">)</span><span class="main">|</span> <span class="main">)</span><span class="main">::</span> <span class="tfree">'a</span> <span class="main">\&lt;avenv&gt;</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> abs_venv_union<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⪅</span> <span class="main">|</span><span class="main">[</span><span class="skolem">v</span> <span class="main">↦</span> <span class="skolem">k</span><span class="main">]</span><span class="main">|</span> <span class="main">∪.</span> <span class="main">(</span><span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">k</span><span class="main">)</span><span class="main">.</span> <span class="main">|</span><span class="main">[</span><span class="bound">v</span>  <span class="main">↦</span> <span class="bound">k</span><span class="main">]</span><span class="main">|</span> <span class="main">)</span> <span class="skolem">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>smap_union_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> smap_less_refl Cons<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">unfolded</span> venv_approx_def<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>venv_approx_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">⋃.</span> <span class="main">(</span> <span class="main">|</span><span class="main">[</span><span class="skolem">v</span> <span class="main">↦</span> <span class="skolem">k</span><span class="main">]</span><span class="main">|</span> <span class="main">#</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">k</span><span class="main">)</span><span class="main">.</span> <span class="main">|</span><span class="main">[</span><span class="bound">v</span> <span class="main">↦</span> <span class="bound">k</span><span class="main">]</span><span class="main">|</span> <span class="main">)</span> <span class="skolem">l</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> smap_Union_union<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">k</span><span class="main">)</span><span class="main">.</span> <span class="main">|</span><span class="main">[</span><span class="bound">v</span> <span class="main">↦</span> <span class="bound">k</span><span class="main">]</span><span class="main">|</span> <span class="main">)</span> <span class="main">(</span><span class="skolem">a</span><span class="main">#</span><span class="skolem">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">k</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> abs_venv_map_of<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span>map_of <span class="free">l</span><span class="main">|</span> <span class="main">⪅</span> <span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">k</span><span class="main">)</span><span class="main">.</span> <span class="main">|</span><span class="main">[</span><span class="bound">v</span> <span class="main">↦</span> <span class="bound">k</span><span class="main">]</span><span class="main">|</span> <span class="main">)</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> abs_venv_map_of_rev<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"rev <span class="free">l</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> abs_venv_singleton<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">↦</span> <span class="free">d</span><span class="main">]</span><span class="main">|</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="main">|</span><span class="free">b</span><span class="main">|</span> <span class="main">)</span> <span class="main">:=</span> <span class="main">|</span><span class="free">d</span><span class="main">|</span><span class="main">}.</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>abs_venv_def smap_singleton_def smap_empty_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ccache_approx_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">\&lt;accache&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">⪅</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ccache_approx_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> ccache_approx_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span> <span class="main">=</span> subset_trans<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>label <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;abenv&gt;</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;aproc&gt;</span><span class="main">)</span>"</span></span><span class="main">,</span> <span class="operator">folded</span> ccache_approx_def<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Un_mono_approx <span class="main">=</span> Un_mono<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>label <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;abenv&gt;</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;aproc&gt;</span><span class="main">)</span>"</span></span><span class="main">,</span> <span class="operator">folded</span> ccache_approx_def<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Un_upper1_approx <span class="main">=</span> Un_upper1<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>label <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;abenv&gt;</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;aproc&gt;</span><span class="main">)</span>"</span></span><span class="main">,</span> <span class="operator">folded</span> ccache_approx_def<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> Un_upper2_approx <span class="main">=</span> Un_upper2<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>label <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;abenv&gt;</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'c</span> <span class="main">\&lt;aproc&gt;</span><span class="main">)</span>"</span></span><span class="main">,</span> <span class="operator">folded</span> ccache_approx_def<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> abs_ccache_union<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="free">c1</span> <span class="main">∪</span> <span class="free">c2</span><span class="main">|</span> <span class="main">⪅</span> <span class="main">|</span><span class="free">c1</span><span class="main">|</span> <span class="main">∪</span> <span class="main">|</span><span class="free">c2</span><span class="main">|</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ccache_approx_def abs_ccache_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> d_approx_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">⪅</span> <span class="main">(</span><span class="free">d</span><span class="main">::</span><span class="tfree">'c</span> <span class="main">\&lt;ad&gt;</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> d_approx_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> ds_approx_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span> <span class="main">⪅</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ds_approx_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lemma 7›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Shivers' lemma 7 says that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aA&gt;›</span></span></span></span> safely approximates <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>𝒜›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lemma7<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="free">ve</span><span class="main">::</span>venv<span class="main">|</span> <span class="main">⪅</span> <span class="free">ve_a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="keyword1">𝒜</span> <span class="free">f</span> <span class="free">β</span> <span class="free">ve</span><span class="main">|</span> <span class="main">⪅</span> <span class="main">\&lt;aA&gt;</span> <span class="free">f</span> <span class="main">|</span><span class="free">β</span><span class="main">|</span> <span class="free">ve_a</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>R _ <span class="skolem">v</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> assm'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">b</span><span class="main">.</span> case_option <span class="main">{}</span> abs_d <span class="main">(</span><span class="free">ve</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⪅</span> <span class="free">ve_a</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="main">|</span><span class="bound">b</span><span class="main">|</span> <span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>d_approx_def abs_venv_def venv_approx_def smap_less_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>allE<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">β</span> <span class="main">(</span>binder <span class="skolem">v</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> None <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> R <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">b</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> R assm'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">v</span></span> <span class="quoted"><span class="skolem">b</span></span><span class="main">]</span>
         <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>abs_benv_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>option.split<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>d_approx_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lemmas 8 and 9›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The main goal of this section is to show that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aF&gt;›</span></span></span></span> safely approximates <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span> and that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aC&gt;›</span></span></span></span> safely approximates <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>𝒞›</span></span></span></span>. This has to be shown at once, as the functions are mutually recursive and requires a fixed point induction. To that end, we have to augment the set of continuity lemmas.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_abs_ccache<span class="main">[</span><span class="operator">cont2cont</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> abs_ccache<span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> abs_ccache_def
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> <span class="dynamic"><span class="dynamic">cont2cont</span></span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> cont_const<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Shivers proves these lemmas using parallel fixed point induction over the two fixed points (the one from the exact semantics and the one from the abstract semantics). But it is simpler and equivalent to just do induction over the exact semantics and keep the abstract semantics functions fixed, so this is what I am doing.
›</span></span>


<span class="keyword1"><span class="command">lemma</span></span> lemma89<span class="main">:</span>
 <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">fstate_a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span><span class="main">::</span>contour_a <span class="main">\&lt;afstate&gt;</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">cstate_a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span><span class="main">::</span>contour_a <span class="main">\&lt;acstate&gt;</span>"</span></span>
 <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="free">fstate</span><span class="main">|</span> <span class="main">⪅</span> <span class="free">fstate_a</span> <span class="main">⟹</span> <span class="main">|</span><span class="keyword1">ℱ</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="free">fstate</span><span class="main">)</span><span class="main">|</span> <span class="main">⪅</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="free">fstate_a</span><span class="main">)</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="free">cstate</span><span class="main">|</span> <span class="main">⪅</span> <span class="free">cstate_a</span> <span class="main">⟹</span> <span class="main">|</span><span class="keyword1">𝒞</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="free">cstate</span><span class="main">)</span><span class="main">|</span> <span class="main">⪅</span> <span class="main">\&lt;aC&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="free">cstate_a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">fstate</span></span> <span class="quoted"><span class="free">fstate_a</span></span> <span class="quoted"><span class="free">cstate</span></span> <span class="quoted"><span class="free">cstate_a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> evalF_evalC_induct<span class="main">)</span>
<span class="keyword3"><span class="command">case</span></span> Admissibility <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ccache_approx_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> adm_lemmas adm_subset adm_prod_split adm_not_conj adm_not_mem adm_single_valued <span class="dynamic"><span class="dynamic">cont2cont</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> Bottom <span class="keyword1"><span class="command">{</span></span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">next</span></span>
<span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Next <span class="skolem">evalF</span> <span class="skolem">evalC</span><span class="main">)</span> <span class="keyword1"><span class="command">{</span></span>
<span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="skolem"><span class="skolem">ds</span></span> <span class="skolem"><span class="skolem">ve</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> fstate<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">fstate</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">d</span><span class="main">,</span><span class="skolem">ds</span><span class="main">,</span><span class="skolem">ve</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">fstate</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">proc</span></span> <span class="skolem"><span class="skolem">ds_a</span></span> <span class="skolem"><span class="skolem">ve_a</span></span> <span class="skolem"><span class="skolem">b_a</span></span> <span class="keyword2"><span class="keyword">where</span></span> fstate_a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">fstate_a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">proc</span><span class="main">,</span><span class="skolem">ds_a</span><span class="main">,</span><span class="skolem">ve_a</span><span class="main">,</span><span class="skolem">b_a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">fstate_a</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword1"><span class="command">have</span></span> abs_d<span class="main">:</span> <span class="quoted"><span class="quoted">"the_elem <span class="main">|</span><span class="skolem">d</span><span class="main">|</span> <span class="main">=</span> <span class="skolem">proc</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> abs_ds<span class="main">:</span> <span class="quoted"><span class="quoted">"map abs_d <span class="skolem">ds</span> <span class="main">⪅</span> <span class="skolem">ds_a</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> abs_ve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">ve</span><span class="main">|</span> <span class="main">⪅</span> <span class="skolem">ve_a</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> abs_b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="main">=</span> <span class="skolem">b_a</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span>fstate_approx.cases<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> abs_ds <span class="keyword1"><span class="command">have</span></span> dslength<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">ds</span> <span class="main">=</span> length <span class="skolem">ds_a</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>ds_approx_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>list_all2_lengthD<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> fstate fstate_a abs_d abs_ds abs_ve abs_ds dslength
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">fstate</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>fstate_case<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>a_evalF.simps a_evalC.simps set_map<span class="main">)</span>

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case Lambda›</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">β</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">lab</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">vs</span><span class="main">::</span> <span class="quoted"><span class="quoted">"var list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">c</span>
  <span class="keyword3"><span class="command">assume</span></span> ds_a_length<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">vs</span> <span class="main">=</span> length <span class="skolem">ds_a</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">β</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">)</span><span class="main">|</span> <span class="main">=</span> <span class="main">|</span><span class="skolem">β</span><span class="main">|</span> <span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="skolem">b_a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> below_fun_def <span class="keyword1"><span class="command">using</span></span> abs_b <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="skolem">vs</span> <span class="main">[↦]</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">|</span>
          <span class="main">⪅</span> <span class="main">|</span><span class="skolem">ve</span><span class="main">|</span> <span class="main">∪.</span> <span class="main">|</span>map_of <span class="main">(</span>rev <span class="main">(</span>zip <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">)</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> map_upds_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> abs_venv_union<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⪅</span> <span class="skolem">ve_a</span>  <span class="main">∪.</span> <span class="main">(</span><span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">k</span><span class="main">)</span><span class="main">.</span> <span class="main">|</span><span class="main">[</span><span class="bound">v</span> <span class="main">↦</span> <span class="bound">k</span><span class="main">]</span><span class="main">|</span> <span class="main">)</span> <span class="main">(</span>zip <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">)</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> abs_ve abs_venv_map_of_rev
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>smap_union_mono <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>venv_approx_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">ve_a</span> <span class="main">∪.</span> <span class="main">(</span><span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">|</span><span class="main">[</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">↦</span> <span class="bound">y</span><span class="main">]</span><span class="main">|</span> <span class="main">)</span> <span class="main">(</span>zip <span class="skolem">vs</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zip_map1 o_def split_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⪅</span> <span class="skolem">ve_a</span> <span class="main">∪.</span> <span class="main">(</span><span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="skolem">b_a</span><span class="main">)</span> <span class="main">:=</span> <span class="bound">y</span><span class="main">}.</span><span class="main">)</span> <span class="main">(</span>zip <span class="skolem">vs</span> <span class="skolem">ds_a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> abs_b abs_ds
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list_all2 venv_approx <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">|</span><span class="main">[</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">↦</span> <span class="bound">y</span><span class="main">]</span><span class="main">|</span> <span class="main">)</span> <span class="main">(</span>zip <span class="skolem">vs</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">)</span>
                                  <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="skolem">b_a</span><span class="main">)</span> <span class="main">:=</span> <span class="bound">y</span><span class="main">}.</span><span class="main">)</span> <span class="main">(</span>zip <span class="skolem">vs</span> <span class="skolem">ds_a</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ds_approx_def d_approx_def venv_approx_def abs_venv_singleton list_all2_conv_all_nth <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>smap_singleton_mono list_all2I<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>venv_approx_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> smap_union_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> smap_less_refl smap_Union_mono<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">finally</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="skolem">vs</span> <span class="main">[↦]</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">|</span>
          <span class="main">⪅</span> <span class="skolem">ve_a</span> <span class="main">∪.</span> <span class="main">(</span><span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b_a</span><span class="main">)</span> <span class="main">:=</span> <span class="bound">y</span><span class="main">}.</span><span class="main">)</span> <span class="main">(</span>zip <span class="skolem">vs</span> <span class="skolem">ds_a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword1"><span class="command">have</span></span> prem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">(</span><span class="skolem">c</span><span class="main">,</span> <span class="skolem">β</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">)</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="skolem">vs</span> <span class="main">[↦]</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">|</span>
        <span class="main">⪅</span> <span class="main">(</span><span class="skolem">c</span><span class="main">,</span>  <span class="main">|</span><span class="skolem">β</span><span class="main">|</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="skolem">b_a</span><span class="main">)</span><span class="main">,</span> <span class="skolem">ve_a</span> <span class="main">∪.</span> <span class="main">(</span><span class="main">⋃.</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b_a</span><span class="main">)</span> <span class="main">:=</span> <span class="bound">y</span><span class="main">}.</span><span class="main">)</span> <span class="main">(</span>zip <span class="skolem">vs</span> <span class="skolem">ds_a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="skolem">b_a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_b
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>cstate_approx.intros <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_cstate.simps<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">evalC</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">c</span><span class="main">,</span> <span class="skolem">β</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">)</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="skolem">vs</span> <span class="main">[↦]</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
        <span class="main">⪅</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>PC <span class="main">(</span>Lambda <span class="skolem">lab</span> <span class="skolem">vs</span> <span class="skolem">c</span><span class="main">,</span> <span class="main">|</span><span class="skolem">β</span><span class="main">|</span> <span class="main">)</span><span class="main">,</span> <span class="skolem">ds_a</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="skolem">b_a</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Next.hyps<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> prem<span class="main">]</span> ds_a_length
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> a_evalF.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>a_evalF.simps a_evalC.simps<span class="main">)</span>

  <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case Plus›</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">lab</span> <span class="skolem">a1</span> <span class="skolem">a2</span> <span class="skolem">cnt</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"isProc <span class="skolem">cnt</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> abs_ds'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{}</span><span class="main">,</span> <span class="main">{}</span><span class="main">,</span> <span class="main">|</span><span class="skolem">cnt</span><span class="main">|</span> <span class="main">]</span> <span class="main">⪅</span> <span class="skolem">ds_a</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a1_a</span></span> <span class="skolem"><span class="skolem">a2_a</span></span> <span class="skolem"><span class="skolem">cnt_a</span></span> <span class="keyword2"><span class="keyword">where</span></span> ds_a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ds_a</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">a1_a</span><span class="main">,</span> <span class="skolem">a2_a</span><span class="main">,</span> <span class="skolem">cnt_a</span><span class="main">]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> abs_cnt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">cnt</span><span class="main">|</span> <span class="main">⪅</span> <span class="skolem">cnt_a</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ds_approx_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ds_a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>list.exhaust<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ list.exhaust<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> _ list.exhaust<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">of</span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span>"</span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span>  <span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>ds_approx_def<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> new_elem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="main">[</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="skolem">cnt</span><span class="main">)</span><span class="main">}</span><span class="main">|</span> <span class="main">⪅</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="main">[</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="skolem">b_a</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="bound">cont</span><span class="main">)</span> <span class="main">|</span><span class="bound">cont</span><span class="main">.</span> <span class="bound">cont</span> <span class="main">∈</span> <span class="skolem">cnt_a</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_cnt <span class="keyword2"><span class="keyword">and</span></span> abs_b
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>ccache_approx_def d_approx_def<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> prem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[</span>DI <span class="main">(</span><span class="skolem">a1</span> <span class="main">+</span> <span class="skolem">a2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">|</span> <span class="main">⪅</span>
              <span class="main">(</span>the_elem <span class="main">|</span><span class="skolem">cnt</span><span class="main">|</span><span class="main">,</span> <span class="main">[</span><span class="main">{}</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="skolem">lab</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_ve <span class="keyword2"><span class="keyword">and</span></span> abs_b
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>fstate_approx.intros <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>ds_approx_def<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[</span>DI <span class="main">(</span><span class="skolem">a1</span> <span class="main">+</span> <span class="skolem">a2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
       <span class="main">⪅</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>the_elem <span class="main">|</span><span class="skolem">cnt</span><span class="main">|</span><span class="main">,</span> <span class="main">[</span><span class="main">{}</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Next.hyps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> prem<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⪅</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="skolem">cnt_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[</span><span class="main">{}</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_cnt
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> the_elem_is_Proc<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹isProc <span class="skolem">cnt</span>›</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> a_evalF.simps <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>ccache_approx_def d_approx_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword1"><span class="command">have</span></span> old_elems<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[</span>DI <span class="main">(</span><span class="skolem">a1</span> <span class="main">+</span> <span class="skolem">a2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
       <span class="main">⪅</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="skolem">cnt_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[</span><span class="main">{}</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">(</span><span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[</span>DI <span class="main">(</span><span class="skolem">a1</span> <span class="main">+</span> <span class="skolem">a2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="main">[</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="skolem">cnt</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">|</span>
        <span class="main">⪅</span> <span class="main">|</span><span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[</span>DI <span class="main">(</span><span class="skolem">a1</span> <span class="main">+</span> <span class="skolem">a2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
          <span class="main">∪</span> <span class="main">|</span><span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="main">[</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="skolem">cnt</span><span class="main">)</span><span class="main">}</span><span class="main">|</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> abs_ccache_union<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⪅</span>
        <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="skolem">cnt_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[</span><span class="main">{}</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="main">[</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="skolem">b_a</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="bound">cont</span><span class="main">)</span> <span class="main">|</span><span class="bound">cont</span><span class="main">.</span> <span class="bound">cont</span> <span class="main">∈</span> <span class="skolem">cnt_a</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Un_mono_approx<span class="main"><span class="main">[</span></span><span class="operator">OF</span> old_elems new_elem<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span>insert <span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="main">[</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="skolem">cnt</span><span class="main">)</span>
                <span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[</span>DI <span class="main">(</span><span class="skolem">a1</span> <span class="main">+</span> <span class="skolem">a2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
        <span class="main">⪅</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>PP <span class="main">(</span>prim.Plus <span class="skolem">lab</span><span class="main">)</span><span class="main">,</span> <span class="skolem">ds_a</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="skolem">b_a</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> ds_a <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> a_evalF.simps<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>a_evalF.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case If (true branch)›</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ct</span> <span class="skolem">cf</span> <span class="skolem">v</span> <span class="skolem">cntt</span> <span class="skolem">cntf</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"isProc <span class="skolem">cntt</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"isProc <span class="skolem">cntf</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> abs_ds'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{}</span><span class="main">,</span> <span class="main">|</span><span class="skolem">cntt</span><span class="main">|</span><span class="main">,</span> <span class="main">|</span><span class="skolem">cntf</span><span class="main">|</span> <span class="main">]</span> <span class="main">⪅</span> <span class="skolem">ds_a</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v_a</span></span> <span class="skolem"><span class="skolem">cntt_a</span></span> <span class="skolem"><span class="skolem">cntf_a</span></span> <span class="keyword2"><span class="keyword">where</span></span> ds_a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ds_a</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">v_a</span><span class="main">,</span> <span class="skolem">cntt_a</span><span class="main">,</span> <span class="skolem">cntf_a</span><span class="main">]</span>"</span></span>
                              <span class="keyword2"><span class="keyword">and</span></span> abs_cntt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">cntt</span><span class="main">|</span> <span class="main">⪅</span> <span class="skolem">cntt_a</span>"</span></span>
                              <span class="keyword2"><span class="keyword">and</span></span> abs_cntf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">cntf</span><span class="main">|</span> <span class="main">⪅</span> <span class="skolem">cntf_a</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ds_a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>list.exhaust<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ list.exhaust<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> _ list.exhaust<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">of</span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span>"</span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span>  <span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>ds_approx_def<span class="main">)</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?c</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">ct</span><span class="main">::</span>label"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?cnt</span></span></span> <span class="main">=</span> <span class="quoted"><span class="skolem">cntt</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?cnt_a</span></span></span> <span class="main">=</span> <span class="quoted"><span class="skolem">cntt_a</span></span>

  <span class="keyword1"><span class="command">have</span></span> new_elem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">[</span><span class="var">?c</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="var">?cnt</span><span class="main">)</span><span class="main">}</span><span class="main">|</span> <span class="main">⪅</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">[</span><span class="var">?c</span> <span class="main">↦</span> <span class="skolem">b_a</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="bound">cont</span><span class="main">)</span> <span class="main">|</span><span class="bound">cont</span><span class="main">.</span> <span class="bound">cont</span> <span class="main">∈</span> <span class="var">?cnt_a</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_cntt <span class="keyword2"><span class="keyword">and</span></span> abs_cntf <span class="keyword2"><span class="keyword">and</span></span> abs_b 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>ccache_approx_def d_approx_def<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> prem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">(</span><span class="var">?cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="var">?c</span><span class="main">)</span><span class="main">|</span> <span class="main">⪅</span>
              <span class="main">(</span>the_elem <span class="main">|</span><span class="var">?cnt</span><span class="main">|</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="var">?c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_ve <span class="keyword2"><span class="keyword">and</span></span> abs_b
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>fstate_approx.intros<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="var">?cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
       <span class="main">⪅</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>the_elem <span class="main">|</span><span class="var">?cnt</span><span class="main">|</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Next.hyps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> prem<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⪅</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="var">?cnt_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_cntt <span class="keyword2"><span class="keyword">and</span></span> abs_cntf
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> the_elem_is_Proc<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹isProc <span class="var">?cnt</span>›</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> a_evalF.simps <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>ccache_approx_def d_approx_def<span class="main">)</span>

  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword1"><span class="command">have</span></span> old_elems<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="var">?cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
       <span class="main">⪅</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="var">?cnt_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="var">?cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span>
          <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">[</span><span class="var">?c</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="var">?cnt</span><span class="main">)</span><span class="main">}</span><span class="main">|</span>
        <span class="main">⪅</span> <span class="main">|</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="var">?cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
          <span class="main">∪</span> <span class="main">|</span><span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">[</span><span class="var">?c</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="var">?cnt</span><span class="main">)</span><span class="main">}</span><span class="main">|</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> abs_ccache_union<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⪅</span>
        <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="var">?cnt_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">[</span><span class="var">?c</span> <span class="main">↦</span> <span class="skolem">b_a</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="bound">cont</span><span class="main">)</span> <span class="main">|</span><span class="bound">cont</span><span class="main">.</span> <span class="bound">cont</span> <span class="main">∈</span> <span class="var">?cnt_a</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Un_mono_approx<span class="main"><span class="main">[</span></span><span class="operator">OF</span> old_elems new_elem<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⪅</span>
        <span class="main">(</span><span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="skolem">cntt_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="skolem">ct</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">ct</span><span class="main">,</span> <span class="main">[</span><span class="skolem">ct</span> <span class="main">↦</span> <span class="skolem">b_a</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="bound">cont</span><span class="main">)</span> <span class="main">|</span><span class="bound">cont</span><span class="main">.</span> <span class="bound">cont</span> <span class="main">∈</span> <span class="skolem">cntt_a</span><span class="main">}</span><span class="main">)</span>
      <span class="main">∪</span> <span class="main">(</span><span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="skolem">cntf_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="skolem">cf</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">cf</span><span class="main">,</span> <span class="main">[</span><span class="skolem">cf</span> <span class="main">↦</span> <span class="skolem">b_a</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="bound">cont</span><span class="main">)</span> <span class="main">|</span><span class="bound">cont</span><span class="main">.</span> <span class="bound">cont</span> <span class="main">∈</span> <span class="skolem">cntf_a</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Un_upper1_approx<span class="main"><span class="keyword3">|</span></span><span class="operator">rule</span> Un_upper2_approx<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span>insert <span class="main">(</span><span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">[</span><span class="var">?c</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="var">?cnt</span><span class="main">)</span>
                <span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="var">?cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">|</span> <span class="main">⪅</span>
          <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>PP <span class="main">(</span>prim.If <span class="skolem">ct</span> <span class="skolem">cf</span><span class="main">)</span><span class="main">,</span> <span class="skolem">ds_a</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="skolem">b_a</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> ds_a <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> a_evalF.simps<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>a_evalF.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case If (false branch). We use schematic variable to keep this similar to the true branch.›</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ct</span> <span class="skolem">cf</span> <span class="skolem">v</span> <span class="skolem">cntt</span> <span class="skolem">cntf</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"isProc <span class="skolem">cntt</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"isProc <span class="skolem">cntf</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> abs_ds'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{}</span><span class="main">,</span> <span class="main">|</span><span class="skolem">cntt</span><span class="main">|</span><span class="main">,</span> <span class="main">|</span><span class="skolem">cntf</span><span class="main">|</span> <span class="main">]</span> <span class="main">⪅</span> <span class="skolem">ds_a</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v_a</span></span> <span class="skolem"><span class="skolem">cntt_a</span></span> <span class="skolem"><span class="skolem">cntf_a</span></span> <span class="keyword2"><span class="keyword">where</span></span> ds_a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ds_a</span> <span class="main">=</span> <span class="main">[</span><span class="skolem">v_a</span><span class="main">,</span> <span class="skolem">cntt_a</span><span class="main">,</span> <span class="skolem">cntf_a</span><span class="main">]</span>"</span></span>
                              <span class="keyword2"><span class="keyword">and</span></span> abs_cntt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">cntt</span><span class="main">|</span> <span class="main">⪅</span> <span class="skolem">cntt_a</span>"</span></span>
                              <span class="keyword2"><span class="keyword">and</span></span> abs_cntf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">cntf</span><span class="main">|</span> <span class="main">⪅</span> <span class="skolem">cntf_a</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ds_a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>list.exhaust<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ list.exhaust<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> _ list.exhaust<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">of</span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span>"</span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">,</span></span>  <span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>ds_approx_def<span class="main">)</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?c</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">cf</span><span class="main">::</span>label"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?cnt</span></span></span> <span class="main">=</span> <span class="quoted"><span class="skolem">cntf</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?cnt_a</span></span></span> <span class="main">=</span> <span class="quoted"><span class="skolem">cntf_a</span></span>

  <span class="keyword1"><span class="command">have</span></span> new_elem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">[</span><span class="var">?c</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="var">?cnt</span><span class="main">)</span><span class="main">}</span><span class="main">|</span> <span class="main">⪅</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">[</span><span class="var">?c</span> <span class="main">↦</span> <span class="skolem">b_a</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="bound">cont</span><span class="main">)</span> <span class="main">|</span><span class="bound">cont</span><span class="main">.</span> <span class="bound">cont</span> <span class="main">∈</span> <span class="var">?cnt_a</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_cntt <span class="keyword2"><span class="keyword">and</span></span> abs_cntf <span class="keyword2"><span class="keyword">and</span></span> abs_b 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>ccache_approx_def d_approx_def<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> prem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">(</span><span class="var">?cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="var">?c</span><span class="main">)</span><span class="main">|</span> <span class="main">⪅</span>
              <span class="main">(</span>the_elem <span class="main">|</span><span class="var">?cnt</span><span class="main">|</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="var">?c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_ve <span class="keyword2"><span class="keyword">and</span></span> abs_b
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>fstate_approx.intros<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="var">?cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
       <span class="main">⪅</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>the_elem <span class="main">|</span><span class="var">?cnt</span><span class="main">|</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Next.hyps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> prem<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⪅</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="var">?cnt_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_cntt <span class="keyword2"><span class="keyword">and</span></span> abs_cntf
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> the_elem_is_Proc<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹isProc <span class="var">?cnt</span>›</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> a_evalF.simps <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>ccache_approx_def d_approx_def<span class="main">)</span>

  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword1"><span class="command">have</span></span> old_elems<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="var">?cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
       <span class="main">⪅</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="var">?cnt_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="var">?cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span>
          <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">[</span><span class="var">?c</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="var">?cnt</span><span class="main">)</span><span class="main">}</span><span class="main">|</span>
        <span class="main">⪅</span> <span class="main">|</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="var">?cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
          <span class="main">∪</span> <span class="main">|</span><span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">[</span><span class="var">?c</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="var">?cnt</span><span class="main">)</span><span class="main">}</span><span class="main">|</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> abs_ccache_union<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⪅</span>
        <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="var">?cnt_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">[</span><span class="var">?c</span> <span class="main">↦</span> <span class="skolem">b_a</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="bound">cont</span><span class="main">)</span> <span class="main">|</span><span class="bound">cont</span><span class="main">.</span> <span class="bound">cont</span> <span class="main">∈</span> <span class="var">?cnt_a</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Un_mono_approx<span class="main"><span class="main">[</span></span><span class="operator">OF</span> old_elems new_elem<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⪅</span>
        <span class="main">(</span><span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="skolem">cntt_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="skolem">ct</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">ct</span><span class="main">,</span> <span class="main">[</span><span class="skolem">ct</span> <span class="main">↦</span> <span class="skolem">b_a</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="bound">cont</span><span class="main">)</span> <span class="main">|</span><span class="bound">cont</span><span class="main">.</span> <span class="bound">cont</span> <span class="main">∈</span> <span class="skolem">cntt_a</span><span class="main">}</span><span class="main">)</span>
      <span class="main">∪</span> <span class="main">(</span><span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="skolem">cntf_a</span><span class="main">.</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b_a</span> <span class="skolem">cf</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">cf</span><span class="main">,</span> <span class="main">[</span><span class="skolem">cf</span> <span class="main">↦</span> <span class="skolem">b_a</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="bound">cont</span><span class="main">)</span> <span class="main">|</span><span class="bound">cont</span><span class="main">.</span> <span class="bound">cont</span> <span class="main">∈</span> <span class="skolem">cntf_a</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Un_upper1_approx<span class="main"><span class="keyword3">|</span></span><span class="operator">rule</span> Un_upper2_approx<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span>insert <span class="main">(</span><span class="main">(</span><span class="var">?c</span><span class="main">,</span> <span class="main">[</span><span class="var">?c</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="var">?cnt</span><span class="main">)</span>
                <span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="var">?cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="var">?c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">|</span> <span class="main">⪅</span>
          <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>PP <span class="main">(</span>prim.If <span class="skolem">ct</span> <span class="skolem">cf</span><span class="main">)</span><span class="main">,</span> <span class="skolem">ds_a</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="skolem">b_a</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> ds_a <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> a_evalF.simps<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>a_evalF.simps<span class="main">)</span>
 <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> 2
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">β</span></span> <span class="skolem"><span class="skolem">ve</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> cstate<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cstate</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">c</span><span class="main">,</span><span class="skolem">β</span><span class="main">,</span><span class="skolem">ve</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">cstate</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c_a</span></span> <span class="skolem"><span class="skolem">β_a</span></span> <span class="skolem"><span class="skolem">ds_a</span></span> <span class="skolem"><span class="skolem">ve_a</span></span> <span class="skolem"><span class="skolem">b_a</span></span> <span class="keyword2"><span class="keyword">where</span></span> cstate_a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cstate_a</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">c_a</span><span class="main">,</span><span class="skolem">β_a</span><span class="main">,</span><span class="skolem">ve_a</span><span class="main">,</span><span class="skolem">b_a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">cstate_a</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword1"><span class="command">have</span></span> abs_c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">=</span> <span class="skolem">c_a</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> abs_β<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">β</span><span class="main">|</span> <span class="main">=</span> <span class="skolem">β_a</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> abs_ve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">ve</span><span class="main">|</span> <span class="main">⪅</span> <span class="skolem">ve_a</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> abs_b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="main">=</span> <span class="skolem">b_a</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span>cstate_approx.cases<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> cstate cstate_a abs_c abs_β abs_b
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">c</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>HOL.Let_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>a_evalF.simps a_evalC.simps set_map evalV.simps<span class="main">)</span>

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case App›</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">lab</span> <span class="skolem">f</span> <span class="skolem">vs</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?d</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">𝒜</span> <span class="skolem">f</span> <span class="skolem">β</span> <span class="skolem">ve</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"isProc <span class="var">?d</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map <span class="main">(</span>abs_d <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">𝒜</span> <span class="bound">v</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span><span class="main">)</span> <span class="skolem">vs</span> <span class="main">⪅</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">v</span> <span class="skolem">β_a</span> <span class="skolem">ve_a</span><span class="main">)</span> <span class="skolem">vs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_β <span class="keyword2"><span class="keyword">and</span></span> lemma7<span class="main">[</span><span class="operator">OF</span> abs_ve<span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">β</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> list_all2I <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>set_zip ds_approx_def<span class="main">)</span>

  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="var">?d</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">𝒜</span> <span class="bound">v</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
     <span class="main">⪅</span> <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr<span class="main">(</span>the_elem <span class="main">|</span><span class="var">?d</span><span class="main">|</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">v</span> <span class="skolem">β_a</span> <span class="skolem">ve_a</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_ve <span class="keyword2"><span class="keyword">and</span></span> abs_cnt_nb <span class="keyword2"><span class="keyword">and</span></span> abs_b
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> Next.hyps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>fstate_approx.intros<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⪅</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">f'</span><span class="main">∈</span><span class="main">\&lt;aA&gt;</span> <span class="skolem">f</span> <span class="skolem">β_a</span> <span class="skolem">ve_a</span><span class="main">.</span>
              <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr<span class="main">(</span><span class="bound">f'</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">v</span> <span class="skolem">β_a</span> <span class="skolem">ve_a</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> lemma7<span class="main">[</span><span class="operator">OF</span> abs_ve<span class="main">]</span> the_elem_is_Proc<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹isProc <span class="var">?d</span>›</span></span><span class="main">]</span> abs_β
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> a_evalF.simps <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>d_approx_def ccache_approx_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword1"><span class="command">have</span></span> old_elems<span class="main">:</span> <span class="quoted"><span class="quoted">"
     <span class="main">|</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="keyword1">𝒜</span> <span class="skolem">f</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">𝒜</span> <span class="bound">v</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
     <span class="main">⪅</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">f'</span><span class="main">∈</span> <span class="main">\&lt;aA&gt;</span> <span class="skolem">f</span> <span class="skolem">β_a</span> <span class="skolem">ve_a</span><span class="main">.</span>
              <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr<span class="main">(</span><span class="bound">f'</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">v</span> <span class="skolem">β_a</span> <span class="skolem">ve_a</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> new_elem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="skolem">β</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="skolem">f</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span><span class="main">}</span><span class="main">|</span>
                  <span class="main">⪅</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="skolem">β_a</span><span class="main">)</span><span class="main">,</span> <span class="bound">f'</span><span class="main">)</span> <span class="main">|</span><span class="bound">f'</span><span class="main">.</span> <span class="bound">f'</span> <span class="main">∈</span> <span class="main">\&lt;aA&gt;</span> <span class="skolem">f</span> <span class="skolem">β_a</span> <span class="skolem">ve_a</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_β <span class="keyword2"><span class="keyword">and</span></span> lemma7<span class="main">[</span><span class="operator">OF</span> abs_ve<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>ccache_approx_def d_approx_def<span class="main">)</span>
 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="keyword1">𝒜</span> <span class="skolem">f</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">𝒜</span> <span class="bound">v</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span>
        <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="skolem">β</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="skolem">f</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span><span class="main">}</span><span class="main">|</span>
        <span class="main">⪅</span> <span class="main">|</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="keyword1">𝒜</span> <span class="skolem">f</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">𝒜</span> <span class="bound">v</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
        <span class="main">∪</span> <span class="main">|</span><span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="skolem">β</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="skolem">f</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span><span class="main">}</span><span class="main">|</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> abs_ccache_union<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span>
        <span class="main">⪅</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">f'</span><span class="main">∈</span><span class="main">\&lt;aA&gt;</span> <span class="skolem">f</span> <span class="skolem">β_a</span> <span class="skolem">ve_a</span><span class="main">.</span>
              <span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr<span class="main">(</span><span class="bound">f'</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">v</span> <span class="skolem">β_a</span> <span class="skolem">ve_a</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="skolem">β_a</span><span class="main">)</span><span class="main">,</span> <span class="bound">f'</span><span class="main">)</span> <span class="main">|</span><span class="bound">f'</span><span class="main">.</span> <span class="bound">f'</span> <span class="main">∈</span> <span class="main">\&lt;aA&gt;</span> <span class="skolem">f</span> <span class="skolem">β_a</span> <span class="skolem">ve_a</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Un_mono_approx<span class="main"><span class="main">[</span></span><span class="operator">OF</span> old_elems new_elem<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span>insert <span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="skolem">β</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="skolem">f</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span>
                <span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="keyword1">𝒜</span> <span class="skolem">f</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">𝒜</span> <span class="bound">v</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
        <span class="main">⪅</span> <span class="main">\&lt;aC&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>App <span class="skolem">lab</span> <span class="skolem">f</span> <span class="skolem">vs</span><span class="main">,</span> <span class="main">|</span><span class="skolem">β</span><span class="main">|</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_β
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> a_evalC.simps<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HOL.Let_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>a_evalF.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case Let›</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">lab</span> <span class="skolem">binds</span> <span class="skolem">c'</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">β</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">|</span> <span class="main">=</span>
        <span class="skolem">β_a</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_β <span class="keyword2"><span class="keyword">and</span></span> abs_b
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span>map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">,</span>
                                 DC <span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="skolem">β</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                     <span class="skolem">binds</span><span class="main">)</span><span class="main">|</span>
    <span class="main">⪅</span> <span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span><span class="main">.</span>
              <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span> <span class="main">:=</span>  <span class="main">{</span>PC <span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="skolem">β_a</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">}.</span><span class="main">)</span>
              <span class="skolem">binds</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_b <span class="keyword2"><span class="keyword">and</span></span> abs_β
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> venv_approx_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> abs_venv_map_of<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>smap_union_mono list_all2I
              <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>venv_approx_def o_def set_zip abs_venv_singleton split_def smap_less_refl<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">ve</span> <span class="main">++</span> map_of
            <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span><span class="main">.</span>
                   <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">,</span>
                    DC <span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="skolem">β</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                  <span class="skolem">binds</span><span class="main">)</span><span class="main">|</span> <span class="main">⪅</span>
        <span class="skolem">ve_a</span> <span class="main">∪.</span>
        <span class="main">(</span><span class="main">⋃.</span>
          <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span><span class="main">.</span>
            <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span> <span class="main">:=</span>  <span class="main">{</span>PC <span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="skolem">β_a</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">}.</span><span class="main">)</span>
            <span class="skolem">binds</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> venv_approx_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> abs_venv_union
      smap_union_mono<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> abs_ve<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">unfolded</span> venv_approx_def<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">folded</span> venv_approx_def<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">evalC</span><span class="main">⋅</span><span class="main">(</span>Discr<span class="main">(</span><span class="skolem">c'</span><span class="main">,</span> <span class="skolem">β</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">,</span>
            <span class="skolem">ve</span> <span class="main">++</span> map_of
                  <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">,</span> DC <span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="skolem">β</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">binds</span><span class="main">)</span><span class="main">,</span>
            nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">|</span>
    <span class="main">⪅</span> <span class="main">\&lt;aC&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">c'</span><span class="main">,</span> <span class="skolem">β_a</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">,</span>
            <span class="skolem">ve_a</span> <span class="main">∪.</span>
             <span class="main">(</span><span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span><span class="main">.</span>
                   <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span> <span class="main">:=</span>  <span class="main">{</span>PC <span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="skolem">β_a</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">}.</span><span class="main">)</span>
                   <span class="skolem">binds</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
         <span class="main">\&lt;anb&gt;</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_cnt_nb <span class="keyword2"><span class="keyword">and</span></span> abs_b
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> Next.hyps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> cstate_approx.intros<span class="main">)</span>

  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="skolem">evalC</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">c'</span><span class="main">,</span> <span class="skolem">β</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">,</span>
                      <span class="skolem">ve</span> <span class="main">++</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span><span class="main">.</span><span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">,</span><span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="main">(</span><span class="skolem">β</span><span class="main">(</span><span class="skolem">lab</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span> <span class="skolem">ve</span><span class="main">)</span><span class="main">)</span> <span class="skolem">binds</span><span class="main">)</span><span class="main">,</span>
                      nb <span class="skolem">b</span> <span class="skolem">lab</span><span class="main">)</span><span class="main">)</span><span class="main">|</span> <span class="main">⪅</span>
          <span class="main">\&lt;aC&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>call.Let <span class="skolem">lab</span> <span class="skolem">binds</span> <span class="skolem">c'</span><span class="main">,</span> <span class="main">|</span><span class="skolem">β</span><span class="main">|</span><span class="main">,</span> <span class="skolem">ve_a</span><span class="main">,</span> <span class="main">|</span><span class="skolem">b</span><span class="main">|</span> <span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> abs_β
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> a_evalC.simps<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HOL.Let_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>a_evalC.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
And finally, we lift this result to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aPR&gt;›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;PR&gt;›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lemma6<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">|</span><span class="main">\&lt;PR&gt;</span> <span class="free">l</span><span class="main">|</span> <span class="main">⪅</span> <span class="main">\&lt;aPR&gt;</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> evalCPS_def evalCPS_a_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>lemma89 fstate_approx.intros <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>evalF.simps a_evalF.simps
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ds_approx_def d_approx_def venv_approx_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="ExCFSV">
<div class="head">
<h1>Theory ExCFSV</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The exact call cache is a map›</span></span>

<span class="keyword1"><span class="command">theory</span></span> ExCFSV
<span class="keyword2"><span class="keyword">imports</span></span> <a href="ExCF.html">ExCF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Preparations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Before we state the main result of this section, we need to define
\begin{itemize}
\item the set of binding environments occurring in a semantic value (which exists only if it is a closure),
\item the set of binding environments in a variable environment, using the previous definition,
\item the set of contour counters occurring in a semantic value and
\item the set of contour counters occurring in a variable environment.
\end{itemize}
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">benv_in_d</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"d <span class="main">⇒</span> benv set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">benv_in_d</span> <span class="main">(</span>DC <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">}</span>"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">benv_in_d</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">benv_in_ve</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"venv <span class="main">⇒</span> benv set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">benv_in_ve</span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span> <span class="main">⋃</span><span class="main">{</span>benv_in_d <span class="bound">d</span> <span class="main">|</span> <span class="bound">d</span> <span class="main">.</span> <span class="bound">d</span> <span class="main">∈</span> ran <span class="free"><span class="bound"><span class="entity">ve</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">contours_in_d</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"d <span class="main">⇒</span> contour set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">contours_in_d</span> <span class="main">(</span>DC <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ran <span class="free"><span class="bound"><span class="entity">β</span></span></span>"</span></span>
      <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">contours_in_d</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">contours_in_ve</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"venv <span class="main">⇒</span> contour set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">contours_in_ve</span> <span class="free"><span class="bound"><span class="entity">ve</span></span></span> <span class="main">=</span> <span class="main">⋃</span><span class="main">{</span>contours_in_d <span class="bound">d</span> <span class="main">|</span> <span class="bound">d</span> <span class="main">.</span> <span class="bound">d</span> <span class="main">∈</span> ran <span class="free"><span class="bound"><span class="entity">ve</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The following 6 lemmas allow us to calculate the above definition, when applied to constructs used in our semantics function, e.g. map updates, empty maps etc.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> benv_in_ve_upds<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eq_length<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">vs</span> <span class="main">=</span> length <span class="free">ds</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">β</span><span class="main">∈</span>benv_in_ve <span class="free">ve</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">β</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d'</span><span class="main">∈</span>set <span class="free">ds</span><span class="main">.</span> <span class="main">∀</span><span class="bound">β</span><span class="main">∈</span>benv_in_d <span class="bound">d'</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">β</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">β</span><span class="main">∈</span>benv_in_ve <span class="main">(</span><span class="free">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="free">b''</span><span class="main">)</span><span class="main">)</span> <span class="free">vs</span> <span class="main">[↦]</span> <span class="free">ds</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">β</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">β</span>
  <span class="keyword3"><span class="command">assume</span></span> ass<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">β</span> <span class="main">∈</span> benv_in_ve <span class="main">(</span><span class="free">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="free">b''</span><span class="main">)</span><span class="main">)</span> <span class="free">vs</span> <span class="main">[↦]</span> <span class="free">ds</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">β</span><span class="main">∈</span>benv_in_d <span class="skolem">d</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> ran <span class="main">(</span><span class="free">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="free">b''</span><span class="main">)</span><span class="main">)</span> <span class="free">vs</span> <span class="main">[↦]</span> <span class="free">ds</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> benv_in_ve_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ran <span class="main">(</span><span class="free">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="free">b''</span><span class="main">)</span><span class="main">)</span> <span class="free">vs</span> <span class="main">[↦]</span> <span class="free">ds</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> ran <span class="free">ve</span> <span class="main">∪</span> set <span class="free">ds</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq_length <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>ran_upds<span class="main">)</span> 
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> ran <span class="free">ve</span> <span class="main">∨</span> <span class="skolem">d</span> <span class="main">∈</span> set <span class="free">ds</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="skolem">β</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="skolem">β</span><span class="main">∈</span>benv_in_d <span class="skolem">d</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> benv_in_ve_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> benv_in_eval<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">β'</span><span class="main">∈</span>benv_in_ve <span class="free">ve</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">β'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">β</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">β</span><span class="main">∈</span>benv_in_d <span class="main">(</span><span class="keyword1">𝒜</span> <span class="free">v</span> <span class="free">β</span> <span class="free">ve</span><span class="main">)</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">β</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>R _ <span class="skolem">var</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">β</span> <span class="main">(</span>fst <span class="skolem">var</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> None <span class="keyword1"><span class="command">with</span></span> R <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">cnt</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ve</span> <span class="main">(</span><span class="skolem">var</span><span class="main">,</span><span class="skolem">cnt</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> None <span class="keyword1"><span class="command">with</span></span> Some R <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">d</span><span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> ran <span class="free">ve</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ran_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Some <span class="quoted"><span class="quoted">‹<span class="free">β</span> <span class="main">(</span>fst <span class="skolem">var</span><span class="main">)</span> <span class="main">=</span> Some <span class="skolem">cnt</span>›</span></span> R assms<span class="main">(</span>1<span class="main">)</span>
          <span class="keyword1"><span class="command">unfolding</span></span> benv_in_ve_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>L <span class="skolem">l</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> C <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> P <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> contours_in_ve_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"contours_in_ve Map.empty <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> contours_in_ve_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> contours_in_ve_upds<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eq_length<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">vs</span> <span class="main">=</span> length <span class="free">ds</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_ve <span class="free">ve</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">b'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d'</span><span class="main">∈</span>set <span class="free">ds</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="bound">d'</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">b'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_ve <span class="main">(</span><span class="free">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="free">b''</span><span class="main">)</span><span class="main">)</span> <span class="free">vs</span> <span class="main">[↦]</span> <span class="free">ds</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">b'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ran <span class="main">(</span><span class="free">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="free">b''</span><span class="main">)</span><span class="main">)</span> <span class="free">vs</span> <span class="main">[↦]</span> <span class="free">ds</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> ran <span class="free">ve</span> <span class="main">∪</span> set <span class="free">ds</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> eq_length <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>ran_upds<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> contours_in_ve_def  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> contours_in_ve_upds_binds<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_ve <span class="free">ve</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">b'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>ran <span class="free">β'</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">b'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_ve <span class="main">(</span><span class="free">ve</span> <span class="main">++</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">b''</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="free">β'</span> <span class="free">ve</span><span class="main">)</span><span class="main">)</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">b'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">b'</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b'</span><span class="main">∈</span>contours_in_ve <span class="main">(</span><span class="free">ve</span> <span class="main">++</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">b''</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="free">β'</span> <span class="free">ve</span><span class="main">)</span><span class="main">)</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="keyword2"><span class="keyword">where</span></span> d<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> ran <span class="main">(</span><span class="free">ve</span> <span class="main">++</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">b''</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="free">β'</span> <span class="free">ve</span><span class="main">)</span><span class="main">)</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> b<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">b'</span> <span class="main">∈</span> contours_in_d <span class="skolem">d</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> contours_in_ve_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ran <span class="main">(</span><span class="free">ve</span> <span class="main">++</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">b''</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="free">β'</span> <span class="free">ve</span><span class="main">)</span><span class="main">)</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> ran <span class="free">ve</span> <span class="main">∪</span> ran <span class="main">(</span>map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">b''</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="free">β'</span> <span class="free">ve</span><span class="main">)</span><span class="main">)</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>ran_concat<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊆</span> ran <span class="free">ve</span> <span class="main">∪</span> snd <span class="main">`</span> set <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">b''</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="free">β'</span> <span class="free">ve</span><span class="main">)</span><span class="main">)</span> <span class="free">ls</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Un_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"ran <span class="free"><span class="free"><span class="free">ve</span></span></span>"</span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"ran <span class="free"><span class="free"><span class="free">ve</span></span></span>"</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> subset_refl ran_map_of<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊆</span> ran <span class="free">ve</span> <span class="main">∪</span> set <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="free">β'</span> <span class="free">ve</span><span class="main">)</span><span class="main">)</span> <span class="free">ls</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Un_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"ran <span class="free"><span class="free"><span class="free">ve</span></span></span>"</span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"ran <span class="free"><span class="free"><span class="free">ve</span></span></span>"</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> subset_refl <span class="main"><span class="main">]</span></span><span class="main">)</span><span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span>  ran <span class="free">ve</span> <span class="main">∪</span> set <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="free">β'</span> <span class="free">ve</span><span class="main">)</span><span class="main">)</span> <span class="free">ls</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> d <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="skolem">b'</span>"</span></span>  <span class="keyword1"><span class="command">using</span></span> assms b <span class="keyword1"><span class="command">unfolding</span></span> contours_in_ve_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> contours_in_eval<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_ve <span class="free">ve</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">b'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span> ran <span class="free">β</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">b'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="main">(</span><span class="keyword1">𝒜</span> <span class="free">f</span> <span class="free">β</span> <span class="free">ve</span><span class="main">)</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">b'</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> contours_in_ve_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>R _ <span class="skolem">var</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">β</span> <span class="main">(</span>fst <span class="skolem">var</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> None <span class="keyword1"><span class="command">with</span></span> R <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">cnt</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ve</span> <span class="main">(</span><span class="skolem">var</span><span class="main">,</span><span class="skolem">cnt</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> None <span class="keyword1"><span class="command">with</span></span> Some R <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">d</span><span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> ran <span class="free">ve</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ran_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Some <span class="quoted"><span class="quoted">‹<span class="free">β</span> <span class="main">(</span>fst <span class="skolem">var</span><span class="main">)</span> <span class="main">=</span> Some <span class="skolem">cnt</span>›</span></span> R <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_ve <span class="free">ve</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">b'</span>›</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> contours_in_ve_def
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>L <span class="skolem">l</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span> ran <span class="free">β</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">b'</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> C <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> P <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The proof›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The set returned by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>𝒞›</span></span></span></span> is actually a partial map from callsite/binding environment pairs to called values. The corresponding predicate in Isabelle is <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>single_valued›</span></span></span></span>.

We would like to show an auxiliary result about the contour counter passed to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>𝒞›</span></span></span></span> (such that it is an unused counter when passed to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span> and others) first. Unfortunately, this is not possible with induction proofs over fixed points: While proving the inductive case, one does not show results for the function in question, but for an information-theoretical approximation. Thus, any previously shown results are not available.
We therefore intertwine the two inductions in one large proof.

This is a proof by fixpoint induction, so we have are obliged to show that the predicate is admissible and that it holds for the base case, i.e. the empty set. For the proof of admissibiliy, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../../HOL/HOLCF/HOLCF.html"></a><a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> provides a number of introduction lemmas that, together with some additions in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="HOLCFUtils.html"></a><a href="HOLCFUtils.html">Shivers-CFA.HOLCFUtils</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and the continuity lemmas, mechanically proove admissibiliy. The base case is trivial.

The remaining case is the preservation of the properties when applying the recursive equations to a function known to have have the desired property. Here, we break the proof into the various cases that occur in the definitions of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ℱ›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>𝒞›</span></span></span></span> and use the induction hypothesises.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cc_single_valued'<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">∀</span><span class="bound">b'</span> <span class="main">∈</span> contours_in_ve <span class="free">ve</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> <span class="free">b</span>
       <span class="main">;</span> <span class="main">∀</span><span class="bound">b'</span> <span class="main">∈</span> contours_in_d <span class="free">d</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> <span class="free">b</span>
       <span class="main">;</span> <span class="main">∀</span><span class="bound">d'</span> <span class="main">∈</span> set <span class="free">ds</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b'</span> <span class="main">∈</span> contours_in_d <span class="bound">d'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> <span class="free">b</span>
       <span class="main">⟧</span>
       <span class="main">⟹</span>
       <span class="main">(</span>   single_valued <span class="main">(</span><span class="keyword1">ℱ</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="free">d</span><span class="main">,</span><span class="free">ds</span><span class="main">,</span><span class="free">ve</span><span class="main">,</span><span class="free">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
       <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="main">(</span><span class="main">(</span><span class="bound">lab</span><span class="main">,</span><span class="bound">β</span><span class="main">)</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> <span class="keyword1">ℱ</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="free">d</span><span class="main">,</span><span class="free">ds</span><span class="main">,</span><span class="free">ve</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">b'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">∈</span> ran <span class="bound">β</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">≤</span> <span class="bound">b'</span><span class="main">)</span>
       <span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">b</span> <span class="main">∈</span> ran <span class="free">β'</span>
       <span class="main">;</span> <span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>ran <span class="free">β'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">≤</span> <span class="free">b</span>
       <span class="main">;</span> <span class="main">∀</span><span class="bound">b'</span> <span class="main">∈</span> contours_in_ve <span class="free">ve</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">≤</span> <span class="free">b</span>
       <span class="main">⟧</span>
       <span class="main">⟹</span>
       <span class="main">(</span>   single_valued <span class="main">(</span><span class="keyword1">𝒞</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="free">c</span><span class="main">,</span><span class="free">β'</span><span class="main">,</span><span class="free">ve</span><span class="main">,</span><span class="free">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
       <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="main">(</span><span class="main">(</span><span class="bound">lab</span><span class="main">,</span><span class="bound">β</span><span class="main">)</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> <span class="keyword1">𝒞</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="free">c</span><span class="main">,</span><span class="free">β'</span><span class="main">,</span><span class="free">ve</span><span class="main">,</span><span class="free">b</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">b'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">∈</span> ran <span class="bound">β</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">≤</span> <span class="bound">b'</span><span class="main">)</span>
       <span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">d</span></span> <span class="quoted"><span class="free">ds</span></span> <span class="quoted"><span class="free">ve</span></span> <span class="quoted"><span class="free">b</span></span> <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">β'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>evalF_evalC_induct<span class="main">)</span>
<span class="keyword3"><span class="command">case</span></span> Admissibility <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> adm_lemmas adm_ball' adm_prod_split adm_not_conj adm_not_mem adm_single_valued <span class="dynamic"><span class="dynamic">cont2cont</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> Bottom <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Next <span class="skolem">evalF</span> <span class="skolem">evalC</span><span class="main">)</span>

  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Nicer names for the hypothesises:›</span></span>
  <span class="keyword1"><span class="command">note</span></span> hyps_F_sv <span class="main">=</span> Next.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">THEN</span> conjunct1<span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> hyps_F_b <span class="main">=</span> Next.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">THEN</span> conjunct2<span class="main">,</span> <span class="operator">THEN</span> bspec<span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> hyps_C_sv <span class="main">=</span> Next.hyps<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">THEN</span> conjunct1<span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> hyps_C_b <span class="main">=</span> Next.hyps<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">THEN</span> conjunct2<span class="main">,</span> <span class="operator">THEN</span> bspec<span class="main">]</span>
  <span class="keyword1"><span class="command">{</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">d</span> <span class="skolem">ds</span> <span class="skolem">ve</span> <span class="skolem">b</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">d</span><span class="main">,</span><span class="skolem">ds</span><span class="main">,</span><span class="skolem">ve</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>fstate_case<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>Un_insert_left Un_insert_right<span class="main">)</span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case Closure›</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">lab'</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">vs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"var list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">c</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">β'</span> <span class="main">::</span> <span class="quoted">benv</span>
    <span class="keyword3"><span class="command">assume</span></span> prem_d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>ran <span class="skolem">β'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> eq_length<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">vs</span> <span class="main">=</span> length <span class="skolem">ds</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∈</span>ran <span class="main">(</span><span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">have</span></span> b_dom_beta<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span> ran <span class="main">(</span><span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">≤</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">b'</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b'</span> <span class="main">∈</span> ran <span class="main">(</span><span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b'</span> <span class="main">∈</span> ran <span class="skolem">β'</span> <span class="main">∨</span> <span class="skolem">b'</span> <span class="main">≤</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span>ran_upd<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b'</span> <span class="main">≤</span> <span class="skolem">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> prem_d <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">from</span></span> contours_in_ve_upds<span class="main">[</span><span class="operator">OF</span> eq_length <span class="quoted">"1.prems"</span><span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> <span class="quoted">"1.prems"</span><span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> b_dom_ve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_ve <span class="main">(</span><span class="skolem">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="skolem">vs</span> <span class="main">[↦]</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">≤</span> <span class="skolem">b</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span><span class="skolem">evalC</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">c</span><span class="main">,</span> <span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">)</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="skolem">vs</span> <span class="main">[↦]</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hyps_C_sv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> new b_dom_beta b_dom_ve<span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">c</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">lab</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">β</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">t</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="skolem">β</span><span class="main">)</span><span class="main">,</span> <span class="skolem">t</span><span class="main">)</span><span class="main">∈</span> <span class="skolem">evalC</span><span class="main">⋅</span><span class="main">(</span>Discr<span class="main">(</span><span class="skolem">c</span><span class="main">,</span> <span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">)</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="skolem">vs</span> <span class="main">[↦]</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">b'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">∈</span> ran <span class="skolem">β</span> <span class="main">∧</span> <span class="skolem">b</span> <span class="main">≤</span> <span class="bound">b'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> hyps_C_b<span class="main"><span class="main">[</span></span><span class="operator">OF</span> new b_dom_beta b_dom_ve<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case Plus›</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">cp</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">i1</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">i2</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">cnt</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="skolem">cnt</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> b_dom_d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="skolem">cnt</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">cp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> b_dom_ds<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d'</span> <span class="main">∈</span> set <span class="main">[</span>DI <span class="main">(</span><span class="skolem">i1</span><span class="main">+</span><span class="skolem">i2</span><span class="main">)</span><span class="main">]</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="bound">d'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">cp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> b_dom_ve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span> <span class="main">∈</span> contours_in_ve <span class="skolem">ve</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">cp</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"1.prems"</span><span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">cp</span><span class="main">,</span><span class="main">[</span><span class="skolem">cp</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[</span>DI <span class="main">(</span><span class="skolem">i1</span> <span class="main">+</span> <span class="skolem">i2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">cp</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span>hyps_F_b<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b_dom_ve b_dom_d b_dom_ds<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> hyps_F_sv<span class="main">[</span><span class="operator">OF</span> b_dom_ve b_dom_d b_dom_ds<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span><span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[</span>DI <span class="main">(</span><span class="skolem">i1</span> <span class="main">+</span> <span class="skolem">i2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">cp</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                      <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">cp</span><span class="main">,</span> <span class="main">[</span><span class="skolem">cp</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="skolem">cnt</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>single_valued_insert<span class="main">)</span>

    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">lab</span> <span class="skolem">β</span> <span class="skolem">t</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="skolem">β</span><span class="main">)</span><span class="main">,</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[</span>DI <span class="main">(</span><span class="skolem">i1</span> <span class="main">+</span> <span class="skolem">i2</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">cp</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">b'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">∈</span> ran <span class="skolem">β</span> <span class="main">∧</span> <span class="skolem">b</span> <span class="main">≤</span> <span class="bound">b'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> hyps_F_b<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b_dom_ve b_dom_d b_dom_ds<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case If (true branch)›</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">cp1</span> <span class="skolem">cp2</span> <span class="skolem">i</span> <span class="skolem">cntt</span> <span class="skolem">cntf</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="skolem">cntt</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> b_dom_d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="skolem">cntt</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">cp1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> b_dom_ds<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d'</span> <span class="main">∈</span> set <span class="main">[]</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="bound">d'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">cp1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> b_dom_ve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span> <span class="main">∈</span> contours_in_ve <span class="skolem">ve</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">cp1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"1.prems"</span><span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">cp1</span><span class="main">,</span><span class="main">[</span><span class="skolem">cp1</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cntt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">cp1</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span>hyps_F_b<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b_dom_ve b_dom_d b_dom_ds<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> Next.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> b_dom_ve b_dom_d b_dom_ds<span class="main">,</span> <span class="operator">THEN</span> conjunct1<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span><span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cntt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">cp1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                       <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">cp1</span><span class="main">,</span> <span class="main">[</span><span class="skolem">cp1</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="skolem">cntt</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>single_valued_insert<span class="main">)</span>

    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">lab</span> <span class="skolem">β</span> <span class="skolem">t</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="skolem">β</span><span class="main">)</span><span class="main">,</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cntt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">cp1</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">b'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">∈</span> ran <span class="skolem">β</span> <span class="main">∧</span> <span class="skolem">b</span> <span class="main">≤</span> <span class="bound">b'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> hyps_F_b<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b_dom_ve b_dom_d b_dom_ds<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case If (false branch). Variable names swapped for easier code reuse.›</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">cp2</span> <span class="skolem">cp1</span> <span class="skolem">i</span> <span class="skolem">cntf</span> <span class="skolem">cntt</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="skolem">cntt</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> b_dom_d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="skolem">cntt</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">cp1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> b_dom_ds<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d'</span> <span class="main">∈</span> set <span class="main">[]</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="bound">d'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">cp1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> b_dom_ve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span> <span class="main">∈</span> contours_in_ve <span class="skolem">ve</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">cp1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"1.prems"</span><span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">cp1</span><span class="main">,</span><span class="main">[</span><span class="skolem">cp1</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cntt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">cp1</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span>hyps_F_b<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b_dom_ve b_dom_d b_dom_ds<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> Next.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> b_dom_ve b_dom_d b_dom_ds<span class="main">,</span> <span class="operator">THEN</span> conjunct1<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span><span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cntt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">cp1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                       <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">cp1</span><span class="main">,</span> <span class="main">[</span><span class="skolem">cp1</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="skolem">cntt</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>single_valued_insert<span class="main">)</span>

    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">lab</span> <span class="skolem">β</span> <span class="skolem">t</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="skolem">β</span><span class="main">)</span><span class="main">,</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">cntt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">cp1</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">b'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">∈</span> ran <span class="skolem">β</span> <span class="main">∧</span> <span class="skolem">b</span> <span class="main">≤</span> <span class="bound">b'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> hyps_F_b<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b_dom_ve b_dom_d b_dom_ds<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">ve</span> <span class="skolem">b</span> <span class="skolem">c</span> <span class="skolem">β'</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">c</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>HOL.Let_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>Un_insert_left Un_insert_right evalV.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case App›</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">lab'</span> <span class="skolem">f</span> <span class="skolem">vs</span>

    <span class="keyword1"><span class="command">have</span></span> prem2'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>ran <span class="skolem">β'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"2.prems"</span><span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> prem3'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_ve <span class="skolem">ve</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"2.prems"</span><span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">note</span></span> c_in_e <span class="main">=</span> contours_in_eval<span class="main">[</span><span class="operator">OF</span> prem3' prem2'<span class="main">]</span>

    <span class="keyword1"><span class="command">have</span></span> b_dom_d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="main">(</span>evalV <span class="skolem">f</span> <span class="skolem">β'</span> <span class="skolem">ve</span><span class="main">)</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> c_in_e<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> b_dom_ds<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">d'</span> <span class="main">∈</span> set <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> evalV <span class="bound">v</span> <span class="skolem">β'</span> <span class="skolem">ve</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_d <span class="bound">d'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c_in_e <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> b_dom_ve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span> <span class="main">∈</span> contours_in_ve <span class="skolem">ve</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">&lt;</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> prem3'<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="skolem">lab'</span><span class="main">,</span> <span class="skolem">β'</span><span class="main">)</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>evalV <span class="skolem">f</span> <span class="skolem">β'</span> <span class="skolem">ve</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> evalV <span class="bound">v</span> <span class="skolem">β'</span> <span class="skolem">ve</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> allI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> notI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">lab'</span><span class="main">,</span> <span class="skolem">β'</span><span class="main">)</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>evalV <span class="skolem">f</span> <span class="skolem">β'</span> <span class="skolem">ve</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> evalV <span class="bound">v</span> <span class="skolem">β'</span> <span class="skolem">ve</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">b'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">∈</span> ran <span class="skolem">β'</span> <span class="main">∧</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span> <span class="main">≤</span> <span class="bound">b'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> hyps_F_b<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b_dom_ve b_dom_d b_dom_ds<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> prem2' <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span>less_le_not_le<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1"><span class="command">with</span></span> hyps_F_sv<span class="main">[</span><span class="operator">OF</span> b_dom_ve b_dom_d b_dom_ds<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>evalV <span class="skolem">f</span> <span class="skolem">β'</span> <span class="skolem">ve</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> evalV <span class="bound">v</span> <span class="skolem">β'</span> <span class="skolem">ve</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span>
                       <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="skolem">lab'</span><span class="main">,</span> <span class="skolem">β'</span><span class="main">)</span><span class="main">,</span> evalV <span class="skolem">f</span> <span class="skolem">β'</span> <span class="skolem">ve</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>single_valued_insert<span class="main">)</span>

    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">lab</span> <span class="skolem">β</span> <span class="skolem">t</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="skolem">β</span><span class="main">)</span><span class="main">,</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="skolem">evalF</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>evalV <span class="skolem">f</span> <span class="skolem">β'</span> <span class="skolem">ve</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> evalV <span class="bound">v</span> <span class="skolem">β'</span> <span class="skolem">ve</span><span class="main">)</span> <span class="skolem">vs</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">b'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">∈</span> ran <span class="skolem">β</span> <span class="main">∧</span> <span class="skolem">b</span> <span class="main">≤</span> <span class="bound">b'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> hyps_F_b<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b_dom_ve b_dom_d b_dom_ds<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case Let›</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">lab'</span> <span class="skolem">ls</span> <span class="skolem">c'</span>
    <span class="keyword1"><span class="command">have</span></span> prem2'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>ran <span class="main">(</span><span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">≤</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">b'</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b'</span><span class="main">∈</span>ran <span class="main">(</span><span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b'</span> <span class="main">∈</span> ran <span class="skolem">β'</span> <span class="main">∨</span> <span class="skolem">b'</span> <span class="main">=</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span>ran_upd<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b'</span> <span class="main">≤</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"2.prems"</span><span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">have</span></span> prem3'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>contours_in_ve <span class="skolem">ve</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">≤</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"2.prems"</span><span class="main">(</span>3<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">note</span></span> c_in_e <span class="main">=</span> contours_in_eval<span class="main">[</span><span class="operator">OF</span> prem3' prem2'<span class="main">]</span>
    <span class="keyword1"><span class="command">note</span></span> c_in_ve' <span class="main">=</span> contours_in_ve_upds_binds<span class="main">[</span><span class="operator">OF</span> prem3' prem2'<span class="main">]</span>

    <span class="keyword1"><span class="command">have</span></span> b_dom_ve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span> <span class="main">∈</span> contours_in_ve <span class="main">(</span><span class="skolem">ve</span> <span class="main">++</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span>nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">,</span> evalV <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">ve</span><span class="main">)</span><span class="main">)</span> <span class="skolem">ls</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">≤</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> c_in_ve'<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> b_dom_beta<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">b'</span><span class="main">∈</span>ran <span class="main">(</span><span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">≤</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> prem2'<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> new<span class="main">:</span> <span class="quoted"><span class="quoted">"nb <span class="skolem">b</span> <span class="skolem">lab'</span> <span class="main">∈</span> ran <span class="main">(</span><span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      
    <span class="keyword1"><span class="command">from</span></span> hyps_C_sv<span class="main">[</span><span class="operator">OF</span> new b_dom_beta b_dom_ve<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">c'</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span><span class="skolem">evalC</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">c'</span><span class="main">,</span> <span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">,</span>
       <span class="skolem">ve</span> <span class="main">++</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span><span class="main">.</span><span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">,</span> evalV <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="main">(</span><span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span> <span class="skolem">ve</span><span class="main">)</span><span class="main">)</span><span class="skolem">ls</span><span class="main">)</span><span class="main">,</span>
       nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
    
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">lab</span> <span class="skolem">β</span> <span class="skolem">t</span> 
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">lab</span><span class="main">,</span> <span class="skolem">β</span><span class="main">)</span><span class="main">,</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">evalC</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span><span class="skolem">c'</span><span class="main">,</span> <span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">,</span>
       <span class="skolem">ve</span> <span class="main">++</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span><span class="main">.</span><span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">𝒜</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="main">(</span><span class="skolem">β'</span><span class="main">(</span><span class="skolem">lab'</span> <span class="main">↦</span> nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span> <span class="skolem">ve</span><span class="main">)</span><span class="main">)</span><span class="skolem">ls</span><span class="main">)</span><span class="main">,</span>
       nb <span class="skolem">b</span> <span class="skolem">lab'</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">b'</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">∈</span> ran <span class="skolem">β</span> <span class="main">∧</span> <span class="skolem">b</span> <span class="main">≤</span> <span class="bound">b'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">drule</span> hyps_C_b<span class="main"><span class="main">[</span></span><span class="operator">OF</span> new b_dom_beta b_dom_ve<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
 <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"single_valued <span class="main">(</span><span class="main">\&lt;PR&gt;</span> <span class="free">prog</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> evalCPS_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="main">(</span><span class="operator">subst</span> HOL.Let_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cc_single_valued'<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> conjunct1<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Computability">
<div class="head">
<h1>Theory Computability</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Generic Computability›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Computability
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a> <a href="HOLCFUtils.html">HOLCFUtils</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Shivers proves the computability of the abstract semantics functions only by generic and slightly simplified example. This theory contains the abstract treatment in Section 4.4.3. Later, we will work out the details apply this to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aPR&gt;›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Non-branching case›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

After the following lemma (which could go into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../../HOL/HOL/Set_Interval.html"></a><a href="../../HOL/HOL/Set_Interval.html">HOL.Set_Interval</a><span class="antiquote"><span class="antiquote">}</span></span></span></span>), we show Shivers' Theorem 10. This says that the least fixed point of the equation
\[
f\ x = g\ x \cup f\ (r\ x)
\]
is given by 
\[
f\ x = \bigcup_{i\ge 0} g\ (r^i\ x).
\]

The proof follows the standard proof of showing an equality involving a fixed point: First we show that the right hand side fulfills the above equation and then show that our solution is less than any other solution to that equation.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> insert_greaterThan<span class="main">:</span>
  <span class="quoted"><span class="quoted">"insert <span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">{</span><span class="free">n</span><span class="main">&lt;..}</span> <span class="main">=</span> <span class="main">{</span><span class="free">n</span><span class="main">..}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> theorem10<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>cpo <span class="main">→</span> <span class="tfree">'b</span><span class="main">::</span>type set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> f x<span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">∪</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>fix_eqI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cfun_eqI cfun_belowI<span class="main"><span class="main">,</span></span> <span class="operator">case_names</span> fp least<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>fp <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="main">0</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span>Suc <span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iterate_Suc2 <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> iterate_Suc<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="main">0</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="main">{</span><span class="main">0</span><span class="main">&lt;..}</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> less_iff_Suc_add <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span>  <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span>insert <span class="main">0</span> <span class="main">{</span><span class="main">0</span><span class="main">&lt;..}</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> insert_greaterThan atLeast_0 <span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>least <span class="skolem">f</span> <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> expand<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">∪</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>cfun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="main">{..</span><span class="skolem">n</span><span class="main">}</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span>Suc <span class="skolem">n</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>expand<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="main">{..</span><span class="skolem">n</span><span class="main">}</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span>Suc <span class="skolem">n</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="main">{..</span><span class="skolem">n</span><span class="main">}</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">∪</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span>Suc <span class="skolem">n</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span>Suc <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span>"</span></span>
             <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> expand<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free">r</span></span></span><span class="main"><span class="main"><span class="main"><span class="hidden">⇗</span><sup></sup></span></span></span>Suc <span class="skolem"><span class="skolem"><span class="skolem">n</span></span></span><span class="main"><span class="main"><span class="main"><span class="hidden">⇖</span></span></span></span><span class="main"><span class="main"><span class="main">⋅</span></span></span><span class="skolem"><span class="skolem"><span class="skolem">x</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span>insert <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">{..</span><span class="skolem">n</span><span class="main">}</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span>Suc <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span>"</span></span>
             <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="main">{..</span>Suc <span class="skolem">n</span><span class="main">}</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span>Suc <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span>"</span></span>
             <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>atMost_Suc<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> fin <span class="main">=</span> this
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">f</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> UN_least<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="skolem">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">f</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> fin<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sqsubset_is_subset<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Branching case›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Actually, our functions are more complicated than the one above: The abstract semantics functions recurse with multiple arguments. So we have to handle a recursive equation of the kind
\[
f\ x = g\ x \cup \bigcup_{a \in R\ x} f\ r.
\]
By moving to the power-set relatives of our function, e.g.
\[
{\uline g}Y = \bigcup_{a\in A} g\ a \quad \text{and} {\uline R}Y = \bigcup_{a\in R} R\ a
\]
the equation becomes
\[
{\uline f}Y ={\uline g}Y \cup {\uline f}\ ({\uline R}Y)
\]
(which is shown in Lemma 11) and we can apply Theorem 10 to obtain Theorem 12.

We define the power-set relative for a function together with some properties.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">powerset_lift</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>cpo <span class="main">→</span> <span class="tfree">'b</span><span class="main">::</span>type set<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">→</span> <span class="tfree">'b</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span></span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> S<span class="main">.</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="bound">S</span> <span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> powerset_lift_singleton<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">f</span><span class="main">⋅</span><span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> powerset_lift_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> powerset_lift_union<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">f</span><span class="main">⋅</span><span class="free">A</span> <span class="main">∪</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">f</span><span class="main">⋅</span><span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> powerset_lift_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> UNION_commute<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">B</span> <span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">B</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span> <span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> powerset_lift_UNION<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">A</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> <span class="free">A</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> powerset_lift_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> powerset_lift_iterate_UNION<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> <span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="free">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="main">(</span><span class="free">A</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="free">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> <span class="free">A</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">i</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>powerset_lift_UNION<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> powerset_distr <span class="main">=</span> powerset_lift_UNION powerset_lift_iterate_UNION


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Lemma 11 shows that if a function satisfies the relation with the branching $R$, its power-set function satisfies the powerset variant of the equation.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lemma11<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">=</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">R</span><span class="main">⋅</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">f</span><span class="main">⋅</span><span class="free">S</span> <span class="main">=</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span><span class="main">⋅</span><span class="free">S</span> <span class="main">∪</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">R</span><span class="main">⋅</span><span class="free">S</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">f</span><span class="main">⋅</span><span class="free">S</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span> <span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> powerset_lift_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span> <span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">R</span><span class="main">⋅</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> assms<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span><span class="main">⋅</span><span class="free">S</span> <span class="main">∪</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">R</span><span class="main">⋅</span><span class="free">S</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>powerset_lift_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Theorem 10 as it will be used in Theorem 12.
›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> theorem10ps <span class="main">=</span> theorem10<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">r</span>"</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">g</span> <span class="free">r</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Now we can show Lemma 12: If $F$ is the least solution to the recursive power-set equation, then $x \mapsto F\ {x}$ is the least solution to the equation with branching $R$.

We fix the type variable <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a›</span></span></span></span> to be a discrete cpo, as otherwise $x \mapsto \{x\}$ is not continuous.
›</span></span>

<span class="comment1">(* discrete_cpo, otherwise x ↦ {x} not continuous *)</span>
<span class="keyword1"><span class="command">lemma</span></span> theorem12'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>discrete_cpo <span class="main">→</span> <span class="tfree">'b</span><span class="main">::</span>type set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F_fix<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> F x<span class="main">.</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">∪</span> <span class="bound">F</span><span class="main">⋅</span><span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">R</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> f x<span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">R</span><span class="main">⋅</span><span class="bound">x</span><span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">F</span><span class="main">⋅</span><span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>fix_eqI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cfun_eqI cfun_belowI<span class="main"><span class="main">,</span></span> <span class="operator">case_names</span> fp least<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">have</span></span> F_union<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">R</span><span class="main">)</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> F_fix <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> theorem10ps<span class="main">)</span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>fp <span class="skolem">x</span><span class="main">)</span>
   <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x'</span><span class="main">∈</span><span class="free">R</span><span class="main">⋅</span><span class="skolem">x</span><span class="main">.</span> <span class="free">F</span><span class="main">⋅</span><span class="main">{</span><span class="bound">x'</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span><span class="main">⋅</span><span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">∪</span> <span class="free">F</span><span class="main">⋅</span><span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">R</span><span class="main">⋅</span><span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> powerset_lift_singleton
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> powerset_distr UNION_commute F_union<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">F</span><span class="main">⋅</span><span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> fix_eq4<span class="main"><span class="main">[</span></span><span class="operator">OF</span> F_fix<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>least <span class="skolem">f'</span> <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> expand<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f'</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">R</span><span class="main">⋅</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f'</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="skolem">f'</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> S<span class="main">.</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span><span class="main">⋅</span><span class="bound">S</span> <span class="main">∪</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="skolem">f'</span><span class="main">⋅</span><span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">R</span><span class="main">⋅</span><span class="bound">S</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> expand<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>powerset_lift_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">Λ</span> F<span class="main">.</span> <span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">∪</span> <span class="bound">F</span><span class="main">⋅</span><span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">R</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="skolem">f'</span><span class="main">)</span> <span class="main">=</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="skolem">f'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> fix_least<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword2"><span class="keyword">and</span></span> F_fix
  <span class="keyword1"><span class="command">have</span></span>  <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">⊑</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="skolem">f'</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span>  <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="main">⋅</span><span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">⊑</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="skolem">f'</span><span class="main">⋅</span><span class="main">{</span><span class="skolem">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span>cfun_below_iff<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>powerset_lift_singleton<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>sqsubset_is_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> theorem12<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>discrete_cpo <span class="main">→</span> <span class="tfree">'b</span><span class="main">::</span>type set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> f x<span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="free">R</span><span class="main">⋅</span><span class="bound">x</span><span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span>  <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span><span class="main">(</span><span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span><span class="free">R</span><span class="main">)</span><span class="main"><span class="hidden">⇗</span><sup></sup></span><span class="bound">i</span><span class="main"><span class="hidden">⇖</span></span><span class="main">⋅</span><span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> theorem12'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> theorem10ps<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> sym<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>powerset_distr<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="FixTransform">
<div class="head">
<h1>Theory FixTransform</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Fixed point transformations›</span></span>

<span class="keyword1"><span class="command">theory</span></span> FixTransform
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">default_sort</span></span> <span class="quoted">type</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
In his treatment of the computabily, Shivers gives proofs only for a generic example and leaves it to the reader to apply this to the mutually recursive functions used for the semantics. As we carry this out, we need to transform a fixed point for two functions (implemented in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../../HOL/HOLCF/HOLCF.html"></a><a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> as a fixed point over a tuple) to a simple fixed point equation. The approach here works as long as both functions in the tuple have the same return type, using the equation
\[
X^A\cdot X^B = X^{A+B}.
\]

Generally, a fixed point can be transformed using any retractable continuous function:
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fix_transform<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">=</span><span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="free">F</span> <span class="main">=</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">F</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parallel_fix_ind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> adm_eq<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> retraction_strict<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">g</span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="main"><span class="main">,</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The functions we use here convert a tuple of functions to a function taking a direct sum as parameters and back. We only care about discrete arguments here.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tup_to_sum</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> discr <span class="main">→</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'b</span> discr <span class="main">→</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> discr <span class="main">→</span> <span class="tfree">'c</span><span class="main">::</span>cpo"</span></span>
 <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tup_to_sum</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> p s<span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">g</span><span class="main">)</span><span class="main">.</span>
          <span class="keyword1">case</span> undiscr <span class="bound">s</span> <span class="keyword1">of</span> Inl <span class="bound">x</span> <span class="main">⇒</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">x</span><span class="main">)</span>
                          <span class="main">|</span> Inr <span class="bound">x</span> <span class="main">⇒</span> <span class="bound">g</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="bound">p</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sum_to_tup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">+</span> <span class="tfree">'b</span><span class="main">)</span> discr <span class="main">→</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'a</span> discr <span class="main">→</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'b</span> discr <span class="main">→</span> <span class="tfree">'c</span><span class="main">::</span>cpo<span class="main">)</span>"</span></span>
 <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sum_to_tup</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> f<span class="main">.</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>Inl <span class="main">(</span>undiscr <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                             <span class="keyword1">Λ</span> x<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>Inr <span class="main">(</span>undiscr <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
As so often when working with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../../HOL/HOLCF/HOLCF.html"></a><a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a><span class="antiquote"><span class="antiquote">}</span></span></span></span>, some continuity lemmas are required.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_case_sum<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cont <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_sum <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>cont2cont_fun<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_circ<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
 <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cont2cont_lambda<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> comp_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span>  cont2cont_fun<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">x</span></span>"</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> <span class="quoted">"cont_id"</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont2cont_split_pair<span class="main">[</span><span class="operator">cont2cont</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
 <span class="keyword2"><span class="keyword">assumes</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="free">f</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> f2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> cont <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> g1<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="free">g</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> g2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> cont <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
 <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">,</span> <span class="free">g</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic"><span class="dynamic">cont2cont</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cont_apply<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cont_snd _ cont_const<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cont_apply<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cont_snd f2<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cont_apply<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cont_fst cont2cont_fun<span class="main"><span class="main">[</span></span><span class="operator">OF</span> f1<span class="main"><span class="main">]</span></span> cont_const<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cont_apply<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cont_snd _ cont_const<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cont_apply<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cont_snd g2<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cont_apply<span class="main"><span class="main">[</span></span><span class="operator">OF</span> cont_fst cont2cont_fun<span class="main"><span class="main">[</span></span><span class="operator">OF</span> g1<span class="main"><span class="main">]</span></span> cont_const<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Using these continuity lemmas, we can show that our function are actually continuous and thus allow us to apply them to a value.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sum_to_tup_app<span class="main">:</span>
 <span class="quoted"><span class="quoted">"sum_to_tup<span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>Inl <span class="main">(</span>undiscr <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>Inr <span class="main">(</span>undiscr <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> sum_to_tup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> tup_to_sum_app<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tup_to_sum<span class="main">⋅</span><span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">f</span><span class="main">,</span><span class="bound">g</span><span class="main">)</span><span class="main">.</span>
          <span class="keyword1">case</span> undiscr <span class="bound">s</span> <span class="keyword1">of</span> Inl <span class="bound">x</span> <span class="main">⇒</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">x</span><span class="main">)</span>
                          <span class="main">|</span> Inr <span class="bound">x</span> <span class="main">⇒</span> <span class="bound">g</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> tup_to_sum_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Generally, lambda abstractions with discrete domain are continuous and can be resolved immediately.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> discr_app<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> <span class="free">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span>Discr <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Our transformation functions are inverse to each other, so we can use them to transform a fixed point.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> tup_to_sum_to_tup<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"sum_to_tup<span class="main">⋅</span><span class="main">(</span>tup_to_sum<span class="main">⋅</span><span class="free">F</span><span class="main">)</span> <span class="main">=</span> <span class="free">F</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> sum_to_tup_app <span class="keyword2"><span class="keyword">and</span></span> tup_to_sum_app
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">F</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>cfun_eqI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fix_transform_pair_sum<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="free">F</span> <span class="main">=</span> sum_to_tup<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span>tup_to_sum <span class="keyword1">oo</span> <span class="free">F</span> <span class="keyword1">oo</span> sum_to_tup<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fix_transform<span class="main"><span class="main">[</span></span><span class="operator">OF</span> tup_to_sum_to_tup<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
After such a transformation, we want to get rid of these helper functions again. This is done by the next two simplification lemmas.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> tup_sum_oo<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
 <span class="keyword2"><span class="keyword">assumes</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="free">F</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> f2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> cont <span class="main">(</span><span class="free">F</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> g1<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="free">G</span>"</span></span>
     <span class="keyword2"><span class="keyword">and</span></span> g2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> cont <span class="main">(</span><span class="free">G</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"tup_to_sum <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> p<span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">F</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">,</span> <span class="free">G</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="bound">p</span><span class="main">)</span> <span class="keyword1">oo</span> sum_to_tup
  <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> f s<span class="main">.</span> <span class="main">(</span><span class="keyword1">case</span> undiscr <span class="bound">s</span> <span class="keyword1">of</span>
        Inl <span class="bound">x</span> <span class="main">⇒</span>
          <span class="free">F</span> <span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>Inl <span class="main">(</span>undiscr <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
           <span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>Inr <span class="main">(</span>undiscr <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>
          <span class="main">(</span>Discr <span class="bound">x</span><span class="main">)</span>
        <span class="main">|</span> Inr <span class="bound">x</span> <span class="main">⇒</span>
            <span class="free">G</span> <span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>Inl <span class="main">(</span>undiscr <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
             <span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>Inr <span class="main">(</span>undiscr <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>
            <span class="main">(</span>Discr <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span>
    <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_to_tup_app tup_to_sum_app
       cont2cont_split_pair<span class="main"><span class="main">[</span></span><span class="operator">OF</span> f1 f2 g1 g2<span class="main"><span class="main">]</span></span>
       cont2cont_lambda
       cont_apply<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ f2 cont2cont_fun<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> cont_compose<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> f1<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span>
       cont_apply<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ g2 cont2cont_fun<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> cont_compose<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> g1<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fst_sum_to_tup<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fst <span class="main">(</span>sum_to_tup<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> xa<span class="main">.</span> <span class="free">x</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>Inl <span class="main">(</span>undiscr <span class="bound">xa</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_to_tup_app<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="CPSUtils">
<div class="head">
<h1>Theory CPSUtils</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span>  <span class="quoted"><span class="plain_text">‹Syntax tree helpers›</span></span>

<span class="keyword1"><span class="command">theory</span></span> CPSUtils
<span class="keyword2"><span class="keyword">imports</span></span> <a href="CPSScheme.html">CPSScheme</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This theory defines the sets <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lambdas p›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>calls p›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>calls p›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>vars p›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>labels p›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prims p›</span></span></span></span> as the subexpressions of the program <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p›</span></span></span></span>. Finiteness is shown for each of these sets, and some rules about how these sets relate. All these rules are proven more or less the same ways, which is very inelegant due to the nesting of the type and the shape of the derived induction rule.

It would be much nicer to start with these rules and define the set inductively. Unfortunately, that approach would make it very hard to show the finiteness of the sets in question.
›</span></span>


<span class="keyword1"><span class="command">fun</span></span> <span class="entity">lambdas</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"lambda <span class="main">⇒</span> lambda set"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">lambdasC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"call <span class="main">⇒</span> lambda set"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">lambdasV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"val <span class="main">⇒</span> lambda set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lambdas</span>  <span class="main">(</span>Lambda <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">{</span>Lambda <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">}</span> <span class="main">∪</span> <span class="free">lambdasC</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lambdasC</span> <span class="main">(</span>App <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">lambdasV</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">∪</span> <span class="main">⋃</span> <span class="main">(</span><span class="free">lambdasV</span> <span class="main">`</span> set <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lambdasC</span> <span class="main">(</span>Let <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">binds</span></span></span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">binds</span></span></span><span class="main">.</span> <span class="free">lambdas</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∪</span> <span class="free">lambdasC</span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lambdasV</span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">lambdas</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lambdasV</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span>     <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">calls</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"lambda <span class="main">⇒</span> call set"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">callsC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"call <span class="main">⇒</span> call set"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">callsV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"val <span class="main">⇒</span> call set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">calls</span>  <span class="main">(</span>Lambda <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">callsC</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">callsC</span> <span class="main">(</span>App <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>App <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">}</span> <span class="main">∪</span> <span class="free">callsV</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="free">callsV</span> <span class="main">`</span> <span class="main">(</span>set <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">callsC</span> <span class="main">(</span>Let <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">binds</span></span></span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>call.Let <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">binds</span></span></span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span><span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">binds</span></span></span><span class="main">.</span> <span class="free">calls</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∪</span> <span class="free">callsC</span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">callsV</span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">calls</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">callsV</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span>     <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_lambdas<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>lambdas <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>lambdasC <span class="free">c</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>lambdasV <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lambdas_lambdasC_lambdasV.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_calls<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>calls <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>callsC <span class="free">c</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>callsV <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> calls_callsC_callsV.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">vars</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"lambda <span class="main">⇒</span> var set"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">varsC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"call <span class="main">⇒</span> var set"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">varsV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"val <span class="main">⇒</span> var set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">vars</span> <span class="main">(</span>Lambda <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> set <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">∪</span> <span class="free">varsC</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">varsC</span> <span class="main">(</span>App <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">varsV</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">∪</span> <span class="main">⋃</span><span class="main">(</span><span class="free">varsV</span> <span class="main">`</span> <span class="main">(</span>set <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">varsC</span> <span class="main">(</span>Let <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">binds</span></span></span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">l</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">binds</span></span></span><span class="main">.</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span> <span class="main">∪</span> <span class="free">vars</span> <span class="bound">l</span><span class="main">)</span> <span class="main">∪</span> <span class="free">varsC</span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">varsV</span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">vars</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">varsV</span> <span class="main">(</span>R <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">varsV</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span>  <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_vars<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>vars <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>varsC <span class="free">c</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>varsV <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> vars_varsC_varsV.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">label</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"lambda <span class="main">+</span> call <span class="main">⇒</span> label"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">label</span> <span class="main">(</span>Inl <span class="main">(</span>Lambda <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">label</span> <span class="main">(</span>Inr <span class="main">(</span>App <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">label</span> <span class="main">(</span>Inr <span class="main">(</span>Let <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">labels</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"lambda <span class="main">⇒</span> label set"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">labelsC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"call <span class="main">⇒</span> label set"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">labelsV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"val <span class="main">⇒</span> label set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">labels</span> <span class="main">(</span>Lambda <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">}</span> <span class="main">∪</span> <span class="free">labelsC</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">labelsC</span> <span class="main">(</span>App <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">}</span> <span class="main">∪</span> <span class="free">labelsV</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">∪</span> <span class="main">⋃</span><span class="main">(</span><span class="free">labelsV</span> <span class="main">`</span> <span class="main">(</span>set <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">labelsC</span> <span class="main">(</span>Let <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">binds</span></span></span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">binds</span></span></span><span class="main">.</span> <span class="free">labels</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∪</span> <span class="free">labelsC</span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">labelsV</span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">labels</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">labelsV</span> <span class="main">(</span>R <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">}</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">labelsV</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span>  <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_labels<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>labels <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>labelsC <span class="free">c</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>labelsV <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> labels_labelsC_labelsV.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">prims</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"lambda <span class="main">⇒</span> prim set"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">primsC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"call <span class="main">⇒</span> prim set"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">primsV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"val <span class="main">⇒</span> prim set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">prims</span> <span class="main">(</span>Lambda <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">primsC</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">primsC</span> <span class="main">(</span>App <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">primsV</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">∪</span> <span class="main">⋃</span><span class="main">(</span><span class="free">primsV</span> <span class="main">`</span> <span class="main">(</span>set <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">primsC</span> <span class="main">(</span>Let <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">binds</span></span></span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">binds</span></span></span><span class="main">.</span> <span class="free">prims</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∪</span> <span class="free">primsC</span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">primsV</span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">prims</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">primsV</span> <span class="main">(</span>R <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">primsV</span> <span class="main">(</span>P <span class="free"><span class="bound"><span class="entity">prim</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">prim</span></span></span><span class="main">}</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">primsV</span> <span class="main">(</span>C <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_prims<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>prims <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>primsC <span class="free">c</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>primsV <span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> labels_labelsC_labelsV.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">vals</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"lambda <span class="main">⇒</span> val set"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">valsC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"call <span class="main">⇒</span> val set"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">valsV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"val <span class="main">⇒</span> val set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">vals</span> <span class="main">(</span>Lambda <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">valsC</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">valsC</span> <span class="main">(</span>App <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">valsV</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">∪</span> <span class="main">⋃</span><span class="main">(</span><span class="free">valsV</span> <span class="main">`</span> <span class="main">(</span>set <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">valsC</span> <span class="main">(</span>Let <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">binds</span></span></span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">binds</span></span></span><span class="main">.</span> <span class="free">vals</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∪</span> <span class="free">valsC</span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">valsV</span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>L <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">}</span> <span class="main">∪</span> <span class="free">vals</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">valsV</span> <span class="main">(</span>R <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>R <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">valsV</span> <span class="main">(</span>P <span class="free"><span class="bound"><span class="entity">prim</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>P <span class="free"><span class="bound"><span class="entity">prim</span></span></span><span class="main">}</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">valsV</span> <span class="main">(</span>C <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>C <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">list2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"var<span class="main">×</span>lambda"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> lambdas1<span class="main">:</span> <span class="quoted"><span class="quoted">"Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdas <span class="free">x</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∈</span> calls <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdasC <span class="free">y</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∈</span> callsC <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdasV <span class="free">z</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∈</span> callsV <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdasV <span class="bound">z</span> <span class="main">⟶</span> <span class="free">c</span> <span class="main">∈</span> callsV <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span> set <span class="free">list2</span><span class="main">.</span> Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdas <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">c</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdas <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>mutual_lambda_call_var_inducts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">c</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> lambdas2<span class="main">:</span> <span class="quoted"><span class="quoted">"Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdas <span class="free">x</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">∈</span> labels <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdasC <span class="free">y</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">∈</span> labelsC <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdasV <span class="free">z</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">∈</span> labelsV <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdasV <span class="bound">z</span> <span class="main">⟶</span> <span class="free">l</span> <span class="main">∈</span> labelsV <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span> set <span class="main">(</span><span class="free">list2</span> <span class="main">::</span> <span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list<span class="main">)</span> <span class="main">.</span> Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdas <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">l</span> <span class="main">∈</span> labels <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdas <span class="main">(</span>snd <span class="main">(</span><span class="free">t</span><span class="main">::</span> var<span class="main">×</span>lambda<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">∈</span> labels <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>mutual_lambda_call_var_inducts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> lambdas3<span class="main">:</span> <span class="quoted"><span class="quoted">"Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdas <span class="free">x</span> <span class="main">⟹</span> set <span class="free">vs</span> <span class="main">⊆</span> vars <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdasC <span class="free">y</span> <span class="main">⟹</span> set <span class="free">vs</span> <span class="main">⊆</span> varsC <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdasV <span class="free">z</span> <span class="main">⟹</span> set <span class="free">vs</span> <span class="main">⊆</span> varsV <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdasV <span class="bound">z</span> <span class="main">⟶</span> set <span class="free">vs</span> <span class="main">⊆</span> varsV <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span> set <span class="main">(</span><span class="free">list2</span> <span class="main">::</span> <span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list<span class="main">)</span> <span class="main">.</span> Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdas <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> set <span class="free">vs</span> <span class="main">⊆</span> vars <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Lambda <span class="free">l</span> <span class="free">vs</span> <span class="free">c</span> <span class="main">∈</span> lambdas <span class="main">(</span>snd <span class="main">(</span><span class="free">t</span><span class="main">::</span> var<span class="main">×</span>lambda<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> set <span class="free">vs</span> <span class="main">⊆</span> vars <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">y</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">z</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list2</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>mutual_lambda_call_var_inducts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">aa</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span><span class="main">,</span> <span class="improper">bb</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ballE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">aa</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span><span class="main">,</span> <span class="improper">bb</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> app1<span class="main">:</span> <span class="quoted"><span class="quoted">"App <span class="free">l</span> <span class="free">d</span> <span class="free">ds</span> <span class="main">∈</span> calls <span class="free">x</span> <span class="main">⟹</span> <span class="free">d</span> <span class="main">∈</span> vals <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"App <span class="free">l</span> <span class="free">d</span> <span class="free">ds</span> <span class="main">∈</span> callsC <span class="free">y</span> <span class="main">⟹</span> <span class="free">d</span> <span class="main">∈</span> valsC <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"App <span class="free">l</span> <span class="free">d</span> <span class="free">ds</span> <span class="main">∈</span> callsV <span class="free">z</span> <span class="main">⟹</span> <span class="free">d</span> <span class="main">∈</span> valsV <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> App <span class="free">l</span> <span class="free">d</span> <span class="free">ds</span> <span class="main">∈</span> callsV <span class="bound">z</span> <span class="main">⟶</span> <span class="free">d</span> <span class="main">∈</span> valsV <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span> set <span class="main">(</span><span class="free">list2</span> <span class="main">::</span> <span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list<span class="main">)</span> <span class="main">.</span> App <span class="free">l</span> <span class="free">d</span> <span class="free">ds</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">d</span> <span class="main">∈</span> vals <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"App <span class="free">l</span> <span class="free">d</span> <span class="free">ds</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="main">(</span><span class="free">t</span><span class="main">::</span> var<span class="main">×</span>lambda<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">d</span> <span class="main">∈</span> vals <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">y</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">z</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list2</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>mutual_lambda_call_var_inducts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">d</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ballE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> app2<span class="main">:</span> <span class="quoted"><span class="quoted">"App <span class="free">l</span> <span class="free">d</span> <span class="free">ds</span> <span class="main">∈</span> calls <span class="free">x</span> <span class="main">⟹</span> set <span class="free">ds</span> <span class="main">⊆</span> vals <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"App <span class="free">l</span> <span class="free">d</span> <span class="free">ds</span> <span class="main">∈</span> callsC <span class="free">y</span> <span class="main">⟹</span> set <span class="free">ds</span> <span class="main">⊆</span> valsC <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"App <span class="free">l</span> <span class="free">d</span> <span class="free">ds</span> <span class="main">∈</span> callsV <span class="free">z</span> <span class="main">⟹</span> set <span class="free">ds</span> <span class="main">⊆</span> valsV <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> App <span class="free">l</span> <span class="free">d</span> <span class="free">ds</span> <span class="main">∈</span> callsV <span class="bound">z</span> <span class="main">⟶</span> set <span class="free">ds</span> <span class="main">⊆</span> valsV <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span> set <span class="main">(</span><span class="free">list2</span> <span class="main">::</span> <span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list<span class="main">)</span> <span class="main">.</span> App <span class="free">l</span> <span class="free">d</span> <span class="free">ds</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> set <span class="free">ds</span> <span class="main">⊆</span> vals <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"App <span class="free">l</span> <span class="free">d</span> <span class="free">ds</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="main">(</span><span class="free">t</span><span class="main">::</span> var<span class="main">×</span>lambda<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> set <span class="free">ds</span> <span class="main">⊆</span> vals <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span>  <span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">y</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">z</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list2</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>mutual_lambda_call_var_inducts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ballE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> let1<span class="main">:</span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="free">x</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">∈</span> labels <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> callsC <span class="free">y</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">∈</span> labelsC <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> callsV <span class="free">z</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">∈</span> labelsV <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> callsV <span class="bound">z</span> <span class="main">⟶</span> <span class="free">l</span> <span class="main">∈</span> labelsV <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span> set <span class="main">(</span><span class="free">list2</span> <span class="main">::</span> <span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list<span class="main">)</span> <span class="main">.</span> Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">l</span> <span class="main">∈</span> labels <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="main">(</span><span class="free">t</span><span class="main">::</span> var<span class="main">×</span>lambda<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">∈</span> labels <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">y</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">z</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list2</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>mutual_lambda_call_var_inducts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ballE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> let2<span class="main">:</span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="free">x</span> <span class="main">⟹</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> callsC <span class="free">y</span> <span class="main">⟹</span> <span class="free">c'</span> <span class="main">∈</span> callsC <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> callsV <span class="free">z</span> <span class="main">⟹</span> <span class="free">c'</span> <span class="main">∈</span> callsV <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> callsV <span class="bound">z</span> <span class="main">⟶</span> <span class="free">c'</span> <span class="main">∈</span> callsV <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span> set <span class="main">(</span><span class="free">list2</span> <span class="main">::</span> <span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list<span class="main">)</span> <span class="main">.</span> Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="main">(</span><span class="free">t</span><span class="main">::</span> var<span class="main">×</span>lambda<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">y</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">z</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list2</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>mutual_lambda_call_var_inducts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">c'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ballE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> let3<span class="main">:</span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="free">x</span> <span class="main">⟹</span> fst <span class="main">`</span> set <span class="free">binds</span> <span class="main">⊆</span> vars <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> callsC <span class="free">y</span> <span class="main">⟹</span> fst <span class="main">`</span> set <span class="free">binds</span> <span class="main">⊆</span> varsC <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> callsV <span class="free">z</span> <span class="main">⟹</span> fst <span class="main">`</span> set <span class="free">binds</span> <span class="main">⊆</span> varsV <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> callsV <span class="bound">z</span> <span class="main">⟶</span> fst <span class="main">`</span> set <span class="free">binds</span> <span class="main">⊆</span> varsV <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span> set <span class="main">(</span><span class="free">list2</span> <span class="main">::</span> <span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list<span class="main">)</span> <span class="main">.</span> Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> fst <span class="main">`</span> set <span class="free">binds</span> <span class="main">⊆</span> vars <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="main">(</span><span class="free">t</span><span class="main">::</span> var<span class="main">×</span>lambda<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> fst <span class="main">`</span> set <span class="free">binds</span> <span class="main">⊆</span> vars <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">y</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">z</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list2</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>mutual_lambda_call_var_inducts<span class="main">)</span>
             <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> let4<span class="main">:</span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="free">x</span> <span class="main">⟹</span> snd <span class="main">`</span> set <span class="free">binds</span> <span class="main">⊆</span> lambdas <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> callsC <span class="free">y</span> <span class="main">⟹</span> snd <span class="main">`</span> set <span class="free">binds</span> <span class="main">⊆</span> lambdasC <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> callsV <span class="free">z</span> <span class="main">⟹</span> snd <span class="main">`</span> set <span class="free">binds</span> <span class="main">⊆</span> lambdasV <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> callsV <span class="bound">z</span> <span class="main">⟶</span> snd <span class="main">`</span> set <span class="free">binds</span> <span class="main">⊆</span> lambdasV <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span> set <span class="main">(</span><span class="free">list2</span> <span class="main">::</span> <span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list<span class="main">)</span> <span class="main">.</span> Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> snd <span class="main">`</span> set <span class="free">binds</span> <span class="main">⊆</span> lambdas <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">l</span> <span class="free">binds</span> <span class="free">c'</span> <span class="main">∈</span> calls <span class="main">(</span>snd <span class="main">(</span><span class="free">t</span><span class="main">::</span> var<span class="main">×</span>lambda<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> snd <span class="main">`</span> set <span class="free">binds</span> <span class="main">⊆</span> lambdas <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">y</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">z</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">list2</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>mutual_lambda_call_var_inducts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">ba</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">aa</span><span class="main">,</span> <span class="improper">bb</span><span class="main">)</span><span class="main">,</span> <span class="improper">bc</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ballE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">aa</span><span class="main">,</span> <span class="improper">bb</span><span class="main">)</span><span class="main">,</span> <span class="improper">bc</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> vals1<span class="main">:</span> <span class="quoted"><span class="quoted">"P <span class="free">prim</span> <span class="main">∈</span> vals <span class="free">p</span> <span class="main">⟹</span> <span class="free">prim</span> <span class="main">∈</span> prims <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"P <span class="free">prim</span> <span class="main">∈</span> valsC <span class="free">y</span> <span class="main">⟹</span> <span class="free">prim</span> <span class="main">∈</span> primsC <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"P <span class="free">prim</span> <span class="main">∈</span> valsV <span class="free">z</span> <span class="main">⟹</span> <span class="free">prim</span> <span class="main">∈</span> primsV <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> P <span class="free">prim</span> <span class="main">∈</span> valsV <span class="bound">z</span> <span class="main">⟶</span> <span class="free">prim</span> <span class="main">∈</span> primsV <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span> set <span class="main">(</span><span class="free">list2</span> <span class="main">::</span> <span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list<span class="main">)</span> <span class="main">.</span> P <span class="free">prim</span> <span class="main">∈</span> vals <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">prim</span> <span class="main">∈</span> prims <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"P <span class="free">prim</span> <span class="main">∈</span> vals <span class="main">(</span>snd <span class="main">(</span><span class="free">t</span><span class="main">::</span> var<span class="main">×</span>lambda<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">prim</span> <span class="main">∈</span> prims <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>mutual_lambda_call_var_inducts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ballE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> vals2<span class="main">:</span> <span class="quoted"><span class="quoted">"R <span class="free">l</span> <span class="free">var</span> <span class="main">∈</span> vals <span class="free">p</span> <span class="main">⟹</span> <span class="free">var</span> <span class="main">∈</span> vars <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"R <span class="free">l</span> <span class="free">var</span> <span class="main">∈</span> valsC <span class="free">y</span> <span class="main">⟹</span> <span class="free">var</span> <span class="main">∈</span> varsC <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"R <span class="free">l</span> <span class="free">var</span> <span class="main">∈</span> valsV <span class="free">z</span> <span class="main">⟹</span> <span class="free">var</span> <span class="main">∈</span> varsV <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> R <span class="free">l</span> <span class="free">var</span> <span class="main">∈</span> valsV <span class="bound">z</span> <span class="main">⟶</span> <span class="free">var</span> <span class="main">∈</span> varsV <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span> set <span class="main">(</span><span class="free">list2</span> <span class="main">::</span> <span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list<span class="main">)</span> <span class="main">.</span> R <span class="free">l</span> <span class="free">var</span> <span class="main">∈</span> vals <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">var</span> <span class="main">∈</span> vars <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"R <span class="free">l</span> <span class="free">var</span> <span class="main">∈</span> vals <span class="main">(</span>snd <span class="main">(</span><span class="free">t</span><span class="main">::</span> var<span class="main">×</span>lambda<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">var</span> <span class="main">∈</span> vars <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>mutual_lambda_call_var_inducts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ballE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> vals3<span class="main">:</span> <span class="quoted"><span class="quoted">"L <span class="free">l</span> <span class="main">∈</span> vals <span class="free">p</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">∈</span> lambdas <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"L <span class="free">l</span> <span class="main">∈</span> valsC <span class="free">y</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">∈</span> lambdasC <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"L <span class="free">l</span> <span class="main">∈</span> valsV <span class="free">z</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">∈</span> lambdasV <span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">∈</span> set <span class="free">list</span><span class="main">.</span> L <span class="free">l</span> <span class="main">∈</span> valsV <span class="bound">z</span> <span class="main">⟶</span> <span class="free">l</span> <span class="main">∈</span> lambdasV <span class="bound">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span> set <span class="main">(</span><span class="free">list2</span> <span class="main">::</span> <span class="main">(</span>var <span class="main">×</span> lambda<span class="main">)</span> list<span class="main">)</span> <span class="main">.</span> L <span class="free">l</span> <span class="main">∈</span> vals <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">l</span> <span class="main">∈</span> lambdas <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"L <span class="free">l</span> <span class="main">∈</span> vals <span class="main">(</span>snd <span class="main">(</span><span class="free">t</span><span class="main">::</span> var<span class="main">×</span>lambda<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">∈</span> lambdas <span class="main">(</span>snd <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>mutual_lambda_call_var_inducts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ballE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="improper">a</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">,</span> <span class="improper">ba</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">nList</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">=&gt;</span> nat <span class="main">=&gt;</span> <span class="tfree">'a</span> list set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">nList</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> set <span class="bound">l</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> length <span class="bound">l</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_nList<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finA<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>nList <span class="free">A</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
<span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>nList_def<span class="main">)</span> <span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> finn<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>nList <span class="main">(</span><span class="free">A</span><span class="main">)</span> <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nList <span class="free">A</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>case_prod <span class="main">(#)</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="free">A</span> <span class="main">×</span> nList <span class="free">A</span> <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> subset_antisym<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subsetI subsetI<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>nList_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>nList_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> finA <span class="keyword2"><span class="keyword">and</span></span> finn
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">NList</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">=&gt;</span> nat set <span class="main">=&gt;</span> <span class="tfree">'a</span> list set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">NList</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">≡</span> <span class="main">⋃</span> <span class="bound">n</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span><span class="main">.</span> nList <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="bound">n</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_Nlist<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> finite <span class="free">N</span> <span class="main">⟧</span> <span class="main">⟹</span> finite <span class="main">(</span>NList <span class="free">A</span> <span class="free">N</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> NList_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">call_list_lengths</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">call_list_lengths</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">c</span> <span class="keyword1">of</span> <span class="main">(</span>App <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">ds</span><span class="main">)</span> <span class="main">⇒</span> length <span class="bound">ds</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">0</span><span class="main">)</span> <span class="main">`</span> calls <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_call_list_lengths<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>call_list_lengths <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> call_list_lengths_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="MapSets">
<div class="head">
<h1>Theory MapSets</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Sets of maps›</span></span>
<span class="keyword1"><span class="command">theory</span></span> MapSets
<span class="keyword2"><span class="keyword">imports</span></span> <a href="SetMap.html">SetMap</a> <a href="Utils.html">Utils</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
In the section about the finiteness of the argument space, we need the fact that the set of maps from a finite domain to a finite range is finite, and the same for the set-valued maps defined in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="SetMap.html"></a><a href="SetMap.html">Shivers-CFA.SetMap</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. Both these sets are defined (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>maps_over›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>smaps_over›</span></span></span></span>) and the finiteness is shown.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">maps_over</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>type set <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>type set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇀</span> <span class="tfree">'b</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">maps_over</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">m</span><span class="main">.</span> dom <span class="bound">m</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> ran <span class="bound">m</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> maps_over_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Map.empty <span class="main">∈</span> maps_over <span class="free">A</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> maps_over_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> maps_over_upd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">∈</span> maps_over <span class="free">A</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> <span class="free">B</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span><span class="main">(</span><span class="free">v</span> <span class="main">↦</span> <span class="free">k</span><span class="main">)</span> <span class="main">∈</span> maps_over <span class="free">A</span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> maps_over_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ran_upd<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> maps_over_finite<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>maps_over <span class="free">A</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> inj_map_graph<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> Some <span class="bound">y</span> <span class="main">=</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> inj_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted">"1.hyps"</span><span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> hyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span>Some <span class="bound">b</span> <span class="main">=</span> <span class="skolem">x</span> <span class="bound">a</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>Some <span class="bound">b</span> <span class="main">=</span> <span class="skolem">y</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_eq_iff<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="skolem">z</span> <span class="main">=</span> <span class="skolem">y</span> <span class="skolem">z</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> hyp<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">z</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="skolem">z</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="skolem">z</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> Some <span class="bound">y</span> <span class="main">=</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span> <span class="main">`</span> maps_over <span class="free">A</span> <span class="free">B</span> <span class="main">⊆</span> Pow<span class="main">(</span> <span class="free">A</span> <span class="main">×</span> <span class="free">B</span> <span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?graph</span> <span class="main">⊆</span> <span class="main">_</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> maps_over_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>subsetD<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="free">A</span></span><span class="main"><span class="main">]</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="free">B</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>ranI<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Pow<span class="main">(</span> <span class="free">A</span> <span class="main">×</span> <span class="free">B</span> <span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?graph</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_imageD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ subset_inj_on<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inj_map_graph subset_UNIV<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">smaps_over</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>type set <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>type set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> set<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">smaps_over</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">m</span><span class="main">.</span> sdom <span class="bound">m</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> sran <span class="bound">m</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> smaps_over_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">{}.</span> <span class="main">∈</span> smaps_over <span class="free">A</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> smaps_over_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> smaps_over_singleton<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">vs</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">k</span> <span class="main">:=</span> <span class="free">vs</span><span class="main">}.</span> <span class="main">∈</span> smaps_over <span class="free">A</span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> smaps_over_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sdom_singleton<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smaps_over_un<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">m1</span> <span class="main">∈</span> smaps_over <span class="free">A</span> <span class="free">B</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">m2</span> <span class="main">∈</span> smaps_over <span class="free">A</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">m1</span> <span class="main">∪.</span> <span class="free">m2</span> <span class="main">∈</span> smaps_over <span class="free">A</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> smaps_over_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>smap_union_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smaps_over_Union<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="free">ms</span> <span class="main">⊆</span> smaps_over <span class="free">A</span> <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃.</span><span class="free">ms</span> <span class="main">∈</span> smaps_over <span class="free">A</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ms</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> smaps_over_un<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smaps_over_im<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">f</span> <span class="main">∈</span> <span class="free">m</span> <span class="free">a</span> <span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> smaps_over <span class="free">A</span> <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∈</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> smaps_over_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>sran_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> smaps_over_finite<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>smaps_over <span class="free">A</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> inj_smap_graph<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="bound">f</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"inj <span class="var">?gr</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> inj_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted">"1.hyps"</span><span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> hyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="bound">b</span> <span class="main">=</span> <span class="skolem">x</span> <span class="bound">a</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">b</span> <span class="main">=</span> <span class="skolem">y</span> <span class="bound">a</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> set_eq_iff<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="skolem">z</span> <span class="main">=</span> <span class="skolem">y</span> <span class="skolem">z</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> hyp<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="skolem">z</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="skolem">z</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="skolem">z</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?gr</span> <span class="main">`</span> smaps_over <span class="free">A</span> <span class="free">B</span> <span class="main">⊆</span> Pow<span class="main">(</span> <span class="free">A</span> <span class="main">×</span> Pow  <span class="free">B</span> <span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?graph</span> <span class="main">⊆</span> <span class="main">_</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> smaps_over_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>subsetD<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="free">A</span></span><span class="main"><span class="main">]</span></span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"Pow <span class="free">B</span>"</span></span><span class="main"><span class="main">]</span></span> sdom_not_mem <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span>sranI<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>Pow<span class="main">(</span> <span class="free">A</span> <span class="main">×</span> Pow <span class="free">B</span> <span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?graph</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_imageD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ subset_inj_on<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inj_smap_graph subset_UNIV<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="AbsCFComp">
<div class="head">
<h1>Theory AbsCFComp</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The abstract semantics is computable›</span></span>

<span class="keyword1"><span class="command">theory</span></span> AbsCFComp
<span class="keyword2"><span class="keyword">imports</span></span> <a href="AbsCF.html">AbsCF</a> <a href="Computability.html">Computability</a> <a href="FixTransform.html">FixTransform</a> <a href="CPSUtils.html">CPSUtils</a> <a href="MapSets.html">MapSets</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">default_sort</span></span> <span class="quoted">type</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The point of the abstract semantics is that it is computable. To show this, we exploit the special structure of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aF&gt;›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aC&gt;›</span></span></span></span>: Each call adds some elements to the result set and joins this with the results from a number of recursive calls. So we separate these two actions into separate functions. These take as arguments the direct sum of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;afstate&gt;›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;acstate&gt;›</span></span></span></span>, i.e.\ we treat the two mutually recursive functions now as one.

<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>abs_g›</span></span></span></span> gives the local result for the given argument.
›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">abs_g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">::</span>contour <span class="main">\&lt;afstate&gt;</span> <span class="main">+</span> <span class="tfree">'c</span> <span class="main">\&lt;acstate&gt;</span><span class="main">)</span> discr <span class="main">→</span> <span class="tfree">'c</span> <span class="main">\&lt;aans&gt;</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">abs_g</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> undiscr <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span>
              <span class="main">(</span>Inl <span class="main">(</span>PC <span class="main">(</span>Lambda <span class="bound">lab</span> <span class="bound">vs</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span> <span class="bound">as</span><span class="main">,</span> <span class="bound">ve</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">{}</span>
            <span class="main">|</span> <span class="main">(</span>Inl <span class="main">(</span>PP <span class="main">(</span>Plus <span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">cnts</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span>
                     <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">;</span>
                         <span class="bound">β</span>  <span class="main">=</span> <span class="main">[</span><span class="bound">c</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                     <span class="keyword1">in</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span> <span class="bound">cont</span><span class="main">)</span> <span class="main">|</span> <span class="bound">cont</span> <span class="main">.</span> <span class="bound">cont</span> <span class="main">∈</span> <span class="bound">cnts</span><span class="main">}</span>
            <span class="main">|</span> <span class="main">(</span>Inl <span class="main">(</span>PP <span class="main">(</span>prim.If <span class="bound">ct</span> <span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">cntts</span><span class="main">,</span> <span class="bound">cntfs</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span>
                  <span class="main">(</span><span class="main">(</span>   <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">ct</span><span class="main">;</span>
                            <span class="bound">β</span> <span class="main">=</span> <span class="main">[</span><span class="bound">ct</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                        <span class="keyword1">in</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">ct</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span> <span class="bound">cnt</span><span class="main">)</span> <span class="main">|</span> <span class="bound">cnt</span> <span class="main">.</span> <span class="bound">cnt</span> <span class="main">∈</span> <span class="bound">cntts</span><span class="main">}</span>
                   <span class="main">)</span><span class="main">∪</span><span class="main">(</span>
                       <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">cf</span><span class="main">;</span>
                            <span class="bound">β</span> <span class="main">=</span> <span class="main">[</span><span class="bound">cf</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                        <span class="keyword1">in</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">cf</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span> <span class="bound">cnt</span><span class="main">)</span> <span class="main">|</span> <span class="bound">cnt</span> <span class="main">.</span> <span class="bound">cnt</span> <span class="main">∈</span> <span class="bound">cntfs</span><span class="main">}</span>
                   <span class="main">)</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>Inl <span class="main">(</span>AStop<span class="main">,</span><span class="main">[</span><span class="main"><span class="bound">_</span></span><span class="main">]</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">{}</span>
            <span class="main">|</span> <span class="main">(</span>Inl <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="main">⊥</span>
            <span class="main">|</span> <span class="main">(</span>Inr <span class="main">(</span>App <span class="bound">lab</span> <span class="bound">f</span> <span class="bound">vs</span><span class="main">,</span><span class="bound">β</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span>
                 <span class="keyword1">let</span> <span class="bound">fs</span> <span class="main">=</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">f</span> <span class="bound">β</span> <span class="bound">ve</span><span class="main">;</span>
                     <span class="bound">as</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">v</span> <span class="bound">β</span> <span class="bound">ve</span><span class="main">)</span> <span class="bound">vs</span><span class="main">;</span>
                     <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">lab</span>
                  <span class="keyword1">in</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">lab</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span><span class="bound">f'</span><span class="main">)</span> <span class="main">|</span> <span class="bound">f'</span> <span class="main">.</span> <span class="bound">f'</span><span class="main">∈</span> <span class="bound">fs</span><span class="main">}</span>
            <span class="main">|</span> <span class="main">(</span>Inr <span class="main">(</span>Let <span class="bound">lab</span> <span class="bound">ls</span> <span class="bound">c'</span><span class="main">,</span><span class="bound">β</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">{}</span>
        <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>abs_R›</span></span></span></span> gives the set of arguments passed to the recursive calls.
›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">abs_R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">::</span>contour <span class="main">\&lt;afstate&gt;</span> <span class="main">+</span> <span class="tfree">'c</span> <span class="main">\&lt;acstate&gt;</span><span class="main">)</span> discr <span class="main">→</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">::</span>contour <span class="main">\&lt;afstate&gt;</span> <span class="main">+</span> <span class="tfree">'c</span> <span class="main">\&lt;acstate&gt;</span><span class="main">)</span> discr set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">abs_R</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> undiscr <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span>
              <span class="main">(</span>Inl <span class="main">(</span>PC <span class="main">(</span>Lambda <span class="bound">lab</span> <span class="bound">vs</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">β</span><span class="main">)</span><span class="main">,</span> <span class="bound">as</span><span class="main">,</span> <span class="bound">ve</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span>
               <span class="main">(</span><span class="keyword1">if</span> length <span class="bound">vs</span> <span class="main">=</span> length <span class="bound">as</span>
                <span class="keyword1">then</span> <span class="keyword1">let</span> <span class="bound">β'</span> <span class="main">=</span> <span class="bound">β</span> <span class="main">(</span><span class="bound">lab</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">)</span><span class="main">;</span>
                         <span class="bound">ve'</span> <span class="main">=</span> <span class="bound">ve</span> <span class="main">∪.</span> <span class="main">(</span><span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">:=</span> <span class="bound">a</span><span class="main">}.</span><span class="main">)</span> <span class="main">(</span>zip <span class="bound">vs</span> <span class="bound">as</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                     <span class="keyword1">in</span> <span class="main">{</span>Discr <span class="main">(</span>Inr <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">β'</span><span class="main">,</span><span class="bound">ve'</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>
                <span class="keyword1">else</span> <span class="main">⊥</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>Inl <span class="main">(</span>PP <span class="main">(</span>Plus <span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">cnts</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span>
                     <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">c</span><span class="main">;</span>
                         <span class="bound">β</span>  <span class="main">=</span> <span class="main">[</span><span class="bound">c</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                     <span class="keyword1">in</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="bound">cnts</span><span class="main">.</span> <span class="main">{</span>Discr <span class="main">(</span>Inl <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="main">[</span><span class="main">{}</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>Inl <span class="main">(</span>PP <span class="main">(</span>prim.If <span class="bound">ct</span> <span class="bound">cf</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">cntts</span><span class="main">,</span> <span class="bound">cntfs</span><span class="main">]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span>
                  <span class="main">(</span><span class="main">(</span>   <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">ct</span><span class="main">;</span>
                            <span class="bound">β</span> <span class="main">=</span> <span class="main">[</span><span class="bound">ct</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                        <span class="keyword1">in</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="bound">cntts</span> <span class="main">.</span> <span class="main">{</span>Discr <span class="main">(</span>Inl <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
                   <span class="main">)</span><span class="main">∪</span><span class="main">(</span>
                       <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">cf</span><span class="main">;</span>
                            <span class="bound">β</span> <span class="main">=</span> <span class="main">[</span><span class="bound">cf</span> <span class="main">↦</span> <span class="bound">b</span><span class="main">]</span>
                        <span class="keyword1">in</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">cnt</span><span class="main">∈</span><span class="bound">cntfs</span> <span class="main">.</span> <span class="main">{</span>Discr <span class="main">(</span>Inl <span class="main">(</span><span class="bound">cnt</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
                   <span class="main">)</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>Inl <span class="main">(</span>AStop<span class="main">,</span><span class="main">[</span><span class="main"><span class="bound">_</span></span><span class="main">]</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">{}</span>
            <span class="main">|</span> <span class="main">(</span>Inl <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="main">⊥</span>
            <span class="main">|</span> <span class="main">(</span>Inr <span class="main">(</span>App <span class="bound">lab</span> <span class="bound">f</span> <span class="bound">vs</span><span class="main">,</span><span class="bound">β</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span>
                 <span class="keyword1">let</span> <span class="bound">fs</span> <span class="main">=</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">f</span> <span class="bound">β</span> <span class="bound">ve</span><span class="main">;</span>
                     <span class="bound">as</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">v</span> <span class="bound">β</span> <span class="bound">ve</span><span class="main">)</span> <span class="bound">vs</span><span class="main">;</span>
                     <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">lab</span>
                  <span class="keyword1">in</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">f'</span> <span class="main">∈</span> <span class="bound">fs</span><span class="main">.</span> <span class="main">{</span>Discr <span class="main">(</span>Inl <span class="main">(</span><span class="bound">f'</span><span class="main">,</span><span class="bound">as</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span>Inr <span class="main">(</span>Let <span class="bound">lab</span> <span class="bound">ls</span> <span class="bound">c'</span><span class="main">,</span><span class="bound">β</span><span class="main">,</span><span class="bound">ve</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span>
                 <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="main">\&lt;anb&gt;</span> <span class="bound">b</span> <span class="bound">lab</span><span class="main">;</span>
                     <span class="bound">β'</span> <span class="main">=</span> <span class="bound">β</span> <span class="main">(</span><span class="bound">lab</span> <span class="main">↦</span> <span class="bound">b'</span><span class="main">)</span><span class="main">;</span>
                     <span class="bound">ve'</span> <span class="main">=</span> <span class="bound">ve</span> <span class="main">∪.</span> <span class="main">(</span><span class="main">⋃.</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span> <span class="main">:=</span> <span class="main">(</span><span class="main">\&lt;aA&gt;</span> <span class="main">(</span>L <span class="bound">l</span><span class="main">)</span> <span class="bound">β'</span> <span class="bound">ve</span><span class="main">)</span><span class="main">}.</span><span class="main">)</span> <span class="bound">ls</span><span class="main">)</span><span class="main">)</span>
                 <span class="keyword1">in</span> <span class="main">{</span>Discr <span class="main">(</span>Inr <span class="main">(</span><span class="bound">c'</span><span class="main">,</span><span class="bound">β'</span><span class="main">,</span><span class="bound">ve'</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>
        <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The initial argument vector, as created by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aPR&gt;›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">initial_r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">::</span>contour <span class="main">\&lt;afstate&gt;</span> <span class="main">+</span> <span class="tfree">'c</span> <span class="main">\&lt;acstate&gt;</span><span class="main">)</span> discr"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">initial_r</span> <span class="free"><span class="bound"><span class="entity">prog</span></span></span> <span class="main">=</span> Discr <span class="main">(</span>Inl
     <span class="main">(</span>the_elem <span class="main">(</span><span class="main">\&lt;aA&gt;</span> <span class="main">(</span>L <span class="free"><span class="bound"><span class="entity">prog</span></span></span><span class="main">)</span> Map.empty <span class="main">{}.</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">{</span>AStop<span class="main">}</span><span class="main">]</span><span class="main">,</span> <span class="main">{}.</span><span class="main">,</span> <span class="main">\&lt;abinit&gt;</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Towards finiteness›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We need to show that the set of possible arguments for a given program <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p›</span></span></span></span> is finite. Therefore, we define the set of possible procedures, of possible arguments to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aF&gt;›</span></span></span></span>, or possible arguments to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aC&gt;›</span></span></span></span> and of possible arguments.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">proc_poss</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>contour proc set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">proc_poss</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> PC <span class="main">`</span> <span class="main">(</span>lambdas <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">×</span> maps_over <span class="main">(</span>labels <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> UNIV<span class="main">)</span> <span class="main">∪</span> PP <span class="main">`</span> prims <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∪</span> <span class="main">{</span>AStop<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fstate_poss</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>contour a_fstate set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fstate_poss</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>proc_poss <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">×</span> NList <span class="main">(</span>Pow <span class="main">(</span>proc_poss <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>call_list_lengths <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">×</span> smaps_over <span class="main">(</span>vars <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">(</span>proc_poss <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">×</span> UNIV<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cstate_poss</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span>contour a_cstate set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cstate_poss</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span>calls <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">×</span> maps_over <span class="main">(</span>labels <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> UNIV <span class="main">×</span> smaps_over <span class="main">(</span>vars <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">(</span>proc_poss <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">×</span> UNIV<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">arg_poss</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">::</span>contour a_fstate <span class="main">+</span> <span class="tfree">'c</span> a_cstate<span class="main">)</span> discr set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">arg_poss</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> Discr <span class="main">`</span> <span class="main">(</span>fstate_poss <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">&lt;+&gt;</span> cstate_poss <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Using the auxiliary results from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="CPSUtils.html"></a><a href="CPSUtils.html">Shivers-CFA.CPSUtils</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, we see that the argument space as defined here is finite.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_arg_space<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>arg_poss <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> arg_poss_def <span class="keyword2"><span class="keyword">and</span></span> cstate_poss_def <span class="keyword2"><span class="keyword">and</span></span> fstate_poss_def <span class="keyword2"><span class="keyword">and</span></span> proc_poss_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> finite_cartesian_product finite_imageI maps_over_finite smaps_over_finite finite_UNIV finite_Nlist<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
But is it closed? I.e.\ if we pass a member of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>arg_poss›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>abs_R›</span></span></span></span>, are the generated recursive call arguments also in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>arg_poss›</span></span></span></span>? This is shown in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>arg_space_complete›</span></span></span></span>, after proving an auxiliary result about the possible outcome of a call to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aA&gt;›</span></span></span></span> and an admissibility lemma.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> evalV_possible<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> <span class="main">\&lt;aA&gt;</span> <span class="free">d</span> <span class="free">β</span> <span class="free">ve</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">∈</span> vals <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ve</span> <span class="main">∈</span> smaps_over <span class="main">(</span>vars <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> β<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">β</span> <span class="main">∈</span> maps_over <span class="main">(</span>labels <span class="free">p</span><span class="main">)</span> UNIV"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> proc_poss <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">d</span><span class="main">,</span><span class="free">β</span><span class="main">,</span><span class="free">ve</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> evalV_a.cases<span class="main">)</span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">cl</span> <span class="skolem">β'</span> <span class="skolem">ve'</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> f <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">prim</span> <span class="skolem">β'</span> <span class="skolem">ve'</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> d f
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> vals1 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>proc_poss_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">l</span> <span class="skolem">var</span> <span class="skolem">β'</span> <span class="skolem">ve'</span><span class="main">)</span> 
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> f d smaps_over_im<span class="main">[</span><span class="operator">OF</span> _ ve<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>option.split_asm <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> vals2<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">l</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> f d β
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> vals3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>proc_poss_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> adm_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span>  adm <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">⊆</span> <span class="free">S</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sqsubset_is_subset<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> sym<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> adm_lemmas <span class="dynamic"><span class="dynamic">cont2cont</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> arg_space_complete<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">state</span> <span class="main">∈</span> arg_poss <span class="free">p</span> <span class="main">⟹</span> abs_R<span class="main">⋅</span><span class="free">state</span> <span class="main">⊆</span> arg_poss <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> abs_R.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> Admissibility Bot Step<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword3"><span class="command">case</span></span> Admissibility <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> adm_lemmas adm_subset <span class="dynamic"><span class="dynamic">cont2cont</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> Bot <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Step <span class="skolem">abs_R</span><span class="main">)</span> 
  <span class="keyword1"><span class="command">note</span></span> state <span class="main">=</span> Step<span class="main">(</span>2<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">state</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Discr <span class="skolem">state'</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
   <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">state'</span></span><span class="main">)</span>
     <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Inl <span class="skolem">fstate</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
     <span class="keyword1"><span class="command">using</span></span> Inl Discr state
     <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">fstate</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> a_fstate_case<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
     <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case Lambda›</span></span>
     <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="skolem">vs</span> <span class="skolem">c</span> <span class="skolem">β</span> <span class="skolem">as</span> <span class="skolem">ve</span> <span class="skolem">b</span>
     <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Discr <span class="main">(</span>Inl <span class="main">(</span>PC <span class="main">(</span>Lambda <span class="skolem">l</span> <span class="skolem">vs</span> <span class="skolem">c</span><span class="main">,</span> <span class="skolem">β</span><span class="main">)</span><span class="main">,</span> <span class="skolem">as</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> arg_poss <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">hence</span></span> lam<span class="main">:</span> <span class="quoted"><span class="quoted">"Lambda <span class="skolem">l</span> <span class="skolem">vs</span> <span class="skolem">c</span> <span class="main">∈</span> lambdas <span class="free">p</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span>  beta<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">β</span> <span class="main">∈</span> maps_over <span class="main">(</span>labels <span class="free">p</span><span class="main">)</span> UNIV "</span></span>
       <span class="keyword2"><span class="keyword">and</span></span>  ve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ve</span> <span class="main">∈</span> smaps_over <span class="main">(</span>vars <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span>  as<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">as</span> <span class="main">∈</span> NList <span class="main">(</span>Pow <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>call_list_lengths <span class="free">p</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> arg_poss_def fstate_poss_def proc_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

     <span class="keyword1"><span class="command">from</span></span> lam <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> calls <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lambdas1<span class="main">)</span>

     <span class="keyword1"><span class="command">moreover</span></span>
     <span class="keyword1"><span class="command">from</span></span> lam <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">∈</span> labels <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lambdas2<span class="main">)</span>
     <span class="keyword1"><span class="command">with</span></span> beta <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">β</span><span class="main">(</span><span class="skolem">l</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> maps_over <span class="main">(</span>labels <span class="free">p</span><span class="main">)</span> UNIV"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> maps_over_upd<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

     <span class="keyword1"><span class="command">moreover</span></span>
     <span class="keyword1"><span class="command">from</span></span> lam <span class="keyword1"><span class="command">have</span></span> vs<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">vs</span> <span class="main">⊆</span> vars <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lambdas3<span class="main">)</span>
     <span class="keyword1"><span class="command">from</span></span> as <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="skolem">as</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> Pow <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> NList_def nList_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">with</span></span> vs <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ve</span> <span class="main">∪.</span> <span class="main">⋃.</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">:=</span> <span class="bound">y</span><span class="main">}.</span><span class="main">)</span> <span class="main">(</span>zip <span class="skolem">vs</span> <span class="skolem">as</span><span class="main">)</span>
       <span class="main">∈</span> smaps_over <span class="main">(</span>vars <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?ve'</span> <span class="main">∈</span> <span class="main">_</span>"</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> smaps_over_un<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ve<span class="main"><span class="main">]</span></span> smaps_over_Union smaps_over_singleton<span class="main">)</span>
          <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>set_zip<span class="main">)</span>

     <span class="keyword1"><span class="command">ultimately</span></span>
     <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">c</span><span class="main">,</span> <span class="skolem">β</span><span class="main">(</span><span class="skolem">l</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">)</span><span class="main">,</span> <span class="var">?ve'</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> cstate_poss <span class="free">p</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?cstate</span> <span class="main">∈</span> <span class="main">_</span>"</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command">unfolding</span></span> cstate_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
     <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"Discr <span class="main">(</span>Inr <span class="var">?cstate</span><span class="main">)</span> <span class="main">∈</span> arg_poss <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> arg_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">next</span></span>

     <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case Plus›</span></span>
     <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ve</span> <span class="skolem">b</span> <span class="skolem">l</span> <span class="skolem">v1</span> <span class="skolem">v2</span> <span class="skolem">cnts</span> <span class="skolem">cnt</span>
     <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Discr <span class="main">(</span>Inl <span class="main">(</span>PP <span class="main">(</span>prim.Plus <span class="skolem">l</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="skolem">v1</span><span class="main">,</span> <span class="skolem">v2</span><span class="main">,</span> <span class="skolem">cnts</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> arg_poss <span class="free">p</span>"</span></span>
         <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cnt</span> <span class="main">∈</span> <span class="skolem">cnts</span>"</span></span>
     <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cnt</span> <span class="main">∈</span> proc_poss <span class="free">p</span>"</span></span> 
         <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ve</span> <span class="main">∈</span> smaps_over <span class="main">(</span>vars <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> arg_poss_def fstate_poss_def NList_def nList_def
       <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">moreover</span></span>
     <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">{}</span><span class="main">]</span> <span class="main">∈</span> NList <span class="main">(</span>Pow <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>call_list_lengths <span class="free">p</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> call_list_lengths_def NList_def nList_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">ultimately</span></span>
     <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[</span><span class="main">{}</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b</span> <span class="skolem">l</span><span class="main">)</span> <span class="main">∈</span> fstate_poss <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> fstate_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"Discr <span class="main">(</span>Inl <span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[</span><span class="main">{}</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b</span> <span class="skolem">l</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> arg_poss <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> arg_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">next</span></span>
  
     <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case If (true case)›</span></span>
     <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ve</span> <span class="skolem">b</span> <span class="skolem">l1</span> <span class="skolem">l2</span> <span class="skolem">v</span> <span class="skolem">cntst</span> <span class="skolem">cntsf</span> <span class="skolem">cnt</span>
     <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Discr <span class="main">(</span>Inl <span class="main">(</span>PP <span class="main">(</span>prim.If <span class="skolem">l1</span> <span class="skolem">l2</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">cntst</span><span class="main">,</span> <span class="skolem">cntsf</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> arg_poss <span class="free">p</span>"</span></span>
         <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cnt</span> <span class="main">∈</span> <span class="skolem">cntst</span>"</span></span>
     <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cnt</span> <span class="main">∈</span> proc_poss <span class="free">p</span>"</span></span>
         <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ve</span> <span class="main">∈</span> smaps_over <span class="main">(</span>vars <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> arg_poss_def fstate_poss_def NList_def nList_def
       <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">moreover</span></span>
     <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span> <span class="main">∈</span> NList <span class="main">(</span>Pow <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>call_list_lengths <span class="free">p</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> call_list_lengths_def NList_def nList_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">ultimately</span></span>
     <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b</span> <span class="skolem">l1</span><span class="main">)</span> <span class="main">∈</span> fstate_poss <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> fstate_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"Discr <span class="main">(</span>Inl <span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b</span> <span class="skolem">l1</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> arg_poss <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> arg_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">next</span></span>
  
     <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case If (false case)›</span></span>
     <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ve</span> <span class="skolem">b</span> <span class="skolem">l1</span> <span class="skolem">l2</span> <span class="skolem">v</span> <span class="skolem">cntst</span> <span class="skolem">cntsf</span> <span class="skolem">cnt</span>
     <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Discr <span class="main">(</span>Inl <span class="main">(</span>PP <span class="main">(</span>prim.If <span class="skolem">l1</span> <span class="skolem">l2</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">cntst</span><span class="main">,</span> <span class="skolem">cntsf</span><span class="main">]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> arg_poss <span class="free">p</span>"</span></span>
         <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cnt</span> <span class="main">∈</span> <span class="skolem">cntsf</span>"</span></span>
     <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cnt</span> <span class="main">∈</span> proc_poss <span class="free">p</span>"</span></span>
         <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ve</span> <span class="main">∈</span> smaps_over <span class="main">(</span>vars <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> arg_poss_def fstate_poss_def NList_def nList_def
       <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">moreover</span></span>
     <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span> <span class="main">∈</span> NList <span class="main">(</span>Pow <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>call_list_lengths <span class="free">p</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> call_list_lengths_def NList_def nList_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword1"><span class="command">ultimately</span></span>
     <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b</span> <span class="skolem">l2</span><span class="main">)</span> <span class="main">∈</span> fstate_poss <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> fstate_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
     <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"Discr <span class="main">(</span>Inl <span class="main">(</span><span class="skolem">cnt</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b</span> <span class="skolem">l2</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> arg_poss <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> arg_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Inr <span class="skolem">cstate</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">cstate</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> prod_cases4<span class="main">)</span>
   <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>fields <span class="skolem">c</span> <span class="skolem">β</span> <span class="skolem">ve</span> <span class="skolem">b</span><span class="main">)</span>
   <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Discr Inr fields state <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">c</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>HOL.Let_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>evalV_a.simps<span class="main">)</span>

     <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case App›</span></span>
     <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="skolem">d</span> <span class="skolem">ds</span> <span class="skolem">f</span>
     <span class="keyword3"><span class="command">assume</span></span> arg<span class="main">:</span> <span class="quoted"><span class="quoted">"Discr <span class="main">(</span>Inr <span class="main">(</span>App <span class="skolem">l</span> <span class="skolem">d</span> <span class="skolem">ds</span><span class="main">,</span> <span class="skolem">β</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> arg_poss <span class="free">p</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">∈</span> <span class="main">\&lt;aA&gt;</span> <span class="skolem">d</span> <span class="skolem">β</span> <span class="skolem">ve</span>"</span></span>
     <span class="keyword1"><span class="command">hence</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"App <span class="skolem">l</span> <span class="skolem">d</span> <span class="skolem">ds</span> <span class="main">∈</span> calls <span class="free">p</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> vals <span class="free">p</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> ds<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">ds</span> <span class="main">⊆</span> vals <span class="free">p</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> beta<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">β</span> <span class="main">∈</span> maps_over <span class="main">(</span>labels <span class="free">p</span><span class="main">)</span> UNIV"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> ve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ve</span> <span class="main">∈</span> smaps_over <span class="main">(</span>vars <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> arg_poss_def cstate_poss_def call_list_lengths_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> app1 app2<span class="main">)</span>

     <span class="keyword1"><span class="command">have</span></span> len<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">ds</span> <span class="main">∈</span> call_list_lengths <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> c<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> call_list_lengths_def<span class="main">)</span>

     <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">∈</span> proc_poss <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">using</span></span> f d ve beta <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> evalV_possible<span class="main">)</span>
     <span class="keyword1"><span class="command">moreover</span></span>
     <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">v</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span> <span class="skolem">ds</span> <span class="main">∈</span> NList <span class="main">(</span>Pow <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>call_list_lengths <span class="free">p</span><span class="main">)</span>"</span></span>
       <span class="keyword1"><span class="command">using</span></span> ds len
       <span class="keyword1"><span class="command">unfolding</span></span> NList_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>nList_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> evalV_possible<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ _ ve beta<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command">ultimately</span></span> 
     <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">\&lt;aA&gt;</span> <span class="bound">v</span> <span class="skolem">β</span> <span class="skolem">ve</span><span class="main">)</span> <span class="skolem">ds</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b</span> <span class="skolem">l</span><span class="main">)</span> <span class="main">∈</span> fstate_poss <span class="free">p</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?fstate</span> <span class="main">∈</span> <span class="main">_</span>"</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command">using</span></span> ve 
       <span class="keyword1"><span class="command">unfolding</span></span> fstate_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
     <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"Discr <span class="main">(</span>Inl <span class="var">?fstate</span><span class="main">)</span> <span class="main">∈</span> arg_poss <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> arg_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

   <span class="keyword1"><span class="command">next</span></span>
     <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Case Let›</span></span>
     <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="skolem">binds</span> <span class="skolem">c'</span>
     <span class="keyword3"><span class="command">assume</span></span> arg<span class="main">:</span> <span class="quoted"><span class="quoted">"Discr <span class="main">(</span>Inr <span class="main">(</span>Let <span class="skolem">l</span> <span class="skolem">binds</span> <span class="skolem">c'</span><span class="main">,</span> <span class="skolem">β</span><span class="main">,</span> <span class="skolem">ve</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> arg_poss <span class="free">p</span>"</span></span>
     <span class="keyword1"><span class="command">hence</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">∈</span> labels <span class="free">p</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> c'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c'</span> <span class="main">∈</span> calls <span class="free">p</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> vars<span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="main">`</span> set <span class="skolem">binds</span> <span class="main">⊆</span> vars <span class="free">p</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> ls<span class="main">:</span> <span class="quoted"><span class="quoted">"snd <span class="main">`</span> set <span class="skolem">binds</span> <span class="main">⊆</span> lambdas <span class="free">p</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> beta<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">β</span> <span class="main">∈</span> maps_over <span class="main">(</span>labels <span class="free">p</span><span class="main">)</span> UNIV"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> ve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ve</span> <span class="main">∈</span> smaps_over <span class="main">(</span>vars <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> arg_poss_def cstate_poss_def call_list_lengths_def
              <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span>let1 let2 let3 let4<span class="main">)</span>

     <span class="keyword1"><span class="command">have</span></span> beta'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">β</span><span class="main">(</span><span class="skolem">l</span> <span class="main">↦</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b</span> <span class="skolem">l</span><span class="main">)</span> <span class="main">∈</span> maps_over <span class="main">(</span>labels <span class="free">p</span><span class="main">)</span> UNIV"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?β'</span> <span class="main">∈</span> <span class="main">_</span>"</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> maps_over_upd<span class="main"><span class="main">[</span></span><span class="operator">OF</span> beta l<span class="main"><span class="main">]</span></span><span class="main">)</span>

     <span class="keyword1"><span class="command">moreover</span></span>
     <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ve</span> <span class="main">∪.</span> <span class="main">⋃.</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">lam</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b</span> <span class="skolem">l</span><span class="main">)</span> <span class="main">:=</span> <span class="main">\&lt;aA&gt;</span> <span class="main">(</span>L <span class="bound">lam</span><span class="main">)</span> <span class="main">(</span><span class="skolem">β</span><span class="main">(</span><span class="skolem">l</span> <span class="main">↦</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b</span> <span class="skolem">l</span><span class="main">)</span><span class="main">)</span> <span class="skolem">ve</span> <span class="main">}.</span><span class="main">)</span>
                <span class="skolem">binds</span>
       <span class="main">∈</span> smaps_over <span class="main">(</span>vars <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">(</span>proc_poss <span class="free">p</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?ve'</span> <span class="main">∈</span> <span class="main">_</span>"</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command">using</span></span> vars ls beta'
       <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> smaps_over_un<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ve<span class="main"><span class="main">]</span></span> smaps_over_Union<span class="main">)</span>
          <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>smaps_over_singleton <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> proc_poss_def<span class="main">)</span>

     <span class="keyword1"><span class="command">ultimately</span></span>
     <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">c'</span><span class="main">,</span> <span class="var">?β'</span><span class="main">,</span> <span class="var">?ve'</span><span class="main">,</span> <span class="main">\&lt;anb&gt;</span> <span class="skolem">b</span> <span class="skolem">l</span><span class="main">)</span> <span class="main">∈</span> cstate_poss <span class="free">p</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?cstate</span> <span class="main">∈</span> <span class="main">_</span>"</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command">using</span></span> c' <span class="keyword1"><span class="command">unfolding</span></span> cstate_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
     <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"Discr <span class="main">(</span>Inr <span class="var">?cstate</span><span class="main">)</span> <span class="main">∈</span> arg_poss <span class="free">p</span>"</span></span>
       <span class="keyword1"><span class="command">unfolding</span></span> arg_poss_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
   <span class="keyword1"><span class="command">qed</span></span>
 <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This result is now lifted to the powerset of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>abs_R›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> arg_space_complete_ps<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">states</span> <span class="main">⊆</span> arg_poss <span class="free">p</span> <span class="main">⟹</span> <span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span>abs_R<span class="main">)</span><span class="main">⋅</span><span class="free">states</span> <span class="main">⊆</span> arg_poss <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> arg_space_complete <span class="keyword1"><span class="command">unfolding</span></span> powerset_lift_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We are not so much interested in the finiteness of the set of possible arguments but rather of the the set of occurring arguments, when we start with the initial argument. But as this is of course a subset of the set of possible arguments, this is not hard to show.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> UN_iterate_less<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> start<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span><span class="main">⊆</span><span class="free">S</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> iterate <span class="bound">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span> <span class="keyword1"><span class="command">{</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"iterate <span class="skolem">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> <span class="free">S</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> step<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"iterate <span class="skolem">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> args_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> iterate <span class="bound">i</span><span class="main">⋅</span><span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span>abs_R<span class="main">)</span><span class="main">⋅</span><span class="main">{</span>initial_r <span class="free">p</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?S</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _finite_arg_space<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∈</span> lambdas <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">⊆</span> arg_poss <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> initial_r_def
  <span class="keyword1"><span class="command">by</span></span>  <span class="main">(</span><span class="operator">rule</span> UN_iterate_less<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ arg_space_complete_ps<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>arg_poss_def fstate_poss_def proc_poss_def call_list_lengths_def NList_def nList_def
         <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> imageI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A decomposition›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The functions <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>abs_g›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>abs_R›</span></span></span></span> are derived from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aF&gt;›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aC&gt;›</span></span></span></span>. This connection has yet to expressed explicitly. 
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Un_commute_helper<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">∪</span> <span class="free">b</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">c</span> <span class="main">∪</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">∪</span> <span class="free">c</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="free">b</span> <span class="main">∪</span> <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> a_evalF_decomp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">\&lt;aF&gt;</span> <span class="main">=</span> fst <span class="main">(</span>sum_to_tup<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> f x<span class="main">.</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span>abs_R<span class="main">⋅</span><span class="bound">x</span><span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span> <span class="main">∪</span> abs_g<span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> a_evalF_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_transform_pair_sum<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> fst <span class="main"><span class="main">(</span></span>sum_to_tup<span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span>fix<span class="main"><span class="main">⋅</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> discr_app undiscr_Discr<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> a<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">aa</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>a_fstate_case<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Un_commute_helper<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">b</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>prod_cases4<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">aa</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>HOL.Let_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The iterative equation›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Because of the special form of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aF&gt;›</span></span></span></span> (and thus <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>\&lt;aPR&gt;›</span></span></span></span>) derived in the previous lemma, we can apply our generic results from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="Computability.html"></a><a href="Computability.html">Shivers-CFA.Computability</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and express the abstract semantics as the image of a finite set under a computable function.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> a_evalF_iterative<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">\&lt;aF&gt;</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span>abs_g<span class="main">⋅</span><span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> iterate <span class="bound">i</span><span class="main">⋅</span><span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span>abs_R<span class="main">)</span><span class="main">⋅</span><span class="main">{</span>Discr <span class="main">(</span>Inl <span class="free">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>abs_R.simps abs_g.simps <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> theorem12 Un_commute a_evalF_decomp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> a_evalCPS_interative<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">\&lt;aPR&gt;</span> <span class="free">prog</span> <span class="main">=</span> <span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span>abs_g<span class="main">⋅</span><span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> iterate <span class="bound">i</span><span class="main">⋅</span><span class="main">(</span><span class="main"><span class="hidden">\&lt;^</span><span class="control">ps</span><span class="hidden">&gt;</span></span>abs_R<span class="main">)</span><span class="main">⋅</span><span class="main">{</span>initial_r <span class="free">prog</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> evalCPS_a_def <span class="keyword2"><span class="keyword">and</span></span> initial_r_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> a_evalF_iterative<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>abs_R.simps abs_g.simps evalV_a.simps<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>