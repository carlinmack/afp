<div id="Stimuli">
<div class="head"><h1>Theory Stimuli</h1>
<span class="command">theory</span> <span class="name">Stimuli</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:        C2KA Stimulus Structure
    Author:       Maxime Buyse &lt;maxime.buyse at polytechnique.edu&gt;, 2019
    Maintainers:  Maxime Buyse &lt;maxime.buyse at polytechnique.edu&gt; and Jason Jaskolka &lt;jason.jaskolka at carleton.ca&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Stimulus Structure \label{sec:stimulus_structure}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
A stimulus constitutes the basis for behaviour. Because of this, each discrete, observable event 
introduced to a system, such as that which occurs through the communication among agents or from the 
system environment, is considered to be a stimulus which invokes a response from each system agent.

A \emph{stimulus structure} is an idempotent semiring~$\STIMstructure$ with a multiplicatively 
absorbing~$\Dstim$ and identity~$\Nstim$. Within the context of stimuli,~$\STIMset$ is a set of 
stimuli which may be introduced to a system. The operator~$\STIMplus$ is interpreted as a choice 
between two stimuli and the operator~$\STIMdot$ is interpreted as a sequential composition of two 
stimuli. The element~$\Dstim$ represents the \emph{deactivation stimulus} which influences all agents 
to become inactive and the element~$\Nstim$ represents the \emph{neutral stimulus} which has no influence 
on the behaviour of all agents. The natural ordering relation~$\STIMle$ on a stimulus structure~$\stim$ 
is called the sub-stimulus relation. For stimuli~$s,t \in \STIMset$, we write~$s \STIMle t$ and say 
that~$s$ is a sub-stimulus of~$t$ if and only if~$s \STIMplus t = t$. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Stimuli</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The class \emph{stimuli} describes the stimulus structure for \CCKAabbrv. We do not use 
Isabelle's built-in theories for groups and orderings to allow a different notation for the operations 
on stimuli to be consistent with~\cite{Jaskolka2015ab}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>plus_ord</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>leq</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_/ ≤<span class="hidden">⇩</span><sub>𝒮</sub> _)"</span></span></span><span>  </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">]</span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>add</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊕"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>leq_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤<span class="hidden">⇩</span><sub>𝒮</sub> y ⟷ x ⊕ y = y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>add_assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ⊕ y) ⊕ z = x ⊕ (y ⊕ z)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>add_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊕ y = y ⊕ x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span>
</span><span>  </span><span>leq</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'(≤')"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>leq</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_/ ≤<span class="hidden">⇩</span><sub>𝒮</sub> _)"</span></span></span><span>  </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">]</span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>stimuli</span><span> </span><span class="delimiter">=</span><span> </span><span>plus_ord</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>seq_comp</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊙"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>neutral</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"𝔫"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>deactivation</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"𝔡"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>basic</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"𝒮<span class="hidden">⇩</span><sub>a</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>stim_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊕ x = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seq_nl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔫 ⊙ x = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seq_nr</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊙ 𝔫 = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>add_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 ⊕ x = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>absorbingl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 ⊙ x = 𝔡"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>absorbingr</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊙ 𝔡 = 𝔡"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>zero_not_basic</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 ∉ 𝒮<span class="hidden">⇩</span><sub>a</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_add_S_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤<span class="hidden">⇩</span><sub>𝒮</sub> y ⟹ x ≤<span class="hidden">⇩</span><sub>𝒮</sub> y ⊕ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>leq_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_assoc</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_add_S_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤<span class="hidden">⇩</span><sub>𝒮</sub> y ⟹ x ≤<span class="hidden">⇩</span><sub>𝒮</sub> z ⊕ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_comm</span><span> </span><span>inf_add_S_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>leq_refl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤<span class="hidden">⇩</span><sub>𝒮</sub> x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>leq_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="CKA">
<div class="head"><h1>Theory CKA</h1>
<span class="command">theory</span> <span class="name">CKA</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:        C2KA Behaviour Structure (Concurrent Kleene Algebra)
    Author:       Maxime Buyse &lt;maxime.buyse at polytechnique.edu&gt;, 2019
    Maintainers:  Maxime Buyse &lt;maxime.buyse at polytechnique.edu&gt; and Jason Jaskolka &lt;jason.jaskolka at carleton.ca&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Behaviour Structure \label{sec:behaviour_structure}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Hoare et al.~\cite{Hoare2011aa} presented the framework of Concurrent Kleene Algebra (\CKAabbrv) which captures the concurrent 
behaviour of agents. The framework of \CKAabbrv is adopted to describe agent behaviours in distributed 
systems. For a \CKAabbrv~$\CKAstructure$,~$\CKAset$ is a set of possible behaviours. The operator~$+$ is 
interpreted as a choice between two behaviours, the operator~$\CKAseq$ is interpreted as a sequential 
composition of two behaviours, and the operator~$\CKApar$ is interpreted as a parallel composition of 
two behaviours. The operators~$\CKAiterSeq{\,}$ and~$\CKAiterPar{\,}$ are interpreted as a finite sequential 
iteration and a finite parallel iteration of behaviours, respectively. The element~$0$ represents the 
behaviour of the \emph{inactive agent} and the element~$1$ represents the behaviour of the \emph{idle agent}. 
Associated with a \CKAabbrv~$\cka$ is a natural ordering relation~$\CKAle$ related to the semirings upon which the 
\CKAabbrv is built which is called the sub-behaviour relation. For behaviours~$a,b \in \CKAset$, we 
write~$a \CKAle b$ and say that~$a$ is a sub-behaviour of~$b$ if and only if~$a + b = b$.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CKA</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span>
</span><span>rtrancl</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>999</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span>
</span><span>times</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"*"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>less_eq</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'(≤<span class="hidden">⇩</span><sub>𝒦</sub>')"</span></span></span><span class="delimiter">)</span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>less_eq</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_/ ≤<span class="hidden">⇩</span><sub>𝒦</sub> _)"</span></span></span><span>  </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">]</span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The class \emph{cka} contains an axiomatisation of Concurrent Kleene Algebras and a selection of useful theorems.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>join_semilattice</span><span> </span><span class="delimiter">=</span><span> </span><span>ordered_ab_semigroup_add</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>leq_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟷ x + y = y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>le_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; y ⟷ x ≤ y ∧ x ≠ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>add_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x + x = x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_add_K_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤<span class="hidden">⇩</span><sub>𝒦</sub> a + b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>leq_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>add_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_add_K_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤<span class="hidden">⇩</span><sub>𝒦</sub> b + a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>add_commute</span><span class="delimiter">,</span><span> </span><span>fact</span><span> </span><span>inf_add_K_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>dioid</span><span> </span><span class="delimiter">=</span><span> </span><span>semiring</span><span> </span><span class="delimiter">+</span><span> </span><span>one</span><span> </span><span class="delimiter">+</span><span> </span><span>zero</span><span> </span><span class="delimiter">+</span><span> </span><span>join_semilattice</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>par_onel</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 * x = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>par_oner</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x * 1 = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>add_zerol</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 + x = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>annil</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 * x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>annir</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x * 0 = 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>kleene_algebra</span><span> </span><span class="delimiter">=</span><span> </span><span>dioid</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>star</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>101</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>star_unfoldl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + x * x<span class="hidden">⇧</span><sup>*</sup> ≤<span class="hidden">⇩</span><sub>𝒦</sub> x<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>star_unfoldr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + x<span class="hidden">⇧</span><sup>*</sup> * x ≤<span class="hidden">⇩</span><sub>𝒦</sub> x<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>star_inductl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + x * y ≤<span class="hidden">⇩</span><sub>𝒦</sub> y ⟹ x<span class="hidden">⇧</span><sup>*</sup> * z ≤<span class="hidden">⇩</span><sub>𝒦</sub> y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>star_inductr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y * x ≤<span class="hidden">⇩</span><sub>𝒦</sub> y ⟹ z * x<span class="hidden">⇧</span><sup>*</sup> ≤<span class="hidden">⇩</span><sub>𝒦</sub> y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>cka</span><span> </span><span class="delimiter">=</span><span> </span><span>kleene_algebra</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>seq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seqstar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇧</span><sup>;</sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>101</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>seq_assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ; (y ; z) = (x ; y) ; z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seq_rident</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ; 1 = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seq_lident</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ; x = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seq_rdistrib</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x + y);z = x;z + y;z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seq_ldistrib</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x;(y + z) = x;y + x;z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seq_annir</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ; 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seq_annil</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ; x = 0"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seqstar_unfoldl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + x ; x<span class="hidden">⇧</span><sup>;</sup> ≤<span class="hidden">⇩</span><sub>𝒦</sub> x<span class="hidden">⇧</span><sup>;</sup>"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seqstar_unfoldr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + x<span class="hidden">⇧</span><sup>;</sup> ; x ≤<span class="hidden">⇩</span><sub>𝒦</sub> x<span class="hidden">⇧</span><sup>;</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seqstar_inductl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + x ; y ≤<span class="hidden">⇩</span><sub>𝒦</sub> y ⟹ x<span class="hidden">⇧</span><sup>;</sup> ; z ≤<span class="hidden">⇩</span><sub>𝒦</sub> y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seqstar_inductr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y ; x ≤<span class="hidden">⇩</span><sub>𝒦</sub> y ⟹ z ; x<span class="hidden">⇧</span><sup>;</sup> ≤<span class="hidden">⇩</span><sub>𝒦</sub> y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>exchange</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a*b) ; (c*d) ≤<span class="hidden">⇩</span><sub>𝒦</sub> (b;c) * (a;d)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>cka</span><span class="delimiter">:</span><span> </span><span>kleene_algebra</span><span> </span><span>plus</span><span> </span><span>less_eq</span><span> </span><span>less</span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0"</span></span></span><span> </span><span>seq</span><span> </span><span>seqstar</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq_assoc</span><span> </span><span>seqstar_unfoldl</span><span> </span><span>seqstar_unfoldr</span><span> </span><span>seqstar_inductl</span><span> </span><span>seqstar_inductr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>par_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a * b = b * a"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(b*a) ; (1*1) ≤<span class="hidden">⇩</span><sub>𝒦</sub> (a;1) * (b;1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>  </span><span>exchange</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b * a ≤<span class="hidden">⇩</span><sub>𝒦</sub> a * b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a * b ≤<span class="hidden">⇩</span><sub>𝒦</sub> b * a ⟷ a * b  = b * a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a * b ≤<span class="hidden">⇩</span><sub>𝒦</sub> b * a"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a*b) ; (1*1) ≤<span class="hidden">⇩</span><sub>𝒦</sub> (b;1) * (a;1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span>  </span><span>exchange</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exchange_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a*b) ; (c*d) ≤<span class="hidden">⇩</span><sub>𝒦</sub> (a;c) * (b;d)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(b*a) ; (c*d) ≤<span class="hidden">⇩</span><sub>𝒦</sub> (a;c) * (b;d)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exchange</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>par_comm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_inf_par</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ; b ≤<span class="hidden">⇩</span><sub>𝒦</sub> a * b"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(1*a) ; (1*b) ≤<span class="hidden">⇩</span><sub>𝒦</sub> (a;1) * (1;b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exchange</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_seq_inf_par</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a;b + b;a ≤<span class="hidden">⇩</span><sub>𝒦</sub> a*b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a;b ≤<span class="hidden">⇩</span><sub>𝒦</sub> a*b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>seq_inf_par</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b;a ≤<span class="hidden">⇩</span><sub>𝒦</sub> b*a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>seq_inf_par</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a;b + b;a ≤<span class="hidden">⇩</span><sub>𝒦</sub> a*b + b*a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>par_comm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exchange_3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a*b) ; c ≤<span class="hidden">⇩</span><sub>𝒦</sub> a * (b;c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a*b) ; (1*c) ≤<span class="hidden">⇩</span><sub>𝒦</sub> (a;1) * (b;c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exchange_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exchange_4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ; (b*c) ≤<span class="hidden">⇩</span><sub>𝒦</sub> (a;b) * c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(1*a) ; (b*c) ≤<span class="hidden">⇩</span><sub>𝒦</sub> (a;b) * (1;c)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exchange</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seqstar_inf_parstar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a<span class="hidden">⇧</span><sup>;</sup> ≤<span class="hidden">⇩</span><sub>𝒦</sub> a<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ; a<span class="hidden">⇧</span><sup>*</sup> ≤<span class="hidden">⇩</span><sub>𝒦</sub> a * a<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>seq_inf_par</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + a ; a<span class="hidden">⇧</span><sup>*</sup> ≤<span class="hidden">⇩</span><sub>𝒦</sub> 1 + a * a<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_left_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + a ; a<span class="hidden">⇧</span><sup>*</sup> ≤<span class="hidden">⇩</span><sub>𝒦</sub> a<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>star_unfoldl</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a<span class="hidden">⇧</span><sup>;</sup> ; 1 ≤<span class="hidden">⇩</span><sub>𝒦</sub> a<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>seqstar_inductl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="C2KA">
<div class="head"><h1>Theory C2KA</h1>
<span class="command">theory</span> <span class="name">C2KA</span><br/>
<span class="keyword">imports</span> <a href="CKA.html"><span class="name">CKA</span></a> <a href="Stimuli.html"><span class="name">Stimuli</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:        C2KA: Communicating Concurrent Kleene Algebra
    Author:       Maxime Buyse &lt;maxime.buyse at polytechnique.edu&gt;, 2019
    Maintainers:  Maxime Buyse &lt;maxime.buyse at polytechnique.edu&gt; and Jason Jaskolka &lt;jason.jaskolka at carleton.ca&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Communicating Concurrent Kleene Algebra \label{sec:ccka}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
\CCKAabbrv extends the algebraic foundation of \CKAabbrv with the notions of semimodules and 
stimulus structures to capture the influence of stimuli on the behaviour of system agents.

A \CCKAabbrv is a mathematical system consisting of two semimodules which describe how a stimulus 
structure~$\stim$ and a \CKAabbrv~$\cka$ mutually act upon one another to characterize the response 
invoked by a stimulus on an agent behaviour as a next behaviour and a next stimulus. The 
\leftSemimodule{\stim}~$\ActSemimodule$ describes how the stimulus structure~$\stim$ acts upon the 
\CKAabbrv~$\cka$ via the mapping~$\actOp$. The mapping~$\actOp$ is called the \emph{next behaviour mapping} 
and it describes how a stimulus invokes a behavioural response from a given agent. From~$\ActSemimodule$, 
the next behaviour mapping~$\actOp$ distributes over~$+$ and~$\STIMplus$. Additionally, since~$\ActSemimodule$ 
is unitary, it is the case that the neutral stimulus has no influence on the behaviour of all agents and 
since~$\ActSemimodule$ is zero-preserving, the deactivation stimulus influences all agents to become inactive. 
The \rightSemimodule{\cka}~$\OutSemimodule$ describes how the \CKAabbrv~$\cka$ acts upon the stimulus 
structure~$\stim$ via the mapping~$\outOp$. The mapping~$\outOp$ is called the \emph{next stimulus mapping} 
and it describes how a new stimulus is generated as a result of the response invoked by a given stimulus on 
an agent behaviour. From~$\OutSemimodule$, the next stimulus mapping~$\outOp$ distributes over~$\STIMplus$ 
and~$+$. Also, since~$\OutSemimodule$ is unitary, it is the case that the idle agent forwards any stimulus that 
acts on it and since~$\OutSemimodule$ is zero-preserving, the inactive agent always generates the deactivation 
stimulus. A full account of \CCKAabbrv can be found in~\cite{Jaskolka2015ab,Jaskolka2013aa,Jaskolka2014aa}. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>C2KA</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>CKA</span><span> </span><span>Stimuli</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span>
</span><span>comp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∘"</span></span></span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rtrancl</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>999</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The locale \emph{c2ka} contains an axiomatisation of \CCKAabbrv  and some basic theorems relying on the 
axiomatisations of stimulus structures and \CKAabbrv provided in Sections~\ref{sec:stimulus_structure} 
and~\ref{sec:behaviour_structure}, respectively. We use a locale instead of a class in order to allow 
stimuli and behaviours to have two different types.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>c2ka</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>next_behaviour</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b::stimuli ⇒ 'a::cka ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∘"</span></span></span><span> </span><span>75</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>next_stimulus</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b::stimuli × 'a::cka) ⇒ 'b"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"λ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lsemimodule1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ (a + b) = (s ∘ a) + (s ∘ b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lsemimodule2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s ⊕ t) ∘ a = (s ∘ a) + (t ∘ a)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lsemimodule3</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s ⊙ t) ∘ a = s ∘ (t ∘ a)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lsemimodule4</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔫 ∘ a = a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lsemimodule5</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝔡 ∘ a = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rsemimodule1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s ⊕ t, a) = λ(s, a) ⊕ λ(t, a)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rsemimodule2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, a + b) = λ(s, a) ⊕ λ(s, b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rsemimodule3</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, a ; b) = λ(λ(s, a), b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rsemimodule4</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, 1) = s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rsemimodule5</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, 0) = 𝔡"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cascadingaxiom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ (a ; b) = (s ∘ a);(λ(s, a) ∘ b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cascadingoutputlaw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤<span class="hidden">⇩</span><sub>𝒦</sub> c ∨ b = 1 ∨ (s ∘ a);(λ(s,c) ∘ b) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sequentialoutputlaw</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s ⊙ t, a) = λ(s, t∘a) ⊙ λ(t, a)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>onefix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s = 𝔡 ∨ s ∘ 1 = 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>neutralunmodified</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = 0 ∨ λ(𝔫, a) = 𝔫"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Lemmas \emph{inf-K-S-next-behaviour} and \emph{inf-K-S-next-stimulus} show basic results from the axiomatisation of \CCKAabbrv.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_K_S_next_behaviour</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a ≤<span class="hidden">⇩</span><sub>𝒦</sub> b ∧ s ≤<span class="hidden">⇩</span><sub>𝒮</sub> t) ⟹ (s ∘ a ≤<span class="hidden">⇩</span><sub>𝒦</sub> t ∘ b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Stimuli.leq_def</span><span> </span><span>CKA.leq_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a + b = b ∧ s ⊕ t = t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ a + t ∘ b = s ∘ a + (s ⊕ t) ∘ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ a + t ∘ b = s ∘ a + s ∘ b + t ∘ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ (a + b) = s ∘ a + s ∘ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ a + t ∘ b = s ∘ (a + b) + t ∘ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ a + t ∘ b = s ∘ b + t ∘ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hyp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ a + t ∘ b = (s ⊕ t) ∘ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ a + t ∘ b = t ∘ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hyp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_K_S_next_stimulus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤<span class="hidden">⇩</span><sub>𝒦</sub> b ∧ s ≤<span class="hidden">⇩</span><sub>𝒮</sub> t ⟹ λ(s,a) ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(t,b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Stimuli.leq_def</span><span> </span><span>CKA.leq_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a + b = b ∧ s ⊕ t = t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s,a) ⊕ λ(t,b) = λ(s,a) ⊕ λ(s⊕t,b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s,a) ⊕ λ(t,b) = λ(s,a) ⊕ λ(s,b) ⊕ λ(t,b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s,a+b) = λ(s,a) ⊕ λ(s,b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s,a) ⊕ λ(t,b) = λ(s,a+b) ⊕ λ(t,b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s,a) ⊕ λ(t,b) = λ(s,b) ⊕ λ(t,b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hyp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s,a) ⊕ λ(t,b) = λ(s⊕t,b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s,a) ⊕ λ(t,b) = λ(t,b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hyp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The following lemmas show additional results from the axiomatisation of \CCKAabbrv which follow from lemmas \emph{inf-K-S-next-behaviour} and \emph{inf-K-S-next-stimulus}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_K_next_behaviour</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤<span class="hidden">⇩</span><sub>𝒦</sub> b ⟹ s ∘ a ≤<span class="hidden">⇩</span><sub>𝒦</sub> s ∘ b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inf_K_S_next_behaviour</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_S_next_behaviour</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≤<span class="hidden">⇩</span><sub>𝒮</sub> t ⟹ s ∘ a ≤<span class="hidden">⇩</span><sub>𝒦</sub> t ∘ a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inf_K_S_next_behaviour</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_add_seq_par_next_behaviour</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ (a;b + b;a) ≤<span class="hidden">⇩</span><sub>𝒦</sub> s ∘ (a*b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_K_next_behaviour</span><span> </span><span>add_seq_inf_par</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_seqstar_parstar_next_behaviour</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ a<span class="hidden">⇧</span><sup>;</sup> ≤<span class="hidden">⇩</span><sub>𝒦</sub> s ∘ a<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seqstar_inf_parstar</span><span> </span><span>inf_K_next_behaviour</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_S_next_stimulus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≤<span class="hidden">⇩</span><sub>𝒮</sub> t ⟹ λ(s,a) ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(t,a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inf_K_S_next_stimulus</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_K_next_stimulus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤<span class="hidden">⇩</span><sub>𝒦</sub> b ⟹ λ(s,a) ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inf_K_S_next_stimulus</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_add_seq_par_next_stimulus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, a;b + b;a) ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s, a*b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a;b ≤<span class="hidden">⇩</span><sub>𝒦</sub> a*b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>seq_inf_par</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b;a ≤<span class="hidden">⇩</span><sub>𝒦</sub> b*a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>seq_inf_par</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a;b + b;a ≤<span class="hidden">⇩</span><sub>𝒦</sub> a*b + b*a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a;b + b;a ≤<span class="hidden">⇩</span><sub>𝒦</sub> a*b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>par_comm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, a;b + b;a) ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s, a*b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inf_K_next_stimulus</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_seqstar_parstar_next_stimulus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, a<span class="hidden">⇧</span><sup>;</sup>) ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s, a<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seqstar_inf_parstar</span><span> </span><span>inf_K_next_stimulus</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Topology_C2KA">
<div class="head"><h1>Theory Topology_C2KA</h1>
<span class="command">theory</span> <span class="name">Topology_C2KA</span><br/>
<span class="keyword">imports</span> <a href="C2KA.html"><span class="name">C2KA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:        Notions of Topology for C2KA
    Author:       Maxime Buyse &lt;maxime.buyse at polytechnique.edu&gt;, 2019
    Maintainers:  Maxime Buyse &lt;maxime.buyse at polytechnique.edu&gt; and Jason Jaskolka &lt;jason.jaskolka at carleton.ca&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Notions of Topology for \CCKAabbrv \label{sec:topology}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Orbits, stabilisers, and fixed points are notions that allow us to perceive a kind of topology of a system 
with respect to the stimulus-response relationships among system agents. In this context, the term ``topology'' 
is used to capture the relationships (influence) and connectedness via stimuli of the agents in a distributed 
system. It intends to capture a kind of reachability in terms of the possible behaviours for a given agent.

A \CCKAabbrv consists of two semimodules~$\ActSemimodule$ and~$\OutSemimodule$ for which we have a 
\leftAct{\stim}~$\lSact$ and a \rightAct{\cka}~$\rKact$. Therefore, there are two complementary notions of orbits, 
stabilisers, and fixed points within the context of agent behaviours and stimuli, respectively. In this way, one 
can use these notions to think about distributed systems from two different perspectives, namely the behavioural 
perspective provided by the action of stimuli on agent behaviours described by~$\ActSemimodule$ and the external 
event (stimulus) perspective provided by the action of agent behaviours on stimuli described by~$\OutSemimodule$. 
In this section, only the treatment of these notions with respect to the \leftSemimodule{\stim}~$\ActSemimodule$ 
and agent behaviours is provided. The same notions for the \rightSemimodule{\cka}~$\OutSemimodule$ and stimuli 
can be provided in a very similar way.

When discussing the interplay between \CCKAabbrv and the notions of orbits, stabilisers, and fixed points, the 
partial order of sub-behaviours~$\CKAle$ is extended to sets in order to express sets of agent behaviours 
encompassing one another. For two subsets of agent behaviours~$A,B \STleq \CKAset$, we say that~$A$ 
\emph{is encompassed by}~$B$ (or~$B$ \emph{encompasses}~$A$), written~$\CKAencompass{A}{B}$, if and only 
if~$\biglnotation{\forall}{a}{a \in A}{\lnotation{\exists}{b}{b \in B}{a \CKAle b}}$. In essence,~$A \CKAenc B$ 
indicates that every behaviour contained within the set~$A$ is a sub-behaviour of at least one behaviour in the 
set~$B$. The encompassing relation~$\STIMenc$ for stimuli can be defined similarly. 

Throughout this section, let~$\ActSemimodule$ be the unitary and zero-preserving \leftSemimodule{\stim} of a 
\CCKAabbrv and let~$a \in \CKAset$.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Topology_C2KA</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>C2KA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span>
</span><span>comp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∘"</span></span></span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rtrancl</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>999</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The locale \emph{topology-c2ka} extends the axiomatisation of \emph{c2ka} to support the notions of topology. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>topology_c2ka</span><span> </span><span class="delimiter">=</span><span> </span><span>c2ka</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>orbit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka ⇒ 'a::cka set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Orb"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>strong_orbit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka ⇒ 'a::cka set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Orb<span class="hidden">⇩</span><sub>S</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stabiliser</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka ⇒ 'b::stimuli set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Stab"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fixed</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encompassing_relation_behaviours</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a set ⇒ bool"</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≪<span class="hidden">⇩</span><sub>𝒦</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encompassing_relation_stimuli</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b set ⇒ 'b set ⇒ bool"</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≪<span class="hidden">⇩</span><sub>𝒮</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>induced</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka ⇒ 'a::cka ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊲"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>orbit_equivalent</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka ⇒ 'a::cka ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∼<span class="hidden">⇩</span><sub>𝒦</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>orb_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ Orb(a) ⟷ (∃s. (s ∘ a = x))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>orbs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ Orb<span class="hidden">⇩</span><sub>S</sub>(a) ⟷ Orb(b) = Orb(a)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stab_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ Stab(a) ⟷ s ∘ a = a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fixed_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fixed(a) ⟷ (∀s::'b. s≠𝔡 ⟶ s ∘ a = a)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>erb_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≪<span class="hidden">⇩</span><sub>𝒦</sub> B ⟷ (∀a::'a. a ∈ A ⟶ (∃b. b ∈ B ∧ a ≤<span class="hidden">⇩</span><sub>𝒦</sub> b))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ers_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E ≪<span class="hidden">⇩</span><sub>𝒮</sub> F ⟷ (∀a::'b. a ∈ E ⟶ (∃b. b ∈ F ∧ a ≤<span class="hidden">⇩</span><sub>𝒮</sub> b))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>induced_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊲ b ⟷ b ∈ Orb(a)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>orbit_equivalent_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∼<span class="hidden">⇩</span><sub>𝒦</sub> b ⟷ Orb(a) = Orb(b)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Orbits \label{sub:orbits}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The \emph{orbit} of~$a$ in~$\stim$ is the set given by~$\orb{a} = \sets{\lAct{a}{s}}{s \in \STIMset}$. The orbit of 
an agent~$a \in \CKAset$ represents the set of all possible behavioural responses from an agent behaving as~$a$ to 
any stimulus from~$\stim$. In this way, the orbit of a given agent can be perceived as the set of all possible 
future behaviours for that agent. 
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Lemma \emph{inf-K-enc-orb} provides an isotonicity law with respect to the orbits and the encompassing relation for agent behaviours.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_K_enc_orb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤<span class="hidden">⇩</span><sub>𝒦</sub> b ⟹ Orb(a) ≪<span class="hidden">⇩</span><sub>𝒦</sub> Orb(b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>erb_def</span><span> </span><span>orb_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_K_next_behaviour</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The following lemmas provide a selection of properties regarding orbits and the encompassing relation for agent behaviours.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enc_orb_add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Orb(a) ≪<span class="hidden">⇩</span><sub>𝒦</sub> Orb(a + b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>inf_K_enc_orb</span><span> </span><span>inf_add_K_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enc_orb_exchange</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Orb((a*b) ; (c*d)) ≪<span class="hidden">⇩</span><sub>𝒦</sub> Orb((a;c) * (b;d))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_K_enc_orb</span><span> </span><span>exchange_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enc_orb_seq_par</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Orb(a;b) ≪<span class="hidden">⇩</span><sub>𝒦</sub> Orb(a*b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_K_enc_orb</span><span> </span><span>seq_inf_par</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enc_orb_add_seq_par</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Orb(a;b + b;a) ≪<span class="hidden">⇩</span><sub>𝒦</sub> Orb(a*b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_K_enc_orb</span><span> </span><span>add_seq_inf_par</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enc_orb_parseq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Orb((a*b);c) ≪<span class="hidden">⇩</span><sub>𝒦</sub> Orb(a*(b;c))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_K_enc_orb</span><span> </span><span>exchange_3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enc_orb_seqpar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Orb(a;(b*c)) ≪<span class="hidden">⇩</span><sub>𝒦</sub> Orb((a;b)*c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_K_enc_orb</span><span> </span><span>exchange_4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enc_orb_seqstar_parstar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Orb(a<span class="hidden">⇧</span><sup>;</sup>) ≪<span class="hidden">⇩</span><sub>𝒦</sub> Orb(a<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_K_enc_orb</span><span> </span><span>seqstar_inf_parstar</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enc_orb_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Orb(a) ≪<span class="hidden">⇩</span><sub>𝒦</sub> Orb(c) ∧ Orb(b) ≪<span class="hidden">⇩</span><sub>𝒦</sub> Orb(c) 
⟷ Orb(a) ∪ Orb(b) ≪<span class="hidden">⇩</span><sub>𝒦</sub>  Orb(c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>erb_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Stabilisers \label{sub:stabilisers}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The \emph{stabiliser} of~$a$ in~$\stim$ is the set given by~$\stab{a} = \sets{s \in \STIMset}{\lAct{a}{s} = a}$. 
The stabiliser of an agent~$a \in \CKAset$ represents the set of stimuli which have no observable influence 
(or act as neutral stimuli) on an agent behaving as~$a$.
›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Lemma \emph{enc-stab-inter-add} provides a property regarding stabilisers and the encompassing relation for stimuli.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enc_stab_inter_add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Stab(a) ∩ Stab(b) ≪<span class="hidden">⇩</span><sub>𝒮</sub> Stab(a + b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ers_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stab_def</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Fixed Points \label{sub:fixed_points}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
An element~$a \in \CKAset$ is called a \emph{fixed point} if~$\lnotation{\forall}{s}{s \in \STIMset \STdiff \set{\Dstim}}{\lAct{a}{s} = a}$.\linebreak 
When an agent behaviour is a fixed point, it is not influenced by any stimulus other than the deactivation stimulus~$\Dstim$. 
It is important to note that since~$\ActSemimodule$ is zero-preserving, every agent behaviour becomes inactive when subjected to the 
deactivation stimulus~$\Dstim$. Because of this, we exclude this special case when discussing fixed point agent behaviours.
›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zerofix</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ 0 = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 = 𝔡 ∘ a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ 0 = s ∘ (𝔡 ∘ a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ 0 = (s ⊙ 𝔡) ∘ a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>lsemimodule3</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ 0 = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The following lemmas provide a selection of properties regarding fixed agent behaviours.
›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fixed_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fixed(0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fixed_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fixed_a_b_add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fixed(a) ∧ fixed(b) ⟶ fixed(a + b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fixed_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fix_not_deactivation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ a = a ∧ λ(s,a) = 𝔡 ⟹ a = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ a = a ∧ λ(s,a) = 𝔡"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∘ (a;1) = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s∘a) ; (λ(s,a)∘1) = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>cascadingaxiom</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>E</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fixed_a_b_seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fixed(a) ∧ fixed(b) ⟶ fixed(a ; b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fixed_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. s ≠ 𝔡 ⟶ s ∘ a = a) ∧ (∀s. s ≠ 𝔡 ⟶ s ∘ b = b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. λ(s,a) = 𝔡 ⟶ s ≠ 𝔡 ⟶ s ∘ (a ; b) = a ; b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. s ≠ 𝔡 ∧ λ(s,a) = 𝔡 ⟶ s ∘ (a ; b) = 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. s ≠ 𝔡 ∧ λ(s,a) = 𝔡 ⟶ s ∘ a = a ∧ λ(s,a) = 𝔡)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hyp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. s ∘ a = a ∧ λ(s,a) = 𝔡 ⟶ a = 0)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fix_not_deactivation</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. s ≠ 𝔡 ∧ λ(s,a) = 𝔡 ⟶ a = 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>E</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. λ(s,a) ≠ 𝔡 ⟶ s ≠ 𝔡 ⟶ s ∘ (a ; b) = a ; b)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hyp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. s ≠ 𝔡 ⟶ s ∘ (a ; b) = a ; b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Strong Orbits and Induced Behaviours \label{sub:strong_orbits_and_induced_behaviours}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The \emph{strong orbit} of~$a$ in~$\stim$ is the set given by~$\orbS{a} = \sets{b \in \CKAset}{\orb{b} = \orb{a}}$. 
Two agents are in the same strong orbit, denoted~$a \CKAsim b$ for~$a,b \in \CKAset$, if and only if their orbits are 
identical. This is to say when~$a \CKAsim b$, if an agent behaving as~$a$ is influenced by a stimulus to behave as~$b$, 
then there exists a stimulus which influences the agent, now behaving as~$b$, to revert back to its original behaviour~$a$. 

The influence of stimuli on agent behaviours is called the \emph{induced behaviours} via stimuli. Let~$a,b \in \CKAset$ 
be agent behaviours with~$a \neq b$. We say that~$b$ is \emph{induced by~$a$ via stimuli} (denoted by~$\induced{b}{a}$) 
if and only if~$\lnotation{\exists}{s}{s \in \STIMset}{\lAct{a}{s} = b}$. The notion of induced behaviours allows us to make 
some predictions about the evolution of agent behaviours in a given system by providing some insight into how different agents 
can respond to any stimuli.
›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Lemma \emph{fixed-not-induce} states that if an agent has a fixed point behaviour, then it does not induce any agent behaviours via  stimuli besides the inactive behaviour~$0$.
›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fixed_not_induce</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fixed(a) ⟶ (∀b. b ≠ 0 ∧ b ≠ a ⟶ ¬(a ⊲ b))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. s = 𝔡 ∨ s ≠ 𝔡 ⟹ (∀t. t ≠ 𝔡 ⟶ t ∘ a = a) ⟹ s ∘ a ≠ 0 
⟹ s ∘ a ≠ a ⟹ False"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. (∀t. t ≠ 𝔡 ⟶ t ∘ a = a) ⟹ s ∘ a ≠ 0 ⟹ s ∘ a ≠ a ⟹ False"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fixed_def</span><span> </span><span>induced_def</span><span> </span><span>orb_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Lemma \emph{strong-orbit-both-induced} states that all agent behaviours which belong to the same strong orbit are mutually induced via some (possibly different) stimuli.
This is to say that if two agent behaviours are in the same strong orbit, then there exists inverse stimuli for each agent behaviour in a 
strong orbit allowing an agent to revert back to its previous behaviour.
›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_own_orbit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ Orb(a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>orb_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"𝔫"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strong_orbit_both_induced</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∼<span class="hidden">⇩</span><sub>𝒦</sub> b ⟶ a ⊲ b ∧ b ⊲ a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>orbit_equivalent_def</span><span> </span><span>induced_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>in_own_orbit</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Lemma \emph{strong-orbit-induce-same} states that if two agent behaviours are in the same strong orbit, then a third behaviour can be induced via  stimuli by either of 
the behaviours within the strong orbit. This is to say that each behaviour in a strong orbit can induce the same set of behaviours
(perhaps via different stimuli).
›</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strong_orbit_induce_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∼<span class="hidden">⇩</span><sub>𝒦</sub> b ⟶ (a ⊲ c ⟷ b ⊲ c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>induced_def</span><span> </span><span>orbit_equivalent_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Communication_C2KA">
<div class="head"><h1>Theory Communication_C2KA</h1>
<span class="command">theory</span> <span class="name">Communication_C2KA</span><br/>
<span class="keyword">imports</span> <a href="Topology_C2KA.html"><span class="name">Topology_C2KA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:        Notions of Communication for C2KA
    Author:       Maxime Buyse &lt;maxime.buyse at polytechnique.edu&gt;, 2019
    Maintainers:  Maxime Buyse &lt;maxime.buyse at polytechnique.edu&gt; and Jason Jaskolka &lt;jason.jaskolka at carleton.ca&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Notions of Communication for \CCKAabbrv \label{sec:communication}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Distributed systems contain a significant number of interactions among their constituent agents. Any interaction, 
direct or indirect, of an agent with its neighbouring agents can be understood as a \emph{communication}~\cite{Milner1989aa}. 
Therefore, any potential for communication between two system agents can be characterized by the existence of a communication 
path allowing for the transfer of data or control from one agent to another. Potential for communication allows system
agents to have an \emph{influence} over each other. The study of agent influence allows for the 
determination of the overall structure of the distributed system of which the agents comprise. A full treatment of the potential 
for communication within distributed systems specified using \CCKAabbrv has been given in~\cite{Jaskolka2015ab} 
and~\cite{Jaskolka2014ac} and is highlighted below.

Consider a distributed system with~$\Agent{A}, \Agent{B} \in \A$ such that~$\Agent{A} \neq \Agent{B}$. We write~$\agent{A}{a}$ 
where~$\Agent{A}$ is the name given to the agent and~$a \in \CKAset$ is the agent behaviour. For~$\agent{A}{a}$ and~$\agent{B}{b}$, 
we write~$\Agent{A+B}$ to denote the agent~$\bigA{a+b}$. In a sense, we extend the operators on behaviours of~$\CKAset$ to their 
corresponding agents. 

Communication via stimuli from agent~$\Agent{A}$ to agent~$\Agent{B}$ is said to have taken place only when 
a stimulus generated by~$\Agent{A}$ \emph{influences} (i.e., causes an observable change in, directly or indirectly) the behaviour 
of~$\Agent{B}$. Note that it is possible that more than one agent is influenced by the generation of the same stimulus by another 
agent in the system. Formally, we say that agent~$\agent{A}{a}$ has the \emph{potential for direct communication via stimuli} with 
agent~$\agent{B}{b}$ (denoted by~$\STIMcommD{\Agent{A}}{\Agent{B}}$) if and only 
if~$\biglnotation{\exists}{s,t}{s,t \in \STIMbasic \nAnd t \STIMle \lOut{a}{s} }{\lAct{b}{t} \neq b}$ where~$\STIMbasic$ is the 
set of all basic stimuli. A stimulus is called \emph{basic} if it is indivisible with regard to the sequential composition 
operator~$\STIMdot$ of a stimulus structure. Similarly, we say that agent~$\Agent{A}$ has the \emph{potential for communication 
via stimuli with agent~$\Agent{B}$ using at most~$n$ basic stimuli} (denoted by~$\STIMcommN{\Agent{A}}{\Agent{B}}{n}$) if and only 
if~$\biglnotation{\exists}{\Agent{C}}{\Agent{C} \in \A \nAnd \Agent{C} \neq \Agent{A} \nAnd \Agent{C} \neq \Agent{B}}{\STIMcommN{\Agent{A}}{\Agent{C}}{(n-1)} \nAnd \STIMcommD{\Agent{C}}{\Agent{B}}}$. 
More generally, we say that agent~$\Agent{A}$ has the \emph{potential for communication via stimuli} with agent~$\Agent{B}$ 
(denoted by~$\STIMcomm{\Agent{A}}{\Agent{B}}$) if and only if~$\biglnotation{\exists}{n}{n \ge 1}{\STIMcommN{\Agent{A}}{\Agent{B}}{n}}$. 
When~$\STIMcomm{\Agent{A}}{\Agent{B}}$, there is a sequence of stimuli of arbitrary length which allows for the transfer of data or 
control from agent~$\Agent{A}$ to agent~$\Agent{B}$ in the system. To simplify the Isabelle theory, we do not implement 
the potential for communication using at most~$n$ basic stimuli. Instead, we give the definition of potential for direct communication 
via stimuli and the fact that~$\STIMcommD{\Agent{A}}{\Agent{B}} \Longrightarrow \STIMcomm{\Agent{A}}{\Agent{B}}$ as axioms because 
these are the only properties that we use about potential for communication via stimuli.

Communication via shared environments from agent~$\Agent{A}$ to agent~$\Agent{B}$ (denoted by~$\ENVcomm{\Agent{A}}{\Agent{B}}$) is 
said to have taken place only when~$\Agent{A}$ has the ability to alter an element of the environment that it shares with~$\Agent{B}$ 
such that~$\Agent{B}$ is able to observe the alteration that was made. Formally, we say that agent~$\agent{A}{a}$ has the 
\emph{potential for direct communication via shared environments} with agent~$\agent{B}{b}$ (denoted by~$\ENVcommD{\Agent{A}}{\Agent{B}}$) 
if and only if~$\dep{b}{a}$ where~$\depOp$ is a given dependence relation. More generally, agent~$\Agent{A}$ has the 
\emph{potential for communication via shared environments} with agent~$\Agent{B}$ (denoted by~$\ENVcomm{\Agent{A}}{\Agent{B}}$) if and 
only if~$\depTC{b}{a}$ where~$\depOpTC$ is the transitive closure of the given dependence relation. This means that if two agents respect 
the given dependence relation, then there is a potential for communication via shared environments.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Communication_C2KA</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Topology_C2KA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The locale \emph{communication-c2ka} extends \emph{topology-c2ka} to include aspects of potential for communication 
among distributed system agents.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>communication_c2ka</span><span> </span><span class="delimiter">=</span><span> </span><span>topology_c2ka</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>dcs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka ⇒ 'a::cka ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"→<span class="hidden">⇩</span><sub>𝒮</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pcs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka ⇒ 'a::cka ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"→<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dce</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka ⇒ 'a::cka ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"→<span class="hidden">⇩</span><sub>ℰ</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pce</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka ⇒ 'a::cka ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"→<span class="hidden">⇩</span><sub>ℰ</sub><span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pdc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka ⇒ 'a::cka ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↝"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pfc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka ⇒ 'a::cka ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↝<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stimuli_connected</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>universally_influential</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::cka × 'a set ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>dcs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a →<span class="hidden">⇩</span><sub>𝒮</sub> b ⟷ 
  (∃ s t. s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,a) ∧ t ∘ b ≠ b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pdc_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ↝ b ⟷ (a →<span class="hidden">⇩</span><sub>𝒮</sub> b ∨ a →<span class="hidden">⇩</span><sub>ℰ</sub> b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>zero_dce</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(0 →<span class="hidden">⇩</span><sub>ℰ</sub> a)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>one_dce</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(1 →<span class="hidden">⇩</span><sub>ℰ</sub> a)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dce_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(a →<span class="hidden">⇩</span><sub>ℰ</sub> 0)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dce_one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(a →<span class="hidden">⇩</span><sub>ℰ</sub> 1)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sum_dce</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A + B →<span class="hidden">⇩</span><sub>ℰ</sub> C) ⟷ (A →<span class="hidden">⇩</span><sub>ℰ</sub> C ∨ B →<span class="hidden">⇩</span><sub>ℰ</sub> C)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dce_sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A →<span class="hidden">⇩</span><sub>ℰ</sub> B + C) ⟷ (A →<span class="hidden">⇩</span><sub>ℰ</sub> B ∨ A →<span class="hidden">⇩</span><sub>ℰ</sub> C)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dcs_pcs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A →<span class="hidden">⇩</span><sub>𝒮</sub> B ⟹ A →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stimuli_connected_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stimuli_connected(𝒞) ⟷ 
(∀ X<span class="hidden">⇩</span><sub>1</sub> X<span class="hidden">⇩</span><sub>2</sub>. X<span class="hidden">⇩</span><sub>1</sub> ∩ X<span class="hidden">⇩</span><sub>2</sub> = {} ∧ X<span class="hidden">⇩</span><sub>1</sub> ∪ X<span class="hidden">⇩</span><sub>2</sub> = 𝒞 ∧ X<span class="hidden">⇩</span><sub>1</sub> ≠ {} ∧ X<span class="hidden">⇩</span><sub>2</sub> ≠ {} ⟶ 
(∃ A B. A ∈ X<span class="hidden">⇩</span><sub>1</sub> ∧ B ∈ X<span class="hidden">⇩</span><sub>2</sub> ∧ (A →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> B ∨ B →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> A)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>universally_influential_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"universally_influential(A,𝒞) ⟷
A ∈ 𝒞 ∧ (∀ B. B ∈ 𝒞 ∧ B ≠ A ⟶ A →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> B)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Stimuli-Connected Systems \&amp; Universally Influential Agents \label{sub:stimuli_connected_universally_influential}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Two subsets~$X_1$ and~$X_2$ of~$\A$ form a partition of~$\A$ if and only if~$X_1 \cap X_2 = \STbot$ and~$X_1 \cup X_2 = \A$. A distributed system 
of agents~$\A$ is called \emph{stimuli-connected} if and only if for every~$X_1$ and~$X_2$ nonempty that form a partition of~$\A$, we 
have~$\lnotation{\exists}{\Agent{A},\Agent{B}}{\Agent{A} \in X_1 \nAnd \Agent{B} \in X_2}{\STIMcomm{\Agent{A}}{\Agent{B}} \Ors \STIMcomm{\Agent{B}}{\Agent{A}}}$. 
Otherwise,~$\A$ is called \emph{stimuli-disconnected}. In a stimuli-connected system, every agent is a participant, either as the source or sink, 
of at least one direct communication via stimuli.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
An agent~$\Agent{A} \in \A$ is called \emph{universally influential} if and only 
if~$\biglnotation{\forall}{\Agent{B}}{\Agent{B} \in \A \STdiff \set{\Agent{A}}}{\STIMcomm{\Agent{A}}{\Agent{B}}}$. 
A universally influential agent is able to generate some stimuli that influences the behaviour, either directly or 
indirectly, of each other agent in the system. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Lemma \emph{universally-influential-stimuli-connected} shows that the existence of a universally influential agent yields a stimuli-connected system. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>universally_influential_stimuli_connected</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"(∃ A. universally_influential(A,𝒞)) ⟶ stimuli_connected(𝒞)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>universally_influential_def</span><span> </span><span>stimuli_connected_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>X<span class="hidden">⇩</span><sub>2</sub></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃A. A ∈ 𝒞 ∧ (∀B. B ∈ 𝒞 ∧ B ≠ A ⟶ A →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> B)) ⟹
X<span class="hidden">⇩</span><sub>1</sub> ∩ X<span class="hidden">⇩</span><sub>2</sub> = {} ∧ X<span class="hidden">⇩</span><sub>1</sub> ∪ X<span class="hidden">⇩</span><sub>2</sub> = 𝒞 ∧ X<span class="hidden">⇩</span><sub>1</sub> ≠ {} ∧ X<span class="hidden">⇩</span><sub>2</sub> ≠ {} ⟹ 
(∃ A B. A ∈ X<span class="hidden">⇩</span><sub>1</sub> ∧ B ∈ X<span class="hidden">⇩</span><sub>2</sub> ∧ (A →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> B ∨ B →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> A))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃A. A ∈ 𝒞 ∧ (∀B. B ∈ 𝒞 ∧ B ≠ A ⟶ A →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> B))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Aui</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ 𝒞 ∧ (∀B. B ∈ 𝒞 ∧ B ≠ A ⟶ 
A →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> B)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X<span class="hidden">⇩</span><sub>1</sub> ∩ X<span class="hidden">⇩</span><sub>2</sub> = {} ∧ X<span class="hidden">⇩</span><sub>1</sub> ∪ X<span class="hidden">⇩</span><sub>2</sub> = 𝒞 ∧ X<span class="hidden">⇩</span><sub>1</sub> ≠ {} ∧ X<span class="hidden">⇩</span><sub>2</sub> ≠ {} ⟹
(∃A B. A ∈ X<span class="hidden">⇩</span><sub>1</sub> ∧ B ∈ X<span class="hidden">⇩</span><sub>2</sub> ∧ (A →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> B ∨ B →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> A))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>partition</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"X<span class="hidden">⇩</span><sub>1</sub> ∩ X<span class="hidden">⇩</span><sub>2</sub> = {} ∧ X<span class="hidden">⇩</span><sub>1</sub> ∪ X<span class="hidden">⇩</span><sub>2</sub> = 𝒞 ∧ X<span class="hidden">⇩</span><sub>1</sub> ≠ {} ∧ X<span class="hidden">⇩</span><sub>2</sub> ≠ {}"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃A B. A ∈ X<span class="hidden">⇩</span><sub>1</sub> ∧ B ∈ X<span class="hidden">⇩</span><sub>2</sub> ∧ (A →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> B ∨ B →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> A))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>in1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ X<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>partition</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>in2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ X<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = B ⟹ False"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = B"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ X<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ X<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>in1</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ X<span class="hidden">⇩</span><sub>1</sub> ∩ X<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>partition</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≠ B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ 𝒞"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>partition</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒞 = X<span class="hidden">⇩</span><sub>1</sub> ∪ X<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X<span class="hidden">⇩</span><sub>2</sub> ⊆ 𝒞"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Aui</span><span> </span><span>in2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in1</span><span> </span><span>in2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>notin1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∉ X<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ 𝒞"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Aui</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X<span class="hidden">⇩</span><sub>1</sub> ∪ X<span class="hidden">⇩</span><sub>2</sub> = 𝒞"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>partition</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ X<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>partition</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>in1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ X<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B = A ⟹ False"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B = A"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ X<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ X<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>in1</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ X<span class="hidden">⇩</span><sub>1</sub> ∩ X<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>partition</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ≠ A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ 𝒞"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>partition</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒞 = X<span class="hidden">⇩</span><sub>1</sub> ∪ X<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X<span class="hidden">⇩</span><sub>1</sub> ⊆ 𝒞"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A →<span class="hidden">⇩</span><sub>𝒮</sub><span class="hidden">⇧</span><sup>+</sup> B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Aui</span><span> </span><span>in2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in1</span><span> </span><span>in2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Lemma \emph{fixed-no-stimcomm} shows that no agent has the potential for communication via stimuli with an agent that has a fixed point behaviour.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fixed_no_stimcomm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fixed(A) ⟶ (∀ B. ¬(B →<span class="hidden">⇩</span><sub>𝒮</sub> A))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fixed_def</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. s ≠ 𝔡 ⟶ s ∘ A = A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ B. B →<span class="hidden">⇩</span><sub>𝒮</sub> A ⟹ False"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ B. B →<span class="hidden">⇩</span><sub>𝒮</sub> A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B →<span class="hidden">⇩</span><sub>𝒮</sub> A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ s t. s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,B) ∧ t ∘ A ≠ A"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>dcs_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,B) ∧ t ∘ A ≠ A"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ 𝔡"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>zero_not_basic</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∘ A = A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hyp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>st</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ B. ¬(B →<span class="hidden">⇩</span><sub>𝒮</sub> A))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preserving the Potential for Communication under Non-Determinism \label{sub:non_determinism}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Potential for Communication via Stimuli \label{ssub:pfc_stim}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The following results show how the potential for communication via stimuli can be preserved when non-determinism is introduced among agents. 
Specifically, Lemma \emph{source-nondet-stimcomm} states that when non-determinism is added at the source of a potential communication path via stimuli, the potential 
for communication via stimuli is always preserved. On the other hand, Lemma \emph{sink-nondet-stimcomm} states that when non-determinism is added at the sink of a 
potential communication path via stimuli, the potential for communication is preserved only if there does not exist any basic stimulus that is 
generated by the source that influences agent~$\Agent{B}$ and agent~$\Agent{C}$ to behave as a sub-behaviour of agent~$\Agent{B + C}$. This 
condition ensures that agent~$\Agent{B + C}$ cannot have a fixed point behaviour.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>source_nondet_stimcomm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(B →<span class="hidden">⇩</span><sub>𝒮</sub> C) ⟹ ((A + B) →<span class="hidden">⇩</span><sub>𝒮</sub> C)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B →<span class="hidden">⇩</span><sub>𝒮</sub> C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,B) ∧ t ∘ C ≠ C"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>dcs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A + B) →<span class="hidden">⇩</span><sub>𝒮</sub> C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dcs_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>st</span><span> </span><span>inf_add_S_left</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comm_source_nondet_stimcomm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(B →<span class="hidden">⇩</span><sub>𝒮</sub> C) ⟹ ((B + A) →<span class="hidden">⇩</span><sub>𝒮</sub> C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>source_nondet_stimcomm</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sink_sum_stimcomm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ s t. s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) ∧ 
¬(t ∘ B ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C ∧ t ∘ C ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C)) ⟹ (A →<span class="hidden">⇩</span><sub>𝒮</sub> B + C)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ s t. s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) ∧ 
¬(t ∘ B ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C ∧ t ∘ C ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) ∧ 
¬(t ∘ B ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C ∧ t ∘ C ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∘ (B + C) = B + C ⟹ False"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>fixbc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∘ (B + C) = B + C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∘ B  ≤<span class="hidden">⇩</span><sub>𝒦</sub> t ∘ (B + C)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>inf_add_K_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∘ C  ≤<span class="hidden">⇩</span><sub>𝒦</sub> t ∘ (B + C)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>inf_add_K_left</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∘ B ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C ∧ t ∘ C ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>fixbc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>st</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A →<span class="hidden">⇩</span><sub>𝒮</sub> B + C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dcs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>st</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sink_nondet_stimcomm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A →<span class="hidden">⇩</span><sub>𝒮</sub> B ⟹ (∀ s t. s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) 
⟶ ¬(t ∘ B ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C ∧ t ∘ C ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C)) ⟹ (A →<span class="hidden">⇩</span><sub>𝒮</sub> B + C)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sink_sum_stimcomm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A →<span class="hidden">⇩</span><sub>𝒮</sub> B"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ s t. s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) ⟶ 
¬(t ∘ B ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C ∧ t ∘ C ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ s t. s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) ∧ 
¬(t ∘ B ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C ∧ t ∘ C ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>h1</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) ∧ t ∘ B ≠ B"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>dcs_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>h2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) ∧ 
¬(t ∘ B ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C ∧ t ∘ C ≤<span class="hidden">⇩</span><sub>𝒦</sub> B + C)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Potential for Communication via Shared Environments \label{ssub:pfc_env}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Lemmas \emph{source-nondet-envcomm} and \emph{sink-nondet-envcomm} show how the potential for communication via shared environments is preserved when non-determinism is 
introduced at the source or the sink of a potential communication path via shared environments.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>source_nondet_envcomm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B →<span class="hidden">⇩</span><sub>ℰ</sub> C ⟹ (A + B) →<span class="hidden">⇩</span><sub>ℰ</sub> C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_dce</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sink_nondet_envcomm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A →<span class="hidden">⇩</span><sub>ℰ</sub> B ⟹ A →<span class="hidden">⇩</span><sub>ℰ</sub> (B + C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dce_sum</span><span class="delimiter">)</span><span>
</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preserving the Potential for Communication with Agent Behaviour Modifications\label{sub:preservation}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The following results identify the conditions constraining the modifications that can be made to the source or sink agent involved in a direct potential for communication to 
preserve the communication in a distributed system. In this way, it demonstrates the conditions under which a modification to an agent behaviour can be made while maintaining 
the communicating behaviour of the agents in the system.

Specifically, Lemma \emph{sink-seq-stimcomm} shows how the sequential composition of an additional behaviour on the left of a sink agent will not affect the potential for communication 
provided that every stimulus that is generated by the source agent either does not fix the behaviour of the first component of the sequential composition, or causes the 
first component of the sequential composition to generate a stimulus that does not fix the behaviour of the second component of the sequential composition. Alternatively, 
Lemma \emph{nondet-right-source-communication} shows how non-determinism added on the right of a source agent will not affect the potential for communication provided that 
the non-deterministic behaviours can be influenced by the source agent to stop being a sub-behaviour of the non-deterministic behaviour.
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sink_seq_stimcomm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A →<span class="hidden">⇩</span><sub>𝒮</sub> B 
⟹ ∀ s t. s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) ⟶ λ(t,C) = t ⟹ A;C →<span class="hidden">⇩</span><sub>𝒮</sub> B"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A →<span class="hidden">⇩</span><sub>𝒮</sub> B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) ∧ t ∘ B ≠ B"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dcs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ s t. s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) ⟶ λ(t,C) = t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tfix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t,C) = t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(t,C) ≤<span class="hidden">⇩</span><sub>𝒮</sub>  λ(λ(s,A),C)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inf_S_next_stimulus</span><span> </span><span>st</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ (λ (s, A), C)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tfix</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A;C →<span class="hidden">⇩</span><sub>𝒮</sub> B"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dcs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>st</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nondet_right_source_communication</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ↝ C ∧ C ↝ B ⟹ (∀ s t. s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) 
⟶ ¬(t ∘ C ≤<span class="hidden">⇩</span><sub>𝒦</sub> C + D ∧ t ∘ D ≤<span class="hidden">⇩</span><sub>𝒦</sub> C + D)) ⟹ A ↝ C+D ∧ C+D ↝ B"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"A ↝ C ∧ C ↝ B"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(∀ s t. s ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ∈ 𝒮<span class="hidden">⇩</span><sub>a</sub> ∧ t ≤<span class="hidden">⇩</span><sub>𝒮</sub> λ(s,A) 
⟶ ¬(t ∘ C ≤<span class="hidden">⇩</span><sub>𝒦</sub> C + D ∧ t ∘ D ≤<span class="hidden">⇩</span><sub>𝒦</sub> C + D))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>h2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A →<span class="hidden">⇩</span><sub>𝒮</sub> C ⟹ A →<span class="hidden">⇩</span><sub>𝒮</sub> C+D"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sink_nondet_stimcomm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ↝ C ⟹ A ↝ C+D"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pdc_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dce_sum</span><span> </span><span>hs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ↝ B ⟹ C + D ↝ B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pdc_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comm_source_nondet_stimcomm</span><span> </span><span>sum_dce</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ↝ C+D ∧ C+D ↝ B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>h1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>